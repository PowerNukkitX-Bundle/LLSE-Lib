declare type byte = number;
declare type char = number;
declare type short = number;
declare type int = number;
declare type long = number;
declare type float = number;
declare type double = number;

declare namespace java.lang {
    declare type Object = globalThis.Object;
}

declare namespace java.util {
    declare type List<T> = globalThis.Array<T>;
    declare type Set<T> = globalThis.Set<T>;
    declare type Map<K, V> = globalThis.Map<K, V>;
}

declare namespace cn.nukkit.command.defaults {
    declare class PluginsCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        sendPluginList(sender: cn.nukkit.command.CommandSender): void

    }
}

declare module "cn.nukkit.command.defaults.PluginsCommand" {
    declare const PluginsCommand = cn.nukkit.command.defaults.PluginsCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class DebugPasteCommand$1 extends cn.nukkit.scheduler.AsyncTask {
        constructor(this$0: cn.nukkit.command.defaults.DebugPasteCommand, var1: string[], var2: cn.nukkit.command.CommandSender, var3: cn.nukkit.Server): void
        public onRun(): void
        static lambda$onRun$1(a: java.nio.file.Path, b: java.nio.file.Path): int
        static lambda$onRun$0(path: java.nio.file.Path): boolean
        val$args: string[]
        val$sender: cn.nukkit.command.CommandSender
        val$server: cn.nukkit.Server
        this$0: cn.nukkit.command.defaults.DebugPasteCommand

    }
}

declare module "cn.nukkit.command.defaults.DebugPasteCommand$1" {
    declare const DebugPasteCommand$1 = cn.nukkit.command.defaults.DebugPasteCommand$1;
}

declare namespace cn.nukkit.command.defaults {
    declare class CloneCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.CloneCommand" {
    declare const CloneCommand = cn.nukkit.command.defaults.CloneCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class XpCommand extends cn.nukkit.command.Command {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$execute$3(p: cn.nukkit.entity.Entity): cn.nukkit.Player
        static lambda$execute$2(entity: cn.nukkit.entity.Entity): boolean
        static lambda$execute$1(p: cn.nukkit.entity.Entity): cn.nukkit.Player
        static lambda$execute$0(entity: cn.nukkit.entity.Entity): boolean

    }
}

declare module "cn.nukkit.command.defaults.XpCommand" {
    declare const XpCommand = cn.nukkit.command.defaults.XpCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class CloneCommand$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$command$defaults$CloneCommand$MaskMode: int[]

    }
}

declare module "cn.nukkit.command.defaults.CloneCommand$1" {
    declare const CloneCommand$1 = cn.nukkit.command.defaults.CloneCommand$1;
}

declare namespace cn.nukkit.command.defaults {
    declare class EffectCommand extends cn.nukkit.command.Command {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.EffectCommand" {
    declare const EffectCommand = cn.nukkit.command.defaults.EffectCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class DebugPasteCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        static filterValidPastes(file: java.nio.file.Path): boolean
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static clear(sender: cn.nukkit.command.CommandSender): void
        static uploadLast(sender: cn.nukkit.command.CommandSender): void
        static upload(sender: cn.nukkit.command.CommandSender, zipPath: java.nio.file.Path): void
        static eval(command: string[]): string
        static lambda$uploadLast$3(line: string): boolean
        static lambda$uploadLast$2(file: java.nio.file.Path): long
        static lambda$uploadLast$1(x$0: java.nio.file.Path): boolean
        static lambda$clear$0(count: java.util.concurrent.atomic.AtomicInteger, file: java.nio.file.Path): void
        static log: org.apache.logging.log4j.Logger
        static ENDPOINT: string
        static USER_AGENT: string

    }
}

declare module "cn.nukkit.command.defaults.DebugPasteCommand" {
    declare const DebugPasteCommand = cn.nukkit.command.defaults.DebugPasteCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class ScoreboardCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$execute$7(t: cn.nukkit.entity.Entity): cn.nukkit.scoreboard.interfaces.Scorer
        static lambda$execute$6(t: cn.nukkit.entity.Entity): cn.nukkit.scoreboard.interfaces.Scorer
        static lambda$execute$5(t: cn.nukkit.entity.Entity): cn.nukkit.scoreboard.interfaces.Scorer
        static lambda$execute$4(t: cn.nukkit.entity.Entity): cn.nukkit.scoreboard.interfaces.Scorer
        static lambda$execute$3(t: cn.nukkit.entity.Entity): boolean
        static lambda$execute$2(t: cn.nukkit.entity.Entity): cn.nukkit.scoreboard.interfaces.Scorer
        static lambda$execute$1(t: cn.nukkit.entity.Entity): cn.nukkit.scoreboard.interfaces.Scorer
        static lambda$execute$0(t: cn.nukkit.entity.Entity): cn.nukkit.scoreboard.interfaces.Scorer

    }
}

declare module "cn.nukkit.command.defaults.ScoreboardCommand" {
    declare const ScoreboardCommand = cn.nukkit.command.defaults.ScoreboardCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class DefaultGamemodeCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.DefaultGamemodeCommand" {
    declare const DefaultGamemodeCommand = cn.nukkit.command.defaults.DefaultGamemodeCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class ParticleCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.ParticleCommand" {
    declare const ParticleCommand = cn.nukkit.command.defaults.ParticleCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class ReloadCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.ReloadCommand" {
    declare const ReloadCommand = cn.nukkit.command.defaults.ReloadCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class FillCommand$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$command$defaults$FillCommand$FillMode: int[]

    }
}

declare module "cn.nukkit.command.defaults.FillCommand$1" {
    declare const FillCommand$1 = cn.nukkit.command.defaults.FillCommand$1;
}

declare namespace cn.nukkit.command.defaults {
    declare class WeatherCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.WeatherCommand" {
    declare const WeatherCommand = cn.nukkit.command.defaults.WeatherCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class DamageCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$execute$4(e: cn.nukkit.entity.Entity): string
        static lambda$execute$3(e: cn.nukkit.entity.Entity): string
        static lambda$execute$2(e: cn.nukkit.entity.Entity): string
        static lambda$new$1(e: cn.nukkit.event.entity.EntityDamageEvent$DamageCause): string
        static lambda$new$0(e: cn.nukkit.event.entity.EntityDamageEvent$DamageCause): string

    }
}

declare module "cn.nukkit.command.defaults.DamageCommand" {
    declare const DamageCommand = cn.nukkit.command.defaults.DamageCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class DeopCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$execute$0(p: cn.nukkit.Player): cn.nukkit.IPlayer

    }
}

declare module "cn.nukkit.command.defaults.DeopCommand" {
    declare const DeopCommand = cn.nukkit.command.defaults.DeopCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class SpreadPlayersCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        nextXZ(centerX: double, var1: double, centerZ: int): cn.nukkit.math.Vector3
        random: java.util.concurrent.ThreadLocalRandom

    }
}

declare module "cn.nukkit.command.defaults.SpreadPlayersCommand" {
    declare const SpreadPlayersCommand = cn.nukkit.command.defaults.SpreadPlayersCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class CloneCommand$CloneMode extends java.lang.Enum {
        public static values(): cn.nukkit.command.defaults.CloneCommand$CloneMode[]
        public static valueOf(name: string): cn.nukkit.command.defaults.CloneCommand$CloneMode
        constructor(): void
        static $values(): cn.nukkit.command.defaults.CloneCommand$CloneMode[]
        public static NORMAL: cn.nukkit.command.defaults.CloneCommand$CloneMode
        public static FORCE: cn.nukkit.command.defaults.CloneCommand$CloneMode
        public static MOVE: cn.nukkit.command.defaults.CloneCommand$CloneMode
        static $VALUES: cn.nukkit.command.defaults.CloneCommand$CloneMode[]

    }
}

declare module "cn.nukkit.command.defaults.CloneCommand$CloneMode" {
    declare const CloneCommand$CloneMode = cn.nukkit.command.defaults.CloneCommand$CloneMode;
}

declare namespace cn.nukkit.command.defaults {
    declare class FillCommand$FillMode extends java.lang.Enum {
        public static values(): cn.nukkit.command.defaults.FillCommand$FillMode[]
        public static valueOf(name: string): cn.nukkit.command.defaults.FillCommand$FillMode
        constructor(): void
        static $values(): cn.nukkit.command.defaults.FillCommand$FillMode[]
        public static REPLACE: cn.nukkit.command.defaults.FillCommand$FillMode
        public static OUTLINE: cn.nukkit.command.defaults.FillCommand$FillMode
        public static HOLLOW: cn.nukkit.command.defaults.FillCommand$FillMode
        public static DESTROY: cn.nukkit.command.defaults.FillCommand$FillMode
        public static KEEP: cn.nukkit.command.defaults.FillCommand$FillMode
        static $VALUES: cn.nukkit.command.defaults.FillCommand$FillMode[]

    }
}

declare module "cn.nukkit.command.defaults.FillCommand$FillMode" {
    declare const FillCommand$FillMode = cn.nukkit.command.defaults.FillCommand$FillMode;
}

declare namespace cn.nukkit.command.defaults {
    declare class SaveOffCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.SaveOffCommand" {
    declare const SaveOffCommand = cn.nukkit.command.defaults.SaveOffCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class SpawnpointCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$execute$1(e: cn.nukkit.entity.Entity): cn.nukkit.Player
        static lambda$execute$0(e: cn.nukkit.entity.Entity): boolean

    }
}

declare module "cn.nukkit.command.defaults.SpawnpointCommand" {
    declare const SpawnpointCommand = cn.nukkit.command.defaults.SpawnpointCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class SetWorldSpawnCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.SetWorldSpawnCommand" {
    declare const SetWorldSpawnCommand = cn.nukkit.command.defaults.SetWorldSpawnCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class KickCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$execute$1(p: cn.nukkit.entity.Entity): cn.nukkit.Player
        static lambda$execute$0(entity: cn.nukkit.entity.Entity): boolean

    }
}

declare module "cn.nukkit.command.defaults.KickCommand" {
    declare const KickCommand = cn.nukkit.command.defaults.KickCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class SeedCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.SeedCommand" {
    declare const SeedCommand = cn.nukkit.command.defaults.SeedCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class CameraShakeCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$execute$2(packet: cn.nukkit.network.protocol.CameraShakePacket, player: cn.nukkit.Player): void
        static lambda$execute$1(packet: cn.nukkit.network.protocol.CameraShakePacket, player: cn.nukkit.Player): void
        static lambda$execute$0(p: cn.nukkit.Player): string

    }
}

declare module "cn.nukkit.command.defaults.CameraShakeCommand" {
    declare const CameraShakeCommand = cn.nukkit.command.defaults.CameraShakeCommand;
}

declare namespace cn.nukkit.command {
    declare class SimpleCommandMap extends java.lang.Object implements cn.nukkit.command.CommandMap {
        public constructor(server: cn.nukkit.Server): void
        setDefaultCommands(): void
        public registerAll(fallbackPrefix: string, commands: java.util.List<cn.nukkit.command.Command>): void
        public register(fallbackPrefix: string, command: cn.nukkit.command.Command): boolean
        public register(fallbackPrefix: string, command: cn.nukkit.command.Command, label: string): boolean
        public registerSimpleCommands(object: java.lang.Object): void
        registerAlias(command: cn.nukkit.command.Command, isAlias: boolean, fallbackPrefix: string, label: string): boolean
        public static parseArguments(cmdLine: string): java.util.ArrayList<string>
        public dispatch(sender: cn.nukkit.command.CommandSender, cmdLine: string): boolean
        public clearCommands(): void
        public getCommand(name: string): cn.nukkit.command.Command
        public getCommands(): java.util.Map<string, cn.nukkit.command.Command>
        public registerServerAliases(): void
        static lambda$registerSimpleCommands$2(parameters: cn.nukkit.command.simple.Parameters): cn.nukkit.command.data.CommandParameter[]
        static lambda$registerSimpleCommands$1(x$0: int): cn.nukkit.command.data.CommandParameter[]
        static lambda$registerSimpleCommands$0(parameter: cn.nukkit.command.simple.Parameter): cn.nukkit.command.data.CommandParameter
        static log: org.apache.logging.log4j.Logger
        knownCommands: java.util.Map<string, cn.nukkit.command.Command>
        server: cn.nukkit.Server

    }
}

declare module "cn.nukkit.command.SimpleCommandMap" {
    declare const SimpleCommandMap = cn.nukkit.command.SimpleCommandMap;
}

declare namespace cn.nukkit {
    declare interface InterruptibleThread {

    }
}

declare module "cn.nukkit.InterruptibleThread" {
    declare type InterruptibleThread = cn.nukkit.InterruptibleThread;
}

declare namespace cn.nukkit.metrics {
    declare class Metrics$AdvancedPie extends cn.nukkit.metrics.Metrics$CustomChart {
        public constructor(chartId: string, callable: java.util.concurrent.Callable<java.util.Map<string, int>>): void
        getChartData(): com.nimbusds.jose.shaded.json.JSONObject
        callable: java.util.concurrent.Callable<java.util.Map<string, int>>

    }
}

declare module "cn.nukkit.metrics.Metrics$AdvancedPie" {
    declare const Metrics$AdvancedPie = cn.nukkit.metrics.Metrics$AdvancedPie;
}

declare namespace cn.nukkit.metrics {
    declare class Metrics$CustomChart extends java.lang.Object {
        constructor(chartId: string): void
        getRequestJsonObject(): com.nimbusds.jose.shaded.json.JSONObject
        getChartData(): com.nimbusds.jose.shaded.json.JSONObject
        chartId: string

    }
}

declare module "cn.nukkit.metrics.Metrics$CustomChart" {
    declare const Metrics$CustomChart = cn.nukkit.metrics.Metrics$CustomChart;
}

declare namespace cn.nukkit.metrics {
    declare class Metrics extends java.lang.Object {
        public constructor(name: string, serverUUID: string, logFailedRequests: boolean, logger: cn.nukkit.utils.MainLogger): void
        public constructor(name: string, serverUUID: string, logFailedRequests: boolean): void
        public addCustomChart(chart: cn.nukkit.metrics.Metrics$CustomChart): void
        startSubmitting(): void
        getPluginData(): com.nimbusds.jose.shaded.json.JSONObject
        getServerData(): com.nimbusds.jose.shaded.json.JSONObject
        submitData(): void
        static sendData(data: com.nimbusds.jose.shaded.json.JSONObject): void
        static compress(str: string): byte[]
        static createAdvancedChartData(callable: java.util.concurrent.Callable<java.util.Map<string, int>>): com.nimbusds.jose.shaded.json.JSONObject
        static log: org.apache.logging.log4j.Logger
        public static B_STATS_VERSION: int
        static VALUES: string
        scheduler: java.util.concurrent.ScheduledExecutorService
        static URL: string
        charts: java.util.List<cn.nukkit.metrics.Metrics$CustomChart>
        name: string
        serverUUID: string
        logFailedRequests: boolean

    }
}

declare module "cn.nukkit.metrics.Metrics" {
    declare const Metrics = cn.nukkit.metrics.Metrics;
}

declare namespace cn.nukkit.metrics {
    declare class Metrics$SimpleBarChart extends cn.nukkit.metrics.Metrics$CustomChart {
        public constructor(chartId: string, callable: java.util.concurrent.Callable<java.util.Map<string, int>>): void
        getChartData(): com.nimbusds.jose.shaded.json.JSONObject
        callable: java.util.concurrent.Callable<java.util.Map<string, int>>

    }
}

declare module "cn.nukkit.metrics.Metrics$SimpleBarChart" {
    declare const Metrics$SimpleBarChart = cn.nukkit.metrics.Metrics$SimpleBarChart;
}

declare namespace cn.nukkit.metrics {
    declare class NukkitMetrics$JavaVersionRetriever extends java.lang.Object implements java.util.concurrent.Callable {
        constructor(): void
        public call(): java.util.Map<string, java.util.Map<string, int>>
        public call(): java.lang.Object

    }
}

declare module "cn.nukkit.metrics.NukkitMetrics$JavaVersionRetriever" {
    declare const NukkitMetrics$JavaVersionRetriever = cn.nukkit.metrics.NukkitMetrics$JavaVersionRetriever;
}

declare namespace cn.nukkit.metrics {
    declare class Metrics$DrilldownPie extends cn.nukkit.metrics.Metrics$CustomChart {
        public constructor(chartId: string, callable: java.util.concurrent.Callable<java.util.Map<string, java.util.Map<string, int>>>): void
        public getChartData(): com.nimbusds.jose.shaded.json.JSONObject
        callable: java.util.concurrent.Callable<java.util.Map<string, java.util.Map<string, int>>>

    }
}

declare module "cn.nukkit.metrics.Metrics$DrilldownPie" {
    declare const Metrics$DrilldownPie = cn.nukkit.metrics.Metrics$DrilldownPie;
}

declare namespace cn.nukkit.metrics {
    declare class Metrics$AdvancedBarChart extends cn.nukkit.metrics.Metrics$CustomChart {
        public constructor(chartId: string, callable: java.util.concurrent.Callable<string, int[]>): void
        getChartData(): com.nimbusds.jose.shaded.json.JSONObject
        callable: java.util.concurrent.Callable<string, int[]>

    }
}

declare module "cn.nukkit.metrics.Metrics$AdvancedBarChart" {
    declare const Metrics$AdvancedBarChart = cn.nukkit.metrics.Metrics$AdvancedBarChart;
}

declare namespace cn.nukkit.metrics {
    declare class Metrics$MultiLineChart extends cn.nukkit.metrics.Metrics$CustomChart {
        public constructor(chartId: string, callable: java.util.concurrent.Callable<java.util.Map<string, int>>): void
        getChartData(): com.nimbusds.jose.shaded.json.JSONObject
        callable: java.util.concurrent.Callable<java.util.Map<string, int>>

    }
}

declare module "cn.nukkit.metrics.Metrics$MultiLineChart" {
    declare const Metrics$MultiLineChart = cn.nukkit.metrics.Metrics$MultiLineChart;
}

declare namespace cn.nukkit.metrics {
    declare class Metrics$SimplePie extends cn.nukkit.metrics.Metrics$CustomChart {
        public constructor(chartId: string, callable: java.util.concurrent.Callable<string>): void
        getChartData(): com.nimbusds.jose.shaded.json.JSONObject
        callable: java.util.concurrent.Callable<string>

    }
}

declare module "cn.nukkit.metrics.Metrics$SimplePie" {
    declare const Metrics$SimplePie = cn.nukkit.metrics.Metrics$SimplePie;
}

declare namespace cn.nukkit.metrics {
    declare class NukkitMetrics extends java.lang.Object {
        public constructor(server: cn.nukkit.Server): void
        constructor(server: cn.nukkit.Server, start: boolean): void
        public static startNow(server: cn.nukkit.Server): boolean
        static getOrCreateMetrics(server: cn.nukkit.Server): cn.nukkit.metrics.NukkitMetrics
        static createMetrics(server: cn.nukkit.Server): cn.nukkit.metrics.NukkitMetrics
        loadConfig(): void
        writeFile(file: java.io.File, lines: string[]): void
        mapDeviceOSToString(os: int): string
        static lambda$createMetrics$4(server: cn.nukkit.Server): java.util.Map
        static lambda$createMetrics$3(server: cn.nukkit.Server, nukkitMetrics: cn.nukkit.metrics.NukkitMetrics): java.util.Map
        static lambda$createMetrics$2(server: cn.nukkit.Server): string
        static lambda$createMetrics$1(server: cn.nukkit.Server): int
        static lambda$getOrCreateMetrics$0(server: cn.nukkit.Server, before: java.util.Map): java.util.Map
        static log: org.apache.logging.log4j.Logger
        static metricsStarted: java.util.concurrent.atomic.AtomicReference<java.util.Map<cn.nukkit.Server, cn.nukkit.metrics.NukkitMetrics>>
        server: cn.nukkit.Server
        enabled: boolean
        serverUUID: string
        logFailedRequests: boolean
        metrics: cn.nukkit.metrics.Metrics
        static $assertionsDisabled: boolean

    }
}

declare module "cn.nukkit.metrics.NukkitMetrics" {
    declare const NukkitMetrics = cn.nukkit.metrics.NukkitMetrics;
}

declare namespace cn.nukkit.metrics {
    declare class Metrics$SingleLineChart extends cn.nukkit.metrics.Metrics$CustomChart {
        public constructor(chartId: string, callable: java.util.concurrent.Callable<int>): void
        getChartData(): com.nimbusds.jose.shaded.json.JSONObject
        callable: java.util.concurrent.Callable<int>

    }
}

declare module "cn.nukkit.metrics.Metrics$SingleLineChart" {
    declare const Metrics$SingleLineChart = cn.nukkit.metrics.Metrics$SingleLineChart;
}

declare namespace cn.nukkit.lang {
    declare class BaseLang extends java.lang.Object {
        public constructor(lang: string): void
        public constructor(lang: string, path: string): void
        public constructor(lang: string, path: string, fallback: string): void
        public getLangMap(): java.util.Map<string, string>
        public getFallbackLangMap(): java.util.Map<string, string>
        public getName(): string
        public getLang(): string
        loadLang(path: string): java.util.Map<string, string>
        loadLang(stream: java.io.InputStream): java.util.Map<string, string>
        parseLang(reader: java.io.BufferedReader): java.util.Map<string, string>
        public translateString(str: string): string
        public translateString(str: string, params: string[]): string
        public translateString(str: string, params: java.lang.Object[]): string
        public translateString(str: string, param: string, onlyPrefix: string): string
        public translateString(str: string, params: string[], onlyPrefix: string): string
        public translate(c: cn.nukkit.lang.TextContainer): string
        public internalGet(id: string): string
        public get(id: string): string
        parseTranslation(text: string): string
        parseTranslation(text: string, onlyPrefix: string): string
        static log: org.apache.logging.log4j.Logger
        public static FALLBACK_LANGUAGE: string
        langName: string
        lang: java.util.Map<string, string>
        fallbackLang: java.util.Map<string, string>

    }
}

declare module "cn.nukkit.lang.BaseLang" {
    declare const BaseLang = cn.nukkit.lang.BaseLang;
}

declare namespace cn.nukkit.lang {
    declare class TranslationContainer extends cn.nukkit.lang.TextContainer implements java.lang.Cloneable {
        public constructor(text: string): void
        public constructor(text: string, params: string): void
        public constructor(text: string, params: string[]): void
        public getParameters(): string[]
        public setParameters(params: string[]): void
        public getParameter(i: int): string
        public setParameter(i: int, str: string): void
        public clone(): cn.nukkit.lang.TranslationContainer
        public clone(): cn.nukkit.lang.TextContainer
        public clone(): java.lang.Object
        params: string[]

    }
}

declare module "cn.nukkit.lang.TranslationContainer" {
    declare const TranslationContainer = cn.nukkit.lang.TranslationContainer;
}

declare namespace cn.nukkit.lang {
    declare class TextContainer extends java.lang.Object implements java.lang.Cloneable {
        public constructor(text: string): void
        public setText(text: string): void
        public getText(): string
        public toString(): string
        public clone(): cn.nukkit.lang.TextContainer
        public clone(): java.lang.Object
        static log: org.apache.logging.log4j.Logger
        text: string

    }
}

declare module "cn.nukkit.lang.TextContainer" {
    declare const TextContainer = cn.nukkit.lang.TextContainer;
}

declare namespace cn.nukkit.utils {
    declare class ChunkException extends java.lang.RuntimeException {
        public constructor(message: string): void
        public constructor(message: string, cause: java.lang.Throwable): void
        public constructor(cause: java.lang.Throwable): void

    }
}

declare module "cn.nukkit.utils.ChunkException" {
    declare const ChunkException = cn.nukkit.utils.ChunkException;
}

declare namespace cn.nukkit.utils {
    declare class BannerPattern extends java.lang.Object {
        public constructor(type: cn.nukkit.utils.BannerPattern$Type, color: cn.nukkit.utils.DyeColor): void
        public getColor(): cn.nukkit.utils.DyeColor
        public getType(): cn.nukkit.utils.BannerPattern$Type
        public static fromCompoundTag(compoundTag: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.utils.BannerPattern
        type: cn.nukkit.utils.BannerPattern$Type
        color: cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.utils.BannerPattern" {
    declare const BannerPattern = cn.nukkit.utils.BannerPattern;
}

declare namespace cn.nukkit.utils {
    declare class TerracottaColor extends java.lang.Enum {
        public static values(): cn.nukkit.utils.TerracottaColor[]
        public static valueOf(name: string): cn.nukkit.utils.TerracottaColor
        constructor(var0: int, var1: int, dyeColorMeta: string, terracottaColorMeta: cn.nukkit.utils.BlockColor): void
        constructor(var0: int, var1: int, dyeColorMeta: string, terracottaColorMeta: string, colorName: cn.nukkit.utils.BlockColor): void
        public getColor(): cn.nukkit.utils.BlockColor
        public getDyeData(): int
        public getTerracottaData(): int
        public getName(): string
        public getDyeName(): string
        public static getByDyeData(dyeColorMeta: int): cn.nukkit.utils.TerracottaColor
        public static getByTerracottaData(terracottaColorMeta: int): cn.nukkit.utils.TerracottaColor
        static $values(): cn.nukkit.utils.TerracottaColor[]
        public static BLACK: cn.nukkit.utils.TerracottaColor
        public static RED: cn.nukkit.utils.TerracottaColor
        public static GREEN: cn.nukkit.utils.TerracottaColor
        public static BROWN: cn.nukkit.utils.TerracottaColor
        public static BLUE: cn.nukkit.utils.TerracottaColor
        public static PURPLE: cn.nukkit.utils.TerracottaColor
        public static CYAN: cn.nukkit.utils.TerracottaColor
        public static LIGHT_GRAY: cn.nukkit.utils.TerracottaColor
        public static GRAY: cn.nukkit.utils.TerracottaColor
        public static PINK: cn.nukkit.utils.TerracottaColor
        public static LIME: cn.nukkit.utils.TerracottaColor
        public static YELLOW: cn.nukkit.utils.TerracottaColor
        public static LIGHT_BLUE: cn.nukkit.utils.TerracottaColor
        public static MAGENTA: cn.nukkit.utils.TerracottaColor
        public static ORANGE: cn.nukkit.utils.TerracottaColor
        public static WHITE: cn.nukkit.utils.TerracottaColor
        dyeColorMeta: int
        terracottaColorMeta: int
        colorName: string
        dyeName: string
        blockColor: cn.nukkit.utils.BlockColor
        static BY_TERRACOTA_DATA: cn.nukkit.utils.TerracottaColor[]
        static BY_DYE_DATA: cn.nukkit.utils.TerracottaColor[]
        static $VALUES: cn.nukkit.utils.TerracottaColor[]

    }
}

declare module "cn.nukkit.utils.TerracottaColor" {
    declare const TerracottaColor = cn.nukkit.utils.TerracottaColor;
}

declare namespace cn.nukkit.utils {
    declare class ThreadCache$6 extends cn.nukkit.utils.IterableThreadLocal {
        constructor(): void
        public init(): char[]
        public init(): java.lang.Object

    }
}

declare module "cn.nukkit.utils.ThreadCache$6" {
    declare const ThreadCache$6 = cn.nukkit.utils.ThreadCache$6;
}

declare namespace cn.nukkit.utils {
    declare class PluginException extends cn.nukkit.utils.ServerException {
        public constructor(message: string): void
        public constructor(message: string, cause: java.lang.Throwable): void

    }
}

declare module "cn.nukkit.utils.PluginException" {
    declare const PluginException = cn.nukkit.utils.PluginException;
}

declare namespace cn.nukkit.utils.collection {
    declare class ConvertingMapWrapper extends java.util.AbstractMap {
        public constructor(proxied: java.util.Map<void>, converter: java.util.function.Function<void, void>, reverseConverter: java.util.function.Function<void, void>, convertReturnedNulls: boolean): void
        public constructor(proxied: java.util.Map<void>, converter: java.util.function.Function<void, void>, reverseConverter: java.util.function.Function<void, void>): void
        public entrySet(): java.util.Set<java.util.Map$Entry<void>>
        public size(): int
        public isEmpty(): boolean
        public containsValue(value: java.lang.Object): boolean
        public containsKey(key: java.lang.Object): boolean
        public get(key: java.lang.Object): void
        public put(key: void): void
        public remove(key: java.lang.Object): void
        public remove(key: java.lang.Object, value: java.lang.Object): boolean
        public clear(): void
        public keySet(): java.util.Set<any>
        lambda$new$1(converter: java.util.function.Function, reverseConverter: java.util.function.Function, entry: java.util.Map$Entry): java.util.Map$Entry
        lambda$new$0(reverseConverter: java.util.function.Function, converter: java.util.function.Function, entry: java.util.Map$Entry): java.util.Map$Entry
        converter: java.util.function.Function<void, void>
        reverseConverter: java.util.function.Function<void, void>
        proxied: java.util.Map<void>
        entrySet: cn.nukkit.utils.collection.ConvertingSetWrapper<void>
        convertReturnedNulls: boolean

    }
}

declare module "cn.nukkit.utils.collection.ConvertingMapWrapper" {
    declare const ConvertingMapWrapper = cn.nukkit.utils.collection.ConvertingMapWrapper;
}

declare namespace cn.nukkit.utils.collection {
    declare class ConvertingSetWrapper extends java.util.AbstractSet {
        public constructor(proxied: java.util.Set<void>, converter: java.util.function.Function<void, void>, reverseConverter: java.util.function.Function<void, void>): void
        public iterator(): java.util.Iterator<void>
        public size(): int
        public isEmpty(): boolean
        public contains(o: java.lang.Object): boolean
        public add(v1: void): boolean
        public remove(o: java.lang.Object): boolean
        public clear(): void
        converter: java.util.function.Function<void, void>
        reverseConverter: java.util.function.Function<void, void>
        proxied: java.util.Set<void>

    }
}

declare module "cn.nukkit.utils.collection.ConvertingSetWrapper" {
    declare const ConvertingSetWrapper = cn.nukkit.utils.collection.ConvertingSetWrapper;
}

declare namespace cn.nukkit.utils {
    declare class BinaryStream extends java.lang.Object {
        public constructor(): void
        public constructor(buffer: byte[]): void
        public constructor(buffer: byte[], offset: int): void
        public reset(): cn.nukkit.utils.BinaryStream
        public setBuffer(buffer: byte[]): void
        public setBuffer(buffer: byte[], offset: int): void
        public getOffset(): int
        public setOffset(offset: int): void
        public getBuffer(): byte[]
        public getCount(): int
        public get(): byte[]
        public get(len: int): byte[]
        public put(bytes: byte[]): void
        public getLong(): long
        public putLong(l: long): void
        public getInt(): int
        public putInt(i: int): void
        public getLLong(): long
        public putLLong(l: long): void
        public getLInt(): int
        public putLInt(i: int): void
        public getShort(): int
        public putShort(s: int): void
        public getLShort(): int
        public putLShort(s: int): void
        public getFloat(): float
        public getFloat(accuracy: int): float
        public putFloat(v: float): void
        public getLFloat(): float
        public getLFloat(accuracy: int): float
        public putLFloat(v: float): void
        public getTriad(): int
        public putTriad(triad: int): void
        public getLTriad(): int
        public putLTriad(triad: int): void
        public getBoolean(): boolean
        public putBoolean(bool: boolean): void
        public getByte(): int
        public putByte(b: byte): void
        public getAttributeList(): cn.nukkit.entity.Attribute[]
        public putAttributeList(attributes: cn.nukkit.entity.Attribute[]): void
        public putUUID(uuid: java.util.UUID): void
        public getUUID(): java.util.UUID
        public putSkin(skin: cn.nukkit.entity.data.Skin): void
        public getSkin(): cn.nukkit.entity.data.Skin
        public putImage(image: cn.nukkit.utils.SerializedImage): void
        public getImage(): cn.nukkit.utils.SerializedImage
        public getSlot(): cn.nukkit.item.Item
        readUnknownItem(item: cn.nukkit.item.Item): cn.nukkit.item.Item
        createFakeUnknownItem(item: cn.nukkit.item.Item): cn.nukkit.item.Item
        public putSlot(item: cn.nukkit.item.Item): void
        public putSlot(item: cn.nukkit.item.Item, instanceItem: boolean): void
        public getRecipeIngredient(): cn.nukkit.item.Item
        public putRecipeIngredient(ingredient: cn.nukkit.item.Item): void
        extractStringList(item: cn.nukkit.item.Item, tagName: string): java.util.List<string>
        public getByteArray(): byte[]
        public putByteArray(b: byte[]): void
        public getString(): string
        public putString(string: string): void
        public getUnsignedVarInt(): long
        public putUnsignedVarInt(v: long): void
        public getVarInt(): int
        public putVarInt(v: int): void
        public getVarLong(): long
        public putVarLong(v: long): void
        public getUnsignedVarLong(): long
        public putUnsignedVarLong(v: long): void
        public getBlockVector3(): cn.nukkit.math.BlockVector3
        public getSignedBlockPosition(): cn.nukkit.math.BlockVector3
        public putSignedBlockPosition(v: cn.nukkit.math.BlockVector3): void
        public putBlockVector3(v: cn.nukkit.math.BlockVector3): void
        public putBlockVector3(x: int, y: int, z: int): void
        public getVector3f(): cn.nukkit.math.Vector3f
        public putVector3f(v: cn.nukkit.math.Vector3f): void
        public putVector3f(x: float, y: float, z: float): void
        public putGameRules(gameRules: cn.nukkit.level.GameRules): void
        public getEntityUniqueId(): long
        public putEntityUniqueId(eid: long): void
        public getEntityRuntimeId(): long
        public putEntityRuntimeId(eid: long): void
        public getBlockFace(): cn.nukkit.math.BlockFace
        public putBlockFace(face: cn.nukkit.math.BlockFace): void
        public putEntityLink(link: cn.nukkit.network.protocol.types.EntityLink): void
        public getEntityLink(): cn.nukkit.network.protocol.types.EntityLink
        public putArray(collection: java.lang.Object, writer: java.util.Collection<any>, var2: java.util.function.Consumer<any>): void
        public putArray(collection: java.lang.Object, writer: java.util.function.Consumer<any>): void
        public getArray(clazz: java.lang.Object, __function__: java.lang.Class<any>): java.util.function.Function<cn.nukkit.utils.BinaryStream>
        public feof(): boolean
        public getTag(): cn.nukkit.nbt.tag.CompoundTag
        public putTag(tag: cn.nukkit.nbt.tag.CompoundTag): void
        ensureCapacity(minCapacity: int): void
        grow(minCapacity: int): void
        static hugeCapacity(minCapacity: int): int
        lambda$putGameRules$0(gameRule: cn.nukkit.level.GameRule, value: cn.nukkit.level.GameRules$Value): void
        static log: org.apache.logging.log4j.Logger
        static FALLBACK_ID: int
        public offset: int
        buffer: byte[]
        count: int
        static MAX_ARRAY_SIZE: int

    }
}

declare module "cn.nukkit.utils.BinaryStream" {
    declare const BinaryStream = cn.nukkit.utils.BinaryStream;
}

declare namespace cn.nukkit.utils {
    declare class Rail$Orientation$State extends java.lang.Enum {
        public static values(): cn.nukkit.utils.Rail$Orientation$State[]
        public static valueOf(name: string): cn.nukkit.utils.Rail$Orientation$State
        constructor(): void
        static $values(): cn.nukkit.utils.Rail$Orientation$State[]
        public static STRAIGHT: cn.nukkit.utils.Rail$Orientation$State
        public static ASCENDING: cn.nukkit.utils.Rail$Orientation$State
        public static CURVED: cn.nukkit.utils.Rail$Orientation$State
        static $VALUES: cn.nukkit.utils.Rail$Orientation$State[]

    }
}

declare module "cn.nukkit.utils.Rail$Orientation$State" {
    declare const Rail$Orientation$State = cn.nukkit.utils.Rail$Orientation$State;
}

declare namespace cn.nukkit.utils {
    declare class ThreadCache$2 extends cn.nukkit.utils.IterableThreadLocal {
        constructor(): void
        public init(): byte[][]
        public init(): java.lang.Object

    }
}

declare module "cn.nukkit.utils.ThreadCache$2" {
    declare const ThreadCache$2 = cn.nukkit.utils.ThreadCache$2;
}

declare namespace cn.nukkit.utils {
    declare interface RedstoneComponent {
        public updateAroundRedstone(ignoredFaces: cn.nukkit.math.BlockFace[]): void
        public updateAroundRedstone(ignoredFaces: java.util.List<cn.nukkit.math.BlockFace>): void
        public updateAllAroundRedstone(ignoredFaces: cn.nukkit.math.BlockFace[]): void
        public updateAllAroundRedstone(ignoredFaces: java.util.List<cn.nukkit.math.BlockFace>): void
        public static updateAroundRedstone(pos: cn.nukkit.level.Position, ignoredFaces: cn.nukkit.math.BlockFace[]): void
        public static updateAroundRedstone(pos: cn.nukkit.level.Position, ignoredFaces: java.util.List<cn.nukkit.math.BlockFace>): void
        public static updateAllAroundRedstone(pos: cn.nukkit.level.Position, ignoredFaces: cn.nukkit.math.BlockFace[]): void
        public static updateAllAroundRedstone(pos: cn.nukkit.level.Position, ignoredFaces: java.util.List<cn.nukkit.math.BlockFace>): void

    }
}

declare module "cn.nukkit.utils.RedstoneComponent" {
    declare type RedstoneComponent = cn.nukkit.utils.RedstoneComponent;
}

declare namespace cn.nukkit.utils.functional {
    declare interface TriFunction {
        public apply(var0: float): short
        public andThen(after: void, var1: java.lang.Object, var2: java.util.function.Function<void>): cn.nukkit.utils.functional.TriFunction<float, short, void>
        lambda$andThen$0(after: java.util.function.Function, f: java.lang.Object, s: java.lang.Object, t: java.lang.Object): java.lang.Object

    }
}

declare module "cn.nukkit.utils.functional.TriFunction" {
    declare type TriFunction = cn.nukkit.utils.functional.TriFunction;
}

declare namespace cn.nukkit.utils.functional {
    declare interface BooleanConsumer {
        public accept(var0: boolean): void
        public andThen(after: cn.nukkit.utils.functional.BooleanConsumer): cn.nukkit.utils.functional.BooleanConsumer
        lambda$andThen$0(after: cn.nukkit.utils.functional.BooleanConsumer, t: boolean): void

    }
}

declare module "cn.nukkit.utils.functional.BooleanConsumer" {
    declare type BooleanConsumer = cn.nukkit.utils.functional.BooleanConsumer;
}

declare namespace cn.nukkit.utils.functional {
    declare interface ToIntTriFunctionTwoInts {
        public apply(var0: float, var1: int, var2: int): int
        public andThen(after: java.util.function.IntUnaryOperator): cn.nukkit.utils.functional.ToIntTriFunctionTwoInts<float>
        lambda$andThen$0(after: java.util.function.IntUnaryOperator, f: java.lang.Object, s: int, t: int): int

    }
}

declare module "cn.nukkit.utils.functional.ToIntTriFunctionTwoInts" {
    declare type ToIntTriFunctionTwoInts = cn.nukkit.utils.functional.ToIntTriFunctionTwoInts;
}

declare namespace cn.nukkit.utils.functional {
    declare interface ToIntTriFunctionOneInt {
        public apply(var0: float, var1: short, var2: int): int
        public andThen(after: java.util.function.IntUnaryOperator): cn.nukkit.utils.functional.ToIntTriFunctionOneInt<float, short>
        lambda$andThen$0(after: java.util.function.IntUnaryOperator, f: java.lang.Object, s: java.lang.Object, t: int): int

    }
}

declare module "cn.nukkit.utils.functional.ToIntTriFunctionOneInt" {
    declare type ToIntTriFunctionOneInt = cn.nukkit.utils.functional.ToIntTriFunctionOneInt;
}

declare namespace cn.nukkit.utils {
    declare class ThreadCache extends java.lang.Object {
        public constructor(): void
        public static clean(): void
        public static idArray: int
        public static dataArray: int
        public static byteCache6144: int
        public static byteCache256: int
        public static boolCache4096: int
        public static charCache4096v2: int
        public static charCache4096: int
        public static intCache256: int
        public static fbaos: cn.nukkit.utils.IterableThreadLocal<cn.nukkit.nbt.stream.FastByteArrayOutputStream>
        public static binaryStream: cn.nukkit.utils.IterableThreadLocal<cn.nukkit.utils.BinaryStream>

    }
}

declare module "cn.nukkit.utils.ThreadCache" {
    declare const ThreadCache = cn.nukkit.utils.ThreadCache;
}

declare namespace cn.nukkit.utils {
    declare class PersonaPiece extends java.lang.Object {
        public constructor(id: string, type: string, packId: string, isDefault: boolean, productId: string): void
        public toString(): string
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        public id: string
        public type: string
        public packId: string
        public isDefault: boolean
        public productId: string

    }
}

declare module "cn.nukkit.utils.PersonaPiece" {
    declare const PersonaPiece = cn.nukkit.utils.PersonaPiece;
}

declare namespace cn.nukkit.utils {
    declare class ConfigSection extends java.util.LinkedHashMap {
        public constructor(): void
        public constructor(key: string, value: java.lang.Object): void
        public constructor(map: java.util.LinkedHashMap<string, java.lang.Object>): void
        parseList(list: java.util.List): java.util.List
        public getAllMap(): java.util.Map<string, java.lang.Object>
        public getAll(): cn.nukkit.utils.ConfigSection
        public get(key: string): java.lang.Object
        public get(key: java.lang.Object): string
        public set(key: string, value: java.lang.Object): void
        public isSection(key: string): boolean
        public getSection(key: string): cn.nukkit.utils.ConfigSection
        public getSections(): cn.nukkit.utils.ConfigSection
        public getSections(key: string): cn.nukkit.utils.ConfigSection
        public getInt(key: string): int
        public getInt(key: string, defaultValue: int): int
        public isInt(key: string): boolean
        public getLong(key: string): long
        public getLong(key: string, defaultValue: long): long
        public isLong(key: string): boolean
        public getDouble(key: string): double
        public getDouble(key: string, defaultValue: double): double
        public isDouble(key: string): boolean
        public getString(key: string): string
        public getString(key: string, defaultValue: string): string
        public isString(key: string): boolean
        public getBoolean(key: string): boolean
        public getBoolean(key: string, defaultValue: boolean): boolean
        public isBoolean(key: string): boolean
        public getList(key: string): java.util.List
        public getList(key: string, defaultList: java.util.List): java.util.List
        public isList(key: string): boolean
        public getStringList(key: string): java.util.List<string>
        public getIntegerList(key: string): java.util.List<int>
        public getBooleanList(key: string): java.util.List<boolean>
        public getDoubleList(key: string): java.util.List<double>
        public getFloatList(key: string): java.util.List<float>
        public getLongList(key: string): java.util.List<long>
        public getByteList(key: string): java.util.List<byte>
        public getCharacterList(key: string): java.util.List<char>
        public getShortList(key: string): java.util.List<java.lang.Short>
        public getMapList(key: string): java.util.List<java.util.Map>
        public exists(key: string, ignoreCase: boolean): boolean
        public exists(key: string): boolean
        public remove(key: string): void
        public getKeys(child: boolean): java.util.Set<string>
        public getKeys(): java.util.Set<string>
        static lambda$getKeys$2(keys: java.util.Set, child: boolean, key: string, value: java.lang.Object): void
        static lambda$getKeys$1(keys: java.util.Set, key: string, childKey: string): void
        static lambda$getSections$0(sections: cn.nukkit.utils.ConfigSection, key1: string, value: java.lang.Object): void

    }
}

declare module "cn.nukkit.utils.ConfigSection" {
    declare const ConfigSection = cn.nukkit.utils.ConfigSection;
}

declare namespace cn.nukkit.utils {
    declare class SimpleConfig extends java.lang.Object {
        public constructor(plugin: cn.nukkit.plugin.Plugin): void
        public constructor(plugin: cn.nukkit.plugin.Plugin, fileName: string): void
        public constructor(file: java.io.File): void
        public save(): boolean
        public save(async: boolean): boolean
        public load(): boolean
        getPath(field: java.lang.reflect.Field): string
        skipSave(field: java.lang.reflect.Field): boolean
        skipLoad(field: java.lang.reflect.Field): boolean
        static log: org.apache.logging.log4j.Logger
        configFile: java.io.File

    }
}

declare module "cn.nukkit.utils.SimpleConfig" {
    declare const SimpleConfig = cn.nukkit.utils.SimpleConfig;
}

declare namespace cn.nukkit.utils {
    declare class SerializedImage extends java.lang.Object {
        public constructor(width: int, height: int, data: byte[]): void
        public static fromLegacy(skinData: byte[]): cn.nukkit.utils.SerializedImage
        public toString(): string
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        public static EMPTY: cn.nukkit.utils.SerializedImage
        public width: int
        public height: int
        public data: byte[]

    }
}

declare module "cn.nukkit.utils.SerializedImage" {
    declare const SerializedImage = cn.nukkit.utils.SerializedImage;
}

declare namespace cn.nukkit.utils {
    declare class DummyBossBar extends java.lang.Object {
        constructor(builder: cn.nukkit.utils.DummyBossBar$Builder): void
        public getPlayer(): cn.nukkit.Player
        public getBossBarId(): long
        public getText(): string
        public setText(text: string): void
        public getLength(): float
        public setLength(length: float): void
        public setColor(color: cn.nukkit.utils.BossBarColor): void
        public getColor(): cn.nukkit.utils.BossBarColor
        createBossEntity(): void
        sendAttributes(): void
        sendShowBossBar(): void
        sendHideBossBar(): void
        sendSetBossBarTexture(): void
        sendSetBossBarTitle(): void
        sendSetBossBarLength(): void
        public updateBossEntityPosition(): void
        updateBossEntityNameTag(): void
        removeBossEntity(): void
        public create(): void
        public reshow(): void
        public destroy(): void
        player: cn.nukkit.Player
        bossBarId: long
        text: string
        length: float
        color: cn.nukkit.utils.BossBarColor

    }
}

declare module "cn.nukkit.utils.DummyBossBar" {
    declare const DummyBossBar = cn.nukkit.utils.DummyBossBar;
}

declare namespace cn.nukkit {
    declare class Nukkit extends java.lang.Object {
        public constructor(): void
        public static main(args: string[]): void
        static requiresShortTitle(): boolean
        static getGitInfo(): java.util.Properties
        static getVersion(): string
        static getGitCommit(): string
        public static setLogLevel(level: org.apache.logging.log4j.Level): void
        public static getLogLevel(): org.apache.logging.log4j.Level
        static lambda$main$5(disableSentry: java.util.concurrent.atomic.AtomicBoolean, options: io.sentry.SentryOptions): void
        static lambda$main$4(disableSentry: java.util.concurrent.atomic.AtomicBoolean, event: io.sentry.SentryEvent, hint: java.lang.Object): io.sentry.SentryEvent
        static lambda$main$3(entry: java.util.Map$Entry): java.util.AbstractMap$SimpleEntry
        static lambda$main$2(l: cn.nukkit.level.Level): int
        static lambda$main$1(l: cn.nukkit.level.Level): int
        static lambda$main$0(l: cn.nukkit.level.Level): int
        static log: org.apache.logging.log4j.Logger
        public static GIT_INFO: java.util.Properties
        public static VERSION: string
        public static GIT_COMMIT: string
        public static API_VERSION: string
        public static CODENAME: string
        public static MINECRAFT_VERSION: string
        public static MINECRAFT_VERSION_NETWORK: string
        public static PATH: string
        public static DATA_PATH: string
        public static PLUGIN_PATH: string
        public static START_TIME: long
        public static ANSI: boolean
        public static TITLE: boolean
        public static shortTitle: boolean
        public static DEBUG: int
        public static CHROME_DEBUG_PORT: int
        public static JS_DEBUG_LIST: java.util.List<string>

    }
}

declare module "cn.nukkit.Nukkit" {
    declare const Nukkit = cn.nukkit.Nukkit;
}

declare namespace cn.nukkit.math {
    declare class ChunkVector2 extends java.lang.Object {
        public constructor(): void
        public constructor(x: int): void
        public constructor(x: int, z: int): void
        public getX(): int
        public getZ(): int
        public setX(x: int): void
        public setZ(z: int): void
        public add(x: int): cn.nukkit.math.ChunkVector2
        public add(x: int, y: int): cn.nukkit.math.ChunkVector2
        public add(x: cn.nukkit.math.ChunkVector2): cn.nukkit.math.ChunkVector2
        public subtract(x: int): cn.nukkit.math.ChunkVector2
        public subtract(x: int, y: int): cn.nukkit.math.ChunkVector2
        public subtract(x: cn.nukkit.math.ChunkVector2): cn.nukkit.math.ChunkVector2
        public abs(): cn.nukkit.math.ChunkVector2
        public multiply(number: int): cn.nukkit.math.ChunkVector2
        public divide(number: int): cn.nukkit.math.ChunkVector2
        public distance(x: double): double
        public distance(x: double, var1: double): double
        public distance(vector: cn.nukkit.math.ChunkVector2): double
        public distanceSquared(x: double): double
        public distanceSquared(x: double, var1: double): double
        public distanceSquared(vector: cn.nukkit.math.ChunkVector2): double
        public length(): double
        public lengthSquared(): int
        public dot(v: cn.nukkit.math.ChunkVector2): int
        public toString(): string
        x: int
        z: int

    }
}

declare module "cn.nukkit.math.ChunkVector2" {
    declare const ChunkVector2 = cn.nukkit.math.ChunkVector2;
}

declare namespace cn.nukkit.math {
    declare class Vector3 extends java.lang.Object implements java.lang.Cloneable {
        public constructor(): void
        public constructor(x: double): void
        public constructor(x: double, var1: double): void
        public constructor(x: double, var1: double, y: double): void
        public getX(): double
        public getY(): double
        public getZ(): double
        public setX(x: double): cn.nukkit.math.Vector3
        public setY(y: double): cn.nukkit.math.Vector3
        public setZ(z: double): cn.nukkit.math.Vector3
        public getFloorX(): int
        public getFloorY(): int
        public getFloorZ(): int
        public getChunkX(): int
        public getChunkZ(): int
        public getChunkSectionY(): int
        public getChunkVector(): cn.nukkit.math.ChunkVector2
        public getRight(): double
        public getUp(): double
        public getForward(): double
        public getSouth(): double
        public getWest(): double
        public add(x: double): cn.nukkit.math.Vector3
        public add(x: double, var1: double): cn.nukkit.math.Vector3
        public add(x: double, var1: double, y: double): cn.nukkit.math.Vector3
        public add(x: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public subtract(): cn.nukkit.math.Vector3
        public subtract(x: double): cn.nukkit.math.Vector3
        public subtract(x: double, var1: double): cn.nukkit.math.Vector3
        public subtract(x: double, var1: double, y: double): cn.nukkit.math.Vector3
        public subtract(x: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public multiply(number: double): cn.nukkit.math.Vector3
        public divide(number: double): cn.nukkit.math.Vector3
        public ceil(): cn.nukkit.math.Vector3
        public floor(): cn.nukkit.math.Vector3
        public round(): cn.nukkit.math.Vector3
        public abs(): cn.nukkit.math.Vector3
        public getSide(face: cn.nukkit.math.BlockFace): cn.nukkit.math.Vector3
        public getSide(face: cn.nukkit.math.BlockFace, step: int): cn.nukkit.math.Vector3
        public getSideVec(face: cn.nukkit.math.BlockFace): cn.nukkit.math.Vector3
        public up(): cn.nukkit.math.Vector3
        public up(step: int): cn.nukkit.math.Vector3
        public down(): cn.nukkit.math.Vector3
        public down(step: int): cn.nukkit.math.Vector3
        public north(): cn.nukkit.math.Vector3
        public north(step: int): cn.nukkit.math.Vector3
        public south(): cn.nukkit.math.Vector3
        public south(step: int): cn.nukkit.math.Vector3
        public east(): cn.nukkit.math.Vector3
        public east(step: int): cn.nukkit.math.Vector3
        public west(): cn.nukkit.math.Vector3
        public west(step: int): cn.nukkit.math.Vector3
        public distanceManhattan(pos: cn.nukkit.math.Vector3): int
        public distance(pos: cn.nukkit.math.Vector3): double
        public distanceSquared(pos: cn.nukkit.math.Vector3): double
        public distance(x: double, var1: double, y: double): double
        public distanceSquared(x: double, var1: double, y: double): double
        public maxPlainDistance(): double
        public maxPlainDistance(x: double): double
        public maxPlainDistance(x: double, var1: double): double
        public maxPlainDistance(vector: cn.nukkit.math.Vector2): double
        public maxPlainDistance(x: cn.nukkit.math.Vector3): double
        public length(): double
        public lengthSquared(): double
        public normalize(): cn.nukkit.math.Vector3
        public dot(v: cn.nukkit.math.Vector3): double
        public cross(v: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public getIntermediateWithXValue(v: cn.nukkit.math.Vector3, x: double): cn.nukkit.math.Vector3
        public getIntermediateWithYValue(v: cn.nukkit.math.Vector3, y: double): cn.nukkit.math.Vector3
        public getIntermediateWithZValue(v: cn.nukkit.math.Vector3, z: double): cn.nukkit.math.Vector3
        public setComponents(x: double, var1: double, y: double): cn.nukkit.math.Vector3
        public setComponentsAdding(x: double, var1: double, y: double, var3: double, z: double, var5: double): cn.nukkit.math.Vector3
        public setComponentsAdding(pos: cn.nukkit.math.Vector3, face: cn.nukkit.math.BlockFace): cn.nukkit.math.Vector3
        public setComponents(pos: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public getAxis(axis: cn.nukkit.math.BlockFace$Axis): double
        public toString(): string
        public equals(obj: java.lang.Object): boolean
        public hashCode(): int
        public rawHashCode(): int
        public clone(): cn.nukkit.math.Vector3
        public asVector3f(): cn.nukkit.math.Vector3f
        public asBlockVector3(): cn.nukkit.math.BlockVector3
        public clone(): java.lang.Object
        public x: double
        public y: double
        public z: double

    }
}

declare module "cn.nukkit.math.Vector3" {
    declare const Vector3 = cn.nukkit.math.Vector3;
}

declare namespace cn.nukkit.math {
    declare interface AxisAlignedBB$BBConsumer {
        public accept(var0: int, var1: int, var2: int): void
        public get(): any

    }
}

declare module "cn.nukkit.math.AxisAlignedBB$BBConsumer" {
    declare type AxisAlignedBB$BBConsumer = cn.nukkit.math.AxisAlignedBB$BBConsumer;
}

declare namespace cn.nukkit.math {
    declare class Vector2 extends java.lang.Object {
        public constructor(): void
        public constructor(x: double): void
        public constructor(x: double, var1: double): void
        public getX(): double
        public getY(): double
        public getFloorX(): int
        public getFloorY(): int
        public add(x: double): cn.nukkit.math.Vector2
        public add(x: double, var1: double): cn.nukkit.math.Vector2
        public add(x: cn.nukkit.math.Vector2): cn.nukkit.math.Vector2
        public subtract(x: double): cn.nukkit.math.Vector2
        public subtract(x: double, var1: double): cn.nukkit.math.Vector2
        public subtract(x: cn.nukkit.math.Vector2): cn.nukkit.math.Vector2
        public ceil(): cn.nukkit.math.Vector2
        public floor(): cn.nukkit.math.Vector2
        public round(): cn.nukkit.math.Vector2
        public abs(): cn.nukkit.math.Vector2
        public multiply(number: double): cn.nukkit.math.Vector2
        public divide(number: double): cn.nukkit.math.Vector2
        public distance(x: double): double
        public distance(x: double, var1: double): double
        public distance(vector: cn.nukkit.math.Vector2): double
        public distanceSquared(x: double): double
        public distanceSquared(x: double, var1: double): double
        public distanceSquared(vector: cn.nukkit.math.Vector2): double
        public length(): double
        public lengthSquared(): double
        public normalize(): cn.nukkit.math.Vector2
        public dot(v: cn.nukkit.math.Vector2): double
        public toString(): string
        public x: double
        public y: double

    }
}

declare module "cn.nukkit.math.Vector2" {
    declare const Vector2 = cn.nukkit.math.Vector2;
}

declare namespace cn.nukkit.math {
    declare class Vector3f$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$math$BlockFace$Axis: int[]

    }
}

declare module "cn.nukkit.math.Vector3f$1" {
    declare const Vector3f$1 = cn.nukkit.math.Vector3f$1;
}

declare namespace cn.nukkit.math {
    declare class BlockVector3$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$math$BlockFace$Axis: int[]

    }
}

declare module "cn.nukkit.math.BlockVector3$1" {
    declare const BlockVector3$1 = cn.nukkit.math.BlockVector3$1;
}

declare namespace cn.nukkit.math {
    declare class IntIncrementSupplier extends java.lang.Object implements java.util.function.IntSupplier {
        public constructor(first: int, increment: int): void
        public getAsInt(): int
        public stream(): java.util.stream.IntStream
        next: int
        increment: int

    }
}

declare module "cn.nukkit.math.IntIncrementSupplier" {
    declare const IntIncrementSupplier = cn.nukkit.math.IntIncrementSupplier;
}

declare namespace cn.nukkit.math {
    declare class CompassRoseDirection extends java.lang.Enum {
        public static values(): cn.nukkit.math.CompassRoseDirection[]
        public static valueOf(name: string): cn.nukkit.math.CompassRoseDirection
        constructor(var0: int, var1: int, modX: cn.nukkit.math.BlockFace, modZ: double): void
        constructor(var0: cn.nukkit.math.CompassRoseDirection, var1: cn.nukkit.math.CompassRoseDirection, face1: cn.nukkit.math.BlockFace, face2: double): void
        public getModX(): int
        public getModZ(): int
        public getClosestBlockFace(): cn.nukkit.math.BlockFace
        public static getClosestFromYaw(yaw: double, var1: cn.nukkit.math.CompassRoseDirection$Precision): cn.nukkit.math.CompassRoseDirection
        public static getClosestFromYaw(yaw: double): cn.nukkit.math.CompassRoseDirection
        public getOppositeFace(): cn.nukkit.math.CompassRoseDirection
        public getYaw(): float
        static $values(): cn.nukkit.math.CompassRoseDirection[]
        public static NORTH: cn.nukkit.math.CompassRoseDirection
        public static EAST: cn.nukkit.math.CompassRoseDirection
        public static SOUTH: cn.nukkit.math.CompassRoseDirection
        public static WEST: cn.nukkit.math.CompassRoseDirection
        public static NORTH_EAST: cn.nukkit.math.CompassRoseDirection
        public static NORTH_WEST: cn.nukkit.math.CompassRoseDirection
        public static SOUTH_EAST: cn.nukkit.math.CompassRoseDirection
        public static SOUTH_WEST: cn.nukkit.math.CompassRoseDirection
        public static WEST_NORTH_WEST: cn.nukkit.math.CompassRoseDirection
        public static NORTH_NORTH_WEST: cn.nukkit.math.CompassRoseDirection
        public static NORTH_NORTH_EAST: cn.nukkit.math.CompassRoseDirection
        public static EAST_NORTH_EAST: cn.nukkit.math.CompassRoseDirection
        public static EAST_SOUTH_EAST: cn.nukkit.math.CompassRoseDirection
        public static SOUTH_SOUTH_EAST: cn.nukkit.math.CompassRoseDirection
        public static SOUTH_SOUTH_WEST: cn.nukkit.math.CompassRoseDirection
        public static WEST_SOUTH_WEST: cn.nukkit.math.CompassRoseDirection
        modX: int
        modZ: int
        closestBlockFace: cn.nukkit.math.BlockFace
        yaw: float
        static $VALUES: cn.nukkit.math.CompassRoseDirection[]

    }
}

declare module "cn.nukkit.math.CompassRoseDirection" {
    declare const CompassRoseDirection = cn.nukkit.math.CompassRoseDirection;
}

declare namespace cn.nukkit.math {
    declare class BlockFace extends java.lang.Enum {
        public static values(): cn.nukkit.math.BlockFace[]
        public static valueOf(name: string): cn.nukkit.math.BlockFace
        constructor(var0: int, var1: int, index: int, opposite: string, horizontalIndex: cn.nukkit.math.BlockFace$AxisDirection, name: cn.nukkit.math.Vector3): void
        public static getHorizontals(): cn.nukkit.math.BlockFace[]
        public static fromIndex(index: int): cn.nukkit.math.BlockFace
        public static fromHorizontalIndex(index: int): cn.nukkit.math.BlockFace
        public static fromHorizontalAngle(angle: double): cn.nukkit.math.BlockFace
        public static fromAxis(axisDirection: cn.nukkit.math.BlockFace$AxisDirection, axis: cn.nukkit.math.BlockFace$Axis): cn.nukkit.math.BlockFace
        public static random(rand: java.util.Random): cn.nukkit.math.BlockFace
        public getIndex(): int
        public getDUNESWIndex(): int
        public getDUSWNEIndex(): int
        public getHorizontalIndex(): int
        public getHorizontalAngle(): float
        public getName(): string
        public getAxis(): cn.nukkit.math.BlockFace$Axis
        public getAxisDirection(): cn.nukkit.math.BlockFace$AxisDirection
        public getUnitVector(): cn.nukkit.math.Vector3
        public getXOffset(): int
        public getYOffset(): int
        public getZOffset(): int
        public getOpposite(): cn.nukkit.math.BlockFace
        public rotateY(): cn.nukkit.math.BlockFace
        public rotateYCCW(): cn.nukkit.math.BlockFace
        public getCompassRoseDirection(): cn.nukkit.math.CompassRoseDirection
        public getEdges(): java.util.Set<cn.nukkit.math.BlockFace>
        public toString(): string
        static $values(): cn.nukkit.math.BlockFace[]
        public static DOWN: cn.nukkit.math.BlockFace
        public static UP: cn.nukkit.math.BlockFace
        public static NORTH: cn.nukkit.math.BlockFace
        public static SOUTH: cn.nukkit.math.BlockFace
        public static WEST: cn.nukkit.math.BlockFace
        public static EAST: cn.nukkit.math.BlockFace
        static VALUES: cn.nukkit.math.BlockFace[]
        static HORIZONTALS: cn.nukkit.math.BlockFace[]
        index: int
        opposite: int
        horizontalIndex: int
        name: string
        axis: cn.nukkit.math.BlockFace$Axis
        axisDirection: cn.nukkit.math.BlockFace$AxisDirection
        unitVector: cn.nukkit.math.Vector3
        static $VALUES: cn.nukkit.math.BlockFace[]

    }
}

declare module "cn.nukkit.math.BlockFace" {
    declare const BlockFace = cn.nukkit.math.BlockFace;
}

declare namespace cn.nukkit.math {
    declare class Vector2f extends java.lang.Object {
        public constructor(): void
        public constructor(x: float): void
        public constructor(x: float, y: float): void
        public getX(): float
        public getY(): float
        public getFloorX(): int
        public getFloorY(): int
        public add(x: float): cn.nukkit.math.Vector2f
        public add(x: float, y: float): cn.nukkit.math.Vector2f
        public add(x: cn.nukkit.math.Vector2f): cn.nukkit.math.Vector2f
        public subtract(x: float): cn.nukkit.math.Vector2f
        public subtract(x: float, y: float): cn.nukkit.math.Vector2f
        public subtract(x: cn.nukkit.math.Vector2f): cn.nukkit.math.Vector2f
        public ceil(): cn.nukkit.math.Vector2f
        public floor(): cn.nukkit.math.Vector2f
        public round(): cn.nukkit.math.Vector2f
        public abs(): cn.nukkit.math.Vector2f
        public multiply(number: float): cn.nukkit.math.Vector2f
        public divide(number: float): cn.nukkit.math.Vector2f
        public distance(x: float): double
        public distance(x: float, y: float): double
        public distance(vector: cn.nukkit.math.Vector2f): double
        public distanceSquared(x: float): double
        public distanceSquared(x: float, y: float): double
        public distanceSquared(vector: cn.nukkit.math.Vector2f): double
        public length(): double
        public lengthSquared(): float
        public normalize(): cn.nukkit.math.Vector2f
        public dot(v: cn.nukkit.math.Vector2f): float
        public toString(): string
        public x: float
        public y: float

    }
}

declare module "cn.nukkit.math.Vector2f" {
    declare const Vector2f = cn.nukkit.math.Vector2f;
}

declare namespace cn.nukkit.math {
    declare class BlockFace$AxisDirection extends java.lang.Enum {
        public static values(): cn.nukkit.math.BlockFace$AxisDirection[]
        public static valueOf(name: string): cn.nukkit.math.BlockFace$AxisDirection
        constructor(var0: int, var1: string): void
        public getOffset(): int
        public toString(): string
        static $values(): cn.nukkit.math.BlockFace$AxisDirection[]
        public static POSITIVE: cn.nukkit.math.BlockFace$AxisDirection
        public static NEGATIVE: cn.nukkit.math.BlockFace$AxisDirection
        offset: int
        description: string
        static $VALUES: cn.nukkit.math.BlockFace$AxisDirection[]

    }
}

declare module "cn.nukkit.math.BlockFace$AxisDirection" {
    declare const BlockFace$AxisDirection = cn.nukkit.math.BlockFace$AxisDirection;
}

declare namespace cn.nukkit.math {
    declare class AtomicIntIncrementSupplier extends java.lang.Object implements java.util.function.IntSupplier {
        public constructor(first: int, increment: int): void
        public getAsInt(): int
        public stream(): java.util.stream.IntStream
        next: java.util.concurrent.atomic.AtomicInteger
        increment: int

    }
}

declare module "cn.nukkit.math.AtomicIntIncrementSupplier" {
    declare const AtomicIntIncrementSupplier = cn.nukkit.math.AtomicIntIncrementSupplier;
}

declare namespace cn.nukkit.math {
    declare class VectorMath extends java.lang.Object {
        public constructor(): void
        public static getDirection2D(azimuth: double): cn.nukkit.math.Vector2
        public static calculateAxis(base: cn.nukkit.math.Vector3, side: cn.nukkit.math.Vector3): cn.nukkit.math.BlockFace$Axis
        public static calculateFace(base: cn.nukkit.math.Vector3, side: cn.nukkit.math.Vector3): cn.nukkit.math.BlockFace

    }
}

declare module "cn.nukkit.math.VectorMath" {
    declare const VectorMath = cn.nukkit.math.VectorMath;
}

declare namespace cn.nukkit.math {
    declare class Vector3f extends java.lang.Object implements java.lang.Cloneable {
        public constructor(): void
        public constructor(x: float): void
        public constructor(x: float, y: float): void
        public constructor(x: float, y: float, z: float): void
        public getX(): float
        public getY(): float
        public getZ(): float
        public setX(x: float): cn.nukkit.math.Vector3f
        public setY(y: float): cn.nukkit.math.Vector3f
        public setZ(z: float): cn.nukkit.math.Vector3f
        public getFloorX(): int
        public getFloorY(): int
        public getFloorZ(): int
        public getRight(): float
        public getUp(): float
        public getForward(): float
        public getSouth(): float
        public getWest(): float
        public add(x: float): cn.nukkit.math.Vector3f
        public add(x: float, y: float): cn.nukkit.math.Vector3f
        public add(x: float, y: float, z: float): cn.nukkit.math.Vector3f
        public add(x: cn.nukkit.math.Vector3f): cn.nukkit.math.Vector3f
        public subtract(): cn.nukkit.math.Vector3f
        public subtract(x: float): cn.nukkit.math.Vector3f
        public subtract(x: float, y: float): cn.nukkit.math.Vector3f
        public subtract(x: float, y: float, z: float): cn.nukkit.math.Vector3f
        public subtract(x: cn.nukkit.math.Vector3f): cn.nukkit.math.Vector3f
        public multiply(number: float): cn.nukkit.math.Vector3f
        public divide(number: float): cn.nukkit.math.Vector3f
        public ceil(): cn.nukkit.math.Vector3f
        public floor(): cn.nukkit.math.Vector3f
        public round(): cn.nukkit.math.Vector3f
        public abs(): cn.nukkit.math.Vector3f
        public getSide(side: int): cn.nukkit.math.Vector3f
        public getSide(side: int, step: int): cn.nukkit.math.Vector3f
        public static getOppositeSide(side: int): int
        public distance(pos: cn.nukkit.math.Vector3f): double
        public distanceSquared(pos: cn.nukkit.math.Vector3f): double
        public maxPlainDistance(): float
        public maxPlainDistance(x: float): float
        public maxPlainDistance(x: float, z: float): float
        public maxPlainDistance(vector: cn.nukkit.math.Vector2f): float
        public maxPlainDistance(x: cn.nukkit.math.Vector3f): float
        public length(): double
        public lengthSquared(): float
        public normalize(): cn.nukkit.math.Vector3f
        public dot(v: cn.nukkit.math.Vector3f): float
        public cross(v: cn.nukkit.math.Vector3f): cn.nukkit.math.Vector3f
        public getIntermediateWithXValue(v: cn.nukkit.math.Vector3f, x: float): cn.nukkit.math.Vector3f
        public getIntermediateWithYValue(v: cn.nukkit.math.Vector3f, y: float): cn.nukkit.math.Vector3f
        public getIntermediateWithZValue(v: cn.nukkit.math.Vector3f, z: float): cn.nukkit.math.Vector3f
        public setComponents(x: float, y: float, z: float): cn.nukkit.math.Vector3f
        public getAxis(axis: cn.nukkit.math.BlockFace$Axis): float
        public toString(): string
        public equals(obj: java.lang.Object): boolean
        public rawHashCode(): int
        public clone(): cn.nukkit.math.Vector3f
        public asVector3(): cn.nukkit.math.Vector3
        public asBlockVector3(): cn.nukkit.math.BlockVector3
        public clone(): java.lang.Object
        public static SIDE_DOWN: int
        public static SIDE_UP: int
        public static SIDE_NORTH: int
        public static SIDE_SOUTH: int
        public static SIDE_WEST: int
        public static SIDE_EAST: int
        public x: float
        public y: float
        public z: float

    }
}

declare module "cn.nukkit.math.Vector3f" {
    declare const Vector3f = cn.nukkit.math.Vector3f;
}

declare namespace cn.nukkit.math {
    declare class MathHelper extends java.lang.Object {
        constructor(): void
        public static sqrt(paramFloat: float): float
        public static sin(paramFloat: float): float
        public static cos(paramFloat: float): float
        public static sin(paramFloat: double): float
        public static cos(paramFloat: double): float
        public static floor(d0: double): int
        public static floor_double_long(d: double): long
        public static floor_float_int(f: float): int
        public static abs(number: int): int
        public static log2(bits: int): int
        public static getRandomNumberInRange(random: java.util.Random, min: int, max: int): int
        public static max(first: double, var1: double, second: double, var3: double): double
        public static ceil(floatNumber: float): int
        public static clamp(check: int, min: int, max: int): int
        public static clamp(num: float, min: float, max: float): float
        public static denormalizeClamp(lowerBnd: double, var1: double, upperBnd: double): double
        public static denormalizeClamp(lowerBnd: float, upperBnd: float, slide: float): float
        static a: float[]

    }
}

declare module "cn.nukkit.math.MathHelper" {
    declare const MathHelper = cn.nukkit.math.MathHelper;
}

declare namespace cn.nukkit.math {
    declare class BlockVector3 extends java.lang.Object implements java.lang.Cloneable {
        public constructor(x: int, y: int, z: int): void
        public constructor(): void
        public setComponents(x: int, y: int, z: int): cn.nukkit.math.BlockVector3
        public setComponentsAdding(pos: cn.nukkit.math.Vector3, face: cn.nukkit.math.BlockFace): cn.nukkit.math.BlockVector3
        public getX(): int
        public getY(): int
        public getZ(): int
        public setX(x: int): cn.nukkit.math.BlockVector3
        public setY(y: int): cn.nukkit.math.BlockVector3
        public setZ(z: int): cn.nukkit.math.BlockVector3
        public add(x: double): cn.nukkit.math.Vector3
        public add(x: double, var1: double): cn.nukkit.math.Vector3
        public add(x: double, var1: double, y: double): cn.nukkit.math.Vector3
        public add(x: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public subtract(x: double): cn.nukkit.math.Vector3
        public subtract(x: double, var1: double): cn.nukkit.math.Vector3
        public subtract(x: double, var1: double, y: double): cn.nukkit.math.Vector3
        public subtract(x: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public add(x: int): cn.nukkit.math.BlockVector3
        public add(x: int, y: int): cn.nukkit.math.BlockVector3
        public add(x: int, y: int, z: int): cn.nukkit.math.BlockVector3
        public add(x: cn.nukkit.math.BlockVector3): cn.nukkit.math.BlockVector3
        public subtract(): cn.nukkit.math.BlockVector3
        public subtract(x: int): cn.nukkit.math.BlockVector3
        public subtract(x: int, y: int): cn.nukkit.math.BlockVector3
        public subtract(x: int, y: int, z: int): cn.nukkit.math.BlockVector3
        public subtract(x: cn.nukkit.math.BlockVector3): cn.nukkit.math.BlockVector3
        public multiply(number: int): cn.nukkit.math.BlockVector3
        public divide(number: int): cn.nukkit.math.BlockVector3
        public getSide(face: cn.nukkit.math.BlockFace): cn.nukkit.math.BlockVector3
        public getSide(face: cn.nukkit.math.BlockFace, step: int): cn.nukkit.math.BlockVector3
        public up(): cn.nukkit.math.BlockVector3
        public up(step: int): cn.nukkit.math.BlockVector3
        public down(): cn.nukkit.math.BlockVector3
        public down(step: int): cn.nukkit.math.BlockVector3
        public north(): cn.nukkit.math.BlockVector3
        public north(step: int): cn.nukkit.math.BlockVector3
        public south(): cn.nukkit.math.BlockVector3
        public south(step: int): cn.nukkit.math.BlockVector3
        public east(): cn.nukkit.math.BlockVector3
        public east(step: int): cn.nukkit.math.BlockVector3
        public west(): cn.nukkit.math.BlockVector3
        public west(step: int): cn.nukkit.math.BlockVector3
        public distance(pos: cn.nukkit.math.Vector3): double
        public distance(pos: cn.nukkit.math.BlockVector3): double
        public distanceSquared(pos: cn.nukkit.math.Vector3): double
        public distanceSquared(pos: cn.nukkit.math.BlockVector3): double
        public distanceSquared(x: double, var1: double, y: double): double
        public getChunkX(): int
        public getChunkZ(): int
        public getChunkSectionY(): int
        public getChunkSectionY(is384World: boolean): int
        public getChunkVector(): cn.nukkit.math.ChunkVector2
        public getAxis(axis: cn.nukkit.math.BlockFace$Axis): int
        public equals(o: java.lang.Object): boolean
        public hashCode(): int
        public toString(): string
        public clone(): cn.nukkit.math.BlockVector3
        public asVector3(): cn.nukkit.math.Vector3
        public asVector3f(): cn.nukkit.math.Vector3f
        public clone(): java.lang.Object
        public x: int
        public y: int
        public z: int

    }
}

declare module "cn.nukkit.math.BlockVector3" {
    declare const BlockVector3 = cn.nukkit.math.BlockVector3;
}

declare namespace cn.nukkit.math {
    declare class BlockFace$Axis extends java.lang.Enum implements java.util.function.Predicate {
        public static values(): cn.nukkit.math.BlockFace$Axis[]
        public static valueOf(name: string): cn.nukkit.math.BlockFace$Axis
        constructor(var0: string): void
        public isVertical(): boolean
        public isHorizontal(): boolean
        public getPlane(): cn.nukkit.math.BlockFace$Plane
        public getName(): string
        public test(face: cn.nukkit.math.BlockFace): boolean
        public toString(): string
        public test(var0: java.lang.Object): boolean
        static $values(): cn.nukkit.math.BlockFace$Axis[]
        public static X: cn.nukkit.math.BlockFace$Axis
        public static Y: cn.nukkit.math.BlockFace$Axis
        public static Z: cn.nukkit.math.BlockFace$Axis
        name: string
        plane: cn.nukkit.math.BlockFace$Plane
        static $VALUES: cn.nukkit.math.BlockFace$Axis[]

    }
}

declare module "cn.nukkit.math.BlockFace$Axis" {
    declare const BlockFace$Axis = cn.nukkit.math.BlockFace$Axis;
}

declare namespace cn.nukkit.math {
    declare class NukkitRandom extends java.lang.Object {
        public constructor(): void
        public constructor(seeds: long): void
        public setSeed(seeds: long): void
        public nextSignedInt(): int
        public getSeed(): long
        public nextInt(): int
        public nextDouble(): double
        public nextFloat(): float
        public nextSignedFloat(): float
        public nextSignedDouble(): double
        public nextBoolean(): boolean
        public nextRange(): int
        public nextRange(start: int): int
        public nextRange(start: int, end: int): int
        public nextBoundedInt(bound: int): int
        seed: long

    }
}

declare module "cn.nukkit.math.NukkitRandom" {
    declare const NukkitRandom = cn.nukkit.math.NukkitRandom;
}

declare namespace cn.nukkit.math {
    declare class BlockFace$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$math$BlockFace: int[]

    }
}

declare module "cn.nukkit.math.BlockFace$1" {
    declare const BlockFace$1 = cn.nukkit.math.BlockFace$1;
}

declare namespace cn.nukkit.math {
    declare class SimpleAxisAlignedBB extends java.lang.Object implements cn.nukkit.math.AxisAlignedBB {
        public constructor(pos1: cn.nukkit.math.Vector3, pos2: cn.nukkit.math.Vector3): void
        public constructor(minX: double, var1: double, minY: double, var3: double, minZ: double, var5: double): void
        public toString(): string
        public getMinX(): double
        public setMinX(minX: double): void
        public getMinY(): double
        public setMinY(minY: double): void
        public getMinZ(): double
        public setMinZ(minZ: double): void
        public getMaxX(): double
        public setMaxX(maxX: double): void
        public getMaxY(): double
        public setMaxY(maxY: double): void
        public getMaxZ(): double
        public setMaxZ(maxZ: double): void
        public clone(): cn.nukkit.math.AxisAlignedBB
        public clone(): java.lang.Object
        minX: double
        minY: double
        minZ: double
        maxX: double
        maxY: double
        maxZ: double

    }
}

declare module "cn.nukkit.math.SimpleAxisAlignedBB" {
    declare const SimpleAxisAlignedBB = cn.nukkit.math.SimpleAxisAlignedBB;
}

declare namespace cn.nukkit.math {
    declare class BlockFace$Plane extends java.lang.Enum implements java.util.function.Predicate, java.lang.Iterable {
        public static values(): cn.nukkit.math.BlockFace$Plane[]
        public static valueOf(name: string): cn.nukkit.math.BlockFace$Plane
        constructor(): void
        public random(): cn.nukkit.math.BlockFace
        public random(rand: cn.nukkit.math.NukkitRandom): cn.nukkit.math.BlockFace
        public test(face: cn.nukkit.math.BlockFace): boolean
        public iterator(): java.util.Iterator<cn.nukkit.math.BlockFace>
        public test(var0: java.lang.Object): boolean
        static $values(): cn.nukkit.math.BlockFace$Plane[]
        public static HORIZONTAL: cn.nukkit.math.BlockFace$Plane
        public static VERTICAL: cn.nukkit.math.BlockFace$Plane
        faces: cn.nukkit.math.BlockFace[]
        static $VALUES: cn.nukkit.math.BlockFace$Plane[]

    }
}

declare module "cn.nukkit.math.BlockFace$Plane" {
    declare const BlockFace$Plane = cn.nukkit.math.BlockFace$Plane;
}

declare namespace cn.nukkit.math {
    declare interface AxisAlignedBB extends java.lang.Cloneable {
        public setBounds(minX: double, var1: double, minY: double, var3: double, minZ: double, var5: double): cn.nukkit.math.AxisAlignedBB
        public addCoord(x: double, var1: double, y: double): cn.nukkit.math.AxisAlignedBB
        public grow(x: double, var1: double, y: double): cn.nukkit.math.AxisAlignedBB
        public expand(x: double, var1: double, y: double): cn.nukkit.math.AxisAlignedBB
        public offset(x: double, var1: double, y: double): cn.nukkit.math.AxisAlignedBB
        public shrink(x: double, var1: double, y: double): cn.nukkit.math.AxisAlignedBB
        public contract(x: double, var1: double, y: double): cn.nukkit.math.AxisAlignedBB
        public setBB(bb: cn.nukkit.math.AxisAlignedBB): cn.nukkit.math.AxisAlignedBB
        public getOffsetBoundingBox(face: cn.nukkit.math.BlockFace, x: double, var2: double, y: double): cn.nukkit.math.AxisAlignedBB
        public getOffsetBoundingBox(x: double, var1: double, y: double): cn.nukkit.math.AxisAlignedBB
        public calculateXOffset(bb: cn.nukkit.math.AxisAlignedBB, x: double): double
        public calculateYOffset(bb: cn.nukkit.math.AxisAlignedBB, y: double): double
        public calculateZOffset(bb: cn.nukkit.math.AxisAlignedBB, z: double): double
        public intersectsWith(bb: cn.nukkit.math.AxisAlignedBB): boolean
        public isVectorInside(vector: cn.nukkit.math.Vector3): boolean
        public getAverageEdgeLength(): double
        public isVectorInYZ(vector: cn.nukkit.math.Vector3): boolean
        public isVectorInXZ(vector: cn.nukkit.math.Vector3): boolean
        public isVectorInXY(vector: cn.nukkit.math.Vector3): boolean
        public calculateIntercept(pos1: cn.nukkit.math.Vector3, pos2: cn.nukkit.math.Vector3): cn.nukkit.level.MovingObjectPosition
        public setMinX(minX: double): void
        public setMinY(minY: double): void
        public setMinZ(minZ: double): void
        public setMaxX(maxX: double): void
        public setMaxY(maxY: double): void
        public setMaxZ(maxZ: double): void
        public getMinX(): double
        public getMinY(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxY(): double
        public getMaxZ(): double
        public clone(): cn.nukkit.math.AxisAlignedBB
        public forEach(action: cn.nukkit.math.AxisAlignedBB$BBConsumer): void
        public static EMPTY_ARRAY: cn.nukkit.math.AxisAlignedBB[]
        public static EMPTY_LIST: java.util.List<cn.nukkit.math.AxisAlignedBB>

    }
}

declare module "cn.nukkit.math.AxisAlignedBB" {
    declare type AxisAlignedBB = cn.nukkit.math.AxisAlignedBB;
}

declare namespace cn.nukkit.math {
    declare class CompassRoseDirection$Precision extends java.lang.Enum {
        public static values(): cn.nukkit.math.CompassRoseDirection$Precision[]
        public static valueOf(name: string): cn.nukkit.math.CompassRoseDirection$Precision
        constructor(var0: int): void
        static $values(): cn.nukkit.math.CompassRoseDirection$Precision[]
        public static CARDINAL: cn.nukkit.math.CompassRoseDirection$Precision
        public static PRIMARY_INTER_CARDINAL: cn.nukkit.math.CompassRoseDirection$Precision
        public static SECONDARY_INTER_CARDINAL: cn.nukkit.math.CompassRoseDirection$Precision
        directions: int
        static $VALUES: cn.nukkit.math.CompassRoseDirection$Precision[]

    }
}

declare module "cn.nukkit.math.CompassRoseDirection$Precision" {
    declare const CompassRoseDirection$Precision = cn.nukkit.math.CompassRoseDirection$Precision;
}

declare namespace cn.nukkit.math {
    declare class Vector3$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$math$BlockFace$Axis: int[]

    }
}

declare module "cn.nukkit.math.Vector3$1" {
    declare const Vector3$1 = cn.nukkit.math.Vector3$1;
}

declare namespace cn.nukkit.math {
    declare class CompassRoseDirection$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$math$CompassRoseDirection: int[]

    }
}

declare module "cn.nukkit.math.CompassRoseDirection$1" {
    declare const CompassRoseDirection$1 = cn.nukkit.math.CompassRoseDirection$1;
}

declare namespace cn.nukkit.math {
    declare class NukkitMath extends java.lang.Object {
        public constructor(): void
        public static isZero(storage: java.lang.Number): boolean
        public static floorDouble(n: double): int
        public static ceilDouble(n: double): int
        public static floorFloat(n: float): int
        public static ceilFloat(n: float): int
        public static randomRange(random: cn.nukkit.math.NukkitRandom): int
        public static randomRange(random: cn.nukkit.math.NukkitRandom, start: int): int
        public static randomRange(random: cn.nukkit.math.NukkitRandom, start: int, end: int): int
        public static round(d: double): double
        public static round(d: double, var1: int): double
        public static clamp(value: double, var1: double, min: double): double
        public static clamp(value: int, min: int, max: int): int
        public static clamp(value: float, min: float, max: float): float
        public static getDirection(diffX: double, var1: double): double
        public static bitLength(data: byte): int
        public static bitLength(data: int): int
        public static bitLength(data: long): int
        public static bitLength(data: java.math.BigInteger): int
        static ZERO_BYTE: byte
        static ZERO_INTEGER: int
        static ZERO_SHORT: java.lang.Short
        static ZERO_LONG: long

    }
}

declare module "cn.nukkit.math.NukkitMath" {
    declare const NukkitMath = cn.nukkit.math.NukkitMath;
}

declare namespace cn.nukkit.api {
    declare interface Unsigned extends java.lang.annotation.Annotation {

    }
}

declare module "cn.nukkit.api.Unsigned" {
    declare type Unsigned = cn.nukkit.api.Unsigned;
}

declare namespace cn.nukkit.api {
    declare class API$Definition extends java.lang.Enum {
        public static values(): cn.nukkit.api.API$Definition[]
        public static valueOf(name: string): cn.nukkit.api.API$Definition
        constructor(): void
        static $values(): cn.nukkit.api.API$Definition[]
        public static INTERNAL: cn.nukkit.api.API$Definition
        public static PLATFORM_NATIVE: cn.nukkit.api.API$Definition
        public static UNIVERSAL: cn.nukkit.api.API$Definition
        static $VALUES: cn.nukkit.api.API$Definition[]

    }
}

declare module "cn.nukkit.api.API$Definition" {
    declare const API$Definition = cn.nukkit.api.API$Definition;
}

declare namespace cn.nukkit.api {
    declare interface Since extends java.lang.annotation.Annotation {
        public value(): string

    }
}

declare module "cn.nukkit.api.Since" {
    declare type Since = cn.nukkit.api.Since;
}

declare namespace cn.nukkit.api {
    declare interface DeprecationDetails extends java.lang.annotation.Annotation {
        public since(): string
        public reason(): string
        public replaceWith(): string
        public toBeRemovedAt(): string
        public by(): string

    }
}

declare module "cn.nukkit.api.DeprecationDetails" {
    declare type DeprecationDetails = cn.nukkit.api.DeprecationDetails;
}

declare namespace cn.nukkit.api {
    declare interface PowerNukkitXOnly extends java.lang.annotation.Annotation {
        public value(): string

    }
}

declare module "cn.nukkit.api.PowerNukkitXOnly" {
    declare type PowerNukkitXOnly = cn.nukkit.api.PowerNukkitXOnly;
}

declare namespace cn.nukkit.api {
    declare class API$Usage extends java.lang.Enum {
        public static values(): cn.nukkit.api.API$Usage[]
        public static valueOf(name: string): cn.nukkit.api.API$Usage
        constructor(): void
        static $values(): cn.nukkit.api.API$Usage[]
        public static DEPRECATED: cn.nukkit.api.API$Usage
        public static INCUBATING: cn.nukkit.api.API$Usage
        public static BLEEDING: cn.nukkit.api.API$Usage
        public static EXPERIMENTAL: cn.nukkit.api.API$Usage
        public static MAINTAINED: cn.nukkit.api.API$Usage
        public static STABLE: cn.nukkit.api.API$Usage
        static $VALUES: cn.nukkit.api.API$Usage[]

    }
}

declare module "cn.nukkit.api.API$Usage" {
    declare const API$Usage = cn.nukkit.api.API$Usage;
}

declare namespace cn.nukkit.api {
    declare interface API extends java.lang.annotation.Annotation {
        public usage(): cn.nukkit.api.API$Usage
        public definition(): cn.nukkit.api.API$Definition

    }
}

declare module "cn.nukkit.api.API" {
    declare type API = cn.nukkit.api.API;
}

declare namespace cn.nukkit.api {
    declare interface PowerNukkitDifference$DifferenceList extends java.lang.annotation.Annotation {
        public value(): cn.nukkit.api.PowerNukkitDifference[]

    }
}

declare module "cn.nukkit.api.PowerNukkitDifference$DifferenceList" {
    declare type PowerNukkitDifference$DifferenceList = cn.nukkit.api.PowerNukkitDifference$DifferenceList;
}

declare namespace cn.nukkit.api {
    declare interface PowerNukkitOnly extends java.lang.annotation.Annotation {
        public value(): string

    }
}

declare module "cn.nukkit.api.PowerNukkitOnly" {
    declare type PowerNukkitOnly = cn.nukkit.api.PowerNukkitOnly;
}

declare namespace cn.nukkit.api {
    declare interface PowerNukkitDifference extends java.lang.annotation.Annotation {
        public info(): string
        public since(): string
        public extendsOnlyInPowerNukkit(): char
        public insteadOf(): char

    }
}

declare module "cn.nukkit.api.PowerNukkitDifference" {
    declare type PowerNukkitDifference = cn.nukkit.api.PowerNukkitDifference;
}

declare namespace cn.nukkit.api {
    declare interface UsedByReflection extends java.lang.annotation.Annotation {

    }
}

declare module "cn.nukkit.api.UsedByReflection" {
    declare type UsedByReflection = cn.nukkit.api.UsedByReflection;
}

declare namespace cn.nukkit {
    declare class Server$ConsoleThread extends java.lang.Thread implements cn.nukkit.InterruptibleThread {
        constructor(var0: cn.nukkit.Server): void
        public run(): void
        this$0: cn.nukkit.Server

    }
}

declare module "cn.nukkit.Server$ConsoleThread" {
    declare const Server$ConsoleThread = cn.nukkit.Server$ConsoleThread;
}

declare namespace cn.nukkit {
    declare class Server$4 extends cn.nukkit.scheduler.Task {
        constructor(this$0: cn.nukkit.Server, var1: cn.nukkit.event.server.PlayerDataSerializeEvent, var2: cn.nukkit.nbt.tag.CompoundTag, var3: string): void
        public onRun(currentTick: int): void
        public onCancel(): void
        hasRun: boolean
        val$event: cn.nukkit.event.server.PlayerDataSerializeEvent
        val$tag: cn.nukkit.nbt.tag.CompoundTag
        val$nameLower: string
        this$0: cn.nukkit.Server

    }
}

declare module "cn.nukkit.Server$4" {
    declare const Server$4 = cn.nukkit.Server$4;
}

declare namespace cn.nukkit {
    declare class AdventureSettings extends java.lang.Object implements java.lang.Cloneable {
        public constructor(player: cn.nukkit.Player): void
        public clone(newPlayer: cn.nukkit.Player): cn.nukkit.AdventureSettings
        public set(type: cn.nukkit.AdventureSettings$Type, value: boolean): cn.nukkit.AdventureSettings
        public get(type: cn.nukkit.AdventureSettings$Type): boolean
        public update(): void
        public static PERMISSION_NORMAL: int
        public static PERMISSION_OPERATOR: int
        public static PERMISSION_HOST: int
        public static PERMISSION_AUTOMATION: int
        public static PERMISSION_ADMIN: int
        values: java.util.Map<cn.nukkit.AdventureSettings$Type, boolean>
        player: cn.nukkit.Player

    }
}

declare module "cn.nukkit.AdventureSettings" {
    declare const AdventureSettings = cn.nukkit.AdventureSettings;
}

declare namespace cn.nukkit.blockstate {
    declare class BlockState$LongStorage extends java.lang.Object implements cn.nukkit.blockstate.BlockState$Storage {
        public constructor(var0: cn.nukkit.blockstate.BlockState, data: long): void
        public getNumber(): java.lang.Number
        public getLegacyDamage(): int
        public getBigDamage(): int
        public getSignedBigDamage(): int
        public getPropertyValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): java.io.Serializable
        public getIntValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): int
        public getBooleanValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): boolean
        public withPropertyString(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string, value: string): cn.nukkit.blockstate.BlockState
        public withBlockId(blockId: int): cn.nukkit.blockstate.BlockState
        public withProperty(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string, value: java.io.Serializable): cn.nukkit.blockstate.BlockState
        public onlyWithProperties(currentState: cn.nukkit.blockstate.BlockState, propertyNames: java.util.List<string>): cn.nukkit.blockstate.BlockState
        public onlyWithProperty(currentState: cn.nukkit.blockstate.BlockState, name: string, value: java.io.Serializable): cn.nukkit.blockstate.BlockState
        public validate(properties: cn.nukkit.blockproperty.BlockProperties): void
        public isDefaultState(): boolean
        public getPersistenceValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): string
        public getHugeDamage(): java.math.BigInteger
        public toString(): string
        public getBitSize(): int
        lambda$validate$2(property: cn.nukkit.blockproperty.BlockProperty, offset: int): void
        static lambda$onlyWithProperty$1(name: string, value: java.io.Serializable, property: cn.nukkit.blockproperty.BlockProperty, offset: int, current: long): long
        static lambda$onlyWithProperties$0(propertyNames: java.util.List, property: cn.nukkit.blockproperty.BlockProperty, offset: int, current: long): long
        static serialVersionUID: long
        data: long
        bitSize: int
        this$0: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.blockstate.BlockState$LongStorage" {
    declare const BlockState$LongStorage = cn.nukkit.blockstate.BlockState$LongStorage;
}

declare namespace cn.nukkit.blockstate {
    declare class BlockState$ByteStorage extends java.lang.Object implements cn.nukkit.blockstate.BlockState$Storage {
        public constructor(var0: cn.nukkit.blockstate.BlockState, data: byte): void
        public getNumber(): java.lang.Number
        public getLegacyDamage(): int
        public getBigDamage(): int
        public getHugeDamage(): java.math.BigInteger
        public getPropertyValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): java.io.Serializable
        public getIntValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): int
        public getBooleanValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): boolean
        public withBlockId(blockId: int): cn.nukkit.blockstate.BlockState
        public withProperty(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string, value: java.io.Serializable): cn.nukkit.blockstate.BlockState
        public withPropertyString(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string, value: string): cn.nukkit.blockstate.BlockState
        public onlyWithProperties(currentState: cn.nukkit.blockstate.BlockState, propertyNames: java.util.List<string>): cn.nukkit.blockstate.BlockState
        public onlyWithProperty(currentState: cn.nukkit.blockstate.BlockState, name: string, value: java.io.Serializable): cn.nukkit.blockstate.BlockState
        public validate(properties: cn.nukkit.blockproperty.BlockProperties): void
        public isDefaultState(): boolean
        public getPersistenceValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): string
        public toString(): string
        public getBitSize(): int
        lambda$validate$2(property: cn.nukkit.blockproperty.BlockProperty, offset: int): void
        static lambda$onlyWithProperty$1(name: string, value: java.io.Serializable, property: cn.nukkit.blockproperty.BlockProperty, offset: int, current: int): int
        static lambda$onlyWithProperties$0(propertyNames: java.util.List, property: cn.nukkit.blockproperty.BlockProperty, offset: int, current: int): int
        data: byte
        bitSize: int
        this$0: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.blockstate.BlockState$ByteStorage" {
    declare const BlockState$ByteStorage = cn.nukkit.blockstate.BlockState$ByteStorage;
}

declare namespace cn.nukkit.blockstate {
    declare class BlockStateRegistry$Registration extends java.lang.Object {
        public constructor(state: cn.nukkit.blockstate.BlockState, runtimeId: int, originalBlock: cn.nukkit.nbt.tag.CompoundTag): void
        public toString(): string
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        state: cn.nukkit.blockstate.BlockState
        runtimeId: int
        originalBlock: cn.nukkit.nbt.tag.CompoundTag

    }
}

declare module "cn.nukkit.blockstate.BlockStateRegistry$Registration" {
    declare const BlockStateRegistry$Registration = cn.nukkit.blockstate.BlockStateRegistry$Registration;
}

declare namespace cn.nukkit.blockstate.exception {
    declare class InvalidBlockStateException extends java.lang.IllegalStateException {
        public constructor(state: cn.nukkit.blockstate.BlockState): void
        public constructor(state: cn.nukkit.blockstate.BlockState, message: string): void
        public constructor(state: cn.nukkit.blockstate.BlockState, message: string, cause: java.lang.Throwable): void
        public constructor(state: cn.nukkit.blockstate.BlockState, cause: java.lang.Throwable): void
        static createMessage(state: cn.nukkit.blockstate.BlockState, message: string): string
        public getState(): cn.nukkit.blockstate.BlockState
        static serialVersionUID: long
        state: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.blockstate.exception.InvalidBlockStateException" {
    declare const InvalidBlockStateException = cn.nukkit.blockstate.exception.InvalidBlockStateException;
}

declare namespace cn.nukkit.blockstate.exception {
    declare class InvalidBlockStateDataTypeException extends java.lang.IllegalArgumentException {
        public constructor(blockData: java.lang.Number): void
        public constructor(blockData: java.lang.Number, cause: java.lang.Throwable): void
        static serialVersionUID: long

    }
}

declare module "cn.nukkit.blockstate.exception.InvalidBlockStateDataTypeException" {
    declare const InvalidBlockStateDataTypeException = cn.nukkit.blockstate.exception.InvalidBlockStateDataTypeException;
}

declare namespace cn.nukkit.blockstate {
    declare class BlockState$IntStorage extends java.lang.Object implements cn.nukkit.blockstate.BlockState$Storage {
        public constructor(var0: cn.nukkit.blockstate.BlockState, data: int): void
        public getNumber(): java.lang.Number
        public getLegacyDamage(): int
        public getBigDamage(): int
        public getPropertyValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): java.io.Serializable
        public getIntValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): int
        public getBooleanValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): boolean
        public withBlockId(blockId: int): cn.nukkit.blockstate.BlockState
        public withProperty(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string, value: java.io.Serializable): cn.nukkit.blockstate.BlockState
        public withPropertyString(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string, value: string): cn.nukkit.blockstate.BlockState
        public onlyWithProperties(currentState: cn.nukkit.blockstate.BlockState, propertyNames: java.util.List<string>): cn.nukkit.blockstate.BlockState
        public onlyWithProperty(currentState: cn.nukkit.blockstate.BlockState, name: string, value: java.io.Serializable): cn.nukkit.blockstate.BlockState
        public validate(properties: cn.nukkit.blockproperty.BlockProperties): void
        public isDefaultState(): boolean
        public getPersistenceValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): string
        public getHugeDamage(): java.math.BigInteger
        public toString(): string
        public getBitSize(): int
        lambda$validate$2(property: cn.nukkit.blockproperty.BlockProperty, offset: int): void
        static lambda$onlyWithProperty$1(name: string, value: java.io.Serializable, property: cn.nukkit.blockproperty.BlockProperty, offset: int, current: int): int
        static lambda$onlyWithProperties$0(propertyNames: java.util.List, property: cn.nukkit.blockproperty.BlockProperty, offset: int, current: int): int
        static serialVersionUID: long
        data: int
        bitSize: int
        this$0: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.blockstate.BlockState$IntStorage" {
    declare const BlockState$IntStorage = cn.nukkit.blockstate.BlockState$IntStorage;
}

declare namespace cn.nukkit.blockstate {
    declare class BlockStateRepair extends java.lang.Object {
        public equals(o: java.lang.Object): boolean
        public hashCode(): int
        public toString(): string
        public constructor(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties, originalState: java.lang.Number, currentState: java.lang.Number, nextState: java.lang.Number, repairs: int, property: byte, propertyOffset: int, brokenPropertyMeta: int, fixedPropertyValue: java.io.Serializable, proposedPropertyValue: java.io.Serializable, validationException: cn.nukkit.blockproperty.exception.InvalidBlockPropertyException): void
        public getBlockId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getOriginalState(): java.lang.Number
        public getCurrentState(): java.lang.Number
        public getNextState(): java.lang.Number
        public getRepairs(): int
        public getProperty(): byte
        public getPropertyOffset(): int
        public getBrokenPropertyMeta(): int
        public getFixedPropertyValue(): java.io.Serializable
        public getProposedPropertyValue(): java.io.Serializable
        public getValidationException(): cn.nukkit.blockproperty.exception.InvalidBlockPropertyException
        blockId: int
        properties: cn.nukkit.blockproperty.BlockProperties
        originalState: java.lang.Number
        currentState: java.lang.Number
        nextState: java.lang.Number
        repairs: int
        property: byte
        propertyOffset: int
        brokenPropertyMeta: int
        fixedPropertyValue: java.io.Serializable
        proposedPropertyValue: java.io.Serializable
        validationException: cn.nukkit.blockproperty.exception.InvalidBlockPropertyException

    }
}

declare module "cn.nukkit.blockstate.BlockStateRepair" {
    declare const BlockStateRepair = cn.nukkit.blockstate.BlockStateRepair;
}

declare namespace cn.nukkit.blockstate {
    declare class LongMutableBlockState extends cn.nukkit.blockstate.MutableBlockState {
        public constructor(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties, state: long): void
        public constructor(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties): void
        public setDataStorage(storage: java.lang.Number): void
        public setDataStorageFromInt(storage: int): void
        setDataStorageWithoutValidation(storage: java.lang.Number): void
        public validate(): void
        validate(state: long): void
        public getLegacyDamage(): int
        public getBigDamage(): int
        public getSignedBigDamage(): int
        public getHugeDamage(): java.math.BigInteger
        public getDataStorage(): java.lang.Number
        public isDefaultState(): boolean
        public setPropertyValue(propertyName: string, value: java.io.Serializable): void
        public setBooleanValue(propertyName: string, value: boolean): void
        public setIntValue(propertyName: string, value: int): void
        public getPropertyValue(propertyName: string): java.io.Serializable
        public getIntValue(propertyName: string): int
        public getBooleanValue(propertyName: string): boolean
        public getPersistenceValue(propertyName: string): string
        public getCurrentState(): cn.nukkit.blockstate.BlockState
        public getExactIntStorage(): int
        public copy(): cn.nukkit.blockstate.LongMutableBlockState
        public toString(): string
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        public copy(): cn.nukkit.blockstate.MutableBlockState
        storage: long

    }
}

declare module "cn.nukkit.blockstate.LongMutableBlockState" {
    declare const LongMutableBlockState = cn.nukkit.blockstate.LongMutableBlockState;
}

declare namespace cn.nukkit.blockstate {
    declare class Loggers extends java.lang.Object {
        constructor(): void
        static logIBlockState: org.apache.logging.log4j.Logger
        static logIMutableBlockState: org.apache.logging.log4j.Logger

    }
}

declare module "cn.nukkit.blockstate.Loggers" {
    declare const Loggers = cn.nukkit.blockstate.Loggers;
}

declare namespace cn.nukkit.blockstate {
    declare class BlockState$BigIntegerStorage extends java.lang.Object implements cn.nukkit.blockstate.BlockState$Storage {
        public constructor(var0: cn.nukkit.blockstate.BlockState, data: java.math.BigInteger): void
        public getNumber(): java.lang.Number
        public getLegacyDamage(): int
        public getBigDamage(): int
        public getSignedBigDamage(): int
        public getPropertyValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): java.io.Serializable
        public getIntValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): int
        public getBooleanValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): boolean
        public withBlockId(blockId: int): cn.nukkit.blockstate.BlockState
        public withProperty(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string, value: java.io.Serializable): cn.nukkit.blockstate.BlockState
        public withPropertyString(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string, value: string): cn.nukkit.blockstate.BlockState
        public onlyWithProperties(currentState: cn.nukkit.blockstate.BlockState, propertyNames: java.util.List<string>): cn.nukkit.blockstate.BlockState
        public onlyWithProperty(currentState: cn.nukkit.blockstate.BlockState, name: string, value: java.io.Serializable): cn.nukkit.blockstate.BlockState
        public validate(properties: cn.nukkit.blockproperty.BlockProperties): void
        public isDefaultState(): boolean
        public getPersistenceValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): string
        public getHugeDamage(): java.math.BigInteger
        public toString(): string
        public getBitSize(): int
        lambda$validate$2(property: cn.nukkit.blockproperty.BlockProperty, offset: int): void
        static lambda$onlyWithProperty$1(name: string, value: java.io.Serializable, property: cn.nukkit.blockproperty.BlockProperty, offset: int, current: java.math.BigInteger): java.math.BigInteger
        static lambda$onlyWithProperties$0(propertyNames: java.util.List, property: cn.nukkit.blockproperty.BlockProperty, offset: int, current: java.math.BigInteger): java.math.BigInteger
        static serialVersionUID: long
        data: java.math.BigInteger
        bitSize: int
        this$0: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.blockstate.BlockState$BigIntegerStorage" {
    declare const BlockState$BigIntegerStorage = cn.nukkit.blockstate.BlockState$BigIntegerStorage;
}

declare namespace cn.nukkit.blockstate {
    declare class ZeroMutableBlockState extends cn.nukkit.blockstate.MutableBlockState {
        public constructor(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties): void
        public validate(): void
        public copy(): cn.nukkit.blockstate.ZeroMutableBlockState
        public setDataStorage(storage: java.lang.Number): void
        public setDataStorageFromInt(storage: int): void
        public setPropertyValue(propertyName: string, value: java.io.Serializable): void
        public setBooleanValue(propertyName: string, value: boolean): void
        public setIntValue(propertyName: string, value: int): void
        public getDataStorage(): java.lang.Number
        public isDefaultState(): boolean
        public getLegacyDamage(): int
        public getBigDamage(): int
        public getHugeDamage(): java.math.BigInteger
        public getPropertyValue(propertyName: string): java.io.Serializable
        public getIntValue(propertyName: string): int
        public getBooleanValue(propertyName: string): boolean
        public getPersistenceValue(propertyName: string): string
        public getCurrentState(): cn.nukkit.blockstate.BlockState
        public getExactIntStorage(): int
        public copy(): cn.nukkit.blockstate.MutableBlockState
        state: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.blockstate.ZeroMutableBlockState" {
    declare const ZeroMutableBlockState = cn.nukkit.blockstate.ZeroMutableBlockState;
}

declare namespace cn.nukkit.blockstate {
    declare class BlockState$ZeroStorage extends java.lang.Object implements cn.nukkit.blockstate.BlockState$Storage {
        constructor(): void
        public getBitSize(): int
        public getNumber(): int
        public getLegacyDamage(): int
        public getBigDamage(): int
        public getHugeDamage(): java.math.BigInteger
        public getPropertyValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): java.io.Serializable
        public getIntValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): int
        public getBooleanValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): boolean
        public withBlockId(blockId: int): cn.nukkit.blockstate.BlockState
        public withProperty(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string, value: java.io.Serializable): cn.nukkit.blockstate.BlockState
        public withPropertyString(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string, value: string): cn.nukkit.blockstate.BlockState
        public onlyWithProperties(currentState: cn.nukkit.blockstate.BlockState, propertyNames: java.util.List<string>): cn.nukkit.blockstate.BlockState
        public onlyWithProperty(currentState: cn.nukkit.blockstate.BlockState, name: string, value: java.io.Serializable): cn.nukkit.blockstate.BlockState
        public validate(properties: cn.nukkit.blockproperty.BlockProperties): void
        public isDefaultState(): boolean
        public getPersistenceValue(properties: cn.nukkit.blockproperty.BlockProperties, propertyName: string): string
        public toString(): string
        public getNumber(): java.lang.Number
        static serialVersionUID: long

    }
}

declare module "cn.nukkit.blockstate.BlockState$ZeroStorage" {
    declare const BlockState$ZeroStorage = cn.nukkit.blockstate.BlockState$ZeroStorage;
}

declare namespace cn.nukkit.blockstate {
    declare interface BlockState$Storage extends java.io.Serializable {
        public getNumber(): java.lang.Number
        public getLegacyDamage(): int
        public getBigDamage(): int
        public getSignedBigDamage(): int
        public getPropertyValue(var0: cn.nukkit.blockproperty.BlockProperties, var1: string): java.io.Serializable
        public getIntValue(var0: cn.nukkit.blockproperty.BlockProperties, var1: string): int
        public getBooleanValue(var0: cn.nukkit.blockproperty.BlockProperties, var1: string): boolean
        public withBlockId(var0: int): cn.nukkit.blockstate.BlockState
        public getPersistenceValue(var0: cn.nukkit.blockproperty.BlockProperties, var1: string): string
        public getBitSize(): int
        public getHugeDamage(): java.math.BigInteger
        public withProperty(var0: int, var1: cn.nukkit.blockproperty.BlockProperties, var2: string, var3: java.io.Serializable): cn.nukkit.blockstate.BlockState
        public onlyWithProperties(var0: cn.nukkit.blockstate.BlockState, var1: java.util.List<string>): cn.nukkit.blockstate.BlockState
        public onlyWithProperty(var0: cn.nukkit.blockstate.BlockState, var1: string, var2: java.io.Serializable): cn.nukkit.blockstate.BlockState
        public validate(var0: cn.nukkit.blockproperty.BlockProperties): void
        public isDefaultState(): boolean
        public withPropertyString(var0: int, var1: cn.nukkit.blockproperty.BlockProperties, var2: string, var3: string): cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.blockstate.BlockState$Storage" {
    declare type BlockState$Storage = cn.nukkit.blockstate.BlockState$Storage;
}

declare namespace cn.nukkit.blockstate {
    declare interface IMutableBlockState extends cn.nukkit.blockstate.IBlockState {
        public setState(state: cn.nukkit.blockstate.IBlockState): void
        public forState(state: cn.nukkit.blockstate.IBlockState): cn.nukkit.blockstate.IMutableBlockState
        public setDataStorage(var0: java.lang.Number): void
        public setDataStorageFromInt(var0: int): void
        public setDataStorage(storage: java.lang.Number, repair: boolean): boolean
        public setDataStorageFromInt(storage: int, repair: boolean): boolean
        public setDataStorage(storage: java.lang.Number, repair: boolean, callback: java.util.function.Consumer<cn.nukkit.blockstate.BlockStateRepair>): boolean
        public setDataStorageFromInt(storage: int, repair: boolean, callback: java.util.function.Consumer<cn.nukkit.blockstate.BlockStateRepair>): boolean
        public setDataStorageFromItemBlockMeta(itemBlockMeta: int): void
        public setPropertyValue(var0: string, var1: java.io.Serializable): void
        public setBooleanValue(var0: string, var1: boolean): void
        public setIntValue(var0: string, var1: int): void
        public setBooleanValue(property: cn.nukkit.blockproperty.BlockProperty<boolean>, value: boolean): void
        public setIntValue(property: cn.nukkit.blockproperty.BlockProperty<int>, value: int): void
        public setPropertyValue(property: java.io.Serializable, value: cn.nukkit.blockproperty.BlockProperty<any>): void
        public toggleBooleanProperty(propertyName: string): boolean
        public toggleBooleanProperty(property: cn.nukkit.blockproperty.BlockProperty<boolean>): boolean
        public static repairStorage(blockId: int, storage: java.math.BigInteger, properties: cn.nukkit.blockproperty.BlockProperties, callback: java.util.function.Consumer<cn.nukkit.blockstate.BlockStateRepair>): java.math.BigInteger
        public static handleUnsupportedStorageType(blockId: int, storage: java.lang.Number, e: java.lang.RuntimeException): java.lang.RuntimeException
        static lambda$setDataStorageFromItemBlockMeta$0(converted: cn.nukkit.blockstate.MutableBlockState, item: cn.nukkit.blockstate.MutableBlockState, property: string): void

    }
}

declare module "cn.nukkit.blockstate.IMutableBlockState" {
    declare type IMutableBlockState = cn.nukkit.blockstate.IMutableBlockState;
}

declare namespace cn.nukkit.blockstate {
    declare class BlockStateRegistry extends java.lang.Object {
        static isNameOwnerOfId(name: string, blockId: int): boolean
        static getStateId(block: cn.nukkit.nbt.tag.CompoundTag): string
        static findRegistrationByRuntimeId(runtimeId: int): cn.nukkit.blockstate.BlockStateRegistry$Registration
        public static getKnownBlockStateIdByRuntimeId(runtimeId: int): string
        public static getKnownRuntimeIdByBlockStateId(stateId: string): int
        public static getBlockStateByRuntimeId(runtimeId: int): cn.nukkit.blockstate.BlockState
        static buildStateFromCompound(block: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.blockstate.BlockState
        static runtimeIdNotRegistered(runtimeId: int): java.util.NoSuchElementException
        public static getBlockIdByRuntimeId(runtimeId: int): int
        public static getRuntimeId(state: cn.nukkit.blockstate.BlockState): int
        static convertToNewState(oldState: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState
        static getRegistration(state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockStateRegistry$Registration
        public static getRuntimeId(blockId: int): int
        public static getRuntimeId(blockId: int, meta: int): int
        static findRegistration(state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockStateRegistry$Registration
        static findRegistrationByStateId(state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockStateRegistry$Registration
        static removeStateIdsAsync(registration: cn.nukkit.blockstate.BlockStateRegistry$Registration): void
        static logDiscoveryError(state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockStateRegistry$Registration
        public static getPersistenceNames(): java.util.List<string>
        public static getPersistenceName(blockId: int): string
        public static registerPersistenceName(blockId: int, persistenceName: string): void
        static registerStateId(block: cn.nukkit.nbt.tag.CompoundTag, runtimeId: int): void
        static registerState(blockId: int, meta: int, originalState: cn.nukkit.nbt.tag.CompoundTag, runtimeId: int): void
        public static getBlockPaletteDataVersion(): int
        public static getBlockPaletteBytes(): byte[]
        public static putBlockPaletteBytes(stream: cn.nukkit.utils.BinaryStream): void
        public static getBlockPaletteLength(): int
        public static copyBlockPaletteBytes(target: byte[], targetIndex: int): void
        public static getProperties(blockId: int): cn.nukkit.blockproperty.BlockProperties
        public static createMutableState(blockId: int): cn.nukkit.blockstate.MutableBlockState
        public static createMutableState(blockId: int, bigMeta: int): cn.nukkit.blockstate.MutableBlockState
        public static createMutableState(blockId: int, storage: java.lang.Number): cn.nukkit.blockstate.MutableBlockState
        public static getUpdateBlockRegistration(): int
        public static getBlockId(persistenceName: string): int
        public static getFallbackRuntimeId(): int
        public static getFallbackBlockState(): cn.nukkit.blockstate.BlockState
        constructor(): void
        static lambda$removeStateIdsAsync$2(registration: cn.nukkit.blockstate.BlockStateRegistry$Registration): boolean
        static lambda$removeStateIdsAsync$1(registration: cn.nukkit.blockstate.BlockStateRegistry$Registration, r: cn.nukkit.blockstate.BlockStateRegistry$Registration): boolean
        static lambda$getStateId$0(stateId: java.lang.StringBuilder, name: string, value: string): void
        static log: org.apache.logging.log4j.Logger
        public static BIG_META_MASK: int
        static asyncStateRemover: java.util.concurrent.ExecutorService
        static BLOCK_ID_NAME_PATTERN: java.util.regex.Pattern
        static updateBlockRegistration: cn.nukkit.blockstate.BlockStateRegistry$Registration
        static blockStateRegistration: java.util.Map<cn.nukkit.blockstate.BlockState, cn.nukkit.blockstate.BlockStateRegistry$Registration>
        static stateIdRegistration: java.util.Map<string, cn.nukkit.blockstate.BlockStateRegistry$Registration>
        static runtimeIdRegistration: it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.blockstate.BlockStateRegistry$Registration>
        static blockIdToPersistenceName: it.unimi.dsi.fastutil.ints.Int2ObjectMap<string>
        static persistenceNameToBlockId: java.util.Map<string, int>
        static blockPaletteBytes: byte[]
        static knownStateIds: java.util.List<string>

    }
}

declare module "cn.nukkit.blockstate.BlockStateRegistry" {
    declare const BlockStateRegistry = cn.nukkit.blockstate.BlockStateRegistry;
}

declare namespace cn.nukkit.blockstate {
    declare class BigIntegerMutableBlockState extends cn.nukkit.blockstate.MutableBlockState {
        public constructor(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties, state: java.math.BigInteger): void
        public constructor(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties): void
        public setDataStorage(storage: java.lang.Number): void
        public setDataStorageFromInt(storage: int): void
        setDataStorageWithoutValidation(storage: java.lang.Number): void
        public validate(): void
        validate(state: java.math.BigInteger): void
        public getLegacyDamage(): int
        public getBigDamage(): int
        public getSignedBigDamage(): int
        public getHugeDamage(): java.math.BigInteger
        public getDataStorage(): java.lang.Number
        public isDefaultState(): boolean
        public setPropertyValue(propertyName: string, value: java.io.Serializable): void
        public setBooleanValue(propertyName: string, value: boolean): void
        public setIntValue(propertyName: string, value: int): void
        public getPropertyValue(propertyName: string): java.io.Serializable
        public getIntValue(propertyName: string): int
        public getBooleanValue(propertyName: string): boolean
        public getPersistenceValue(propertyName: string): string
        public getCurrentState(): cn.nukkit.blockstate.BlockState
        public getExactIntStorage(): int
        public copy(): cn.nukkit.blockstate.BigIntegerMutableBlockState
        public toString(): string
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        public copy(): cn.nukkit.blockstate.MutableBlockState
        static LONG_COMPATIBLE_CLASSES: java.util.Set<char>
        storage: java.math.BigInteger

    }
}

declare module "cn.nukkit.blockstate.BigIntegerMutableBlockState" {
    declare const BigIntegerMutableBlockState = cn.nukkit.blockstate.BigIntegerMutableBlockState;
}

declare namespace cn.nukkit.form.element {
    declare class ElementLabel extends cn.nukkit.form.element.Element {
        public constructor(text: string): void
        public getText(): string
        public setText(text: string): void
        type: string
        text: string

    }
}

declare module "cn.nukkit.form.element.ElementLabel" {
    declare const ElementLabel = cn.nukkit.form.element.ElementLabel;
}

declare namespace cn.nukkit.form.element {
    declare class ElementButton extends java.lang.Object {
        public constructor(text: string): void
        public constructor(text: string, image: cn.nukkit.form.element.ElementButtonImageData): void
        public getText(): string
        public setText(text: string): void
        public getImage(): cn.nukkit.form.element.ElementButtonImageData
        public addImage(image: cn.nukkit.form.element.ElementButtonImageData): void
        text: string
        image: cn.nukkit.form.element.ElementButtonImageData

    }
}

declare module "cn.nukkit.form.element.ElementButton" {
    declare const ElementButton = cn.nukkit.form.element.ElementButton;
}

declare namespace cn.nukkit.form.element {
    declare class ElementButtonImageData extends java.lang.Object {
        public constructor(type: string, data: string): void
        public getType(): string
        public getData(): string
        public setType(type: string): void
        public setData(data: string): void
        public static IMAGE_DATA_TYPE_PATH: string
        public static IMAGE_DATA_TYPE_URL: string
        type: string
        data: string

    }
}

declare module "cn.nukkit.form.element.ElementButtonImageData" {
    declare const ElementButtonImageData = cn.nukkit.form.element.ElementButtonImageData;
}

declare namespace cn.nukkit.form.handler {
    declare interface FormResponseHandler {
        public static withoutPlayer(formIDConsumer: java.util.function.IntConsumer): cn.nukkit.form.handler.FormResponseHandler
        public handle(var0: cn.nukkit.Player, var1: int): void
        static lambda$withoutPlayer$0(formIDConsumer: java.util.function.IntConsumer, player: cn.nukkit.Player, formID: int): void

    }
}

declare module "cn.nukkit.form.handler.FormResponseHandler" {
    declare type FormResponseHandler = cn.nukkit.form.handler.FormResponseHandler;
}

declare namespace cn.nukkit.form.response {
    declare class FormResponseCustom extends cn.nukkit.form.response.FormResponse {
        public constructor(responses: java.util.HashMap<int, java.lang.Object>, dropdownResponses: java.util.HashMap<int, cn.nukkit.form.response.FormResponseData>, inputResponses: java.util.HashMap<int, string>, sliderResponses: java.util.HashMap<int, float>, stepSliderResponses: java.util.HashMap<int, cn.nukkit.form.response.FormResponseData>, toggleResponses: java.util.HashMap<int, boolean>, labelResponses: java.util.HashMap<int, string>): void
        public getResponses(): java.util.HashMap<int, java.lang.Object>
        public getResponse(id: int): java.lang.Object
        public getDropdownResponse(id: int): cn.nukkit.form.response.FormResponseData
        public getInputResponse(id: int): string
        public getSliderResponse(id: int): float
        public getStepSliderResponse(id: int): cn.nukkit.form.response.FormResponseData
        public getToggleResponse(id: int): boolean
        public getLabelResponse(id: int): string
        responses: java.util.HashMap<int, java.lang.Object>
        dropdownResponses: java.util.HashMap<int, cn.nukkit.form.response.FormResponseData>
        inputResponses: java.util.HashMap<int, string>
        sliderResponses: java.util.HashMap<int, float>
        stepSliderResponses: java.util.HashMap<int, cn.nukkit.form.response.FormResponseData>
        toggleResponses: java.util.HashMap<int, boolean>
        labelResponses: java.util.HashMap<int, string>

    }
}

declare module "cn.nukkit.form.response.FormResponseCustom" {
    declare const FormResponseCustom = cn.nukkit.form.response.FormResponseCustom;
}

declare namespace cn.nukkit.form.response {
    declare class FormResponse extends java.lang.Object {
        public constructor(): void

    }
}

declare module "cn.nukkit.form.response.FormResponse" {
    declare const FormResponse = cn.nukkit.form.response.FormResponse;
}

declare namespace cn.nukkit.form.window {
    declare class FormWindow extends java.lang.Object {
        public constructor(): void
        public getJSONData(): string
        public setResponse(var0: string): void
        public getResponse(): cn.nukkit.form.response.FormResponse
        public wasClosed(): boolean
        public addHandler(handler: cn.nukkit.form.handler.FormResponseHandler): void
        public getHandlers(): java.util.List<cn.nukkit.form.handler.FormResponseHandler>
        static GSON: com.google.gson.Gson
        closed: boolean
        handlers: java.util.List<cn.nukkit.form.handler.FormResponseHandler>

    }
}

declare module "cn.nukkit.form.window.FormWindow" {
    declare const FormWindow = cn.nukkit.form.window.FormWindow;
}

declare namespace cn.nukkit.form.window {
    declare class FormWindowCustom$1 extends com.google.gson.reflect.TypeToken {
        constructor(this$0: cn.nukkit.form.window.FormWindowCustom): void
        this$0: cn.nukkit.form.window.FormWindowCustom

    }
}

declare module "cn.nukkit.form.window.FormWindowCustom$1" {
    declare const FormWindowCustom$1 = cn.nukkit.form.window.FormWindowCustom$1;
}

declare namespace cn.nukkit.form.window {
    declare class FormWindowCustom extends cn.nukkit.form.window.FormWindow {
        public constructor(title: string): void
        public constructor(title: string, contents: java.util.List<cn.nukkit.form.element.Element>): void
        public constructor(title: string, contents: java.util.List<cn.nukkit.form.element.Element>, icon: string): void
        public constructor(title: string, contents: java.util.List<cn.nukkit.form.element.Element>, icon: cn.nukkit.form.element.ElementButtonImageData): void
        public getTitle(): string
        public setTitle(title: string): void
        public getElements(): java.util.List<cn.nukkit.form.element.Element>
        public addElement(element: cn.nukkit.form.element.Element): void
        public getIcon(): cn.nukkit.form.element.ElementButtonImageData
        public setIcon(icon: string): void
        public setIcon(icon: cn.nukkit.form.element.ElementButtonImageData): void
        public getResponse(): cn.nukkit.form.response.FormResponseCustom
        public setResponse(data: string): void
        public setElementsFromResponse(): void
        public getResponse(): cn.nukkit.form.response.FormResponse
        lambda$setElementsFromResponse$0(i: int, response: java.lang.Object): void
        type: string
        title: string
        icon: cn.nukkit.form.element.ElementButtonImageData
        content: java.util.List<cn.nukkit.form.element.Element>
        response: cn.nukkit.form.response.FormResponseCustom

    }
}

declare module "cn.nukkit.form.window.FormWindowCustom" {
    declare const FormWindowCustom = cn.nukkit.form.window.FormWindowCustom;
}

declare namespace cn.nukkit.blockproperty.exception {
    declare class InvalidBlockPropertyValueException extends cn.nukkit.blockproperty.exception.InvalidBlockPropertyException {
        public constructor(property: byte, currentValue: java.io.Serializable, invalidValue: java.io.Serializable): void
        public constructor(property: byte, currentValue: java.io.Serializable, invalidValue: java.io.Serializable, message: string): void
        public constructor(property: byte, currentValue: java.io.Serializable, invalidValue: java.io.Serializable, message: string, cause: java.lang.Throwable): void
        public constructor(property: byte, currentValue: java.io.Serializable, invalidValue: java.io.Serializable, cause: java.lang.Throwable): void
        static buildMessage(currentValue: java.lang.Object, invalidValue: java.lang.Object): string
        public getCurrentValue(): java.io.Serializable
        public getInvalidValue(): java.io.Serializable
        static serialVersionUID: long
        currentValue: java.io.Serializable
        invalidValue: java.io.Serializable

    }
}

declare module "cn.nukkit.blockproperty.exception.InvalidBlockPropertyValueException" {
    declare const InvalidBlockPropertyValueException = cn.nukkit.blockproperty.exception.InvalidBlockPropertyValueException;
}

declare namespace cn.nukkit.blockproperty.exception {
    declare class BlockPropertyNotFoundException extends java.util.NoSuchElementException {
        public constructor(propertyName: string): void
        public constructor(propertyName: string, details: string): void
        public constructor(propertyName: string, properties: cn.nukkit.blockproperty.BlockProperties): void
        public getPropertyName(): string
        propertyName: string

    }
}

declare module "cn.nukkit.blockproperty.exception.BlockPropertyNotFoundException" {
    declare const BlockPropertyNotFoundException = cn.nukkit.blockproperty.exception.BlockPropertyNotFoundException;
}

declare namespace cn.nukkit.blockproperty {
    declare class UnknownRuntimeIdException extends java.lang.IllegalStateException {
        public constructor(): void
        public constructor(s: string): void
        public constructor(message: string, cause: java.lang.Throwable): void
        public constructor(cause: java.lang.Throwable): void

    }
}

declare module "cn.nukkit.blockproperty.UnknownRuntimeIdException" {
    declare const UnknownRuntimeIdException = cn.nukkit.blockproperty.UnknownRuntimeIdException;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class DirtType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.DirtType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.DirtType
        constructor(): void
        static $values(): cn.nukkit.blockproperty.value.DirtType[]
        public static NORMAL: cn.nukkit.blockproperty.value.DirtType
        public static COARSE: cn.nukkit.blockproperty.value.DirtType
        static $VALUES: cn.nukkit.blockproperty.value.DirtType[]

    }
}

declare module "cn.nukkit.blockproperty.value.DirtType" {
    declare const DirtType = cn.nukkit.blockproperty.value.DirtType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class PrismarineBlockType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.PrismarineBlockType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.PrismarineBlockType
        public getEnglishName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        constructor(var0: string, var1: cn.nukkit.utils.BlockColor): void
        static $values(): cn.nukkit.blockproperty.value.PrismarineBlockType[]
        public static DEFAULT: cn.nukkit.blockproperty.value.PrismarineBlockType
        public static DARK: cn.nukkit.blockproperty.value.PrismarineBlockType
        public static BRICKS: cn.nukkit.blockproperty.value.PrismarineBlockType
        englishName: string
        color: cn.nukkit.utils.BlockColor
        static $VALUES: cn.nukkit.blockproperty.value.PrismarineBlockType[]

    }
}

declare module "cn.nukkit.blockproperty.value.PrismarineBlockType" {
    declare const PrismarineBlockType = cn.nukkit.blockproperty.value.PrismarineBlockType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class NetherReactorState extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.NetherReactorState[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.NetherReactorState
        constructor(): void
        public static getFromData(data: int): cn.nukkit.blockproperty.value.NetherReactorState
        static $values(): cn.nukkit.blockproperty.value.NetherReactorState[]
        public static READY: cn.nukkit.blockproperty.value.NetherReactorState
        public static INITIALIZED: cn.nukkit.blockproperty.value.NetherReactorState
        public static FINISHED: cn.nukkit.blockproperty.value.NetherReactorState
        static values: cn.nukkit.blockproperty.value.NetherReactorState[]
        static $VALUES: cn.nukkit.blockproperty.value.NetherReactorState[]

    }
}

declare module "cn.nukkit.blockproperty.value.NetherReactorState" {
    declare const NetherReactorState = cn.nukkit.blockproperty.value.NetherReactorState;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class StoneSlab3Type extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.StoneSlab3Type[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.StoneSlab3Type
        constructor(var0: cn.nukkit.utils.BlockColor): void
        public getColor(): cn.nukkit.utils.BlockColor
        public getEnglishName(): string
        static lambda$new$0(name: string): string
        static $values(): cn.nukkit.blockproperty.value.StoneSlab3Type[]
        public static END_STONE_BRICK: cn.nukkit.blockproperty.value.StoneSlab3Type
        public static SMOOTH_RED_SANDSTONE: cn.nukkit.blockproperty.value.StoneSlab3Type
        public static POLISHED_ANDESITE: cn.nukkit.blockproperty.value.StoneSlab3Type
        public static ANDESITE: cn.nukkit.blockproperty.value.StoneSlab3Type
        public static DIORITE: cn.nukkit.blockproperty.value.StoneSlab3Type
        public static POLISHED_DIORITE: cn.nukkit.blockproperty.value.StoneSlab3Type
        public static GRANITE: cn.nukkit.blockproperty.value.StoneSlab3Type
        public static POLISHED_GRANITE: cn.nukkit.blockproperty.value.StoneSlab3Type
        public static PROPERTY: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.StoneSlab3Type>
        color: cn.nukkit.utils.BlockColor
        englishName: string
        static $VALUES: cn.nukkit.blockproperty.value.StoneSlab3Type[]

    }
}

declare module "cn.nukkit.blockproperty.value.StoneSlab3Type" {
    declare const StoneSlab3Type = cn.nukkit.blockproperty.value.StoneSlab3Type;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class AnvilDamage extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.AnvilDamage[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.AnvilDamage
        public getEnglishName(): string
        constructor(var0: string): void
        static $values(): cn.nukkit.blockproperty.value.AnvilDamage[]
        public static UNDAMAGED: cn.nukkit.blockproperty.value.AnvilDamage
        public static SLIGHTLY_DAMAGED: cn.nukkit.blockproperty.value.AnvilDamage
        public static VERY_DAMAGED: cn.nukkit.blockproperty.value.AnvilDamage
        public static BROKEN: cn.nukkit.blockproperty.value.AnvilDamage
        englishName: string
        static $VALUES: cn.nukkit.blockproperty.value.AnvilDamage[]

    }
}

declare module "cn.nukkit.blockproperty.value.AnvilDamage" {
    declare const AnvilDamage = cn.nukkit.blockproperty.value.AnvilDamage;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class StructureBlockType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.StructureBlockType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.StructureBlockType
        public getEnglishName(): string
        constructor(var0: string): void
        static $values(): cn.nukkit.blockproperty.value.StructureBlockType[]
        public static INVALID: cn.nukkit.blockproperty.value.StructureBlockType
        public static DATA: cn.nukkit.blockproperty.value.StructureBlockType
        public static SAVE: cn.nukkit.blockproperty.value.StructureBlockType
        public static LOAD: cn.nukkit.blockproperty.value.StructureBlockType
        public static CORNER: cn.nukkit.blockproperty.value.StructureBlockType
        public static EXPORT: cn.nukkit.blockproperty.value.StructureBlockType
        englishName: string
        static $VALUES: cn.nukkit.blockproperty.value.StructureBlockType[]

    }
}

declare module "cn.nukkit.blockproperty.value.StructureBlockType" {
    declare const StructureBlockType = cn.nukkit.blockproperty.value.StructureBlockType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class BambooStalkThickness extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.BambooStalkThickness[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.BambooStalkThickness
        constructor(): void
        static $values(): cn.nukkit.blockproperty.value.BambooStalkThickness[]
        public static THIN: cn.nukkit.blockproperty.value.BambooStalkThickness
        public static THICK: cn.nukkit.blockproperty.value.BambooStalkThickness
        static $VALUES: cn.nukkit.blockproperty.value.BambooStalkThickness[]

    }
}

declare module "cn.nukkit.blockproperty.value.BambooStalkThickness" {
    declare const BambooStalkThickness = cn.nukkit.blockproperty.value.BambooStalkThickness;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class TallGrassType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.TallGrassType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.TallGrassType
        constructor(): void
        static $values(): cn.nukkit.blockproperty.value.TallGrassType[]
        public static DEFAULT: cn.nukkit.blockproperty.value.TallGrassType
        public static TALL: cn.nukkit.blockproperty.value.TallGrassType
        public static FERN: cn.nukkit.blockproperty.value.TallGrassType
        public static SNOW: cn.nukkit.blockproperty.value.TallGrassType
        static $VALUES: cn.nukkit.blockproperty.value.TallGrassType[]

    }
}

declare module "cn.nukkit.blockproperty.value.TallGrassType" {
    declare const TallGrassType = cn.nukkit.blockproperty.value.TallGrassType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class CauldronLiquid extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.CauldronLiquid[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.CauldronLiquid
        constructor(): void
        static $values(): cn.nukkit.blockproperty.value.CauldronLiquid[]
        public static WATER: cn.nukkit.blockproperty.value.CauldronLiquid
        public static LAVA: cn.nukkit.blockproperty.value.CauldronLiquid
        public static POWDER_SNOW: cn.nukkit.blockproperty.value.CauldronLiquid
        static $VALUES: cn.nukkit.blockproperty.value.CauldronLiquid[]

    }
}

declare module "cn.nukkit.blockproperty.value.CauldronLiquid" {
    declare const CauldronLiquid = cn.nukkit.blockproperty.value.CauldronLiquid;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class DoublePlantType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.DoublePlantType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.DoublePlantType
        constructor(): void
        public getEnglishName(): string
        public isReplaceable(): boolean
        constructor(var0: string, var1: boolean): void
        static $values(): cn.nukkit.blockproperty.value.DoublePlantType[]
        public static SUNFLOWER: cn.nukkit.blockproperty.value.DoublePlantType
        public static SYRINGA: cn.nukkit.blockproperty.value.DoublePlantType
        public static GRASS: cn.nukkit.blockproperty.value.DoublePlantType
        public static FERN: cn.nukkit.blockproperty.value.DoublePlantType
        public static ROSE: cn.nukkit.blockproperty.value.DoublePlantType
        public static PAEONIA: cn.nukkit.blockproperty.value.DoublePlantType
        englishName: string
        replaceable: boolean
        static $VALUES: cn.nukkit.blockproperty.value.DoublePlantType[]

    }
}

declare module "cn.nukkit.blockproperty.value.DoublePlantType" {
    declare const DoublePlantType = cn.nukkit.blockproperty.value.DoublePlantType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class BambooLeafSize extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.BambooLeafSize[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.BambooLeafSize
        constructor(): void
        static $values(): cn.nukkit.blockproperty.value.BambooLeafSize[]
        public static NO_LEAVES: cn.nukkit.blockproperty.value.BambooLeafSize
        public static SMALL_LEAVES: cn.nukkit.blockproperty.value.BambooLeafSize
        public static LARGE_LEAVES: cn.nukkit.blockproperty.value.BambooLeafSize
        static $VALUES: cn.nukkit.blockproperty.value.BambooLeafSize[]

    }
}

declare module "cn.nukkit.blockproperty.value.BambooLeafSize" {
    declare const BambooLeafSize = cn.nukkit.blockproperty.value.BambooLeafSize;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class OxidizationLevel extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.OxidizationLevel[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.OxidizationLevel
        constructor(): void
        static $values(): cn.nukkit.blockproperty.value.OxidizationLevel[]
        public static UNAFFECTED: cn.nukkit.blockproperty.value.OxidizationLevel
        public static EXPOSED: cn.nukkit.blockproperty.value.OxidizationLevel
        public static WEATHERED: cn.nukkit.blockproperty.value.OxidizationLevel
        public static OXIDIZED: cn.nukkit.blockproperty.value.OxidizationLevel
        static $VALUES: cn.nukkit.blockproperty.value.OxidizationLevel[]

    }
}

declare module "cn.nukkit.blockproperty.value.OxidizationLevel" {
    declare const OxidizationLevel = cn.nukkit.blockproperty.value.OxidizationLevel;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class SandType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.SandType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.SandType
        constructor(): void
        static $values(): cn.nukkit.blockproperty.value.SandType[]
        public static NORMAL: cn.nukkit.blockproperty.value.SandType
        public static RED: cn.nukkit.blockproperty.value.SandType
        static $VALUES: cn.nukkit.blockproperty.value.SandType[]

    }
}

declare module "cn.nukkit.blockproperty.value.SandType" {
    declare const SandType = cn.nukkit.blockproperty.value.SandType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class StoneSlab4Type extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.StoneSlab4Type[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.StoneSlab4Type
        constructor(var0: cn.nukkit.utils.BlockColor): void
        public getColor(): cn.nukkit.utils.BlockColor
        public getEnglishName(): string
        static lambda$new$0(name: string): string
        static $values(): cn.nukkit.blockproperty.value.StoneSlab4Type[]
        public static MOSSY_STONE_BRICK: cn.nukkit.blockproperty.value.StoneSlab4Type
        public static SMOOTH_QUARTZ: cn.nukkit.blockproperty.value.StoneSlab4Type
        public static STONE: cn.nukkit.blockproperty.value.StoneSlab4Type
        public static CUT_SANDSTONE: cn.nukkit.blockproperty.value.StoneSlab4Type
        public static CUT_RED_SANDSTONE: cn.nukkit.blockproperty.value.StoneSlab4Type
        public static PROPERTY: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.StoneSlab4Type>
        color: cn.nukkit.utils.BlockColor
        englishName: string
        static $VALUES: cn.nukkit.blockproperty.value.StoneSlab4Type[]

    }
}

declare module "cn.nukkit.blockproperty.value.StoneSlab4Type" {
    declare const StoneSlab4Type = cn.nukkit.blockproperty.value.StoneSlab4Type;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class WoodType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.WoodType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.WoodType
        constructor(var0: cn.nukkit.utils.BlockColor): void
        constructor(var0: cn.nukkit.utils.BlockColor, var1: string): void
        public getColor(): cn.nukkit.utils.BlockColor
        public getEnglishName(): string
        static $values(): cn.nukkit.blockproperty.value.WoodType[]
        public static OAK: cn.nukkit.blockproperty.value.WoodType
        public static SPRUCE: cn.nukkit.blockproperty.value.WoodType
        public static BIRCH: cn.nukkit.blockproperty.value.WoodType
        public static JUNGLE: cn.nukkit.blockproperty.value.WoodType
        public static ACACIA: cn.nukkit.blockproperty.value.WoodType
        public static DARK_OAK: cn.nukkit.blockproperty.value.WoodType
        color: cn.nukkit.utils.BlockColor
        englishName: string
        public static PROPERTY: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.WoodType>
        static $VALUES: cn.nukkit.blockproperty.value.WoodType[]

    }
}

declare module "cn.nukkit.blockproperty.value.WoodType" {
    declare const WoodType = cn.nukkit.blockproperty.value.WoodType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class StructureVoidType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.StructureVoidType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.StructureVoidType
        constructor(): void
        static $values(): cn.nukkit.blockproperty.value.StructureVoidType[]
        public static VOID: cn.nukkit.blockproperty.value.StructureVoidType
        public static AIR: cn.nukkit.blockproperty.value.StructureVoidType
        static $VALUES: cn.nukkit.blockproperty.value.StructureVoidType[]

    }
}

declare module "cn.nukkit.blockproperty.value.StructureVoidType" {
    declare const StructureVoidType = cn.nukkit.blockproperty.value.StructureVoidType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class StoneSlab2Type extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.StoneSlab2Type[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.StoneSlab2Type
        constructor(var0: cn.nukkit.utils.BlockColor): void
        public getColor(): cn.nukkit.utils.BlockColor
        public getEnglishName(): string
        static lambda$new$0(name: string): string
        static $values(): cn.nukkit.blockproperty.value.StoneSlab2Type[]
        public static RED_SANDSTONE: cn.nukkit.blockproperty.value.StoneSlab2Type
        public static PURPUR: cn.nukkit.blockproperty.value.StoneSlab2Type
        public static PRISMARINE_ROUGH: cn.nukkit.blockproperty.value.StoneSlab2Type
        public static PRISMARINE_DARK: cn.nukkit.blockproperty.value.StoneSlab2Type
        public static PRISMARINE_BRICK: cn.nukkit.blockproperty.value.StoneSlab2Type
        public static MOSSY_COBBLESTONE: cn.nukkit.blockproperty.value.StoneSlab2Type
        public static SMOOTH_SANDSTONE: cn.nukkit.blockproperty.value.StoneSlab2Type
        public static RED_NETHER_BRICK: cn.nukkit.blockproperty.value.StoneSlab2Type
        public static PROPERTY: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.StoneSlab2Type>
        color: cn.nukkit.utils.BlockColor
        englishName: string
        static $VALUES: cn.nukkit.blockproperty.value.StoneSlab2Type[]

    }
}

declare module "cn.nukkit.blockproperty.value.StoneSlab2Type" {
    declare const StoneSlab2Type = cn.nukkit.blockproperty.value.StoneSlab2Type;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class SpongeType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.SpongeType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.SpongeType
        constructor(): void
        static $values(): cn.nukkit.blockproperty.value.SpongeType[]
        public static DRY: cn.nukkit.blockproperty.value.SpongeType
        public static WET: cn.nukkit.blockproperty.value.SpongeType
        static $VALUES: cn.nukkit.blockproperty.value.SpongeType[]

    }
}

declare module "cn.nukkit.blockproperty.value.SpongeType" {
    declare const SpongeType = cn.nukkit.blockproperty.value.SpongeType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class CrackState extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.CrackState[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.CrackState
        constructor(): void
        public getNext(): cn.nukkit.blockproperty.value.CrackState
        static $values(): cn.nukkit.blockproperty.value.CrackState[]
        public static NO_CRACKS: cn.nukkit.blockproperty.value.CrackState
        public static CRACKED: cn.nukkit.blockproperty.value.CrackState
        public static MAX_CRACKED: cn.nukkit.blockproperty.value.CrackState
        static VALUES: cn.nukkit.blockproperty.value.CrackState[]
        static $VALUES: cn.nukkit.blockproperty.value.CrackState[]

    }
}

declare module "cn.nukkit.blockproperty.value.CrackState" {
    declare const CrackState = cn.nukkit.blockproperty.value.CrackState;
}

declare namespace cn.nukkit.blockproperty {
    declare class BlockProperties$RegisteredBlockProperty extends java.lang.Object {
        public validateMeta(meta: int): void
        public validateMeta(meta: long): void
        public validateMeta(meta: java.math.BigInteger): void
        public toString(): string
        public constructor(property: byte, offset: int): void
        public getProperty(): byte
        public getOffset(): int
        public equals(o: java.lang.Object): boolean
        public hashCode(): int
        property: byte
        offset: int

    }
}

declare module "cn.nukkit.blockproperty.BlockProperties$RegisteredBlockProperty" {
    declare const BlockProperties$RegisteredBlockProperty = cn.nukkit.blockproperty.BlockProperties$RegisteredBlockProperty;
}

declare namespace cn.nukkit.blockproperty {
    declare class BlockProperties extends java.lang.Object {
        public constructor(properties: byte): void
        public constructor(itemBlockProperties: cn.nukkit.blockproperty.BlockProperties, properties: byte): void
        public getItemBlockProperties(): cn.nukkit.blockproperty.BlockProperties
        public createMutableState(blockId: int): cn.nukkit.blockstate.MutableBlockState
        public contains(propertyName: string): boolean
        public contains(property: byte): boolean
        public getBlockProperty(propertyName: string): byte
        public getBlockProperty(): cn.nukkit.blockproperty.BlockProperty<string, char>
        public getOffset(propertyName: string): int
        public getNames(): java.util.Set<string>
        public getAllProperties(): java.util.Collection<cn.nukkit.blockproperty.BlockProperties$RegisteredBlockProperty>
        public requireRegisteredProperty(propertyName: string): cn.nukkit.blockproperty.BlockProperties$RegisteredBlockProperty
        public setValue(currentMeta: int, propertyName: string, value: java.io.Serializable): int
        public setValue(currentMeta: long, var1: string, propertyName: java.io.Serializable): long
        public setBooleanValue(currentMeta: int, propertyName: string, value: boolean): int
        public setBooleanValue(currentMeta: long, var1: string, propertyName: boolean): long
        public setBooleanValue(currentMeta: java.math.BigInteger, propertyName: string, value: boolean): java.math.BigInteger
        public setIntValue(currentMeta: int, propertyName: string, value: int): int
        public setIntValue(currentMeta: long, var1: string, propertyName: int): long
        public setIntValue(currentMeta: java.math.BigInteger, propertyName: string, value: int): java.math.BigInteger
        public setPersistenceValue(currentMeta: int, propertyName: string, persistenceValue: string): int
        public setPersistenceValue(currentMeta: long, var1: string, propertyName: string): long
        public setPersistenceValue(currentMeta: java.math.BigInteger, propertyName: string, persistenceValue: string): java.math.BigInteger
        public setValue(currentMeta: java.math.BigInteger, propertyName: string, value: java.io.Serializable): java.math.BigInteger
        public getValue(currentMeta: int, propertyName: string): java.io.Serializable
        public getValue(currentMeta: long, var1: string): java.io.Serializable
        public getValue(currentMeta: java.math.BigInteger, propertyName: string): java.io.Serializable
        public getCheckedValue(currentMeta: java.lang.Object, propertyName: int, tClass: string): java.lang.Class<any>
        public getCheckedValue(currentMeta: java.lang.Object, var1: long, propertyName: string): java.lang.Class<any>
        public getCheckedValue(currentMeta: java.lang.Object, propertyName: java.math.BigInteger, tClass: string): java.lang.Class<any>
        public getUncheckedValue(currentMeta: java.lang.Object, propertyName: int): string
        public getUncheckedValue(currentMeta: java.lang.Object, var1: long): string
        public getUncheckedValue(currentMeta: java.lang.Object, propertyName: java.math.BigInteger): string
        public getIntValue(currentMeta: int, propertyName: string): int
        public getIntValue(currentMeta: long, var1: string): int
        public getIntValue(currentMeta: java.math.BigInteger, propertyName: string): int
        public getPersistenceValue(currentMeta: int, propertyName: string): string
        public getPersistenceValue(currentMeta: long, var1: string): string
        public getPersistenceValue(currentMeta: java.math.BigInteger, propertyName: string): string
        public getBooleanValue(currentMeta: int, propertyName: string): boolean
        public getBooleanValue(currentMeta: long, var1: string): boolean
        public getBooleanValue(currentMeta: java.math.BigInteger, propertyName: string): boolean
        public getBitSize(): int
        public forEach(consumer: java.util.function.ObjIntConsumer<byte>): void
        public forEach(consumer: java.util.function.Consumer<byte>): void
        public reduce(identity: java.lang.Object): cn.nukkit.utils.functional.TriFunction<byte, int>
        public reduceInt(identity: int, accumulator: cn.nukkit.utils.functional.ToIntTriFunctionTwoInts<byte>): int
        public reduceLong(identity: long, var1: cn.nukkit.utils.functional.ToLongTriFunctionOneIntOneLong<byte>): long
        public getItemPropertyNames(): java.util.List<string>
        public toString(): string
        public isDefaultValue(propertyName: string, value: java.io.Serializable): boolean
        public isDefaultValue(property: java.io.Serializable, value: cn.nukkit.blockproperty.BlockProperty<any>): boolean
        public isDefaultIntValue(propertyName: string, value: int): boolean
        public isDefaultIntValue(property: java.io.Serializable, value: cn.nukkit.blockproperty.BlockProperty<any>, var2: int): boolean
        public isDefaultBooleanValue(propertyName: string, value: boolean): boolean
        public isDefaultBooleanValue(property: java.io.Serializable, value: cn.nukkit.blockproperty.BlockProperty<any>, var2: boolean): boolean
        byName: java.util.Map<string, cn.nukkit.blockproperty.BlockProperties$RegisteredBlockProperty>
        bitSize: int
        itemBlockProperties: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.blockproperty.BlockProperties" {
    declare const BlockProperties = cn.nukkit.blockproperty.BlockProperties;
}

declare namespace cn.nukkit.blockproperty {
    declare class BooleanBlockProperty extends cn.nukkit.blockproperty.BlockProperty {
        public constructor(name: string, exportedToItem: boolean, persistenceName: string): void
        public constructor(name: string, exportedToItem: boolean): void
        public copy(): cn.nukkit.blockproperty.BooleanBlockProperty
        public exportingToItems(exportedToItem: boolean): cn.nukkit.blockproperty.BooleanBlockProperty
        public setValue(currentMeta: int, bitOffset: int, newValue: boolean): int
        public setValue(currentBigMeta: long, var1: int, bitOffset: boolean): long
        public setValue(currentMeta: int, bitOffset: int, newValue: boolean): int
        public setValue(currentMeta: long, var1: int, bitOffset: boolean): long
        public getValue(currentMeta: int, bitOffset: int): boolean
        public getValue(currentBigMeta: long, var1: int): boolean
        public getBooleanValue(currentMeta: int, bitOffset: int): boolean
        public getBooleanValue(currentBigMeta: long, var1: int): boolean
        public getBooleanValue(currentHugeData: java.math.BigInteger, bitOffset: int): boolean
        public getIntValue(currentMeta: int, bitOffset: int): int
        public getIntValueForMeta(meta: int): int
        public getMetaForValue(value: boolean): int
        public getValueForMeta(meta: int): boolean
        public getBooleanValueForMeta(meta: int): boolean
        public getDefaultValue(): boolean
        public isDefaultValue(value: boolean): boolean
        validateMetaDirectly(meta: int): void
        public getValueClass(): java.lang.Class<boolean>
        public getPersistenceValueForMeta(meta: int): string
        public getMetaForPersistenceValue(persistenceValue: string): int
        public exportingToItems(var0: boolean): cn.nukkit.blockproperty.BlockProperty
        public copy(): cn.nukkit.blockproperty.BlockProperty
        public getDefaultValue(): java.io.Serializable
        public isDefaultValue(var0: java.io.Serializable): boolean
        public getValueForMeta(var0: int): java.io.Serializable
        public getMetaForValue(var0: java.io.Serializable): int
        public getValue(var0: long, var1: int): java.io.Serializable
        public getValue(var0: int, var1: int): java.io.Serializable
        public setValue(var0: long, var1: int, var2: java.io.Serializable): long
        public setValue(var0: int, var1: int, var2: java.io.Serializable): int
        static serialVersionUID: long

    }
}

declare module "cn.nukkit.blockproperty.BooleanBlockProperty" {
    declare const BooleanBlockProperty = cn.nukkit.blockproperty.BooleanBlockProperty;
}

declare namespace cn.nukkit.blockproperty {
    declare class CommonBlockProperties extends java.lang.Object {
        constructor(): void
        public static EMPTY_PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static OPEN: cn.nukkit.blockproperty.BooleanBlockProperty
        public static TOGGLE: cn.nukkit.blockproperty.BooleanBlockProperty
        public static REDSTONE_SIGNAL: cn.nukkit.blockproperty.IntBlockProperty
        public static PERMANENTLY_DEAD: cn.nukkit.blockproperty.BooleanBlockProperty
        public static REDSTONE_SIGNAL_BLOCK_PROPERTY: cn.nukkit.blockproperty.BlockProperties
        public static UPPER_BLOCK: cn.nukkit.blockproperty.BooleanBlockProperty
        public static FACING_DIRECTION: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.math.BlockFace>
        public static CHISEL_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.ChiselType>
        public static AGE_15: cn.nukkit.blockproperty.IntBlockProperty
        public static FACING_DIRECTION_BLOCK_PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static DIRECTION: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.math.BlockFace>
        public static PILLAR_AXIS: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.math.BlockFace$Axis>
        public static DEPRECATED: cn.nukkit.blockproperty.IntBlockProperty
        public static COLOR: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.utils.DyeColor>
        public static COLOR_BLOCK_PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static POWERED: cn.nukkit.blockproperty.BooleanBlockProperty

    }
}

declare module "cn.nukkit.blockproperty.CommonBlockProperties" {
    declare const CommonBlockProperties = cn.nukkit.blockproperty.CommonBlockProperties;
}

declare namespace cn.nukkit {
    declare class OfflinePlayer extends java.lang.Object implements cn.nukkit.IPlayer {
        public constructor(server: cn.nukkit.Server, uuid: java.util.UUID): void
        public constructor(server: cn.nukkit.Server, name: string): void
        public constructor(server: cn.nukkit.Server, uuid: java.util.UUID, name: string): void
        public isOnline(): boolean
        public getName(): string
        public getUniqueId(): java.util.UUID
        public getServer(): cn.nukkit.Server
        public isOp(): boolean
        public setOp(value: boolean): void
        public isBanned(): boolean
        public setBanned(value: boolean): void
        public isWhitelisted(): boolean
        public setWhitelisted(value: boolean): void
        public getPlayer(): cn.nukkit.Player
        public getFirstPlayed(): long
        public getLastPlayed(): long
        public hasPlayedBefore(): boolean
        public setMetadata(metadataKey: string, newMetadataValue: cn.nukkit.metadata.MetadataValue): void
        public getMetadata(metadataKey: string): java.util.List<cn.nukkit.metadata.MetadataValue>
        public hasMetadata(metadataKey: string): boolean
        public removeMetadata(metadataKey: string, owningPlugin: cn.nukkit.plugin.Plugin): void
        server: cn.nukkit.Server
        namedTag: cn.nukkit.nbt.tag.CompoundTag

    }
}

declare module "cn.nukkit.OfflinePlayer" {
    declare const OfflinePlayer = cn.nukkit.OfflinePlayer;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityShulkerBox extends cn.nukkit.blockentity.BlockEntitySpawnable implements cn.nukkit.inventory.InventoryHolder, cn.nukkit.blockentity.BlockEntityContainer, cn.nukkit.blockentity.BlockEntityNameable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public close(): void
        public saveNBT(): void
        public loadNBT(): void
        public isBlockEntityValid(): boolean
        public getSize(): int
        getSlotIndex(index: int): int
        public getItem(index: int): cn.nukkit.item.Item
        public setItem(index: int, item: cn.nukkit.item.Item): void
        public getInventory(): cn.nukkit.inventory.BaseInventory
        public getRealInventory(): cn.nukkit.inventory.ShulkerBoxInventory
        public getName(): string
        public hasName(): boolean
        public setName(name: string): void
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public getInventory(): cn.nukkit.inventory.Inventory
        inventory: cn.nukkit.inventory.ShulkerBoxInventory

    }
}

declare module "cn.nukkit.blockentity.BlockEntityShulkerBox" {
    declare const BlockEntityShulkerBox = cn.nukkit.blockentity.BlockEntityShulkerBox;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityBanner extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public isBlockEntityValid(): boolean
        public saveNBT(): void
        public loadNBT(): void
        public getName(): string
        public getBaseColor(): int
        public setBaseColor(color: cn.nukkit.utils.DyeColor): void
        public getType(): int
        public setType(type: int): void
        public addPattern(pattern: cn.nukkit.utils.BannerPattern): void
        public getPattern(index: int): cn.nukkit.utils.BannerPattern
        public removePattern(index: int): void
        public getPatternsSize(): int
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public getDyeColor(): cn.nukkit.utils.DyeColor
        public color: int

    }
}

declare module "cn.nukkit.blockentity.BlockEntityBanner" {
    declare const BlockEntityBanner = cn.nukkit.blockentity.BlockEntityBanner;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityEndPortal extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public isBlockEntityValid(): boolean

    }
}

declare module "cn.nukkit.blockentity.BlockEntityEndPortal" {
    declare const BlockEntityEndPortal = cn.nukkit.blockentity.BlockEntityEndPortal;
}

declare namespace cn.nukkit.blockentity {
    declare interface ICommandBlock extends cn.nukkit.command.CommandSender, cn.nukkit.inventory.InventoryHolder {
        public getName(): string
        public hasName(): boolean
        public setName(var0: string): void
        public setPowered(): void
        public setPowered(var0: boolean): void
        public isPowered(): boolean
        public trigger(): boolean
        public trigger(chain: int): boolean
        public execute(): boolean
        public execute(var0: int): boolean
        public getMode(): int
        public getCommand(): string
        public setCommand(var0: string): void
        public isAuto(): boolean
        public setAuto(var0: boolean): void
        public isConditional(): boolean
        public setConditional(var0: boolean): void
        public isConditionMet(): boolean
        public setConditionMet(): boolean
        public getSuccessCount(): int
        public setSuccessCount(var0: int): void
        public getLastExecution(): long
        public setLastExecution(var0: long): void
        public isTrackingOutput(): boolean
        public setTrackOutput(var0: boolean): void
        public getLastOutput(): string
        public setLastOutput(var0: string): void
        public getLastOutputCommandMode(): int
        public setLastOutputCommandMode(var0: int): void
        public isLastOutputCondionalMode(): boolean
        public setLastOutputCondionalMode(var0: boolean): void
        public isLastOutputRedstoneMode(): boolean
        public setLastOutputRedstoneMode(var0: boolean): void
        public setLastOutputParams(var0: cn.nukkit.nbt.tag.ListTag<cn.nukkit.nbt.tag.StringTag>): void
        public getTickDelay(): int
        public setTickDelay(var0: int): void
        public isExecutingOnFirstTick(): boolean
        public setExecutingOnFirstTick(var0: boolean): void
        public getLevel(): cn.nukkit.level.Level
        public static CURRENT_VERSION: int
        public static MODE_NORMAL: int
        public static MODE_REPEATING: int
        public static MODE_CHAIN: int
        public static TAG_CONDITIONAL_MODE: string
        public static TAG_AUTO: string
        public static TAG_POWERED: string
        public static TAG_CUSTOM_NAME: string
        public static TAG_COMMAND: string
        public static TAG_LAST_EXECUTION: string
        public static TAG_TRACK_OUTPUT: string
        public static TAG_LAST_OUTPUT: string
        public static TAG_LAST_OUTPUT_PARAMS: string
        public static TAG_LP_COMMAND_MODE: string
        public static TAG_LP_CONDIONAL_MODE: string
        public static TAG_LP_REDSTONE_MODE: string
        public static TAG_SUCCESS_COUNT: string
        public static TAG_CONDITION_MET: string
        public static TAG_VERSION: string
        public static TAG_TICK_DELAY: string
        public static TAG_EXECUTE_ON_FIRST_TICK: string

    }
}

declare module "cn.nukkit.blockentity.ICommandBlock" {
    declare type ICommandBlock = cn.nukkit.blockentity.ICommandBlock;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityBrewingStand extends cn.nukkit.blockentity.BlockEntitySpawnable implements cn.nukkit.inventory.InventoryHolder, cn.nukkit.blockentity.BlockEntityContainer, cn.nukkit.blockentity.BlockEntityNameable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public getName(): string
        public hasName(): boolean
        public setName(name: string): void
        public close(): void
        public onBreak(): void
        public saveNBT(): void
        public loadNBT(): void
        public isBlockEntityValid(): boolean
        public getSize(): int
        getSlotIndex(index: int): int
        public getItem(index: int): cn.nukkit.item.Item
        public setItem(index: int, item: cn.nukkit.item.Item): void
        public getInventory(): cn.nukkit.inventory.BrewingInventory
        checkIngredient(ingredient: cn.nukkit.item.Item): boolean
        public onUpdate(): boolean
        restockFuel(): void
        stopBrewing(): void
        matchRecipes(quickTest: boolean): cn.nukkit.inventory.MixRecipe[]
        sendFuel(): void
        sendBrewTime(): void
        public updateBlock(): void
        public getFuel(): int
        public setFuel(fuel: int): void
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public getInventory(): cn.nukkit.inventory.Inventory
        inventory: cn.nukkit.inventory.BrewingInventory
        public static MAX_BREW_TIME: int
        public brewTime: int
        public fuelTotal: int
        public fuelAmount: int
        public static ingredients: java.util.List<int>

    }
}

declare module "cn.nukkit.blockentity.BlockEntityBrewingStand" {
    declare const BlockEntityBrewingStand = cn.nukkit.blockentity.BlockEntityBrewingStand;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityMovingBlock extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public getBlockEntity(): cn.nukkit.nbt.tag.CompoundTag
        public getMovingBlockEntityCompound(): cn.nukkit.nbt.tag.CompoundTag
        public getMovingBlock(): cn.nukkit.block.Block
        public getMovingBlockString(): string
        public moveCollidedEntities(piston: cn.nukkit.blockentity.BlockEntityPistonArm, moveDirection: cn.nukkit.math.BlockFace): void
        public isBlockEntityValid(): boolean
        blockString: string
        block: cn.nukkit.block.Block
        piston: cn.nukkit.math.BlockVector3

    }
}

declare module "cn.nukkit.blockentity.BlockEntityMovingBlock" {
    declare const BlockEntityMovingBlock = cn.nukkit.blockentity.BlockEntityMovingBlock;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntity extends cn.nukkit.level.Position {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public static createBlockEntity(type: string, position: cn.nukkit.level.Position, args: java.lang.Object[]): cn.nukkit.blockentity.BlockEntity
        public static createBlockEntity(type: string, pos: cn.nukkit.level.Position, nbt: cn.nukkit.nbt.tag.CompoundTag, args: java.lang.Object[]): cn.nukkit.blockentity.BlockEntity
        public static createBlockEntity(type: string, chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, args: java.lang.Object[]): cn.nukkit.blockentity.BlockEntity
        public static registerBlockEntity(name: string, c: java.lang.Class<cn.nukkit.blockentity.BlockEntity>): boolean
        public getSaveId(): string
        public getId(): long
        public saveNBT(): void
        public loadNBT(): void
        public getCleanedNBT(): cn.nukkit.nbt.tag.CompoundTag
        public getBlock(): cn.nukkit.block.Block
        public isBlockEntityValid(): boolean
        public onUpdate(): boolean
        public scheduleUpdate(): void
        public close(): void
        public onBreak(): void
        public onBreak(isSilkTouch: boolean): void
        public setDirty(): void
        public isObservable(): boolean
        public getName(): string
        public isMovable(): boolean
        public static getDefaultCompound(pos: cn.nukkit.math.Vector3, id: string): cn.nukkit.nbt.tag.CompoundTag
        public getLevelBlockEntity(): cn.nukkit.blockentity.BlockEntity
        static log: org.apache.logging.log4j.Logger
        public static CHEST: string
        public static ENDER_CHEST: string
        public static FURNACE: string
        public static BLAST_FURNACE: string
        public static SMOKER: string
        public static SIGN: string
        public static MOB_SPAWNER: string
        public static ENCHANT_TABLE: string
        public static SKULL: string
        public static FLOWER_POT: string
        public static BREWING_STAND: string
        public static DAYLIGHT_DETECTOR: string
        public static MUSIC: string
        public static ITEM_FRAME: string
        public static CAULDRON: string
        public static BEACON: string
        public static PISTON_ARM: string
        public static MOVING_BLOCK: string
        public static COMPARATOR: string
        public static HOPPER: string
        public static BED: string
        public static JUKEBOX: string
        public static SHULKER_BOX: string
        public static BANNER: string
        public static LECTERN: string
        public static BEEHIVE: string
        public static CONDUIT: string
        public static BARREL: string
        public static CAMPFIRE: string
        public static BELL: string
        public static DISPENSER: string
        public static DROPPER: string
        public static NETHER_REACTOR: string
        public static LODESTONE: string
        public static TARGET: string
        public static END_PORTAL: string
        public static END_GATEWAY: string
        public static COMMAND_BLOCK: string
        public static SCULK_SENSOR: string
        public static SCULK_CATALYST: string
        public static SCULK_SHRIEKER: string
        public static count: long
        static knownBlockEntities: com.google.common.collect.BiMap<string, java.lang.Class<cn.nukkit.blockentity.BlockEntity>>
        public chunk: cn.nukkit.level.format.FullChunk
        public name: string
        public id: long
        public movable: boolean
        public closed: boolean
        public namedTag: cn.nukkit.nbt.tag.CompoundTag
        lastUpdate: long
        server: cn.nukkit.Server
        timing: co.aikar.timings.Timing

    }
}

declare module "cn.nukkit.blockentity.BlockEntity" {
    declare const BlockEntity = cn.nukkit.blockentity.BlockEntity;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntitySculkSensor extends cn.nukkit.blockentity.BlockEntity {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public isBlockEntityValid(): boolean

    }
}

declare module "cn.nukkit.blockentity.BlockEntitySculkSensor" {
    declare const BlockEntitySculkSensor = cn.nukkit.blockentity.BlockEntitySculkSensor;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityBed extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public isBlockEntityValid(): boolean
        public saveNBT(): void
        public loadNBT(): void
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public getDyeColor(): cn.nukkit.utils.DyeColor
        public color: int

    }
}

declare module "cn.nukkit.blockentity.BlockEntityBed" {
    declare const BlockEntityBed = cn.nukkit.blockentity.BlockEntityBed;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityLodestone extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public getTrackingHandler(): java.util.OptionalInt
        public requestTrackingHandler(): int
        public isBlockEntityValid(): boolean
        public onBreak(): void
        static log: org.apache.logging.log4j.Logger

    }
}

declare module "cn.nukkit.blockentity.BlockEntityLodestone" {
    declare const BlockEntityLodestone = cn.nukkit.blockentity.BlockEntityLodestone;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityDispenser extends cn.nukkit.blockentity.BlockEntityEjectable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        createInventory(): cn.nukkit.inventory.DispenserInventory
        getBlockEntityName(): string
        public getInventory(): cn.nukkit.inventory.DispenserInventory
        public isBlockEntityValid(): boolean
        public getInventory(): cn.nukkit.inventory.EjectableInventory
        createInventory(): cn.nukkit.inventory.EjectableInventory
        public getInventory(): cn.nukkit.inventory.Inventory

    }
}

declare module "cn.nukkit.blockentity.BlockEntityDispenser" {
    declare const BlockEntityDispenser = cn.nukkit.blockentity.BlockEntityDispenser;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntitySculkCatalyst extends cn.nukkit.blockentity.BlockEntity {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public isBlockEntityValid(): boolean

    }
}

declare module "cn.nukkit.blockentity.BlockEntitySculkCatalyst" {
    declare const BlockEntitySculkCatalyst = cn.nukkit.blockentity.BlockEntitySculkCatalyst;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityBell extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public saveNBT(): void
        public loadNBT(): void
        public onUpdate(): boolean
        spawnToAllWithExceptions(): void
        public isRinging(): boolean
        public setRinging(ringing: boolean): void
        public getDirection(): int
        public setDirection(direction: int): void
        public getTicks(): int
        public setTicks(ticks: int): void
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public isBlockEntityValid(): boolean
        ringing: boolean
        direction: int
        ticks: int
        public spawnExceptions: java.util.List<cn.nukkit.Player>

    }
}

declare module "cn.nukkit.blockentity.BlockEntityBell" {
    declare const BlockEntityBell = cn.nukkit.blockentity.BlockEntityBell;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntitySkull extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public onUpdate(): boolean
        public setMouthMoving(mouthMoving: boolean): void
        public isObservable(): boolean
        public setDirty(): void
        public isMouthMoving(): boolean
        public getMouthTickCount(): int
        public setMouthTickCount(mouthTickCount: int): void
        public saveNBT(): void
        public loadNBT(): void
        public isBlockEntityValid(): boolean
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        mouthMoving: boolean
        mouthTickCount: int

    }
}

declare module "cn.nukkit.blockentity.BlockEntitySkull" {
    declare const BlockEntitySkull = cn.nukkit.blockentity.BlockEntitySkull;
}

declare namespace cn.nukkit.blockentity {
    declare class ICommandBlock$CommandBlockTrigger extends java.lang.Object implements java.lang.Runnable {
        public constructor(commandBlock: cn.nukkit.blockentity.ICommandBlock, chain: int): void
        public run(): void
        commandBlock: cn.nukkit.blockentity.ICommandBlock
        chain: int

    }
}

declare module "cn.nukkit.blockentity.ICommandBlock$CommandBlockTrigger" {
    declare const ICommandBlock$CommandBlockTrigger = cn.nukkit.blockentity.ICommandBlock$CommandBlockTrigger;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityDropper extends cn.nukkit.blockentity.BlockEntityEjectable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        createInventory(): cn.nukkit.inventory.DropperInventory
        getBlockEntityName(): string
        public getInventory(): cn.nukkit.inventory.DropperInventory
        public isBlockEntityValid(): boolean
        public getInventory(): cn.nukkit.inventory.EjectableInventory
        createInventory(): cn.nukkit.inventory.EjectableInventory
        public getInventory(): cn.nukkit.inventory.Inventory

    }
}

declare module "cn.nukkit.blockentity.BlockEntityDropper" {
    declare const BlockEntityDropper = cn.nukkit.blockentity.BlockEntityDropper;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityJukebox extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public isBlockEntityValid(): boolean
        public setRecordItem(recordItem: cn.nukkit.item.Item): void
        public getRecordItem(): cn.nukkit.item.Item
        public play(): void
        public stop(): void
        public dropItem(): void
        public saveNBT(): void
        public loadNBT(): void
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public onBreak(): void
        recordItem: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.blockentity.BlockEntityJukebox" {
    declare const BlockEntityJukebox = cn.nukkit.blockentity.BlockEntityJukebox;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityBeehive$Occupant extends java.lang.Object implements java.lang.Cloneable {
        public constructor(ticksLeftToStay: int, actorIdentifier: string, saveData: cn.nukkit.nbt.tag.CompoundTag): void
        constructor(saved: cn.nukkit.nbt.tag.CompoundTag): void
        public saveNBT(): cn.nukkit.nbt.tag.CompoundTag
        public getHasNectar(): boolean
        public setHasNectar(hasNectar: boolean): void
        public getTicksLeftToStay(): int
        public setTicksLeftToStay(ticksLeftToStay: int): void
        public getActorIdentifier(): string
        public setActorIdentifier(actorIdentifier: string): void
        public getSaveData(): cn.nukkit.nbt.tag.CompoundTag
        public setSaveData(saveData: cn.nukkit.nbt.tag.CompoundTag): void
        public getWorkSound(): cn.nukkit.level.Sound
        public setWorkSound(workSound: cn.nukkit.level.Sound): void
        public getWorkSoundPitch(): float
        public setWorkSoundPitch(workSoundPitch: float): void
        public isMuted(): boolean
        public setMuted(muted: boolean): void
        public toString(): string
        public equals(o: java.lang.Object): boolean
        public hashCode(): int
        clone(): cn.nukkit.blockentity.BlockEntityBeehive$Occupant
        clone(): java.lang.Object
        public static EMPTY_ARRAY: cn.nukkit.blockentity.BlockEntityBeehive$Occupant[]
        ticksLeftToStay: int
        actorIdentifier: string
        saveData: cn.nukkit.nbt.tag.CompoundTag
        workSound: cn.nukkit.level.Sound
        workSoundPitch: float
        hasNectar: boolean
        muted: boolean

    }
}

declare module "cn.nukkit.blockentity.BlockEntityBeehive$Occupant" {
    declare const BlockEntityBeehive$Occupant = cn.nukkit.blockentity.BlockEntityBeehive$Occupant;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityBeacon extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public isBlockEntityValid(): boolean
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public onUpdate(): boolean
        hasSkyAccess(): boolean
        calculatePowerLevel(): int
        public getPowerLevel(): int
        public setPowerLevel(level: int): void
        public getPrimaryPower(): int
        public setPrimaryPower(power: int): void
        public getSecondaryPower(): int
        public setSecondaryPower(power: int): void
        public updateCompoundTag(nbt: cn.nukkit.nbt.tag.CompoundTag, player: cn.nukkit.Player): boolean
        static isPrimaryAllowed(primary: int, powerLevel: int): boolean
        currentTick: long
        static POWER_LEVEL_MAX: int

    }
}

declare module "cn.nukkit.blockentity.BlockEntityBeacon" {
    declare const BlockEntityBeacon = cn.nukkit.blockentity.BlockEntityBeacon;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntitySpawnableContainer extends cn.nukkit.blockentity.BlockEntitySpawnable implements cn.nukkit.inventory.InventoryHolder, cn.nukkit.blockentity.BlockEntityContainer {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public close(): void
        public onBreak(): void
        public saveNBT(): void
        public loadNBT(): void
        getSlotIndex(index: int): int
        public getItem(index: int): cn.nukkit.item.Item
        public setItem(index: int, item: cn.nukkit.item.Item): void
        inventory: cn.nukkit.inventory.ContainerInventory

    }
}

declare module "cn.nukkit.blockentity.BlockEntitySpawnableContainer" {
    declare const BlockEntitySpawnableContainer = cn.nukkit.blockentity.BlockEntitySpawnableContainer;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityEndGateway extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public isBlockEntityValid(): boolean
        public saveNBT(): void
        public loadNBT(): void
        public onUpdate(): boolean
        public teleportEntity(entity: cn.nukkit.entity.Entity): void
        public getSafeExitPortal(): cn.nukkit.math.BlockVector3
        public getAge(): int
        public setAge(age: int): void
        public getExitPortal(): cn.nukkit.math.BlockVector3
        public setExitPortal(exitPortal: cn.nukkit.math.BlockVector3): void
        public isGenerating(): boolean
        public isTeleportCooldown(): boolean
        public setTeleportCooldown(): void
        public setTeleportCooldown(teleportCooldown: int): void
        sendBlockEventPacket(eventData: int): void
        age: int
        exitPortal: cn.nukkit.math.BlockVector3
        static defaultExitPortal: cn.nukkit.math.BlockVector3
        public teleportCooldown: int
        static STATE_BEDROCK: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.blockentity.BlockEntityEndGateway" {
    declare const BlockEntityEndGateway = cn.nukkit.blockentity.BlockEntityEndGateway;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntitySign extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public saveNBT(): void
        public loadNBT(): void
        public isBlockEntityValid(): boolean
        public setText(lines: string[]): boolean
        public getText(): string[]
        public getColor(): cn.nukkit.utils.BlockColor
        public setColor(color: cn.nukkit.utils.BlockColor): void
        public isGlowing(): boolean
        public setGlowing(glowing: boolean): void
        public updateCompoundTag(nbt: cn.nukkit.nbt.tag.CompoundTag, player: cn.nukkit.Player): boolean
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        static sanitizeText(lines: string[]): void
        text: string[]

    }
}

declare module "cn.nukkit.blockentity.BlockEntitySign" {
    declare const BlockEntitySign = cn.nukkit.blockentity.BlockEntitySign;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityLectern extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public loadNBT(): void
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public isBlockEntityValid(): boolean
        public onBreak(): void
        public hasBook(): boolean
        public getBook(): cn.nukkit.item.Item
        public setBook(item: cn.nukkit.item.Item): void
        public getLeftPage(): int
        public getRightPage(): int
        public setLeftPage(newLeftPage: int): void
        public setRightPage(newRightPage: int): void
        public setRawPage(page: int): void
        public getRawPage(): int
        public getTotalPages(): int
        updateTotalPages(): void
        totalPages: int

    }
}

declare module "cn.nukkit.blockentity.BlockEntityLectern" {
    declare const BlockEntityLectern = cn.nukkit.blockentity.BlockEntityLectern;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityHopper extends cn.nukkit.blockentity.BlockEntitySpawnable implements cn.nukkit.inventory.InventoryHolder, cn.nukkit.blockentity.BlockEntityContainer, cn.nukkit.blockentity.BlockEntityNameable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public isBlockEntityValid(): boolean
        public getName(): string
        public hasName(): boolean
        public setName(name: string): void
        public isOnTransferCooldown(): boolean
        public setTransferCooldown(transferCooldown: int): void
        public getSize(): int
        getSlotIndex(index: int): int
        public getItem(index: int): cn.nukkit.item.Item
        public setItem(index: int, item: cn.nukkit.item.Item): void
        public saveNBT(): void
        public loadNBT(): void
        public getInventory(): cn.nukkit.inventory.HopperInventory
        public isDisabled(): boolean
        public setDisabled(disabled: boolean): void
        public onUpdate(): boolean
        public isObservable(): boolean
        public pullItems(): boolean
        public pickupItems(): boolean
        public close(): void
        public onBreak(): void
        public pushItems(): boolean
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public getInventory(): cn.nukkit.inventory.Inventory
        inventory: cn.nukkit.inventory.HopperInventory
        public transferCooldown: int
        pickupArea: cn.nukkit.math.AxisAlignedBB
        disabled: boolean
        temporalVector: cn.nukkit.math.BlockVector3

    }
}

declare module "cn.nukkit.blockentity.BlockEntityHopper" {
    declare const BlockEntityHopper = cn.nukkit.blockentity.BlockEntityHopper;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityConduit extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public saveNBT(): void
        public loadNBT(): void
        public getName(): string
        public onUpdate(): boolean
        public isBlockEntityValid(): boolean
        public setTargetEntity(targetEntity: cn.nukkit.entity.Entity): void
        public getTargetEntity(): cn.nukkit.entity.Entity
        public isActive(): boolean
        public addEffectToPlayers(): void
        public attackMob(): void
        public canAttack(target: cn.nukkit.entity.Entity): boolean
        public canAffect(target: cn.nukkit.entity.Entity): boolean
        scanWater(): boolean
        scanFrame(): int
        public scanEdgeBlock(): java.util.List<cn.nukkit.block.Block>
        public scanStructure(): boolean
        public getValidBlocks(): int
        public getPlayerRadius(): int
        public getAttackRadius(): int
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        static lambda$attackMob$2(x$0: int): cn.nukkit.entity.Entity[]
        static lambda$addEffectToPlayers$1(p: cn.nukkit.Player): void
        static lambda$addEffectToPlayers$0(conduitPos: cn.nukkit.math.Vector2, radiusSquared: int, p: cn.nukkit.Player): boolean
        public static VALID_STRUCTURE_BLOCKS: it.unimi.dsi.fastutil.ints.IntSet
        targetEntity: cn.nukkit.entity.Entity
        target: long
        active: boolean
        validBlocks: int

    }
}

declare module "cn.nukkit.blockentity.BlockEntityConduit" {
    declare const BlockEntityConduit = cn.nukkit.blockentity.BlockEntityConduit;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityCauldron$PotionType extends java.lang.Enum {
        public static values(): cn.nukkit.blockentity.BlockEntityCauldron$PotionType[]
        public static valueOf(name: string): cn.nukkit.blockentity.BlockEntityCauldron$PotionType
        public static getByTypeData(typeData: int): cn.nukkit.blockentity.BlockEntityCauldron$PotionType
        constructor(var0: int): void
        static $values(): cn.nukkit.blockentity.BlockEntityCauldron$PotionType[]
        public static EMPTY: cn.nukkit.blockentity.BlockEntityCauldron$PotionType
        public static NORMAL: cn.nukkit.blockentity.BlockEntityCauldron$PotionType
        public static SPLASH: cn.nukkit.blockentity.BlockEntityCauldron$PotionType
        public static LINGERING: cn.nukkit.blockentity.BlockEntityCauldron$PotionType
        public static LAVA: cn.nukkit.blockentity.BlockEntityCauldron$PotionType
        public static UNKNOWN: cn.nukkit.blockentity.BlockEntityCauldron$PotionType
        potionTypeData: int
        static BY_DATA: it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.blockentity.BlockEntityCauldron$PotionType>
        static $VALUES: cn.nukkit.blockentity.BlockEntityCauldron$PotionType[]

    }
}

declare module "cn.nukkit.blockentity.BlockEntityCauldron$PotionType" {
    declare const BlockEntityCauldron$PotionType = cn.nukkit.blockentity.BlockEntityCauldron$PotionType;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityEnderChest extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public isBlockEntityValid(): boolean
        public getName(): string
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag

    }
}

declare module "cn.nukkit.blockentity.BlockEntityEnderChest" {
    declare const BlockEntityEnderChest = cn.nukkit.blockentity.BlockEntityEnderChest;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityCommandBlock extends cn.nukkit.blockentity.BlockEntitySpawnable implements cn.nukkit.blockentity.ICommandBlock, cn.nukkit.blockentity.BlockEntityNameable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public saveNBT(): void
        public loadNBT(): void
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public isBlockEntityValid(): boolean
        public getName(): string
        public hasName(): boolean
        public setName(name: string): void
        public setPowered(powered: boolean): void
        public isPowered(): boolean
        public onUpdate(): boolean
        public execute(chain: int): boolean
        public getMode(): int
        public getCommand(): string
        public setCommand(command: string): void
        public isAuto(): boolean
        public setAuto(auto: boolean): void
        public isConditional(): boolean
        public setConditional(conditionalMode: boolean): void
        public isConditionMet(): boolean
        public setConditionMet(): boolean
        public getSuccessCount(): int
        public setSuccessCount(count: int): void
        public getLastExecution(): long
        public setLastExecution(time: long): void
        public isTrackingOutput(): boolean
        public setTrackOutput(track: boolean): void
        public getLastOutput(): string
        public setLastOutput(output: string): void
        public getLastOutputCommandMode(): int
        public setLastOutputCommandMode(mode: int): void
        public isLastOutputCondionalMode(): boolean
        public setLastOutputCondionalMode(condionalMode: boolean): void
        public isLastOutputRedstoneMode(): boolean
        public setLastOutputRedstoneMode(redstoneMode: boolean): void
        public setLastOutputParams(params: cn.nukkit.nbt.tag.ListTag<cn.nukkit.nbt.tag.StringTag>): void
        public getTickDelay(): int
        public setTickDelay(tickDelay: int): void
        public isExecutingOnFirstTick(): boolean
        public setExecutingOnFirstTick(executingOnFirstTick: boolean): void
        public isPermissionSet(name: string): boolean
        public isPermissionSet(permission: cn.nukkit.permission.Permission): boolean
        public hasPermission(name: string): boolean
        public hasPermission(permission: cn.nukkit.permission.Permission): boolean
        public addAttachment(plugin: cn.nukkit.plugin.Plugin): cn.nukkit.permission.PermissionAttachment
        public addAttachment(plugin: cn.nukkit.plugin.Plugin, name: string): cn.nukkit.permission.PermissionAttachment
        public addAttachment(plugin: cn.nukkit.plugin.Plugin, name: string, value: boolean): cn.nukkit.permission.PermissionAttachment
        public removeAttachment(attachment: cn.nukkit.permission.PermissionAttachment): void
        public recalculatePermissions(): void
        public getEffectivePermissions(): java.util.Map<string, cn.nukkit.permission.PermissionAttachmentInfo>
        public isPlayer(): boolean
        public isEntity(): boolean
        public getPosition(): cn.nukkit.level.Position
        public getServer(): cn.nukkit.Server
        public sendMessage(message: cn.nukkit.lang.TextContainer): void
        public sendMessage(message: string): void
        public isOp(): boolean
        public setOp(value: boolean): void
        public getInventory(): cn.nukkit.inventory.Inventory
        public onBreak(): void
        public close(): void
        public isConditionalMode(): boolean
        public isTrackOutput(): boolean
        public getLastOutputParams(): cn.nukkit.nbt.tag.ListTag<cn.nukkit.nbt.tag.StringTag>
        public getPerm(): cn.nukkit.permission.PermissibleBase
        public getViewers(): java.util.Set<cn.nukkit.Player>
        public getCurrentTick(): int
        public static getListenMap(): java.util.Map<cn.nukkit.blockentity.BlockEntityCommandBlock, java.util.Map<string, string>>
        static lambda$execute$0(block: cn.nukkit.block.Block): void
        static listenMap: java.util.Map<cn.nukkit.blockentity.BlockEntityCommandBlock, java.util.Map<string, string>>
        conditionalMode: boolean
        auto: boolean
        command: string
        lastExecution: long
        trackOutput: boolean
        lastOutput: string
        lastOutputParams: cn.nukkit.nbt.tag.ListTag<cn.nukkit.nbt.tag.StringTag>
        lastOutputCommandMode: int
        lastOutputCondionalMode: boolean
        lastOutputRedstoneMode: boolean
        successCount: int
        conditionMet: boolean
        powered: boolean
        tickDelay: int
        executingOnFirstTick: boolean
        perm: cn.nukkit.permission.PermissibleBase
        viewers: java.util.Set<cn.nukkit.Player>
        currentTick: int

    }
}

declare module "cn.nukkit.blockentity.BlockEntityCommandBlock" {
    declare const BlockEntityCommandBlock = cn.nukkit.blockentity.BlockEntityCommandBlock;
}

declare namespace cn.nukkit.blockentity {
    declare interface BlockEntityContainer {
        public getItem(var0: int): cn.nukkit.item.Item
        public setItem(var0: int, var1: cn.nukkit.item.Item): void
        public getSize(): int

    }
}

declare module "cn.nukkit.blockentity.BlockEntityContainer" {
    declare type BlockEntityContainer = cn.nukkit.blockentity.BlockEntityContainer;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityMusic extends cn.nukkit.blockentity.BlockEntity {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public isBlockEntityValid(): boolean
        public changePitch(): void
        public getPitch(): int
        public setPowered(powered: boolean): void
        public isPowered(): boolean

    }
}

declare module "cn.nukkit.blockentity.BlockEntityMusic" {
    declare const BlockEntityMusic = cn.nukkit.blockentity.BlockEntityMusic;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntitySmoker extends cn.nukkit.blockentity.BlockEntityFurnace {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        getFurnaceName(): string
        getClientName(): string
        getIdleBlockId(): int
        getBurningBlockId(): int
        getInventoryType(): cn.nukkit.inventory.InventoryType
        matchRecipe(raw: cn.nukkit.item.Item): cn.nukkit.inventory.SmeltingRecipe
        getSpeedMultiplier(): int

    }
}

declare module "cn.nukkit.blockentity.BlockEntitySmoker" {
    declare const BlockEntitySmoker = cn.nukkit.blockentity.BlockEntitySmoker;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityEjectable extends cn.nukkit.blockentity.BlockEntitySpawnable implements cn.nukkit.blockentity.BlockEntityContainer, cn.nukkit.blockentity.BlockEntityNameable, cn.nukkit.inventory.InventoryHolder {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        createInventory(): cn.nukkit.inventory.EjectableInventory
        getBlockEntityName(): string
        initBlockEntity(): void
        public getSize(): int
        getSlotIndex(index: int): int
        public getItem(index: int): cn.nukkit.item.Item
        public setItem(index: int, item: cn.nukkit.item.Item): void
        public getInventory(): cn.nukkit.inventory.EjectableInventory
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public saveNBT(): void
        public loadNBT(): void
        public getName(): string
        public hasName(): boolean
        public setName(name: string): void
        public onBreak(): void
        public getInventory(): cn.nukkit.inventory.Inventory
        inventory: cn.nukkit.inventory.EjectableInventory

    }
}

declare module "cn.nukkit.blockentity.BlockEntityEjectable" {
    declare const BlockEntityEjectable = cn.nukkit.blockentity.BlockEntityEjectable;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntitySpawnable extends cn.nukkit.blockentity.BlockEntity {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public spawnTo(player: cn.nukkit.Player): void
        public getSpawnPacket(): cn.nukkit.network.protocol.BlockEntityDataPacket
        public getSpawnPacket(nbt: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.network.protocol.BlockEntityDataPacket
        public spawnToAll(): void
        public updateCompoundTag(nbt: cn.nukkit.nbt.tag.CompoundTag, player: cn.nukkit.Player): boolean

    }
}

declare module "cn.nukkit.blockentity.BlockEntitySpawnable" {
    declare const BlockEntitySpawnable = cn.nukkit.blockentity.BlockEntitySpawnable;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityTarget extends cn.nukkit.blockentity.BlockEntity {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public isBlockEntityValid(): boolean
        public setActivePower(power: int): void
        public getActivePower(): int

    }
}

declare module "cn.nukkit.blockentity.BlockEntityTarget" {
    declare const BlockEntityTarget = cn.nukkit.blockentity.BlockEntityTarget;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityNetherReactor extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public isBlockEntityValid(): boolean
        public getReactorState(): cn.nukkit.blockproperty.value.NetherReactorState
        public setReactorState(reactorState: cn.nukkit.blockproperty.value.NetherReactorState): void
        public getProgress(): int
        public setProgress(progress: int): void
        initBlockEntity(): void
        public saveNBT(): void
        public loadNBT(): void
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        reactorState: cn.nukkit.blockproperty.value.NetherReactorState
        progress: int

    }
}

declare module "cn.nukkit.blockentity.BlockEntityNetherReactor" {
    declare const BlockEntityNetherReactor = cn.nukkit.blockentity.BlockEntityNetherReactor;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityBeehive extends cn.nukkit.blockentity.BlockEntity {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public saveNBT(): void
        public loadNBT(): void
        public getHoneyLevel(): int
        public setHoneyLevel(honeyLevel: int): void
        public addOccupant(occupant: cn.nukkit.blockentity.BlockEntityBeehive$Occupant): boolean
        public addOccupant(entity: cn.nukkit.entity.Entity): cn.nukkit.blockentity.BlockEntityBeehive$Occupant
        public addOccupant(entity: cn.nukkit.entity.Entity, ticksLeftToStay: int): cn.nukkit.blockentity.BlockEntityBeehive$Occupant
        public addOccupant(entity: cn.nukkit.entity.Entity, ticksLeftToStay: int, hasNectar: boolean): cn.nukkit.blockentity.BlockEntityBeehive$Occupant
        public addOccupant(entity: cn.nukkit.entity.Entity, ticksLeftToStay: int, hasNectar: boolean, playSound: boolean): cn.nukkit.blockentity.BlockEntityBeehive$Occupant
        public getOccupants(): cn.nukkit.blockentity.BlockEntityBeehive$Occupant[]
        public removeOccupant(occupant: cn.nukkit.blockentity.BlockEntityBeehive$Occupant): boolean
        public isHoneyEmpty(): boolean
        public isHoneyFull(): boolean
        public isEmpty(): boolean
        public getOccupantsCount(): int
        public isSpawnFaceValid(face: cn.nukkit.math.BlockFace): boolean
        public scanValidSpawnFaces(): java.util.List<cn.nukkit.math.BlockFace>
        public scanValidSpawnFaces(preferFront: boolean): java.util.List<cn.nukkit.math.BlockFace>
        public spawnOccupant(occupant: cn.nukkit.blockentity.BlockEntityBeehive$Occupant, validFaces: java.util.List<cn.nukkit.math.BlockFace>): cn.nukkit.entity.Entity
        public onBreak(): void
        public onBreak(isSilkTouch: boolean): void
        public angerBees(player: cn.nukkit.Player): void
        public onUpdate(): boolean
        public isBlockEntityValid(): boolean
        static RANDOM: java.util.Random
        occupants: java.util.List<cn.nukkit.blockentity.BlockEntityBeehive$Occupant>

    }
}

declare module "cn.nukkit.blockentity.BlockEntityBeehive" {
    declare const BlockEntityBeehive = cn.nukkit.blockentity.BlockEntityBeehive;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityChest extends cn.nukkit.blockentity.BlockEntitySpawnableContainer implements cn.nukkit.blockentity.BlockEntityNameable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public close(): void
        public isBlockEntityValid(): boolean
        public getSize(): int
        public getInventory(): cn.nukkit.inventory.BaseInventory
        public holdingDoubleInventory(): boolean
        public getRealInventory(): cn.nukkit.inventory.ChestInventory
        checkPairing(): void
        public isPaired(): boolean
        public getPair(): cn.nukkit.blockentity.BlockEntityChest
        public pairWith(chest: cn.nukkit.blockentity.BlockEntityChest): boolean
        public createPair(chest: cn.nukkit.blockentity.BlockEntityChest): void
        public unpair(): boolean
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public getCleanedNBT(): cn.nukkit.nbt.tag.CompoundTag
        public getName(): string
        public hasName(): boolean
        public setName(name: string): void
        public onBreak(): void
        public getInventory(): cn.nukkit.inventory.Inventory
        doubleInventory: cn.nukkit.inventory.DoubleChestInventory

    }
}

declare module "cn.nukkit.blockentity.BlockEntityChest" {
    declare const BlockEntityChest = cn.nukkit.blockentity.BlockEntityChest;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityCauldron extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public saveNBT(): void
        public getPotionId(): int
        public setPotionId(potionId: int): void
        public hasPotion(): boolean
        public setPotionType(potionType: int): void
        public getPotionType(): int
        public getType(): cn.nukkit.blockentity.BlockEntityCauldron$PotionType
        public setType(type: cn.nukkit.blockentity.BlockEntityCauldron$PotionType): void
        public isSplashPotion(): boolean
        public setSplashPotion(value: boolean): void
        public getCustomColor(): cn.nukkit.utils.BlockColor
        public isCustomColor(): boolean
        public setCustomColor(color: cn.nukkit.utils.BlockColor): void
        public setCustomColor(r: int, g: int, b: int): void
        public clearCustomColor(): void
        public spawnToAll(): void
        public isBlockEntityValid(): boolean
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        lambda$spawnToAll$0(location: cn.nukkit.level.Location, viewers: cn.nukkit.Player[]): void
        public static POTION_TYPE_EMPTY: int
        public static POTION_TYPE_NORMAL: int
        public static POTION_TYPE_SPLASH: int
        public static POTION_TYPE_LINGERING: int
        public static POTION_TYPE_LAVA: int

    }
}

declare module "cn.nukkit.blockentity.BlockEntityCauldron" {
    declare const BlockEntityCauldron = cn.nukkit.blockentity.BlockEntityCauldron;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityFlowerPot extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public isBlockEntityValid(): boolean
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag

    }
}

declare module "cn.nukkit.blockentity.BlockEntityFlowerPot" {
    declare const BlockEntityFlowerPot = cn.nukkit.blockentity.BlockEntityFlowerPot;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityDaylightDetector extends cn.nukkit.blockentity.BlockEntity {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public isBlockEntityValid(): boolean
        public onUpdate(): boolean

    }
}

declare module "cn.nukkit.blockentity.BlockEntityDaylightDetector" {
    declare const BlockEntityDaylightDetector = cn.nukkit.blockentity.BlockEntityDaylightDetector;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityBlastFurnace extends cn.nukkit.blockentity.BlockEntityFurnace {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        getFurnaceName(): string
        getClientName(): string
        getIdleBlockId(): int
        getBurningBlockId(): int
        getInventoryType(): cn.nukkit.inventory.InventoryType
        matchRecipe(raw: cn.nukkit.item.Item): cn.nukkit.inventory.SmeltingRecipe
        getSpeedMultiplier(): int

    }
}

declare module "cn.nukkit.blockentity.BlockEntityBlastFurnace" {
    declare const BlockEntityBlastFurnace = cn.nukkit.blockentity.BlockEntityBlastFurnace;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityBarrel extends cn.nukkit.blockentity.BlockEntitySpawnableContainer implements cn.nukkit.blockentity.BlockEntityNameable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public getSize(): int
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public isBlockEntityValid(): boolean
        public getInventory(): cn.nukkit.inventory.BarrelInventory
        public getName(): string
        public hasName(): boolean
        public setName(name: string): void
        public getInventory(): cn.nukkit.inventory.Inventory

    }
}

declare module "cn.nukkit.blockentity.BlockEntityBarrel" {
    declare const BlockEntityBarrel = cn.nukkit.blockentity.BlockEntityBarrel;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityComparator extends cn.nukkit.blockentity.BlockEntity {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public isBlockEntityValid(): boolean
        public getOutputSignal(): int
        public setOutputSignal(outputSignal: int): void
        public saveNBT(): void
        public loadNBT(): void
        outputSignal: int

    }
}

declare module "cn.nukkit.blockentity.BlockEntityComparator" {
    declare const BlockEntityComparator = cn.nukkit.blockentity.BlockEntityComparator;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityFurnace extends cn.nukkit.blockentity.BlockEntitySpawnable implements cn.nukkit.inventory.InventoryHolder, cn.nukkit.blockentity.BlockEntityContainer, cn.nukkit.blockentity.BlockEntityNameable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        getInventoryType(): cn.nukkit.inventory.InventoryType
        initBlockEntity(): void
        getFurnaceName(): string
        getClientName(): string
        public getName(): string
        public hasName(): boolean
        public setName(name: string): void
        public close(): void
        public onBreak(): void
        public saveNBT(): void
        public loadNBT(): void
        public isBlockEntityValid(): boolean
        public getSize(): int
        getSlotIndex(index: int): int
        public getItem(index: int): cn.nukkit.item.Item
        public setItem(index: int, item: cn.nukkit.item.Item): void
        public getInventory(): cn.nukkit.inventory.FurnaceInventory
        getIdleBlockId(): int
        getBurningBlockId(): int
        setBurning(burning: boolean): void
        checkFuel(fuel: cn.nukkit.item.Item): void
        matchRecipe(raw: cn.nukkit.item.Item): cn.nukkit.inventory.SmeltingRecipe
        getSpeedMultiplier(): int
        public onUpdate(): boolean
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public getBurnTime(): int
        public setBurnTime(burnTime: int): void
        public getBurnDuration(): int
        public setBurnDuration(burnDuration: int): void
        public getCookTime(): int
        public setCookTime(cookTime: int): void
        public getMaxTime(): int
        public setMaxTime(maxTime: int): void
        public getInventory(): cn.nukkit.inventory.Inventory
        inventory: cn.nukkit.inventory.FurnaceInventory
        burnTime: int
        burnDuration: int
        cookTime: int
        maxTime: int
        crackledTime: int

    }
}

declare module "cn.nukkit.blockentity.BlockEntityFurnace" {
    declare const BlockEntityFurnace = cn.nukkit.blockentity.BlockEntityFurnace;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityEnchantTable extends cn.nukkit.blockentity.BlockEntitySpawnable implements cn.nukkit.blockentity.BlockEntityNameable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public isBlockEntityValid(): boolean
        public getName(): string
        public hasName(): boolean
        public setName(name: string): void
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag

    }
}

declare module "cn.nukkit.blockentity.BlockEntityEnchantTable" {
    declare const BlockEntityEnchantTable = cn.nukkit.blockentity.BlockEntityEnchantTable;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityItemFrame extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public getName(): string
        public isBlockEntityValid(): boolean
        public getItemRotation(): int
        public setItemRotation(itemRotation: int): void
        public getItem(): cn.nukkit.item.Item
        public setItem(item: cn.nukkit.item.Item): void
        public setItem(item: cn.nukkit.item.Item, setChanged: boolean): void
        public getItemDropChance(): float
        public setItemDropChance(chance: float): void
        public setDirty(): void
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public getAnalogOutput(): int
        public dropItem(player: cn.nukkit.Player): boolean
        public dropItemAndGetEntity(player: cn.nukkit.Player): cn.nukkit.entity.item.EntityItem

    }
}

declare module "cn.nukkit.blockentity.BlockEntityItemFrame" {
    declare const BlockEntityItemFrame = cn.nukkit.blockentity.BlockEntityItemFrame;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntity$1 extends cn.nukkit.scheduler.Task {
        constructor(this$0: cn.nukkit.blockentity.BlockEntity): void
        public onRun(currentTick: int): void
        this$0: cn.nukkit.blockentity.BlockEntity

    }
}

declare module "cn.nukkit.blockentity.BlockEntity$1" {
    declare const BlockEntity$1 = cn.nukkit.blockentity.BlockEntity$1;
}

declare namespace cn.nukkit.blockentity {
    declare interface BlockEntityNameable {
        public getName(): string
        public setName(var0: string): void
        public hasName(): boolean

    }
}

declare module "cn.nukkit.blockentity.BlockEntityNameable" {
    declare type BlockEntityNameable = cn.nukkit.blockentity.BlockEntityNameable;
}

declare namespace cn.nukkit {
    declare class Player$3 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$network$protocol$AnimatePacket$Action: int[]
        static $SwitchMap$cn$nukkit$network$protocol$BookEditPacket$Action: int[]
        static $SwitchMap$cn$nukkit$event$entity$EntityDamageEvent$DamageCause: int[]

    }
}

declare module "cn.nukkit.Player$3" {
    declare const Player$3 = cn.nukkit.Player$3;
}

declare namespace cn.nukkit.item {
    declare class RuntimeItems extends java.lang.Object {
        public static getRuntimeMapping(): cn.nukkit.item.RuntimeItemMapping
        public static getId(fullId: int): int
        public static getData(fullId: int): int
        public static getFullId(id: int, data: int): int
        public static getNetworkId(networkFullId: int): int
        public static hasData(id: int): boolean
        constructor(): void
        static log: org.apache.logging.log4j.Logger
        static GSON: com.google.gson.Gson
        static ENTRY_TYPE: java.lang.reflect.Type
        static itemPalette: cn.nukkit.item.RuntimeItemMapping

    }
}

declare module "cn.nukkit.item.RuntimeItems" {
    declare const RuntimeItems = cn.nukkit.item.RuntimeItems;
}

declare namespace cn.nukkit.item.customitem {
    declare class ItemCustomEdible extends cn.nukkit.item.customitem.ItemCustom {
        public constructor(id: string, name: string): void
        public constructor(id: string, name: string, textureName: string): void
        public getComponentsData(): cn.nukkit.nbt.tag.CompoundTag
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean
        public onUse(player: cn.nukkit.Player, ticksUsed: int): boolean
        public getEatTick(): int
        public isDrink(): boolean
        public canAlwaysEat(): boolean

    }
}

declare module "cn.nukkit.item.customitem.ItemCustomEdible" {
    declare const ItemCustomEdible = cn.nukkit.item.customitem.ItemCustomEdible;
}

declare namespace cn.nukkit.item.customitem {
    declare class ItemCustomTool extends cn.nukkit.item.customitem.ItemCustom implements cn.nukkit.item.ItemDurable {
        public constructor(id: string, name: string): void
        public constructor(id: string, name: string, textureName: string): void
        public getCreativeCategory(): int
        public getComponentsData(): cn.nukkit.nbt.tag.CompoundTag
        public getMaxStackSize(): int
        public useOn(block: cn.nukkit.block.Block): boolean
        public useOn(entity: cn.nukkit.entity.Entity): boolean
        isDurable(): boolean
        public isUnbreakable(): boolean
        public isTool(): boolean
        public getMaxDurability(): int
        public getEnchantAbility(): int
        public noDamageOnAttack(): boolean
        public noDamageOnBreak(): boolean
        public static getPickaxeDiggerNBT(tier: int): cn.nukkit.nbt.tag.CompoundTag
        public static getAxeDiggerNBT(tier: int): cn.nukkit.nbt.tag.CompoundTag
        public static getShovelDiggerNBT(tier: int): cn.nukkit.nbt.tag.CompoundTag
        public static TIER_WOODEN: int
        public static TIER_GOLD: int
        public static TIER_STONE: int
        public static TIER_IRON: int
        public static TIER_DIAMOND: int
        public static TIER_NETHERITE: int
        public static TYPE_NONE: int
        public static TYPE_SWORD: int
        public static TYPE_SHOVEL: int
        public static TYPE_PICKAXE: int
        public static TYPE_AXE: int
        public static TYPE_SHEARS: int
        public static TYPE_HOE: int
        public static DURABILITY_WOODEN: int
        public static DURABILITY_GOLD: int
        public static DURABILITY_STONE: int
        public static DURABILITY_IRON: int
        public static DURABILITY_DIAMOND: int
        public static DURABILITY_NETHERITE: int
        public static DURABILITY_FLINT_STEEL: int
        public static DURABILITY_SHEARS: int
        public static DURABILITY_BOW: int
        public static DURABILITY_CROSSBOW: int
        public static DURABILITY_TRIDENT: int
        public static DURABILITY_FISHING_ROD: int
        public static DURABILITY_CARROT_ON_A_STICK: int
        public static DURABILITY_WARPED_FUNGUS_ON_A_STICK: int

    }
}

declare module "cn.nukkit.item.customitem.ItemCustomTool" {
    declare const ItemCustomTool = cn.nukkit.item.customitem.ItemCustomTool;
}

declare namespace cn.nukkit.item.customitem {
    declare class ItemCustomArmor extends cn.nukkit.item.customitem.ItemCustom implements cn.nukkit.item.ItemDurable {
        public constructor(id: string, name: string): void
        public constructor(id: string, name: string, textureName: string): void
        public getCreativeCategory(): int
        public getComponentsData(): cn.nukkit.nbt.tag.CompoundTag
        public getMaxStackSize(): int
        public getMaxDurability(): int
        public isArmor(): boolean
        public isHelmet(): boolean
        public isChestplate(): boolean
        public isLeggings(): boolean
        public isBoots(): boolean
        public getArmorPoints(): int
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean
        public getEnchantAbility(): int
        public isUnbreakable(): boolean
        public static TIER_LEATHER: int
        public static TIER_IRON: int
        public static TIER_CHAIN: int
        public static TIER_GOLD: int
        public static TIER_DIAMOND: int
        public static TIER_NETHERITE: int
        public static TIER_OTHER: int

    }
}

declare module "cn.nukkit.item.customitem.ItemCustomArmor" {
    declare const ItemCustomArmor = cn.nukkit.item.customitem.ItemCustomArmor;
}

declare namespace cn.nukkit.item.customitem {
    declare class ItemCustom extends cn.nukkit.item.StringItem {
        public constructor(id: string, name: string): void
        public constructor(id: string, name: string, textureName: string): void
        public allowOffHand(): boolean
        public getCreativeCategory(): int
        public getEnchantableValue(): int
        public getComponentsData(): cn.nukkit.nbt.tag.CompoundTag
        static xyzToCompoundTag(x: float, y: float, z: float): cn.nukkit.nbt.tag.CompoundTag
        public clone(): cn.nukkit.item.customitem.ItemCustom
        public getRuntimeId(): int
        public setTextureName(textureName: string): void
        public getTextureName(): string
        public setTextureSize(textureSize: int): void
        public getTextureSize(): int
        public clone(): cn.nukkit.item.StringItem
        public clone(): cn.nukkit.item.Item
        public clone(): java.lang.Object
        static INTERNAL_ALLOCATION_ID_MAP: java.util.concurrent.ConcurrentHashMap<string, int>
        static nextRuntimeId: int
        runtimeId: int
        textureName: string
        textureSize: int

    }
}

declare module "cn.nukkit.item.customitem.ItemCustom" {
    declare const ItemCustom = cn.nukkit.item.customitem.ItemCustom;
}

declare namespace cn.nukkit.item {
    declare class ItemRecordChirp extends cn.nukkit.item.ItemRecord {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getSoundId(): string

    }
}

declare module "cn.nukkit.item.ItemRecordChirp" {
    declare const ItemRecordChirp = cn.nukkit.item.ItemRecordChirp;
}

declare namespace cn.nukkit.item {
    declare class ItemRedstone extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemRedstone" {
    declare const ItemRedstone = cn.nukkit.item.ItemRedstone;
}

declare namespace cn.nukkit.item {
    declare class ItemRecordStrad extends cn.nukkit.item.ItemRecord {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getSoundId(): string

    }
}

declare module "cn.nukkit.item.ItemRecordStrad" {
    declare const ItemRecordStrad = cn.nukkit.item.ItemRecordStrad;
}

declare namespace cn.nukkit.item {
    declare class ItemNetherStar extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemNetherStar" {
    declare const ItemNetherStar = cn.nukkit.item.ItemNetherStar;
}

declare namespace cn.nukkit.item {
    declare class ItemPickaxeWood extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isPickaxe(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemPickaxeWood" {
    declare const ItemPickaxeWood = cn.nukkit.item.ItemPickaxeWood;
}

declare namespace cn.nukkit.item {
    declare class ItemEnderEye extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemEnderEye" {
    declare const ItemEnderEye = cn.nukkit.item.ItemEnderEye;
}

declare namespace cn.nukkit.item {
    declare class ItemRabbitHide extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemRabbitHide" {
    declare const ItemRabbitHide = cn.nukkit.item.ItemRabbitHide;
}

declare namespace cn.nukkit.item {
    declare class ItemShovelIron extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isShovel(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemShovelIron" {
    declare const ItemShovelIron = cn.nukkit.item.ItemShovelIron;
}

declare namespace cn.nukkit.item {
    declare class ItemLeggingsIron extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isLeggings(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemLeggingsIron" {
    declare const ItemLeggingsIron = cn.nukkit.item.ItemLeggingsIron;
}

declare namespace cn.nukkit.item {
    declare class ItemIngotGold extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemIngotGold" {
    declare const ItemIngotGold = cn.nukkit.item.ItemIngotGold;
}

declare namespace cn.nukkit.item {
    declare class ItemMinecartChest extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public canBeActivated(): boolean
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemMinecartChest" {
    declare const ItemMinecartChest = cn.nukkit.item.ItemMinecartChest;
}

declare namespace cn.nukkit.item {
    declare class ItemMushroomStew extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemMushroomStew" {
    declare const ItemMushroomStew = cn.nukkit.item.ItemMushroomStew;
}

declare namespace cn.nukkit.item {
    declare class ItemTotem extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemTotem" {
    declare const ItemTotem = cn.nukkit.item.ItemTotem;
}

declare namespace cn.nukkit.item {
    declare class ItemFeather extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemFeather" {
    declare const ItemFeather = cn.nukkit.item.ItemFeather;
}

declare namespace cn.nukkit.item {
    declare class ItemFishingRod extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getEnchantAbility(): int
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean
        public getMaxDurability(): int
        public noDamageOnAttack(): boolean
        public noDamageOnBreak(): boolean

    }
}

declare module "cn.nukkit.item.ItemFishingRod" {
    declare const ItemFishingRod = cn.nukkit.item.ItemFishingRod;
}

declare namespace cn.nukkit.item {
    declare class ItemBone extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemBone" {
    declare const ItemBone = cn.nukkit.item.ItemBone;
}

declare namespace cn.nukkit.item {
    declare class ItemDoorWarped extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemDoorWarped" {
    declare const ItemDoorWarped = cn.nukkit.item.ItemDoorWarped;
}

declare namespace cn.nukkit.item {
    declare class ItemHoeStone extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isHoe(): boolean
        public getTier(): int

    }
}

declare module "cn.nukkit.item.ItemHoeStone" {
    declare const ItemHoeStone = cn.nukkit.item.ItemHoeStone;
}

declare namespace cn.nukkit.item {
    declare class ItemChickenRaw extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemChickenRaw" {
    declare const ItemChickenRaw = cn.nukkit.item.ItemChickenRaw;
}

declare namespace cn.nukkit.item {
    declare class ItemFish extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        constructor(id: int, meta: int, count: int, name: string): void

    }
}

declare module "cn.nukkit.item.ItemFish" {
    declare const ItemFish = cn.nukkit.item.ItemFish;
}

declare namespace cn.nukkit.item {
    declare class ItemDoorSpruce extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemDoorSpruce" {
    declare const ItemDoorSpruce = cn.nukkit.item.ItemDoorSpruce;
}

declare namespace cn.nukkit.item {
    declare class ItemSalmonCooked extends cn.nukkit.item.ItemFish {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemSalmonCooked" {
    declare const ItemSalmonCooked = cn.nukkit.item.ItemSalmonCooked;
}

declare namespace cn.nukkit.item {
    declare class ItemClownfish extends cn.nukkit.item.ItemFish {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemClownfish" {
    declare const ItemClownfish = cn.nukkit.item.ItemClownfish;
}

declare namespace cn.nukkit.item {
    declare class ItemMangroveSign extends cn.nukkit.item.ItemSign {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemMangroveSign" {
    declare const ItemMangroveSign = cn.nukkit.item.ItemMangroveSign;
}

declare namespace cn.nukkit.item {
    declare class ItemSeedsPumpkin extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemSeedsPumpkin" {
    declare const ItemSeedsPumpkin = cn.nukkit.item.ItemSeedsPumpkin;
}

declare namespace cn.nukkit.item {
    declare class ItemPorkchopCooked extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemPorkchopCooked" {
    declare const ItemPorkchopCooked = cn.nukkit.item.ItemPorkchopCooked;
}

declare namespace cn.nukkit.item {
    declare class ItemMelonGlistering extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemMelonGlistering" {
    declare const ItemMelonGlistering = cn.nukkit.item.ItemMelonGlistering;
}

declare namespace cn.nukkit.item {
    declare class ItemBed extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public setDamage(meta: int): void
        updateName(): void
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemBed" {
    declare const ItemBed = cn.nukkit.item.ItemBed;
}

declare namespace cn.nukkit.item {
    declare class ItemEgg extends cn.nukkit.item.ProjectileItem {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getProjectileEntityType(): string
        public getThrowForce(): float
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemEgg" {
    declare const ItemEgg = cn.nukkit.item.ItemEgg;
}

declare namespace cn.nukkit.item {
    declare class ItemRottenFlesh extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemRottenFlesh" {
    declare const ItemRottenFlesh = cn.nukkit.item.ItemRottenFlesh;
}

declare namespace cn.nukkit.item {
    declare class ItemHelmetIron extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isHelmet(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemHelmetIron" {
    declare const ItemHelmetIron = cn.nukkit.item.ItemHelmetIron;
}

declare namespace cn.nukkit.item {
    declare class ItemMuttonRaw extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemMuttonRaw" {
    declare const ItemMuttonRaw = cn.nukkit.item.ItemMuttonRaw;
}

declare namespace cn.nukkit.item {
    declare class ItemChorusFruit extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean
        public onUse(player: cn.nukkit.Player, ticksUsed: int): boolean

    }
}

declare module "cn.nukkit.item.ItemChorusFruit" {
    declare const ItemChorusFruit = cn.nukkit.item.ItemChorusFruit;
}

declare namespace cn.nukkit.item.food {
    declare class FoodNormal extends cn.nukkit.item.food.Food {
        public constructor(restoreFood: int, restoreSaturation: float): void

    }
}

declare module "cn.nukkit.item.food.FoodNormal" {
    declare const FoodNormal = cn.nukkit.item.food.FoodNormal;
}

declare namespace cn.nukkit.item.food {
    declare class FoodInBowl extends cn.nukkit.item.food.Food {
        public constructor(restoreFood: int, restoreSaturation: float): void
        onEatenBy(player: cn.nukkit.Player): boolean

    }
}

declare module "cn.nukkit.item.food.FoodInBowl" {
    declare const FoodInBowl = cn.nukkit.item.food.FoodInBowl;
}

declare namespace cn.nukkit.item.food {
    declare class FoodChorusFruit extends cn.nukkit.item.food.FoodNormal {
        public constructor(): void
        onEatenBy(player: cn.nukkit.Player): boolean

    }
}

declare module "cn.nukkit.item.food.FoodChorusFruit" {
    declare const FoodChorusFruit = cn.nukkit.item.food.FoodChorusFruit;
}

declare namespace cn.nukkit.item.food {
    declare class Food$NodeIDMetaPlugin extends cn.nukkit.item.food.Food$NodeIDMeta {
        constructor(id: int, meta: int, plugin: cn.nukkit.plugin.Plugin): void
        plugin: cn.nukkit.plugin.Plugin

    }
}

declare module "cn.nukkit.item.food.Food$NodeIDMetaPlugin" {
    declare const Food$NodeIDMetaPlugin = cn.nukkit.item.food.Food$NodeIDMetaPlugin;
}

declare namespace cn.nukkit.item.food {
    declare class Food$NodeIDMeta extends java.lang.Object {
        constructor(id: int, meta: int): void
        id: int
        meta: int

    }
}

declare module "cn.nukkit.item.food.Food$NodeIDMeta" {
    declare const Food$NodeIDMeta = cn.nukkit.item.food.Food$NodeIDMeta;
}

declare namespace cn.nukkit.item.food {
    declare class FoodEffectiveInBow extends cn.nukkit.item.food.FoodEffective {
        public constructor(restoreFood: int, restoreSaturation: float): void
        onEatenBy(player: cn.nukkit.Player): boolean

    }
}

declare module "cn.nukkit.item.food.FoodEffectiveInBow" {
    declare const FoodEffectiveInBow = cn.nukkit.item.food.FoodEffectiveInBow;
}

declare namespace cn.nukkit.item.food {
    declare class FoodMilk extends cn.nukkit.item.food.Food {
        public constructor(): void
        onEatenBy(player: cn.nukkit.Player): boolean

    }
}

declare module "cn.nukkit.item.food.FoodMilk" {
    declare const FoodMilk = cn.nukkit.item.food.FoodMilk;
}

declare namespace cn.nukkit.item.food {
    declare class Food extends java.lang.Object {
        public constructor(): void
        public static registerFood(food: cn.nukkit.item.food.Food, plugin: cn.nukkit.plugin.Plugin): cn.nukkit.item.food.Food
        static registerDefaultFood(food: cn.nukkit.item.food.Food): cn.nukkit.item.food.Food
        public static getByRelative(item: cn.nukkit.item.Item): cn.nukkit.item.food.Food
        public static getByRelative(block: cn.nukkit.block.Block): cn.nukkit.item.food.Food
        public static getByRelative(relativeID: int, meta: int): cn.nukkit.item.food.Food
        public eatenBy(player: cn.nukkit.Player): boolean
        onEatenBy(player: cn.nukkit.Player): boolean
        public addRelative(relativeID: int): cn.nukkit.item.food.Food
        public addRelative(relativeID: int, meta: int): cn.nukkit.item.food.Food
        addRelative(node: cn.nukkit.item.food.Food$NodeIDMeta): cn.nukkit.item.food.Food
        public getRestoreFood(): int
        public setRestoreFood(restoreFood: int): cn.nukkit.item.food.Food
        public getRestoreSaturation(): float
        public setRestoreSaturation(restoreSaturation: float): cn.nukkit.item.food.Food
        public getEatingTick(): int
        public setEatingTick(eatingTick: int): cn.nukkit.item.food.Food
        static lambda$getByRelative$3(relativeID: int, meta: int, result: cn.nukkit.item.food.Food[], n: cn.nukkit.item.food.Food$NodeIDMeta, f: cn.nukkit.item.food.Food): void
        static lambda$getByRelative$2(relativeID: int, meta: int, result: cn.nukkit.item.food.Food[], n: cn.nukkit.item.food.Food$NodeIDMetaPlugin, f: cn.nukkit.item.food.Food): void
        static lambda$registerDefaultFood$1(food: cn.nukkit.item.food.Food, n: cn.nukkit.item.food.Food$NodeIDMeta): void
        static lambda$registerFood$0(plugin: cn.nukkit.plugin.Plugin, food: cn.nukkit.item.food.Food, n: cn.nukkit.item.food.Food$NodeIDMeta): void
        static registryCustom: java.util.Map<cn.nukkit.item.food.Food$NodeIDMetaPlugin, cn.nukkit.item.food.Food>
        static registryDefault: java.util.Map<cn.nukkit.item.food.Food$NodeIDMeta, cn.nukkit.item.food.Food>
        public static apple: cn.nukkit.item.food.Food
        public static apple_golden: cn.nukkit.item.food.Food
        public static apple_golden_enchanted: cn.nukkit.item.food.Food
        public static beef_raw: cn.nukkit.item.food.Food
        public static beetroot: cn.nukkit.item.food.Food
        public static beetroot_soup: cn.nukkit.item.food.Food
        public static bread: cn.nukkit.item.food.Food
        public static cake_slice: cn.nukkit.item.food.Food
        public static carrot: cn.nukkit.item.food.Food
        public static carrot_golden: cn.nukkit.item.food.Food
        public static chicken_raw: cn.nukkit.item.food.Food
        public static chicken_cooked: cn.nukkit.item.food.Food
        public static chorus_fruit: cn.nukkit.item.food.Food
        public static cookie: cn.nukkit.item.food.Food
        public static melon_slice: cn.nukkit.item.food.Food
        public static milk: cn.nukkit.item.food.Food
        public static mushroom_stew: cn.nukkit.item.food.Food
        public static mutton_cooked: cn.nukkit.item.food.Food
        public static mutton_raw: cn.nukkit.item.food.Food
        public static porkchop_cooked: cn.nukkit.item.food.Food
        public static porkchop_raw: cn.nukkit.item.food.Food
        public static potato_raw: cn.nukkit.item.food.Food
        public static potato_baked: cn.nukkit.item.food.Food
        public static potato_poisonous: cn.nukkit.item.food.Food
        public static pumpkin_pie: cn.nukkit.item.food.Food
        public static rabbit_cooked: cn.nukkit.item.food.Food
        public static rabbit_raw: cn.nukkit.item.food.Food
        public static rabbit_stew: cn.nukkit.item.food.Food
        public static rotten_flesh: cn.nukkit.item.food.Food
        public static spider_eye: cn.nukkit.item.food.Food
        public static steak: cn.nukkit.item.food.Food
        public static clownfish: cn.nukkit.item.food.Food
        public static fish_cooked: cn.nukkit.item.food.Food
        public static fish_raw: cn.nukkit.item.food.Food
        public static salmon_cooked: cn.nukkit.item.food.Food
        public static salmon_raw: cn.nukkit.item.food.Food
        public static pufferfish: cn.nukkit.item.food.Food
        public static dried_kelp: cn.nukkit.item.food.Food
        public static sweet_berries: cn.nukkit.item.food.Food
        public static suspicious_stew_night_vision: cn.nukkit.item.food.Food
        public static suspicious_stew_jump: cn.nukkit.item.food.Food
        public static suspicious_stew_weakness: cn.nukkit.item.food.Food
        public static suspicious_stew_blindness: cn.nukkit.item.food.Food
        public static suspicious_stew_poison: cn.nukkit.item.food.Food
        public static suspicious_stew_saturation: cn.nukkit.item.food.Food
        public static suspicious_stew_fire_resistance: cn.nukkit.item.food.Food
        public static suspicious_stew_regeneration: cn.nukkit.item.food.Food
        public static suspicious_stew_wither: cn.nukkit.item.food.Food
        public static honey: cn.nukkit.item.food.Food
        public static honey_bottle: cn.nukkit.item.food.Food
        public static glow_berries: cn.nukkit.item.food.Food
        restoreFood: int
        restoreSaturation: float
        relativeIDs: java.util.List<cn.nukkit.item.food.Food$NodeIDMeta>
        eatingTick: int

    }
}

declare module "cn.nukkit.item.food.Food" {
    declare const Food = cn.nukkit.item.food.Food;
}

declare namespace cn.nukkit.item.food {
    declare class FoodEffective extends cn.nukkit.item.food.Food {
        public constructor(restoreFood: int, restoreSaturation: float): void
        public addEffect(effect: cn.nukkit.potion.Effect): cn.nukkit.item.food.FoodEffective
        public addChanceEffect(chance: float, effect: cn.nukkit.potion.Effect): cn.nukkit.item.food.FoodEffective
        onEatenBy(player: cn.nukkit.Player): boolean
        static lambda$onEatenBy$0(toApply: java.util.List, effect: cn.nukkit.potion.Effect, chance: float): void
        effects: java.util.Map<cn.nukkit.potion.Effect, float>

    }
}

declare module "cn.nukkit.item.food.FoodEffective" {
    declare const FoodEffective = cn.nukkit.item.food.FoodEffective;
}

declare namespace cn.nukkit.item.food {
    declare class FoodHoney extends cn.nukkit.item.food.Food {
        public constructor(restoreFood: int, restoreSaturation: float): void
        onEatenBy(player: cn.nukkit.Player): boolean

    }
}

declare module "cn.nukkit.item.food.FoodHoney" {
    declare const FoodHoney = cn.nukkit.item.food.FoodHoney;
}

declare namespace cn.nukkit.item {
    declare class ItemPickaxeStone extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isPickaxe(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemPickaxeStone" {
    declare const ItemPickaxeStone = cn.nukkit.item.ItemPickaxeStone;
}

declare namespace cn.nukkit.item {
    declare class ItemPaper extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemPaper" {
    declare const ItemPaper = cn.nukkit.item.ItemPaper;
}

declare namespace cn.nukkit.item {
    declare class ItemShovelNetherite extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isShovel(): boolean
        public getTier(): int
        public getAttackDamage(): int
        public isLavaResistant(): boolean

    }
}

declare module "cn.nukkit.item.ItemShovelNetherite" {
    declare const ItemShovelNetherite = cn.nukkit.item.ItemShovelNetherite;
}

declare namespace cn.nukkit.item {
    declare class ItemTrident extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public getAttackDamage(): int
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean
        public onRelease(player: cn.nukkit.Player, ticksUsed: int): boolean

    }
}

declare module "cn.nukkit.item.ItemTrident" {
    declare const ItemTrident = cn.nukkit.item.ItemTrident;
}

declare namespace cn.nukkit.item {
    declare class ItemJungleSign extends cn.nukkit.item.ItemSign {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemJungleSign" {
    declare const ItemJungleSign = cn.nukkit.item.ItemJungleSign;
}

declare namespace cn.nukkit.item {
    declare class ItemItemFrameGlow extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemItemFrameGlow" {
    declare const ItemItemFrameGlow = cn.nukkit.item.ItemItemFrameGlow;
}

declare namespace cn.nukkit.item {
    declare class ItemCrimsonSign extends cn.nukkit.item.ItemSign {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemCrimsonSign" {
    declare const ItemCrimsonSign = cn.nukkit.item.ItemCrimsonSign;
}

declare namespace cn.nukkit.item {
    declare class ItemBookWritable extends cn.nukkit.item.Item {
        constructor(id: int): void
        constructor(id: int, meta: int): void
        constructor(id: int, meta: int, count: int): void
        constructor(id: int, meta: int, count: int, name: string): void
        public pageExists(pageId: int): boolean
        public getPageText(pageId: int): string
        public setPageText(pageId: int, pageText: string): boolean
        public addPage(pageId: int): boolean
        public deletePage(pageId: int): boolean
        public insertPage(pageId: int): boolean
        public insertPage(pageId: int, pageText: string): boolean
        public swapPages(pageId1: int, pageId2: int): boolean
        public getPages(): java.util.List
        static createPageTag(): cn.nukkit.nbt.tag.CompoundTag
        static createPageTag(pageText: string): cn.nukkit.nbt.tag.CompoundTag

    }
}

declare module "cn.nukkit.item.ItemBookWritable" {
    declare const ItemBookWritable = cn.nukkit.item.ItemBookWritable;
}

declare namespace cn.nukkit.item {
    declare class Item$ItemJsonComponents$KeepOnDeath extends java.lang.Object {
        public constructor(): void

    }
}

declare module "cn.nukkit.item.Item$ItemJsonComponents$KeepOnDeath" {
    declare const Item$ItemJsonComponents$KeepOnDeath = cn.nukkit.item.Item$ItemJsonComponents$KeepOnDeath;
}

declare namespace cn.nukkit.item {
    declare class ItemDoorMangrove extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemDoorMangrove" {
    declare const ItemDoorMangrove = cn.nukkit.item.ItemDoorMangrove;
}

declare namespace cn.nukkit.item {
    declare class ItemCompass extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemCompass" {
    declare const ItemCompass = cn.nukkit.item.ItemCompass;
}

declare namespace cn.nukkit.item {
    declare class ItemSwordNetherite extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isSword(): boolean
        public getTier(): int
        public getAttackDamage(): int
        public isLavaResistant(): boolean

    }
}

declare module "cn.nukkit.item.ItemSwordNetherite" {
    declare const ItemSwordNetherite = cn.nukkit.item.ItemSwordNetherite;
}

declare namespace cn.nukkit.item {
    declare class ItemSpyglass extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemSpyglass" {
    declare const ItemSpyglass = cn.nukkit.item.ItemSpyglass;
}

declare namespace cn.nukkit.item {
    declare class ItemDiamond extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemDiamond" {
    declare const ItemDiamond = cn.nukkit.item.ItemDiamond;
}

declare namespace cn.nukkit.item {
    declare class ItemNameTag extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemNameTag" {
    declare const ItemNameTag = cn.nukkit.item.ItemNameTag;
}

declare namespace cn.nukkit.item {
    declare class ItemDoorIron extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemDoorIron" {
    declare const ItemDoorIron = cn.nukkit.item.ItemDoorIron;
}

declare namespace cn.nukkit.item {
    declare class ItemHelmetGold extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isHelmet(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemHelmetGold" {
    declare const ItemHelmetGold = cn.nukkit.item.ItemHelmetGold;
}

declare namespace cn.nukkit.item {
    declare class ItemBow extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public getEnchantAbility(): int
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean
        public onRelease(player: cn.nukkit.Player, ticksUsed: int): boolean
        static lambda$onClickAir$0(inv: cn.nukkit.inventory.BaseInventory): boolean

    }
}

declare module "cn.nukkit.item.ItemBow" {
    declare const ItemBow = cn.nukkit.item.ItemBow;
}

declare namespace cn.nukkit.item {
    declare class ItemLeggingsChain extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isLeggings(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemLeggingsChain" {
    declare const ItemLeggingsChain = cn.nukkit.item.ItemLeggingsChain;
}

declare namespace cn.nukkit.item {
    declare class ItemChestplateIron extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isChestplate(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemChestplateIron" {
    declare const ItemChestplateIron = cn.nukkit.item.ItemChestplateIron;
}

declare namespace cn.nukkit.item {
    declare class ItemPrismarineCrystals extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemPrismarineCrystals" {
    declare const ItemPrismarineCrystals = cn.nukkit.item.ItemPrismarineCrystals;
}

declare namespace cn.nukkit.item {
    declare class ItemAxeStone extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isAxe(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemAxeStone" {
    declare const ItemAxeStone = cn.nukkit.item.ItemAxeStone;
}

declare namespace cn.nukkit.item {
    declare class ItemBanner extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public setDamage(meta: int): void
        updateName(): void
        public getMaxStackSize(): int
        public getBaseColor(): int
        public setBaseColor(color: cn.nukkit.utils.DyeColor): void
        public getBaseDyeColor(): cn.nukkit.utils.DyeColor
        public getType(): int
        public setType(type: int): void
        public addPattern(pattern: cn.nukkit.utils.BannerPattern): void
        public getPattern(index: int): cn.nukkit.utils.BannerPattern
        public removePattern(index: int): void
        public getPatternsSize(): int
        public hasPattern(): boolean
        public correctNBT(): void

    }
}

declare module "cn.nukkit.item.ItemBanner" {
    declare const ItemBanner = cn.nukkit.item.ItemBanner;
}

declare namespace cn.nukkit.item {
    declare class ItemPotatoPoisonous extends cn.nukkit.item.ItemPotato {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemPotatoPoisonous" {
    declare const ItemPotatoPoisonous = cn.nukkit.item.ItemPotatoPoisonous;
}

declare namespace cn.nukkit.item {
    declare class ItemFlintSteel extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public canBeActivated(): boolean
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean
        damageItem(player: cn.nukkit.Player, block: cn.nukkit.block.Block): void
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemFlintSteel" {
    declare const ItemFlintSteel = cn.nukkit.item.ItemFlintSteel;
}

declare namespace cn.nukkit.item {
    declare class ItemRecordPigstep extends cn.nukkit.item.ItemRecord {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getSoundId(): string

    }
}

declare module "cn.nukkit.item.ItemRecordPigstep" {
    declare const ItemRecordPigstep = cn.nukkit.item.ItemRecordPigstep;
}

declare namespace cn.nukkit.item {
    declare class ItemScrapNetherite extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public isLavaResistant(): boolean

    }
}

declare module "cn.nukkit.item.ItemScrapNetherite" {
    declare const ItemScrapNetherite = cn.nukkit.item.ItemScrapNetherite;
}

declare namespace cn.nukkit.item {
    declare class ItemSuspiciousStew extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemSuspiciousStew" {
    declare const ItemSuspiciousStew = cn.nukkit.item.ItemSuspiciousStew;
}

declare namespace cn.nukkit.item {
    declare class ItemArrow extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public setDamage(meta: int): void
        updateName(): void
        public getTippedArrowPotion(): cn.nukkit.potion.Potion
        static GENERIC_NAME: string

    }
}

declare module "cn.nukkit.item.ItemArrow" {
    declare const ItemArrow = cn.nukkit.item.ItemArrow;
}

declare namespace cn.nukkit.item {
    declare class ItemClock extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemClock" {
    declare const ItemClock = cn.nukkit.item.ItemClock;
}

declare namespace cn.nukkit.item {
    declare class ItemHelmetNetherite extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isHelmet(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int
        public getToughness(): int
        public isLavaResistant(): boolean

    }
}

declare module "cn.nukkit.item.ItemHelmetNetherite" {
    declare const ItemHelmetNetherite = cn.nukkit.item.ItemHelmetNetherite;
}

declare namespace cn.nukkit.item {
    declare class Item$ItemLockMode extends java.lang.Enum {
        public static values(): cn.nukkit.item.Item$ItemLockMode[]
        public static valueOf(name: string): cn.nukkit.item.Item$ItemLockMode
        constructor(): void
        static $values(): cn.nukkit.item.Item$ItemLockMode[]
        public static NONE: cn.nukkit.item.Item$ItemLockMode
        public static LOCK_IN_SLOT: cn.nukkit.item.Item$ItemLockMode
        public static LOCK_IN_INVENTORY: cn.nukkit.item.Item$ItemLockMode
        static $VALUES: cn.nukkit.item.Item$ItemLockMode[]

    }
}

declare module "cn.nukkit.item.Item$ItemLockMode" {
    declare const Item$ItemLockMode = cn.nukkit.item.Item$ItemLockMode;
}

declare namespace cn.nukkit.item {
    declare class ItemSpiderEye extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemSpiderEye" {
    declare const ItemSpiderEye = cn.nukkit.item.ItemSpiderEye;
}

declare namespace cn.nukkit.item {
    declare class ItemCarrotOnAStick extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public getMaxStackSize(): int
        public noDamageOnAttack(): boolean
        public noDamageOnBreak(): boolean

    }
}

declare module "cn.nukkit.item.ItemCarrotOnAStick" {
    declare const ItemCarrotOnAStick = cn.nukkit.item.ItemCarrotOnAStick;
}

declare namespace cn.nukkit.item {
    declare class PNAlphaItemID extends java.lang.Enum {
        public static values(): cn.nukkit.item.PNAlphaItemID[]
        public static valueOf(name: string): cn.nukkit.item.PNAlphaItemID
        public static getBadAlphaId(id: int): cn.nukkit.item.PNAlphaItemID
        public getBadItemId(): int
        public getMinecraftItemId(): cn.nukkit.item.MinecraftItemID
        constructor(var0: int, var1: cn.nukkit.item.MinecraftItemID): void
        static $values(): cn.nukkit.item.PNAlphaItemID[]
        public static COD_BUCKET: cn.nukkit.item.PNAlphaItemID
        public static GHAST_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static FLOWER_BANNER_PATTERN: cn.nukkit.item.PNAlphaItemID
        public static ZOGLIN_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static BLUE_DYE: cn.nukkit.item.PNAlphaItemID
        public static SKULL_BANNER_PATTERN: cn.nukkit.item.PNAlphaItemID
        public static ENDERMITE_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static POLAR_BEAR_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static WHITE_DYE: cn.nukkit.item.PNAlphaItemID
        public static TROPICAL_FISH_BUCKET: cn.nukkit.item.PNAlphaItemID
        public static CYAN_DYE: cn.nukkit.item.PNAlphaItemID
        public static LIGHT_BLUE_DYE: cn.nukkit.item.PNAlphaItemID
        public static LIME_DYE: cn.nukkit.item.PNAlphaItemID
        public static ZOMBIE_VILLAGER_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static STRAY_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static GREEN_DYE: cn.nukkit.item.PNAlphaItemID
        public static EVOKER_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static WITHER_SKELETON_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static SALMON_BUCKET: cn.nukkit.item.PNAlphaItemID
        public static JUNGLE_BOAT: cn.nukkit.item.PNAlphaItemID
        public static BLACK_DYE: cn.nukkit.item.PNAlphaItemID
        public static MAGMA_CUBE_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static TROPICAL_FISH_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static VEX_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static FIELD_MASONED_BANNER_PATTERN: cn.nukkit.item.PNAlphaItemID
        public static WANDERING_TRADER_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static BROWN_DYE: cn.nukkit.item.PNAlphaItemID
        public static PANDA_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static SILVERFISH_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static OCELOT_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static LAVA_BUCKET: cn.nukkit.item.PNAlphaItemID
        public static SKELETON_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static VILLAGER_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static ELDER_GUARDIAN_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static ACACIA_BOAT: cn.nukkit.item.PNAlphaItemID
        public static OAK_BOAT: cn.nukkit.item.PNAlphaItemID
        public static PHANTOM_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static HOGLIN_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static DARK_OAK_BOAT: cn.nukkit.item.PNAlphaItemID
        public static HUSK_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static BLAZE_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static BORDURE_INDENTED_BANNER_PATTERN: cn.nukkit.item.PNAlphaItemID
        public static MULE_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static CREEPER_BANNER_PATTERN: cn.nukkit.item.PNAlphaItemID
        public static ZOMBIE_HORSE_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static BEE_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static COD_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static LLAMA_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static FOX_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static PIGLIN_BRUTE_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static PIG_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static COW_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static NPC_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static SQUID_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static MAGENTA_DYE: cn.nukkit.item.PNAlphaItemID
        public static RED_DYE: cn.nukkit.item.PNAlphaItemID
        public static WITCH_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static INK_SAC: cn.nukkit.item.PNAlphaItemID
        public static ORANGE_DYE: cn.nukkit.item.PNAlphaItemID
        public static PILLAGER_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static CAVE_SPIDER_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static BONE_MEAL: cn.nukkit.item.PNAlphaItemID
        public static PUFFERFISH_BUCKET: cn.nukkit.item.PNAlphaItemID
        public static BAT_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static SPRUCE_BOAT: cn.nukkit.item.PNAlphaItemID
        public static SPIDER_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static PIGLIN_BANNER_PATTERN: cn.nukkit.item.PNAlphaItemID
        public static RABBIT_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static MOJANG_BANNER_PATTERN: cn.nukkit.item.PNAlphaItemID
        public static PIGLIN_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static TURTLE_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static MOOSHROOM_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static PUFFERFISH_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static PARROT_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static ZOMBIE_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static WOLF_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static GRAY_DYE: cn.nukkit.item.PNAlphaItemID
        public static COCOA_BEANS: cn.nukkit.item.PNAlphaItemID
        public static SKELETON_HORSE_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static SHEEP_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static SLIME_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static VINDICATOR_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static DROWNED_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static MILK_BUCKET: cn.nukkit.item.PNAlphaItemID
        public static DOLPHIN_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static DONKEY_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static PURPLE_DYE: cn.nukkit.item.PNAlphaItemID
        public static BIRCH_BOAT: cn.nukkit.item.PNAlphaItemID
        public static ENDERMAN_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static CHICKEN_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static SHULKER_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static STRIDER_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static ZOMBIE_PIGMAN_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static YELLOW_DYE: cn.nukkit.item.PNAlphaItemID
        public static CAT_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static GUARDIAN_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static PINK_DYE: cn.nukkit.item.PNAlphaItemID
        public static SALMON_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static CREEPER_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static HORSE_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static LAPIS_LAZULI: cn.nukkit.item.PNAlphaItemID
        public static RAVAGER_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        public static WATER_BUCKET: cn.nukkit.item.PNAlphaItemID
        public static LIGHT_GRAY_DYE: cn.nukkit.item.PNAlphaItemID
        public static CHARCOAL: cn.nukkit.item.PNAlphaItemID
        public static AGENT_SPAWN_EGG: cn.nukkit.item.PNAlphaItemID
        badItemId: int
        minecraftItemId: cn.nukkit.item.MinecraftItemID
        static byId: it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.item.PNAlphaItemID>
        static $VALUES: cn.nukkit.item.PNAlphaItemID[]

    }
}

declare module "cn.nukkit.item.PNAlphaItemID" {
    declare const PNAlphaItemID = cn.nukkit.item.PNAlphaItemID;
}

declare namespace cn.nukkit.item {
    declare class ProjectileItem extends cn.nukkit.item.Item {
        public constructor(id: int, meta: int, count: int, name: string): void
        public getProjectileEntityType(): string
        public getThrowForce(): float
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean
        addThrowSound(player: cn.nukkit.Player): void
        correctProjectile(player: cn.nukkit.Player, projectile: cn.nukkit.entity.Entity): cn.nukkit.entity.Entity
        correctNBT(nbt: cn.nukkit.nbt.tag.CompoundTag): void

    }
}

declare module "cn.nukkit.item.ProjectileItem" {
    declare const ProjectileItem = cn.nukkit.item.ProjectileItem;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentSwiftSneak extends cn.nukkit.item.enchantment.Enchantment {
        constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxLevel(): int

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentSwiftSneak" {
    declare const EnchantmentSwiftSneak = cn.nukkit.item.enchantment.EnchantmentSwiftSneak;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentEntry extends java.lang.Object {
        public constructor(enchantments: cn.nukkit.item.enchantment.Enchantment[], cost: int, randomName: string): void
        public getEnchantments(): cn.nukkit.item.enchantment.Enchantment[]
        public getCost(): int
        public getRandomName(): string
        enchantments: cn.nukkit.item.enchantment.Enchantment[]
        cost: int
        randomName: string

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentEntry" {
    declare const EnchantmentEntry = cn.nukkit.item.enchantment.EnchantmentEntry;
}

declare namespace cn.nukkit.item.enchantment.trident {
    declare class EnchantmentTridentChanneling extends cn.nukkit.item.enchantment.trident.EnchantmentTrident {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int

    }
}

declare module "cn.nukkit.item.enchantment.trident.EnchantmentTridentChanneling" {
    declare const EnchantmentTridentChanneling = cn.nukkit.item.enchantment.trident.EnchantmentTridentChanneling;
}

declare namespace cn.nukkit.item.enchantment.trident {
    declare class EnchantmentTrident extends cn.nukkit.item.enchantment.Enchantment {
        constructor(id: int, name: string, weight: int): void
        constructor(id: int, name: string, rarity: cn.nukkit.item.enchantment.Enchantment$Rarity): void
        public getMaxEnchantAbility(level: int): int

    }
}

declare module "cn.nukkit.item.enchantment.trident.EnchantmentTrident" {
    declare const EnchantmentTrident = cn.nukkit.item.enchantment.trident.EnchantmentTrident;
}

declare namespace cn.nukkit.item.enchantment.trident {
    declare class EnchantmentTridentImpaling extends cn.nukkit.item.enchantment.trident.EnchantmentTrident {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getMaxLevel(): int
        public getDamageBonus(entity: cn.nukkit.entity.Entity): double

    }
}

declare module "cn.nukkit.item.enchantment.trident.EnchantmentTridentImpaling" {
    declare const EnchantmentTridentImpaling = cn.nukkit.item.enchantment.trident.EnchantmentTridentImpaling;
}

declare namespace cn.nukkit.item.enchantment.trident {
    declare class EnchantmentTridentLoyalty extends cn.nukkit.item.enchantment.trident.EnchantmentTrident {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxLevel(): int

    }
}

declare module "cn.nukkit.item.enchantment.trident.EnchantmentTridentLoyalty" {
    declare const EnchantmentTridentLoyalty = cn.nukkit.item.enchantment.trident.EnchantmentTridentLoyalty;
}

declare namespace cn.nukkit.item.enchantment.trident {
    declare class EnchantmentTridentRiptide extends cn.nukkit.item.enchantment.trident.EnchantmentTrident {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxLevel(): int
        public checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean

    }
}

declare module "cn.nukkit.item.enchantment.trident.EnchantmentTridentRiptide" {
    declare const EnchantmentTridentRiptide = cn.nukkit.item.enchantment.trident.EnchantmentTridentRiptide;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentType extends java.lang.Enum {
        public static values(): cn.nukkit.item.enchantment.EnchantmentType[]
        public static valueOf(name: string): cn.nukkit.item.enchantment.EnchantmentType
        constructor(): void
        public canEnchantItem(item: cn.nukkit.item.Item): boolean
        static $values(): cn.nukkit.item.enchantment.EnchantmentType[]
        public static ALL: cn.nukkit.item.enchantment.EnchantmentType
        public static ARMOR: cn.nukkit.item.enchantment.EnchantmentType
        public static ARMOR_HEAD: cn.nukkit.item.enchantment.EnchantmentType
        public static ARMOR_TORSO: cn.nukkit.item.enchantment.EnchantmentType
        public static ARMOR_LEGS: cn.nukkit.item.enchantment.EnchantmentType
        public static ARMOR_FEET: cn.nukkit.item.enchantment.EnchantmentType
        public static SWORD: cn.nukkit.item.enchantment.EnchantmentType
        public static DIGGER: cn.nukkit.item.enchantment.EnchantmentType
        public static FISHING_ROD: cn.nukkit.item.enchantment.EnchantmentType
        public static BREAKABLE: cn.nukkit.item.enchantment.EnchantmentType
        public static BOW: cn.nukkit.item.enchantment.EnchantmentType
        public static WEARABLE: cn.nukkit.item.enchantment.EnchantmentType
        public static TRIDENT: cn.nukkit.item.enchantment.EnchantmentType
        public static CROSSBOW: cn.nukkit.item.enchantment.EnchantmentType
        static $VALUES: cn.nukkit.item.enchantment.EnchantmentType[]

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentType" {
    declare const EnchantmentType = cn.nukkit.item.enchantment.EnchantmentType;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentWaterWalker extends cn.nukkit.item.enchantment.Enchantment {
        constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getMaxLevel(): int

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentWaterWalker" {
    declare const EnchantmentWaterWalker = cn.nukkit.item.enchantment.EnchantmentWaterWalker;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentLure extends cn.nukkit.item.enchantment.Enchantment {
        constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getMaxLevel(): int

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentLure" {
    declare const EnchantmentLure = cn.nukkit.item.enchantment.EnchantmentLure;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentList extends java.lang.Object {
        public constructor(size: int): void
        public setSlot(slot: int, entry: cn.nukkit.item.enchantment.EnchantmentEntry): cn.nukkit.item.enchantment.EnchantmentList
        public getSlot(slot: int): cn.nukkit.item.enchantment.EnchantmentEntry
        public getSize(): int
        enchantments: cn.nukkit.item.enchantment.EnchantmentEntry[]

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentList" {
    declare const EnchantmentList = cn.nukkit.item.enchantment.EnchantmentList;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentType$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$item$enchantment$EnchantmentType: int[]

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentType$1" {
    declare const EnchantmentType$1 = cn.nukkit.item.enchantment.EnchantmentType$1;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentSoulSpeed extends cn.nukkit.item.enchantment.Enchantment {
        constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getMaxLevel(): int

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentSoulSpeed" {
    declare const EnchantmentSoulSpeed = cn.nukkit.item.enchantment.EnchantmentSoulSpeed;
}

declare namespace cn.nukkit.item.enchantment.protection {
    declare class EnchantmentProtectionProjectile extends cn.nukkit.item.enchantment.protection.EnchantmentProtection {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getTypeModifier(): double
        public getProtectionFactor(e: cn.nukkit.event.entity.EntityDamageEvent): float

    }
}

declare module "cn.nukkit.item.enchantment.protection.EnchantmentProtectionProjectile" {
    declare const EnchantmentProtectionProjectile = cn.nukkit.item.enchantment.protection.EnchantmentProtectionProjectile;
}

declare namespace cn.nukkit.item.enchantment.protection {
    declare class EnchantmentProtectionExplosion extends cn.nukkit.item.enchantment.protection.EnchantmentProtection {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getTypeModifier(): double
        public getProtectionFactor(e: cn.nukkit.event.entity.EntityDamageEvent): float

    }
}

declare module "cn.nukkit.item.enchantment.protection.EnchantmentProtectionExplosion" {
    declare const EnchantmentProtectionExplosion = cn.nukkit.item.enchantment.protection.EnchantmentProtectionExplosion;
}

declare namespace cn.nukkit.item.enchantment.protection {
    declare class EnchantmentProtectionAll extends cn.nukkit.item.enchantment.protection.EnchantmentProtection {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getTypeModifier(): double
        public getProtectionFactor(e: cn.nukkit.event.entity.EntityDamageEvent): float

    }
}

declare module "cn.nukkit.item.enchantment.protection.EnchantmentProtectionAll" {
    declare const EnchantmentProtectionAll = cn.nukkit.item.enchantment.protection.EnchantmentProtectionAll;
}

declare namespace cn.nukkit.item.enchantment.protection {
    declare class EnchantmentProtection extends cn.nukkit.item.enchantment.Enchantment {
        constructor(id: int, name: string, weight: int, type: cn.nukkit.item.enchantment.protection.EnchantmentProtection$TYPE): void
        constructor(id: int, name: string, rarity: cn.nukkit.item.enchantment.Enchantment$Rarity, type: cn.nukkit.item.enchantment.protection.EnchantmentProtection$TYPE): void
        public canEnchant(item: cn.nukkit.item.Item): boolean
        public checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean
        public getMaxLevel(): int
        public getName(): string
        public getTypeModifier(): double
        public isMajor(): boolean
        protectionType: cn.nukkit.item.enchantment.protection.EnchantmentProtection$TYPE

    }
}

declare module "cn.nukkit.item.enchantment.protection.EnchantmentProtection" {
    declare const EnchantmentProtection = cn.nukkit.item.enchantment.protection.EnchantmentProtection;
}

declare namespace cn.nukkit.item.enchantment.protection {
    declare class EnchantmentProtectionFire extends cn.nukkit.item.enchantment.protection.EnchantmentProtection {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getTypeModifier(): double
        public getProtectionFactor(e: cn.nukkit.event.entity.EntityDamageEvent): float

    }
}

declare module "cn.nukkit.item.enchantment.protection.EnchantmentProtectionFire" {
    declare const EnchantmentProtectionFire = cn.nukkit.item.enchantment.protection.EnchantmentProtectionFire;
}

declare namespace cn.nukkit.item.enchantment.protection {
    declare class EnchantmentProtectionFall extends cn.nukkit.item.enchantment.protection.EnchantmentProtection {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getTypeModifier(): double
        public getProtectionFactor(e: cn.nukkit.event.entity.EntityDamageEvent): float

    }
}

declare module "cn.nukkit.item.enchantment.protection.EnchantmentProtectionFall" {
    declare const EnchantmentProtectionFall = cn.nukkit.item.enchantment.protection.EnchantmentProtectionFall;
}

declare namespace cn.nukkit.item.enchantment.protection {
    declare class EnchantmentProtection$TYPE extends java.lang.Enum {
        public static values(): cn.nukkit.item.enchantment.protection.EnchantmentProtection$TYPE[]
        public static valueOf(name: string): cn.nukkit.item.enchantment.protection.EnchantmentProtection$TYPE
        constructor(): void
        static $values(): cn.nukkit.item.enchantment.protection.EnchantmentProtection$TYPE[]
        public static ALL: cn.nukkit.item.enchantment.protection.EnchantmentProtection$TYPE
        public static FIRE: cn.nukkit.item.enchantment.protection.EnchantmentProtection$TYPE
        public static FALL: cn.nukkit.item.enchantment.protection.EnchantmentProtection$TYPE
        public static EXPLOSION: cn.nukkit.item.enchantment.protection.EnchantmentProtection$TYPE
        public static PROJECTILE: cn.nukkit.item.enchantment.protection.EnchantmentProtection$TYPE
        static $VALUES: cn.nukkit.item.enchantment.protection.EnchantmentProtection$TYPE[]

    }
}

declare module "cn.nukkit.item.enchantment.protection.EnchantmentProtection$TYPE" {
    declare const EnchantmentProtection$TYPE = cn.nukkit.item.enchantment.protection.EnchantmentProtection$TYPE;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentWaterWorker extends cn.nukkit.item.enchantment.Enchantment {
        constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentWaterWorker" {
    declare const EnchantmentWaterWorker = cn.nukkit.item.enchantment.EnchantmentWaterWorker;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentWaterBreath extends cn.nukkit.item.enchantment.Enchantment {
        constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getMaxLevel(): int

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentWaterBreath" {
    declare const EnchantmentWaterBreath = cn.nukkit.item.enchantment.EnchantmentWaterBreath;
}

declare namespace cn.nukkit.item.enchantment.sideeffect {
    declare interface SideEffect extends java.lang.Cloneable {
        public doPreHealthChange(entity: cn.nukkit.entity.Entity, source: cn.nukkit.event.entity.EntityDamageEvent, attacker: cn.nukkit.entity.Entity): void
        public doPostAttack(entity: cn.nukkit.entity.Entity, source: cn.nukkit.event.entity.EntityDamageEvent, attacker: cn.nukkit.entity.Entity): void
        public cloneSideEffect(): cn.nukkit.item.enchantment.sideeffect.SideEffect
        public static EMPTY_ARRAY: cn.nukkit.item.enchantment.sideeffect.SideEffect[]

    }
}

declare module "cn.nukkit.item.enchantment.sideeffect.SideEffect" {
    declare type SideEffect = cn.nukkit.item.enchantment.sideeffect.SideEffect;
}

declare namespace cn.nukkit.item.enchantment.sideeffect {
    declare class SideEffectCombust extends java.lang.Object implements cn.nukkit.item.enchantment.sideeffect.SideEffect {
        public constructor(duration: int): void
        public doPreHealthChange(entity: cn.nukkit.entity.Entity, event: cn.nukkit.event.entity.EntityDamageEvent, attacker: cn.nukkit.entity.Entity): void
        public getDuration(): int
        public setDuration(duration: int): void
        public clone(): cn.nukkit.item.enchantment.sideeffect.SideEffect
        public cloneSideEffect(): cn.nukkit.item.enchantment.sideeffect.SideEffect
        public clone(): java.lang.Object
        duration: int

    }
}

declare module "cn.nukkit.item.enchantment.sideeffect.SideEffectCombust" {
    declare const SideEffectCombust = cn.nukkit.item.enchantment.sideeffect.SideEffectCombust;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentMending extends cn.nukkit.item.enchantment.Enchantment {
        constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentMending" {
    declare const EnchantmentMending = cn.nukkit.item.enchantment.EnchantmentMending;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentThorns extends cn.nukkit.item.enchantment.Enchantment {
        constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getMaxLevel(): int
        public doPostAttack(attacker: cn.nukkit.entity.Entity, entity: cn.nukkit.entity.Entity): void
        public canEnchant(item: cn.nukkit.item.Item): boolean
        public isItemAcceptable(item: cn.nukkit.item.Item): boolean
        static shouldHit(random: java.util.concurrent.ThreadLocalRandom, level: int): boolean
        static getDamage(random: java.util.concurrent.ThreadLocalRandom, level: int): int

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentThorns" {
    declare const EnchantmentThorns = cn.nukkit.item.enchantment.EnchantmentThorns;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentVanishingCurse extends cn.nukkit.item.enchantment.Enchantment {
        constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public canEnchant(item: cn.nukkit.item.Item): boolean

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentVanishingCurse" {
    declare const EnchantmentVanishingCurse = cn.nukkit.item.enchantment.EnchantmentVanishingCurse;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentFireAspect extends cn.nukkit.item.enchantment.Enchantment {
        constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getMaxLevel(): int
        public doPostAttack(attacker: cn.nukkit.entity.Entity, entity: cn.nukkit.entity.Entity): void
        public getAttackSideEffects(attacker: cn.nukkit.entity.Entity, entity: cn.nukkit.entity.Entity): cn.nukkit.item.enchantment.sideeffect.SideEffect[]

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentFireAspect" {
    declare const EnchantmentFireAspect = cn.nukkit.item.enchantment.EnchantmentFireAspect;
}

declare namespace cn.nukkit.item.enchantment.crossbow {
    declare class EnchantmentCrossbowMultishot extends cn.nukkit.item.enchantment.crossbow.EnchantmentCrossbow {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxLevel(): int
        public checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean

    }
}

declare module "cn.nukkit.item.enchantment.crossbow.EnchantmentCrossbowMultishot" {
    declare const EnchantmentCrossbowMultishot = cn.nukkit.item.enchantment.crossbow.EnchantmentCrossbowMultishot;
}

declare namespace cn.nukkit.item.enchantment.crossbow {
    declare class EnchantmentCrossbowQuickCharge extends cn.nukkit.item.enchantment.crossbow.EnchantmentCrossbow {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxLevel(): int

    }
}

declare module "cn.nukkit.item.enchantment.crossbow.EnchantmentCrossbowQuickCharge" {
    declare const EnchantmentCrossbowQuickCharge = cn.nukkit.item.enchantment.crossbow.EnchantmentCrossbowQuickCharge;
}

declare namespace cn.nukkit.item.enchantment.crossbow {
    declare class EnchantmentCrossbow extends cn.nukkit.item.enchantment.Enchantment {
        constructor(id: int, name: string, rarity: cn.nukkit.item.enchantment.Enchantment$Rarity): void
        public getMaxEnchantAbility(level: int): int

    }
}

declare module "cn.nukkit.item.enchantment.crossbow.EnchantmentCrossbow" {
    declare const EnchantmentCrossbow = cn.nukkit.item.enchantment.crossbow.EnchantmentCrossbow;
}

declare namespace cn.nukkit.item.enchantment.crossbow {
    declare class EnchantmentCrossbowPiercing extends cn.nukkit.item.enchantment.crossbow.EnchantmentCrossbow {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxLevel(): int
        public checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean

    }
}

declare module "cn.nukkit.item.enchantment.crossbow.EnchantmentCrossbowPiercing" {
    declare const EnchantmentCrossbowPiercing = cn.nukkit.item.enchantment.crossbow.EnchantmentCrossbowPiercing;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentDurability extends cn.nukkit.item.enchantment.Enchantment {
        constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getMaxLevel(): int
        public canEnchant(item: cn.nukkit.item.Item): boolean
        public static negateDamage(item: cn.nukkit.item.Item, level: int, random: java.util.Random): boolean
        public isItemAcceptable(item: cn.nukkit.item.Item): boolean

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentDurability" {
    declare const EnchantmentDurability = cn.nukkit.item.enchantment.EnchantmentDurability;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentBindingCurse extends cn.nukkit.item.enchantment.Enchantment {
        constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentBindingCurse" {
    declare const EnchantmentBindingCurse = cn.nukkit.item.enchantment.EnchantmentBindingCurse;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentFrostWalker extends cn.nukkit.item.enchantment.Enchantment {
        constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getMaxLevel(): int
        checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentFrostWalker" {
    declare const EnchantmentFrostWalker = cn.nukkit.item.enchantment.EnchantmentFrostWalker;
}

declare namespace cn.nukkit.item.enchantment.damage {
    declare class EnchantmentDamage$TYPE extends java.lang.Enum {
        public static values(): cn.nukkit.item.enchantment.damage.EnchantmentDamage$TYPE[]
        public static valueOf(name: string): cn.nukkit.item.enchantment.damage.EnchantmentDamage$TYPE
        constructor(): void
        static $values(): cn.nukkit.item.enchantment.damage.EnchantmentDamage$TYPE[]
        public static ALL: cn.nukkit.item.enchantment.damage.EnchantmentDamage$TYPE
        public static SMITE: cn.nukkit.item.enchantment.damage.EnchantmentDamage$TYPE
        public static ARTHROPODS: cn.nukkit.item.enchantment.damage.EnchantmentDamage$TYPE
        static $VALUES: cn.nukkit.item.enchantment.damage.EnchantmentDamage$TYPE[]

    }
}

declare module "cn.nukkit.item.enchantment.damage.EnchantmentDamage$TYPE" {
    declare const EnchantmentDamage$TYPE = cn.nukkit.item.enchantment.damage.EnchantmentDamage$TYPE;
}

declare namespace cn.nukkit.item.enchantment.damage {
    declare class EnchantmentDamageArthropods extends cn.nukkit.item.enchantment.damage.EnchantmentDamage {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getDamageBonus(entity: cn.nukkit.entity.Entity): double
        public doPostAttack(attacker: cn.nukkit.entity.Entity, entity: cn.nukkit.entity.Entity): void

    }
}

declare module "cn.nukkit.item.enchantment.damage.EnchantmentDamageArthropods" {
    declare const EnchantmentDamageArthropods = cn.nukkit.item.enchantment.damage.EnchantmentDamageArthropods;
}

declare namespace cn.nukkit.item.enchantment.damage {
    declare class EnchantmentDamageSmite extends cn.nukkit.item.enchantment.damage.EnchantmentDamage {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getDamageBonus(entity: cn.nukkit.entity.Entity): double

    }
}

declare module "cn.nukkit.item.enchantment.damage.EnchantmentDamageSmite" {
    declare const EnchantmentDamageSmite = cn.nukkit.item.enchantment.damage.EnchantmentDamageSmite;
}

declare namespace cn.nukkit.item.enchantment.damage {
    declare class EnchantmentDamageAll extends cn.nukkit.item.enchantment.damage.EnchantmentDamage {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getMaxEnchantableLevel(): int
        public getDamageBonus(entity: cn.nukkit.entity.Entity): double

    }
}

declare module "cn.nukkit.item.enchantment.damage.EnchantmentDamageAll" {
    declare const EnchantmentDamageAll = cn.nukkit.item.enchantment.damage.EnchantmentDamageAll;
}

declare namespace cn.nukkit.item.enchantment.damage {
    declare class EnchantmentDamage extends cn.nukkit.item.enchantment.Enchantment {
        constructor(id: int, name: string, weight: int, type: cn.nukkit.item.enchantment.damage.EnchantmentDamage$TYPE): void
        constructor(id: int, name: string, rarity: cn.nukkit.item.enchantment.Enchantment$Rarity, type: cn.nukkit.item.enchantment.damage.EnchantmentDamage$TYPE): void
        public checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean
        public canEnchant(item: cn.nukkit.item.Item): boolean
        public getMaxLevel(): int
        public getName(): string
        public isMajor(): boolean
        public isItemAcceptable(item: cn.nukkit.item.Item): boolean
        damageType: cn.nukkit.item.enchantment.damage.EnchantmentDamage$TYPE

    }
}

declare module "cn.nukkit.item.enchantment.damage.EnchantmentDamage" {
    declare const EnchantmentDamage = cn.nukkit.item.enchantment.damage.EnchantmentDamage;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentEfficiency extends cn.nukkit.item.enchantment.Enchantment {
        constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getMaxLevel(): int
        public canEnchant(item: cn.nukkit.item.Item): boolean
        public isItemAcceptable(item: cn.nukkit.item.Item): boolean

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentEfficiency" {
    declare const EnchantmentEfficiency = cn.nukkit.item.enchantment.EnchantmentEfficiency;
}

declare namespace cn.nukkit.item.enchantment {
    declare class Enchantment$UnknownEnchantment extends cn.nukkit.item.enchantment.Enchantment {
        constructor(id: int): void
        clone(): java.lang.Object

    }
}

declare module "cn.nukkit.item.enchantment.Enchantment$UnknownEnchantment" {
    declare const Enchantment$UnknownEnchantment = cn.nukkit.item.enchantment.Enchantment$UnknownEnchantment;
}

declare namespace cn.nukkit.item.enchantment.loot {
    declare class EnchantmentLootFishing extends cn.nukkit.item.enchantment.loot.EnchantmentLoot {
        public constructor(): void

    }
}

declare module "cn.nukkit.item.enchantment.loot.EnchantmentLootFishing" {
    declare const EnchantmentLootFishing = cn.nukkit.item.enchantment.loot.EnchantmentLootFishing;
}

declare namespace cn.nukkit.item.enchantment.loot {
    declare class EnchantmentLootWeapon extends cn.nukkit.item.enchantment.loot.EnchantmentLoot {
        public constructor(): void

    }
}

declare module "cn.nukkit.item.enchantment.loot.EnchantmentLootWeapon" {
    declare const EnchantmentLootWeapon = cn.nukkit.item.enchantment.loot.EnchantmentLootWeapon;
}

declare namespace cn.nukkit.item.enchantment.loot {
    declare class EnchantmentLoot extends cn.nukkit.item.enchantment.Enchantment {
        constructor(id: int, name: string, weight: int, type: cn.nukkit.item.enchantment.EnchantmentType): void
        constructor(id: int, name: string, rarity: cn.nukkit.item.enchantment.Enchantment$Rarity, type: cn.nukkit.item.enchantment.EnchantmentType): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getMaxLevel(): int
        public checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean

    }
}

declare module "cn.nukkit.item.enchantment.loot.EnchantmentLoot" {
    declare const EnchantmentLoot = cn.nukkit.item.enchantment.loot.EnchantmentLoot;
}

declare namespace cn.nukkit.item.enchantment.loot {
    declare class EnchantmentLootDigging extends cn.nukkit.item.enchantment.loot.EnchantmentLoot {
        public constructor(): void

    }
}

declare module "cn.nukkit.item.enchantment.loot.EnchantmentLootDigging" {
    declare const EnchantmentLootDigging = cn.nukkit.item.enchantment.loot.EnchantmentLootDigging;
}

declare namespace cn.nukkit.item.enchantment {
    declare class Enchantment extends java.lang.Object implements java.lang.Cloneable {
        public static init(): void
        public static get(id: int): cn.nukkit.item.enchantment.Enchantment
        public static getEnchantment(id: int): cn.nukkit.item.enchantment.Enchantment
        public static getEnchantment(name: string): cn.nukkit.item.enchantment.Enchantment
        public static getEnchantments(): cn.nukkit.item.enchantment.Enchantment[]
        public static getRegisteredEnchantments(): java.util.Collection<cn.nukkit.item.enchantment.Enchantment>
        public static getEnchantmentName2IDMap(): java.util.Map<string, int>
        constructor(id: int, name: string, weight: int, type: cn.nukkit.item.enchantment.EnchantmentType): void
        constructor(id: int, name: string, rarity: cn.nukkit.item.enchantment.Enchantment$Rarity, type: cn.nukkit.item.enchantment.EnchantmentType): void
        public getLevel(): int
        public setLevel(level: int): cn.nukkit.item.enchantment.Enchantment
        public setLevel(level: int, safe: boolean): cn.nukkit.item.enchantment.Enchantment
        public getId(): int
        public getRarity(): cn.nukkit.item.enchantment.Enchantment$Rarity
        public getWeight(): int
        public getMinLevel(): int
        public getMaxLevel(): int
        public getMaxEnchantableLevel(): int
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getProtectionFactor(event: cn.nukkit.event.entity.EntityDamageEvent): float
        public getDamageBonus(entity: cn.nukkit.entity.Entity): double
        public doPostAttack(attacker: cn.nukkit.entity.Entity, entity: cn.nukkit.entity.Entity): void
        public doAttack(attacker: cn.nukkit.entity.Entity, entity: cn.nukkit.entity.Entity): void
        public doPostHurt(attacker: cn.nukkit.entity.Entity, entity: cn.nukkit.entity.Entity): void
        public isCompatibleWith(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean
        checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean
        public getName(): string
        public getOriginalName(): string
        public canEnchant(item: cn.nukkit.item.Item): boolean
        public isMajor(): boolean
        public getAttackSideEffects(attacker: cn.nukkit.entity.Entity, entity: cn.nukkit.entity.Entity): cn.nukkit.item.enchantment.sideeffect.SideEffect[]
        clone(): cn.nukkit.item.enchantment.Enchantment
        public isItemAcceptable(item: cn.nukkit.item.Item): boolean
        public static getRandomName(): string
        clone(): java.lang.Object
        public static EMPTY_ARRAY: cn.nukkit.item.enchantment.Enchantment[]
        static enchantments: cn.nukkit.item.enchantment.Enchantment[]
        static enchantmentName2IDMap: java.util.Map<string, int>
        public static ID_PROTECTION_ALL: int
        public static NAME_PROTECTION_ALL: string
        public static ID_PROTECTION_FIRE: int
        public static NAME_PROTECTION_FIRE: string
        public static ID_PROTECTION_FALL: int
        public static NAME_PROTECTION_FALL: string
        public static ID_PROTECTION_EXPLOSION: int
        public static NAME_PROTECTION_EXPLOSION: string
        public static ID_PROTECTION_PROJECTILE: int
        public static NAME_PROTECTION_PROJECTILE: string
        public static ID_THORNS: int
        public static NAME_THORNS: string
        public static ID_WATER_BREATHING: int
        public static NAME_WATER_BREATHING: string
        public static ID_WATER_WALKER: int
        public static NAME_WATER_WALKER: string
        public static ID_WATER_WORKER: int
        public static NAME_WATER_WORKER: string
        public static ID_DAMAGE_ALL: int
        public static NAME_DAMAGE_ALL: string
        public static ID_DAMAGE_SMITE: int
        public static NAME_DAMAGE_SMITE: string
        public static ID_DAMAGE_ARTHROPODS: int
        public static NAME_DAMAGE_ARTHROPODS: string
        public static ID_KNOCKBACK: int
        public static NAME_KNOCKBACK: string
        public static ID_FIRE_ASPECT: int
        public static NAME_FIRE_ASPECT: string
        public static ID_LOOTING: int
        public static NAME_LOOTING: string
        public static ID_EFFICIENCY: int
        public static NAME_EFFICIENCY: string
        public static ID_SILK_TOUCH: int
        public static NAME_SILK_TOUCH: string
        public static ID_DURABILITY: int
        public static NAME_DURABILITY: string
        public static ID_FORTUNE_DIGGING: int
        public static NAME_FORTUNE_DIGGING: string
        public static ID_BOW_POWER: int
        public static NAME_BOW_POWER: string
        public static ID_BOW_KNOCKBACK: int
        public static NAME_BOW_KNOCKBACK: string
        public static ID_BOW_FLAME: int
        public static NAME_BOW_FLAME: string
        public static ID_BOW_INFINITY: int
        public static NAME_BOW_INFINITY: string
        public static ID_FORTUNE_FISHING: int
        public static NAME_FORTUNE_FISHING: string
        public static ID_LURE: int
        public static NAME_LURE: string
        public static ID_FROST_WALKER: int
        public static NAME_FROST_WALKER: string
        public static ID_MENDING: int
        public static NAME_MENDING: string
        public static ID_BINDING_CURSE: int
        public static NAME_BINDING_CURSE: string
        public static ID_VANISHING_CURSE: int
        public static NAME_VANISHING_CURSE: string
        public static ID_TRIDENT_IMPALING: int
        public static NAME_TRIDENT_IMPALING: string
        public static ID_TRIDENT_RIPTIDE: int
        public static NAME_TRIDENT_RIPTIDE: string
        public static ID_TRIDENT_LOYALTY: int
        public static NAME_TRIDENT_LOYALTY: string
        public static ID_TRIDENT_CHANNELING: int
        public static NAME_TRIDENT_CHANNELING: string
        public static ID_CROSSBOW_MULTISHOT: int
        public static NAME_CROSSBOW_MULTISHOT: string
        public static ID_CROSSBOW_PIERCING: int
        public static NAME_CROSSBOW_PIERCING: string
        public static ID_CROSSBOW_QUICK_CHARGE: int
        public static NAME_CROSSBOW_QUICK_CHARGE: string
        public static ID_SOUL_SPEED: int
        public static NAME_SOUL_SPEED: string
        public static ID_SWIFT_SNEAK: int
        public static NAME_SWIFT_SNEAK: string
        public id: int
        rarity: cn.nukkit.item.enchantment.Enchantment$Rarity
        public type: cn.nukkit.item.enchantment.EnchantmentType
        level: int
        name: string
        public static words: string[]

    }
}

declare module "cn.nukkit.item.enchantment.Enchantment" {
    declare const Enchantment = cn.nukkit.item.enchantment.Enchantment;
}

declare namespace cn.nukkit.item.enchantment.bow {
    declare class EnchantmentBowPower extends cn.nukkit.item.enchantment.bow.EnchantmentBow {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getMaxLevel(): int

    }
}

declare module "cn.nukkit.item.enchantment.bow.EnchantmentBowPower" {
    declare const EnchantmentBowPower = cn.nukkit.item.enchantment.bow.EnchantmentBowPower;
}

declare namespace cn.nukkit.item.enchantment.bow {
    declare class EnchantmentBowInfinity extends cn.nukkit.item.enchantment.bow.EnchantmentBow {
        public constructor(): void
        checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int

    }
}

declare module "cn.nukkit.item.enchantment.bow.EnchantmentBowInfinity" {
    declare const EnchantmentBowInfinity = cn.nukkit.item.enchantment.bow.EnchantmentBowInfinity;
}

declare namespace cn.nukkit.item.enchantment.bow {
    declare class EnchantmentBowKnockback extends cn.nukkit.item.enchantment.bow.EnchantmentBow {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getMaxLevel(): int

    }
}

declare module "cn.nukkit.item.enchantment.bow.EnchantmentBowKnockback" {
    declare const EnchantmentBowKnockback = cn.nukkit.item.enchantment.bow.EnchantmentBowKnockback;
}

declare namespace cn.nukkit.item.enchantment.bow {
    declare class EnchantmentBowFlame extends cn.nukkit.item.enchantment.bow.EnchantmentBow {
        public constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int

    }
}

declare module "cn.nukkit.item.enchantment.bow.EnchantmentBowFlame" {
    declare const EnchantmentBowFlame = cn.nukkit.item.enchantment.bow.EnchantmentBowFlame;
}

declare namespace cn.nukkit.item.enchantment.bow {
    declare class EnchantmentBow extends cn.nukkit.item.enchantment.Enchantment {
        constructor(id: int, name: string, weight: int): void
        constructor(id: int, name: string, rarity: cn.nukkit.item.enchantment.Enchantment$Rarity): void

    }
}

declare module "cn.nukkit.item.enchantment.bow.EnchantmentBow" {
    declare const EnchantmentBow = cn.nukkit.item.enchantment.bow.EnchantmentBow;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentKnockback extends cn.nukkit.item.enchantment.Enchantment {
        constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public getMaxLevel(): int

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentKnockback" {
    declare const EnchantmentKnockback = cn.nukkit.item.enchantment.EnchantmentKnockback;
}

declare namespace cn.nukkit.item.enchantment {
    declare class EnchantmentSilkTouch extends cn.nukkit.item.enchantment.Enchantment {
        constructor(): void
        public getMinEnchantAbility(level: int): int
        public getMaxEnchantAbility(level: int): int
        public checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean
        public canEnchant(item: cn.nukkit.item.Item): boolean
        public isItemAcceptable(item: cn.nukkit.item.Item): boolean

    }
}

declare module "cn.nukkit.item.enchantment.EnchantmentSilkTouch" {
    declare const EnchantmentSilkTouch = cn.nukkit.item.enchantment.EnchantmentSilkTouch;
}

declare namespace cn.nukkit.item.enchantment {
    declare class Enchantment$Rarity extends java.lang.Enum {
        public static values(): cn.nukkit.item.enchantment.Enchantment$Rarity[]
        public static valueOf(name: string): cn.nukkit.item.enchantment.Enchantment$Rarity
        constructor(var0: int): void
        public getWeight(): int
        public static fromWeight(weight: int): cn.nukkit.item.enchantment.Enchantment$Rarity
        static $values(): cn.nukkit.item.enchantment.Enchantment$Rarity[]
        public static COMMON: cn.nukkit.item.enchantment.Enchantment$Rarity
        public static UNCOMMON: cn.nukkit.item.enchantment.Enchantment$Rarity
        public static RARE: cn.nukkit.item.enchantment.Enchantment$Rarity
        public static VERY_RARE: cn.nukkit.item.enchantment.Enchantment$Rarity
        weight: int
        static $VALUES: cn.nukkit.item.enchantment.Enchantment$Rarity[]

    }
}

declare module "cn.nukkit.item.enchantment.Enchantment$Rarity" {
    declare const Enchantment$Rarity = cn.nukkit.item.enchantment.Enchantment$Rarity;
}

declare namespace cn.nukkit.item {
    declare class ItemNuggetGold extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemNuggetGold" {
    declare const ItemNuggetGold = cn.nukkit.item.ItemNuggetGold;
}

declare namespace cn.nukkit.item {
    declare class ItemRawGold extends cn.nukkit.item.ItemRawMaterial {
        public constructor(): void

    }
}

declare module "cn.nukkit.item.ItemRawGold" {
    declare const ItemRawGold = cn.nukkit.item.ItemRawGold;
}

declare namespace cn.nukkit.item {
    declare class ItemEdible extends cn.nukkit.item.Item {
        public constructor(id: int, meta: int, count: int, name: string): void
        public constructor(id: int): void
        public constructor(id: int, meta: int): void
        public constructor(id: int, meta: int, count: int): void
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean
        public onUse(player: cn.nukkit.Player, ticksUsed: int): boolean

    }
}

declare module "cn.nukkit.item.ItemEdible" {
    declare const ItemEdible = cn.nukkit.item.ItemEdible;
}

declare namespace cn.nukkit.item {
    declare class ItemString extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemString" {
    declare const ItemString = cn.nukkit.item.ItemString;
}

declare namespace cn.nukkit.item {
    declare class ItemPhantomMembrane extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemPhantomMembrane" {
    declare const ItemPhantomMembrane = cn.nukkit.item.ItemPhantomMembrane;
}

declare namespace cn.nukkit.item {
    declare class ItemHoeIron extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isHoe(): boolean
        public getTier(): int

    }
}

declare module "cn.nukkit.item.ItemHoeIron" {
    declare const ItemHoeIron = cn.nukkit.item.ItemHoeIron;
}

declare namespace cn.nukkit.item {
    declare class ItemPotionLingering extends cn.nukkit.item.ProjectileItem {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public setDamage(meta: int): void
        updateName(): void
        public getMaxStackSize(): int
        public canBeActivated(): boolean
        public getProjectileEntityType(): string
        public getThrowForce(): float
        correctNBT(nbt: cn.nukkit.nbt.tag.CompoundTag): void

    }
}

declare module "cn.nukkit.item.ItemPotionLingering" {
    declare const ItemPotionLingering = cn.nukkit.item.ItemPotionLingering;
}

declare namespace cn.nukkit.item {
    declare class ItemRabbitRaw extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemRabbitRaw" {
    declare const ItemRabbitRaw = cn.nukkit.item.ItemRabbitRaw;
}

declare namespace cn.nukkit.item {
    declare class ItemRecordWait extends cn.nukkit.item.ItemRecord {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getSoundId(): string

    }
}

declare module "cn.nukkit.item.ItemRecordWait" {
    declare const ItemRecordWait = cn.nukkit.item.ItemRecordWait;
}

declare namespace cn.nukkit.item {
    declare class ItemMagmaCream extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemMagmaCream" {
    declare const ItemMagmaCream = cn.nukkit.item.ItemMagmaCream;
}

declare namespace cn.nukkit.item {
    declare class ItemCampfire extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemCampfire" {
    declare const ItemCampfire = cn.nukkit.item.ItemCampfire;
}

declare namespace cn.nukkit.item {
    declare class ItemHoeNetherite extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public isHoe(): boolean
        public getAttackDamage(): int
        public getTier(): int
        public getMaxDurability(): int
        public isLavaResistant(): boolean

    }
}

declare module "cn.nukkit.item.ItemHoeNetherite" {
    declare const ItemHoeNetherite = cn.nukkit.item.ItemHoeNetherite;
}

declare namespace cn.nukkit.item {
    declare class ItemDoorBirch extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemDoorBirch" {
    declare const ItemDoorBirch = cn.nukkit.item.ItemDoorBirch;
}

declare namespace cn.nukkit.item {
    declare class ItemHorseArmorGold extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemHorseArmorGold" {
    declare const ItemHorseArmorGold = cn.nukkit.item.ItemHorseArmorGold;
}

declare namespace cn.nukkit.item {
    declare class ItemDriedKelp extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemDriedKelp" {
    declare const ItemDriedKelp = cn.nukkit.item.ItemDriedKelp;
}

declare namespace cn.nukkit.item {
    declare class ItemBirchSign extends cn.nukkit.item.ItemSign {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemBirchSign" {
    declare const ItemBirchSign = cn.nukkit.item.ItemBirchSign;
}

declare namespace cn.nukkit.item {
    declare class ItemCrossbow extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public onUse(player: cn.nukkit.Player, ticksUsed: int): boolean
        canLoad(item: cn.nukkit.item.Item): boolean
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean
        public onRelease(player: cn.nukkit.Player, ticksUsed: int): boolean
        public loadArrow(player: cn.nukkit.Player, arrow: cn.nukkit.item.Item): void
        public useArrow(player: cn.nukkit.Player): void
        public isLoaded(): boolean
        public launchArrow(player: cn.nukkit.Player): boolean
        public getEnchantAbility(): int
        loadTick: int

    }
}

declare module "cn.nukkit.item.ItemCrossbow" {
    declare const ItemCrossbow = cn.nukkit.item.ItemCrossbow;
}

declare namespace cn.nukkit.item {
    declare class ItemRawCopper extends cn.nukkit.item.ItemRawMaterial {
        public constructor(): void

    }
}

declare module "cn.nukkit.item.ItemRawCopper" {
    declare const ItemRawCopper = cn.nukkit.item.ItemRawCopper;
}

declare namespace cn.nukkit.item {
    declare class ItemFirework$FireworkExplosion$ExplosionType extends java.lang.Enum {
        public static values(): cn.nukkit.item.ItemFirework$FireworkExplosion$ExplosionType[]
        public static valueOf(name: string): cn.nukkit.item.ItemFirework$FireworkExplosion$ExplosionType
        constructor(): void
        static $values(): cn.nukkit.item.ItemFirework$FireworkExplosion$ExplosionType[]
        public static SMALL_BALL: cn.nukkit.item.ItemFirework$FireworkExplosion$ExplosionType
        public static LARGE_BALL: cn.nukkit.item.ItemFirework$FireworkExplosion$ExplosionType
        public static STAR_SHAPED: cn.nukkit.item.ItemFirework$FireworkExplosion$ExplosionType
        public static CREEPER_SHAPED: cn.nukkit.item.ItemFirework$FireworkExplosion$ExplosionType
        public static BURST: cn.nukkit.item.ItemFirework$FireworkExplosion$ExplosionType
        static $VALUES: cn.nukkit.item.ItemFirework$FireworkExplosion$ExplosionType[]

    }
}

declare module "cn.nukkit.item.ItemFirework$FireworkExplosion$ExplosionType" {
    declare const ItemFirework$FireworkExplosion$ExplosionType = cn.nukkit.item.ItemFirework$FireworkExplosion$ExplosionType;
}

declare namespace cn.nukkit {
    declare class Player$1 extends cn.nukkit.scheduler.Task {
        constructor(this$0: cn.nukkit.Player, var1: cn.nukkit.level.Position): void
        public onRun(currentTick: int): void
        val$newPos: cn.nukkit.level.Position
        this$0: cn.nukkit.Player

    }
}

declare module "cn.nukkit.Player$1" {
    declare const Player$1 = cn.nukkit.Player$1;
}

declare namespace cn.nukkit.block {
    declare class BlockEmerald extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockEmerald" {
    declare const BlockEmerald = cn.nukkit.block.BlockEmerald;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsWood extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getToolType(): int
        public getHardness(): double
        public getResistance(): double
        public getBurnChance(): int
        public getBurnAbility(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]

    }
}

declare module "cn.nukkit.block.BlockStairsWood" {
    declare const BlockStairsWood = cn.nukkit.block.BlockStairsWood;
}

declare namespace cn.nukkit.block {
    declare class BlockStairs$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$math$BlockFace: int[]

    }
}

declare module "cn.nukkit.block.BlockStairs$1" {
    declare const BlockStairs$1 = cn.nukkit.block.BlockStairs$1;
}

declare namespace cn.nukkit.block {
    declare class BlockPistonBase$BlocksCalculator extends java.lang.Object {
        public constructor(this$0: cn.nukkit.block.BlockPistonBase, level: cn.nukkit.level.Level, block: cn.nukkit.block.Block, facing: cn.nukkit.math.BlockFace, extending: boolean): void
        public constructor(this$0: cn.nukkit.block.BlockPistonBase, level: cn.nukkit.level.Level, pos: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, extending: boolean, sticky: boolean): void
        public canMove(): boolean
        public canPush(block: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, destroyBlocks: boolean, extending: boolean): boolean
        public getLockedBlocks(): java.util.Set<cn.nukkit.level.Position>
        public recordLockedBlocks(): void
        addBlockLine(origin: cn.nukkit.block.Block, from: cn.nukkit.block.Block, mainBlockLine: boolean): boolean
        reorderListAtCollision(count: int, index: int): void
        addBranchingBlocks(block: cn.nukkit.block.Block): boolean
        public getBlocksToMove(): java.util.List<cn.nukkit.block.Block>
        public getBlocksToDestroy(): java.util.List<cn.nukkit.block.Block>
        public lockBlocks(): void
        public unlockBlocks(): void
        lambda$recordLockedBlocks$1(block: cn.nukkit.block.Block): void
        lambda$recordLockedBlocks$0(block: cn.nukkit.block.Block): void
        pistonPos: cn.nukkit.level.Position
        armPos: cn.nukkit.math.Vector3
        blockToMove: cn.nukkit.block.Block
        moveDirection: cn.nukkit.math.BlockFace
        extending: boolean
        sticky: boolean
        toMove: java.util.List<cn.nukkit.block.Block>
        toDestroy: java.util.List<cn.nukkit.block.Block>
        toLock: java.util.Set<cn.nukkit.level.Position>
        blockedByPistonHeadOrLockedBlock: boolean
        blockedPos: cn.nukkit.level.Position
        this$0: cn.nukkit.block.BlockPistonBase

    }
}

declare module "cn.nukkit.block.BlockPistonBase$BlocksCalculator" {
    declare const BlockPistonBase$BlocksCalculator = cn.nukkit.block.BlockPistonBase$BlocksCalculator;
}

declare namespace cn.nukkit.block {
    declare class BlockFlower extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getFlowerType(): cn.nukkit.blockproperty.value.SmallFlowerType
        setOnSingleFlowerType(acceptsOnly: cn.nukkit.blockproperty.value.SmallFlowerType, attemptedToSet: cn.nukkit.blockproperty.value.SmallFlowerType): void
        public setFlowerType(flowerType: cn.nukkit.blockproperty.value.SmallFlowerType): void
        public static isSupportValid(block: cn.nukkit.block.Block): boolean
        public canPlantOn(block: cn.nukkit.block.Block): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        getUncommonFlower(): cn.nukkit.block.Block
        public static RED_FLOWER_TYPE: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.blockproperty.value.SmallFlowerType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static TYPE_POPPY: int
        public static TYPE_BLUE_ORCHID: int
        public static TYPE_ALLIUM: int
        public static TYPE_AZURE_BLUET: int
        public static TYPE_RED_TULIP: int
        public static TYPE_ORANGE_TULIP: int
        public static TYPE_WHITE_TULIP: int
        public static TYPE_PINK_TULIP: int
        public static TYPE_OXEYE_DAISY: int
        public static TYPE_CORNFLOWER: int
        public static TYPE_LILY_OF_THE_VALLEY: int

    }
}

declare module "cn.nukkit.block.BlockFlower" {
    declare const BlockFlower = cn.nukkit.block.BlockFlower;
}

declare namespace cn.nukkit.block {
    declare class BlockHyphaeCrimson extends cn.nukkit.block.BlockStem {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        getStrippedState(): cn.nukkit.blockstate.BlockState
        public getHardness(): double
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockHyphaeCrimson" {
    declare const BlockHyphaeCrimson = cn.nukkit.block.BlockHyphaeCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockNetherSprout extends cn.nukkit.block.BlockRoots {
        public constructor(): void
        public getId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor
        public getBurnChance(): int

    }
}

declare module "cn.nukkit.block.BlockNetherSprout" {
    declare const BlockNetherSprout = cn.nukkit.block.BlockNetherSprout;
}

declare namespace cn.nukkit.block {
    declare class BlockTrapdoorJungle extends cn.nukkit.block.BlockTrapdoor {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockTrapdoorJungle" {
    declare const BlockTrapdoorJungle = cn.nukkit.block.BlockTrapdoorJungle;
}

declare namespace cn.nukkit.block {
    declare class BlockRail extends cn.nukkit.block.BlockFlowable implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public canPassThrough(): boolean
        public getToolType(): int
        public sticksToPiston(): boolean
        public onUpdate(type: int): int
        public getMaxY(): double
        public recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getColor(): cn.nukkit.utils.BlockColor
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        checkCanBePlace(check: cn.nukkit.block.Block): boolean
        connect(rail1: cn.nukkit.block.BlockRail, face1: cn.nukkit.math.BlockFace, rail2: cn.nukkit.block.BlockRail, face2: cn.nukkit.math.BlockFace): cn.nukkit.utils.Rail$Orientation
        connect(other: cn.nukkit.block.BlockRail, face: cn.nukkit.math.BlockFace): cn.nukkit.utils.Rail$Orientation
        checkRailsAroundAffected(): java.util.Map<cn.nukkit.block.BlockRail, cn.nukkit.math.BlockFace>
        checkRailsAround(faces: java.util.Collection<cn.nukkit.math.BlockFace>): java.util.Map<cn.nukkit.block.BlockRail, cn.nukkit.math.BlockFace>
        checkRailsConnected(): java.util.Map<cn.nukkit.block.BlockRail, cn.nukkit.math.BlockFace>
        public isAbstract(): boolean
        public canPowered(): boolean
        public getRailDirection(): cn.nukkit.utils.Rail$Orientation
        public setRailDirection(orientation: cn.nukkit.utils.Rail$Orientation): void
        public getOrientation(): cn.nukkit.utils.Rail$Orientation
        public setOrientation(o: cn.nukkit.utils.Rail$Orientation): void
        public getRealMeta(): int
        public isActive(): boolean
        public setActive(active: boolean): void
        public isRailActive(): cn.nukkit.utils.OptionalBoolean
        public setRailActive(active: boolean): void
        public toItem(): cn.nukkit.item.Item
        public getBlockFace(): cn.nukkit.math.BlockFace
        public canBePushed(): boolean
        public canBePulled(): boolean
        public breaksWhenMoved(): boolean
        static lambda$checkRailsConnected$7(r: cn.nukkit.block.BlockRail): cn.nukkit.block.BlockRail
        static lambda$checkRailsConnected$6(railsAround: java.util.Map, r: cn.nukkit.block.BlockRail): boolean
        lambda$checkRailsAround$5(result: java.util.Map, f: cn.nukkit.math.BlockFace): void
        static lambda$checkRailsAround$4(result: java.util.Map, f: cn.nukkit.math.BlockFace, block: cn.nukkit.block.Block): void
        static lambda$checkRailsAroundAffected$3(r: cn.nukkit.block.BlockRail): cn.nukkit.block.BlockRail
        static lambda$checkRailsAroundAffected$2(r: cn.nukkit.block.BlockRail): boolean
        lambda$place$1(f1: cn.nukkit.math.BlockFace, f2: cn.nukkit.math.BlockFace): int
        static lambda$place$0(faces: java.util.List, o: cn.nukkit.utils.Rail$Orientation): boolean
        public static ACTIVE: cn.nukkit.blockproperty.BooleanBlockProperty
        public static UNCURVED_RAIL_DIRECTION: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.utils.Rail$Orientation>
        public static CURVED_RAIL_DIRECTION: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.utils.Rail$Orientation>
        public static ACTIVABLE_PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        canBePowered: boolean

    }
}

declare module "cn.nukkit.block.BlockRail" {
    declare const BlockRail = cn.nukkit.block.BlockRail;
}

declare namespace cn.nukkit.block {
    declare class BlockStemCrimson extends cn.nukkit.block.BlockStem {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        getStrippedState(): cn.nukkit.blockstate.BlockState
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStemCrimson" {
    declare const BlockStemCrimson = cn.nukkit.block.BlockStemCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockDoorSpruce extends cn.nukkit.block.BlockDoorWood {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoorSpruce" {
    declare const BlockDoorSpruce = cn.nukkit.block.BlockDoorSpruce;
}

declare namespace cn.nukkit.block {
    declare class BlockVinesNether extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getGrowthDirection(): cn.nukkit.math.BlockFace
        public getVineAge(): int
        public setVineAge(var0: int): void
        public getMaxVineAge(): int
        public randomizeVineAge(pseudorandom: boolean): void
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public grow(): boolean
        public growMultiple(): int
        public findVineAge(base: boolean): java.util.OptionalInt
        public findVineBlock(base: boolean): java.util.Optional<cn.nukkit.block.BlockVinesNether>
        public findVine(base: boolean): java.util.Optional<cn.nukkit.level.Position>
        public increaseRootAge(): cn.nukkit.utils.OptionalBoolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        isSupportValid(support: cn.nukkit.block.Block): boolean
        public isSupportValid(): boolean
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public hasEntityCollision(): boolean
        public getHardness(): double
        public getResistance(): double
        public canBeClimbed(): boolean
        public canBeFlowedInto(): boolean
        public isSolid(): boolean
        public getMinX(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxZ(): double
        public getMaxY(): double
        public canPassThrough(): boolean
        public sticksToPiston(): boolean
        public breaksWhenMoved(): boolean
        public canBeActivated(): boolean
        public canSilkTouch(): boolean
        public clone(): cn.nukkit.block.BlockVinesNether
        public clone(): cn.nukkit.block.Block
        public clone(): cn.nukkit.math.AxisAlignedBB
        public clone(): cn.nukkit.level.Position
        public clone(): cn.nukkit.positiontracking.NamedPosition
        public clone(): cn.nukkit.math.Vector3
        public clone(): java.lang.Object
        static lambda$findVineAge$0(vine: cn.nukkit.block.BlockVinesNether): java.util.OptionalInt

    }
}

declare module "cn.nukkit.block.BlockVinesNether" {
    declare const BlockVinesNether = cn.nukkit.block.BlockVinesNether;
}

declare namespace cn.nukkit.block {
    declare class BlockEndStone extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockEndStone" {
    declare const BlockEndStone = cn.nukkit.block.BlockEndStone;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabMangrove extends cn.nukkit.block.BlockSlab {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getSlabName(): string
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBurnChance(): int
        public getBurnAbility(): int
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockSlabMangrove" {
    declare const BlockSlabMangrove = cn.nukkit.block.BlockSlabMangrove;
}

declare namespace cn.nukkit.block {
    declare class BlockWoodStrippedDarkOak extends cn.nukkit.block.BlockWoodStripped {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType

    }
}

declare module "cn.nukkit.block.BlockWoodStrippedDarkOak" {
    declare const BlockWoodStrippedDarkOak = cn.nukkit.block.BlockWoodStrippedDarkOak;
}

declare namespace cn.nukkit.block {
    declare class BlockLargeAmethystBud extends cn.nukkit.block.BlockAmethystBud {
        public constructor(): void
        getNamePrefix(): string
        public getId(): int
        public getLightLevel(): int

    }
}

declare module "cn.nukkit.block.BlockLargeAmethystBud" {
    declare const BlockLargeAmethystBud = cn.nukkit.block.BlockLargeAmethystBud;
}

declare namespace cn.nukkit.block {
    declare class BlockKelp extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getAge(): int
        public setAge(age: int): void
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public grow(): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public toItem(): cn.nukkit.item.Item
        public getWaterloggingLevel(): int
        public canBeActivated(): boolean
        public static KELP_AGE: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockKelp" {
    declare const BlockKelp = cn.nukkit.block.BlockKelp;
}

declare namespace cn.nukkit.block {
    declare class BlockRailActivator extends cn.nukkit.block.BlockRail implements cn.nukkit.utils.RedstoneComponent {
        public constructor(meta: int): void
        public constructor(): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public onUpdate(type: int): int
        checkSurrounding(pos: cn.nukkit.math.Vector3, relative: boolean, power: int): boolean
        canPowered(pos: cn.nukkit.math.Vector3, state: cn.nukkit.utils.Rail$Orientation, power: int, relative: boolean): boolean
        public isActive(): boolean
        public isRailActive(): cn.nukkit.utils.OptionalBoolean
        public setRailActive(active: boolean): void
        public getHardness(): double

    }
}

declare module "cn.nukkit.block.BlockRailActivator" {
    declare const BlockRailActivator = cn.nukkit.block.BlockRailActivator;
}

declare namespace cn.nukkit.block {
    declare class BlockSmallAmethystBud extends cn.nukkit.block.BlockAmethystBud {
        public constructor(): void
        getNamePrefix(): string
        public getId(): int
        public getLightLevel(): int

    }
}

declare module "cn.nukkit.block.BlockSmallAmethystBud" {
    declare const BlockSmallAmethystBud = cn.nukkit.block.BlockSmallAmethystBud;
}

declare namespace cn.nukkit.block {
    declare class BlockHoney extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public hasEntityCollision(): boolean
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getMinX(): double
        public getMaxX(): double
        public getMinZ(): double
        public getMaxZ(): double
        public getLightFilter(): int
        public useDefaultFallDamage(): boolean
        public onEntityFallOn(entity: cn.nukkit.entity.Entity, fallDistance: float): void
        static RANDOM: java.util.Random

    }
}

declare module "cn.nukkit.block.BlockHoney" {
    declare const BlockHoney = cn.nukkit.block.BlockHoney;
}

declare namespace cn.nukkit.block {
    declare class BlockFenceBase extends cn.nukkit.block.BlockFence {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getWoodType(): java.util.Optional<cn.nukkit.blockproperty.value.WoodType>
        public setWoodType(woodType: cn.nukkit.blockproperty.value.WoodType): void

    }
}

declare module "cn.nukkit.block.BlockFenceBase" {
    declare const BlockFenceBase = cn.nukkit.block.BlockFenceBase;
}

declare namespace cn.nukkit.block {
    declare class BlockStructure extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getStructureBlockType(): cn.nukkit.blockproperty.value.StructureBlockType
        public setStructureBlockType(type: cn.nukkit.blockproperty.value.StructureBlockType): void
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public canBePushed(): boolean
        public canBePulled(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public static STRUCTURE_BLOCK_TYPE: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.blockproperty.value.StructureBlockType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockStructure" {
    declare const BlockStructure = cn.nukkit.block.BlockStructure;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazedRed extends cn.nukkit.block.BlockTerracottaGlazed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getDyeColor(): cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazedRed" {
    declare const BlockTerracottaGlazedRed = cn.nukkit.block.BlockTerracottaGlazedRed;
}

declare namespace cn.nukkit.block {
    declare interface BlockEntityHolder {
        public getBlockEntity(): any
        public createBlockEntity(): any
        public createBlockEntity(initialData: cn.nukkit.nbt.tag.CompoundTag): java.lang.Object[]
        public getOrCreateBlockEntity(): any
        public getOrCreateBlockEntity(initialData: cn.nukkit.nbt.tag.CompoundTag): java.lang.Object[]
        public getBlockEntityClass(): java.lang.Class<any>
        public getBlockEntityType(): string
        public getChunk(): cn.nukkit.level.format.FullChunk
        public getFloorX(): int
        public getFloorY(): int
        public getFloorZ(): int
        public getLocation(): cn.nukkit.level.Location
        public getLevel(): cn.nukkit.level.Level
        public static setBlockAndCreateEntity(holder: cn.nukkit.blockentity.BlockEntity): cn.nukkit.block.BlockEntityHolder<any>
        public static setBlockAndCreateEntity(holder: cn.nukkit.blockentity.BlockEntity, direct: cn.nukkit.block.BlockEntityHolder<any>, update: boolean): boolean
        public static setBlockAndCreateEntity(holder: cn.nukkit.blockentity.BlockEntity, direct: cn.nukkit.block.BlockEntityHolder<any>, update: boolean, initialData: boolean, args: cn.nukkit.nbt.tag.CompoundTag): java.lang.Object[]
        public getBlock(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockEntityHolder" {
    declare type BlockEntityHolder = cn.nukkit.block.BlockEntityHolder;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazedGreen extends cn.nukkit.block.BlockTerracottaGlazed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getDyeColor(): cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazedGreen" {
    declare const BlockTerracottaGlazedGreen = cn.nukkit.block.BlockTerracottaGlazedGreen;
}

declare namespace cn.nukkit.block {
    declare class BlockCauldron$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$blockentity$BlockEntityCauldron$PotionType: int[]

    }
}

declare module "cn.nukkit.block.BlockCauldron$1" {
    declare const BlockCauldron$1 = cn.nukkit.block.BlockCauldron$1;
}

declare namespace cn.nukkit.block {
    declare class BlockComposter extends cn.nukkit.block.BlockSolidMeta implements cn.nukkit.item.ItemID {
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public canBeActivated(): boolean
        public getWaterloggingLevel(): int
        public toItem(): cn.nukkit.item.Item
        public hasComparatorInputOverride(): boolean
        public getComparatorInputOverride(): int
        public incrementLevel(): boolean
        public isFull(): boolean
        public isEmpty(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public empty(): cn.nukkit.item.Item
        public empty(item: cn.nukkit.item.Item, player: cn.nukkit.Player): cn.nukkit.item.Item
        public static registerItem(chance: int, itemId: cn.nukkit.item.MinecraftItemID): void
        public static registerItems(chance: int, itemId: cn.nukkit.item.MinecraftItemID[]): void
        public static registerItem(chance: int, itemId: int): void
        public static registerItem(chance: int, itemId: int, meta: int): void
        public static registerItems(chance: int, itemIds: int[]): void
        public static registerBlocks(chance: int, blockIds: int[]): void
        public static registerBlock(chance: int, blockId: int): void
        public static registerBlock(chance: int, blockId: int, meta: int): void
        public static register(chance: int, item: cn.nukkit.item.Item): void
        public static getChance(item: cn.nukkit.item.Item): int
        static registerDefaults(): void
        static compostableItems: it.unimi.dsi.fastutil.ints.Int2IntMap
        static compostableStringItems: it.unimi.dsi.fastutil.objects.Object2IntMap<string>
        public static COMPOSTER_FILL_LEVEL: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockComposter" {
    declare const BlockComposter = cn.nukkit.block.BlockComposter;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsRedSandstone extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public canHarvestWithHand(): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStairsRedSandstone" {
    declare const BlockStairsRedSandstone = cn.nukkit.block.BlockStairsRedSandstone;
}

declare namespace cn.nukkit.block {
    declare class BlockBed extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.Faceable, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityBed>
        public getBlockEntityType(): string
        public canBeActivated(): boolean
        public getResistance(): double
        public getHardness(): double
        public getName(): string
        public getMaxY(): double
        public getWaterloggingLevel(): int
        public onActivate(item: cn.nukkit.item.Item): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor
        public getDyeColor(): cn.nukkit.utils.DyeColor
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public isHeadPiece(): boolean
        public setHeadPiece(headPiece: boolean): void
        public isOccupied(): boolean
        public setOccupied(occupied: boolean): void
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        public isBedValid(): boolean
        public getHeadPart(): cn.nukkit.block.BlockBed
        public getFootPart(): cn.nukkit.block.BlockBed
        static log: org.apache.logging.log4j.Logger
        public static HEAD_PIECE: cn.nukkit.blockproperty.BooleanBlockProperty
        public static OCCUPIED: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockBed" {
    declare const BlockBed = cn.nukkit.block.BlockBed;
}

declare namespace cn.nukkit.block {
    declare class BlockBedrock extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBurnIndefinitely(): boolean
        public setBurnIndefinitely(infiniburn: boolean): void
        public getHardness(): double
        public getResistance(): double
        public getName(): string
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public canBePushed(): boolean
        public canBePulled(): boolean
        public canHarvestWithHand(): boolean
        public static INFINIBURN: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockBedrock" {
    declare const BlockBedrock = cn.nukkit.block.BlockBedrock;
}

declare namespace cn.nukkit.block {
    declare class BlockWallBase$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$math$BlockFace: int[]

    }
}

declare module "cn.nukkit.block.BlockWallBase$1" {
    declare const BlockWallBase$1 = cn.nukkit.block.BlockWallBase$1;
}

declare namespace cn.nukkit.block {
    declare class BlockAmethystBud extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public getName(): string
        getNamePrefix(): string
        public getId(): int
        public getWaterloggingLevel(): int
        public getHardness(): double
        public getResistance(): double
        public getLightLevel(): int
        public getToolType(): int
        public getToolTier(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public isSolid(): boolean
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public onUpdate(type: int): int
        lambda$onBreak$0(item1: cn.nukkit.item.Item): void
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockAmethystBud" {
    declare const BlockAmethystBud = cn.nukkit.block.BlockAmethystBud;
}

declare namespace cn.nukkit.block {
    declare class BlockCrops extends cn.nukkit.block.BlockFlowable {
        constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getMinimumLightLevel(): int
        public getMaxGrowth(): int
        public getGrowth(): int
        public setGrowth(growth: int): void
        public isFullyGrown(): boolean
        public canBeActivated(): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public getColor(): cn.nukkit.utils.BlockColor
        public static GROWTH: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static MINIMUM_LIGHT_LEVEL: int

    }
}

declare module "cn.nukkit.block.BlockCrops" {
    declare const BlockCrops = cn.nukkit.block.BlockCrops;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsCopperCutWeathered extends cn.nukkit.block.BlockStairsCopperCut {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStairsCopperCutWeathered" {
    declare const BlockStairsCopperCutWeathered = cn.nukkit.block.BlockStairsCopperCutWeathered;
}

declare namespace cn.nukkit.block {
    declare class BlockShroomlight extends cn.nukkit.block.BlockTransparent {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getToolType(): int
        public getResistance(): double
        public getHardness(): double
        public getLightLevel(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockShroomlight" {
    declare const BlockShroomlight = cn.nukkit.block.BlockShroomlight;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabWood extends cn.nukkit.block.BlockSlab {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getSlabName(): string
        public getId(): int
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBurnChance(): int
        public getBurnAbility(): int
        public getToolType(): int
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType
        public setWoodType(type: cn.nukkit.blockproperty.value.WoodType): void
        public getColor(): cn.nukkit.utils.BlockColor
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockSlabWood" {
    declare const BlockSlabWood = cn.nukkit.block.BlockSlabWood;
}

declare namespace cn.nukkit.block {
    declare class BlockButtonBirch extends cn.nukkit.block.BlockButtonWooden {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockButtonBirch" {
    declare const BlockButtonBirch = cn.nukkit.block.BlockButtonBirch;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabCopperCut extends cn.nukkit.block.BlockDoubleSlabCopperBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getSlabName(): string
        public getSingleSlabId(): int
        getCopperId(waxed: boolean, oxidizationLevel: cn.nukkit.blockproperty.value.OxidizationLevel): int
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabCopperCut" {
    declare const BlockDoubleSlabCopperCut = cn.nukkit.block.BlockDoubleSlabCopperCut;
}

declare namespace cn.nukkit.block {
    declare class BlockHayBale extends cn.nukkit.block.BlockSolidMeta implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getBurnChance(): int
        public getBurnAbility(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getBlockFace(): cn.nukkit.math.BlockFace
        public useDefaultFallDamage(): boolean
        public onEntityFallOn(entity: cn.nukkit.entity.Entity, fallDistance: float): void
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockHayBale" {
    declare const BlockHayBale = cn.nukkit.block.BlockHayBale;
}

declare namespace cn.nukkit.block {
    declare class BlockCaveVinesBodyWithBerries extends cn.nukkit.block.BlockCaveVines {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public isTransparent(): boolean
        public getLightLevel(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public static AGE_PROPERTY: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCaveVinesBodyWithBerries" {
    declare const BlockCaveVinesBodyWithBerries = cn.nukkit.block.BlockCaveVinesBodyWithBerries;
}

declare namespace cn.nukkit.block {
    declare class BlockDeepslateCobbled extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockDeepslateCobbled" {
    declare const BlockDeepslateCobbled = cn.nukkit.block.BlockDeepslateCobbled;
}

declare namespace cn.nukkit.block {
    declare class BlockDoorWood extends cn.nukkit.block.BlockDoor {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoorWood" {
    declare const BlockDoorWood = cn.nukkit.block.BlockDoorWood;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperCut extends cn.nukkit.block.BlockCopperBase {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel
        getCopperId(waxed: boolean, oxidizationLevel: cn.nukkit.blockproperty.value.OxidizationLevel): int

    }
}

declare module "cn.nukkit.block.BlockCopperCut" {
    declare const BlockCopperCut = cn.nukkit.block.BlockCopperCut;
}

declare namespace cn.nukkit.block {
    declare class BlockCampfireSoul extends cn.nukkit.block.BlockCampfire {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getLightLevel(): int
        public toItem(): cn.nukkit.item.Item
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        getDamageEvent(entity: cn.nukkit.entity.Entity): cn.nukkit.event.entity.EntityDamageEvent

    }
}

declare module "cn.nukkit.block.BlockCampfireSoul" {
    declare const BlockCampfireSoul = cn.nukkit.block.BlockCampfireSoul;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCakeWhite extends cn.nukkit.block.BlockCandleCake {
        public constructor(meta: int): void
        public constructor(): void
        getColorName(): string
        public getId(): int
        toCandleForm(): cn.nukkit.block.BlockCandle

    }
}

declare module "cn.nukkit.block.BlockCandleCakeWhite" {
    declare const BlockCandleCakeWhite = cn.nukkit.block.BlockCandleCakeWhite;
}

declare namespace cn.nukkit.block {
    declare class BlockAzaleaFlowering extends cn.nukkit.block.BlockAzalea {
        public constructor(): void
        public getName(): string
        public getId(): int

    }
}

declare module "cn.nukkit.block.BlockAzaleaFlowering" {
    declare const BlockAzaleaFlowering = cn.nukkit.block.BlockAzaleaFlowering;
}

declare namespace cn.nukkit.block {
    declare class BlockFlowerPot extends cn.nukkit.block.BlockFlowable implements cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        static canPlaceIntoFlowerPot(id: int): boolean
        public getWaterloggingLevel(): int
        public getName(): string
        public getId(): int
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityFlowerPot>
        public getBlockEntityType(): string
        public getHardness(): double
        public getResistance(): double
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getFlower(): cn.nukkit.item.Item
        public setFlower(item: cn.nukkit.item.Item): boolean
        public removeFlower(): void
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getMinX(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxY(): double
        public getMaxZ(): double
        public canPassThrough(): boolean
        public toItem(): cn.nukkit.item.Item
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockFlowerPot" {
    declare const BlockFlowerPot = cn.nukkit.block.BlockFlowerPot;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabBrickDeepslate extends cn.nukkit.block.BlockSlab {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getSlabName(): string
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public getToolTier(): int
        public getToolType(): int
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockSlabBrickDeepslate" {
    declare const BlockSlabBrickDeepslate = cn.nukkit.block.BlockSlabBrickDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazedBlack extends cn.nukkit.block.BlockTerracottaGlazed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getDyeColor(): cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazedBlack" {
    declare const BlockTerracottaGlazedBlack = cn.nukkit.block.BlockTerracottaGlazedBlack;
}

declare namespace cn.nukkit.block {
    declare class BlockMangroveWallSign extends cn.nukkit.block.BlockWallSign {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        getPostId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockMangroveWallSign" {
    declare const BlockMangroveWallSign = cn.nukkit.block.BlockMangroveWallSign;
}

declare namespace cn.nukkit.block {
    declare class BlockRailPowered extends cn.nukkit.block.BlockRail implements cn.nukkit.utils.RedstoneComponent {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public onUpdate(type: int): int
        public afterRemoval(newBlock: cn.nukkit.block.Block, update: boolean): void
        checkSurrounding(pos: cn.nukkit.math.Vector3, relative: boolean, power: int): boolean
        canPowered(pos: cn.nukkit.math.Vector3, state: cn.nukkit.utils.Rail$Orientation, power: int, relative: boolean): boolean
        public isActive(): boolean
        public isRailActive(): cn.nukkit.utils.OptionalBoolean
        public setRailActive(active: boolean): void

    }
}

declare module "cn.nukkit.block.BlockRailPowered" {
    declare const BlockRailPowered = cn.nukkit.block.BlockRailPowered;
}

declare namespace cn.nukkit.block {
    declare class BlockWoodStrippedBirch extends cn.nukkit.block.BlockWoodStripped {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType

    }
}

declare module "cn.nukkit.block.BlockWoodStrippedBirch" {
    declare const BlockWoodStrippedBirch = cn.nukkit.block.BlockWoodStrippedBirch;
}

declare namespace cn.nukkit.block {
    declare class BlockRedstoneComparator$Mode extends java.lang.Enum {
        public static values(): cn.nukkit.block.BlockRedstoneComparator$Mode[]
        public static valueOf(name: string): cn.nukkit.block.BlockRedstoneComparator$Mode
        constructor(): void
        static $values(): cn.nukkit.block.BlockRedstoneComparator$Mode[]
        public static COMPARE: cn.nukkit.block.BlockRedstoneComparator$Mode
        public static SUBTRACT: cn.nukkit.block.BlockRedstoneComparator$Mode
        static $VALUES: cn.nukkit.block.BlockRedstoneComparator$Mode[]

    }
}

declare module "cn.nukkit.block.BlockRedstoneComparator$Mode" {
    declare const BlockRedstoneComparator$Mode = cn.nukkit.block.BlockRedstoneComparator$Mode;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperWeathered extends cn.nukkit.block.BlockCopper {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel

    }
}

declare module "cn.nukkit.block.BlockCopperWeathered" {
    declare const BlockCopperWeathered = cn.nukkit.block.BlockCopperWeathered;
}

declare namespace cn.nukkit.block {
    declare class BlockGlassStained extends cn.nukkit.block.BlockGlass {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public getDyeColor(): cn.nukkit.utils.DyeColor
        public setDyeColor(color: cn.nukkit.utils.DyeColor): void
        public canSilkTouch(): boolean
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockGlassStained" {
    declare const BlockGlassStained = cn.nukkit.block.BlockGlassStained;
}

declare namespace cn.nukkit.block {
    declare class BlockBlastFurnace extends cn.nukkit.block.BlockBlastFurnaceBurning {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getLightLevel(): int

    }
}

declare module "cn.nukkit.block.BlockBlastFurnace" {
    declare const BlockBlastFurnace = cn.nukkit.block.BlockBlastFurnace;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabBlackstonePolished extends cn.nukkit.block.BlockSlab {
        public constructor(): void
        public constructor(meta: int): void
        constructor(meta: int, doubleSlab: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getSlabName(): string
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean
        public canHarvestWithHand(): boolean
        public getToolType(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getHardness(): double
        public getResistance(): double
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockSlabBlackstonePolished" {
    declare const BlockSlabBlackstonePolished = cn.nukkit.block.BlockSlabBlackstonePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockNetherWart extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public toItem(): cn.nukkit.item.Item
        public static AGE: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockNetherWart" {
    declare const BlockNetherWart = cn.nukkit.block.BlockNetherWart;
}

declare namespace cn.nukkit.block {
    declare class BlockFenceGateDarkOak extends cn.nukkit.block.BlockFenceGate {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockFenceGateDarkOak" {
    declare const BlockFenceGateDarkOak = cn.nukkit.block.BlockFenceGateDarkOak;
}

declare namespace cn.nukkit.block {
    declare class BlockPressurePlateWood extends cn.nukkit.block.BlockPressurePlateBase {
        public constructor(meta: int): void
        public constructor(): void
        public getName(): string
        public getId(): int
        public getToolType(): int
        public getHardness(): double
        public getResistance(): double
        public getColor(): cn.nukkit.utils.BlockColor
        computeRedstoneStrength(): int

    }
}

declare module "cn.nukkit.block.BlockPressurePlateWood" {
    declare const BlockPressurePlateWood = cn.nukkit.block.BlockPressurePlateWood;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabCopperBase extends cn.nukkit.block.BlockDoubleSlabBase implements cn.nukkit.block.Waxable, cn.nukkit.block.Oxidizable {
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getColor(): cn.nukkit.utils.BlockColor
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public canBeActivated(): boolean
        public getStateWithOxidizationLevel(oxidizationLevel: cn.nukkit.blockproperty.value.OxidizationLevel): cn.nukkit.blockstate.BlockState
        public setOxidizationLevel(oxidizationLevel: cn.nukkit.blockproperty.value.OxidizationLevel): boolean
        public setWaxed(waxed: boolean): boolean
        public isWaxed(): boolean
        getCopperId(var0: boolean, var1: cn.nukkit.blockproperty.value.OxidizationLevel): int

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabCopperBase" {
    declare const BlockDoubleSlabCopperBase = cn.nukkit.block.BlockDoubleSlabCopperBase;
}

declare namespace cn.nukkit.block {
    declare class BlockFence extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.block.BlockConnectable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getWaterloggingLevel(): int
        public getResistance(): double
        public getToolType(): int
        public setWoodType(woodType: cn.nukkit.blockproperty.value.WoodType): void
        public getWoodType(): java.util.Optional<cn.nukkit.blockproperty.value.WoodType>
        public getName(): string
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getBurnChance(): int
        public getBurnAbility(): int
        public canConnect(block: cn.nukkit.block.Block): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static FENCE_OAK: int
        public static FENCE_SPRUCE: int
        public static FENCE_BIRCH: int
        public static FENCE_JUNGLE: int
        public static FENCE_ACACIA: int
        public static FENCE_DARK_OAK: int

    }
}

declare module "cn.nukkit.block.BlockFence" {
    declare const BlockFence = cn.nukkit.block.BlockFence;
}

declare namespace cn.nukkit.block {
    declare class BlockSmithingTable extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getToolType(): int
        public getResistance(): double
        public getHardness(): double
        public getColor(): cn.nukkit.utils.BlockColor
        public getBurnChance(): int
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockSmithingTable" {
    declare const BlockSmithingTable = cn.nukkit.block.BlockSmithingTable;
}

declare namespace cn.nukkit.block {
    declare class BlockUnknown extends cn.nukkit.block.BlockMeta {
        public constructor(id: int): void
        public constructor(id: int, meta: int): void
        public constructor(id: int, meta: java.lang.Number): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getId(): int
        public getName(): string
        public static UNKNOWN: cn.nukkit.blockproperty.UnsignedIntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        id: int

    }
}

declare module "cn.nukkit.block.BlockUnknown" {
    declare const BlockUnknown = cn.nukkit.block.BlockUnknown;
}

declare namespace cn.nukkit.block {
    declare class BlockOreGoldDeepslate extends cn.nukkit.block.BlockOreGold {
        public constructor(): void
        public getId(): int
        public getHardness(): double
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockOreGoldDeepslate" {
    declare const BlockOreGoldDeepslate = cn.nukkit.block.BlockOreGoldDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockTilesDeepslateCracked extends cn.nukkit.block.BlockTilesDeepslate {
        public constructor(): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockTilesDeepslateCracked" {
    declare const BlockTilesDeepslateCracked = cn.nukkit.block.BlockTilesDeepslateCracked;
}

declare namespace cn.nukkit.block {
    declare class BlockNetherWartBlock extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockNetherWartBlock" {
    declare const BlockNetherWartBlock = cn.nukkit.block.BlockNetherWartBlock;
}

declare namespace cn.nukkit.block {
    declare class BlockTransparent extends cn.nukkit.block.Block {
        public constructor(): void
        public isTransparent(): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockTransparent" {
    declare const BlockTransparent = cn.nukkit.block.BlockTransparent;
}

declare namespace cn.nukkit.block {
    declare class BlockWood2 extends cn.nukkit.block.BlockWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType
        public setWoodType(woodType: cn.nukkit.blockproperty.value.WoodType): void
        public static NEW_LOG_TYPE: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.blockproperty.value.WoodType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static ACACIA: int
        public static DARK_OAK: int

    }
}

declare module "cn.nukkit.block.BlockWood2" {
    declare const BlockWood2 = cn.nukkit.block.BlockWood2;
}

declare namespace cn.nukkit.block {
    declare class BlockTarget extends cn.nukkit.block.BlockTransparent implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityTarget>
        public getBlockEntityType(): string
        public isPowerSource(): boolean
        public getWeakPower(face: cn.nukkit.math.BlockFace): int
        public activatePower(power: int): boolean
        public activatePower(power: int, ticks: int): boolean
        public deactivatePower(): boolean
        public onUpdate(type: int): int
        public onProjectileHit(projectile: cn.nukkit.entity.Entity, position: cn.nukkit.level.Position, motion: cn.nukkit.math.Vector3): boolean
        public getToolType(): int
        public getHardness(): double
        public getResistance(): double
        public getBurnAbility(): int
        public getBurnChance(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockTarget" {
    declare const BlockTarget = cn.nukkit.block.BlockTarget;
}

declare namespace cn.nukkit.block {
    declare class BlockButtonAcacia extends cn.nukkit.block.BlockButtonWooden {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockButtonAcacia" {
    declare const BlockButtonAcacia = cn.nukkit.block.BlockButtonAcacia;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabCopperCutExposed extends cn.nukkit.block.BlockDoubleSlabCopperCut {
        public constructor(): void
        public constructor(meta: int): void
        public getSingleSlabId(): int
        public getId(): int
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabCopperCutExposed" {
    declare const BlockDoubleSlabCopperCutExposed = cn.nukkit.block.BlockDoubleSlabCopperCutExposed;
}

declare namespace cn.nukkit.block {
    declare class BlockBricksNetherChiseled extends cn.nukkit.block.BlockBricksNether {
        public constructor(): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockBricksNetherChiseled" {
    declare const BlockBricksNetherChiseled = cn.nukkit.block.BlockBricksNetherChiseled;
}

declare namespace cn.nukkit.block {
    declare class BlockShulkerBox extends cn.nukkit.block.BlockUndyedShulkerBox {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public getDyeColor(): cn.nukkit.utils.DyeColor
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockShulkerBox" {
    declare const BlockShulkerBox = cn.nukkit.block.BlockShulkerBox;
}

declare namespace cn.nukkit.block {
    declare class BlockLectern extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.utils.Faceable, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityLectern>
        public getBlockEntityType(): string
        public getWaterloggingLevel(): int
        public canBeActivated(): boolean
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getMaxY(): double
        public hasComparatorInputOverride(): boolean
        public getComparatorInputOverride(): int
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onTouch(player: cn.nukkit.Player, action: cn.nukkit.event.player.PlayerInteractEvent$Action): int
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public isPowerSource(): boolean
        public isActivated(): boolean
        public setActivated(activated: boolean): void
        public executeRedstonePulse(): void
        public getWeakPower(face: cn.nukkit.math.BlockFace): int
        public getStrongPower(face: cn.nukkit.math.BlockFace): int
        public onUpdate(type: int): int
        public getColor(): cn.nukkit.utils.BlockColor
        public dropBook(player: cn.nukkit.Player): void
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockLectern" {
    declare const BlockLectern = cn.nukkit.block.BlockLectern;
}

declare namespace cn.nukkit.block {
    declare class BlockTrapdoorMangrove extends cn.nukkit.block.BlockTrapdoor {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockTrapdoorMangrove" {
    declare const BlockTrapdoorMangrove = cn.nukkit.block.BlockTrapdoorMangrove;
}

declare namespace cn.nukkit.block {
    declare class BlockTrapdoorAcacia extends cn.nukkit.block.BlockTrapdoor {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockTrapdoorAcacia" {
    declare const BlockTrapdoorAcacia = cn.nukkit.block.BlockTrapdoorAcacia;
}

declare namespace cn.nukkit.block {
    declare class BlockTallGrass extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public canBeActivated(): boolean
        public canBeReplaced(): boolean
        public getBurnChance(): int
        public getBurnAbility(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public static TALL_GRASS_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.TallGrassType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockTallGrass" {
    declare const BlockTallGrass = cn.nukkit.block.BlockTallGrass;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazedBlue extends cn.nukkit.block.BlockTerracottaGlazed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getDyeColor(): cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazedBlue" {
    declare const BlockTerracottaGlazedBlue = cn.nukkit.block.BlockTerracottaGlazedBlue;
}

declare namespace cn.nukkit.block {
    declare class BlockRedstoneComparator extends cn.nukkit.block.BlockRedstoneDiode implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityComparator>
        public getBlockEntityType(): string
        getDelay(): int
        public getFacing(): cn.nukkit.math.BlockFace
        public getMode(): cn.nukkit.block.BlockRedstoneComparator$Mode
        getUnpowered(): cn.nukkit.block.BlockRedstoneComparator
        getPowered(): cn.nukkit.block.BlockRedstoneComparator
        getRedstoneSignal(): int
        public updateState(): void
        calculateInputStrength(): int
        shouldBePowered(): boolean
        calculateOutput(): int
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        onChange(): void
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public isPowered(): boolean
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor
        getPowered(): cn.nukkit.block.Block
        getUnpowered(): cn.nukkit.block.Block
        static log: org.apache.logging.log4j.Logger
        public static OUTPUT_LIT: cn.nukkit.blockproperty.BooleanBlockProperty
        public static OUTPUT_SUBTRACT: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockRedstoneComparator" {
    declare const BlockRedstoneComparator = cn.nukkit.block.BlockRedstoneComparator;
}

declare namespace cn.nukkit.block {
    declare class BlockSweetBerryBush extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public getBurnChance(): int
        public getBurnAbility(): int
        public canBeActivated(): boolean
        public getHardness(): double
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public static isSupportValid(block: cn.nukkit.block.Block): boolean
        public hasEntityCollision(): boolean
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public getCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public toItem(): cn.nukkit.item.Item
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockSweetBerryBush" {
    declare const BlockSweetBerryBush = cn.nukkit.block.BlockSweetBerryBush;
}

declare namespace cn.nukkit.block {
    declare class BlockStone extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getStoneType(): cn.nukkit.blockproperty.value.StoneType
        public setStoneType(stoneType: cn.nukkit.blockproperty.value.StoneType): void
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public getToolTier(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canHarvestWithHand(): boolean
        public canSilkTouch(): boolean
        public static STONE_TYPE: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.blockproperty.value.StoneType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static NORMAL: int
        public static GRANITE: int
        public static POLISHED_GRANITE: int
        public static DIORITE: int
        public static POLISHED_DIORITE: int
        public static ANDESITE: int
        public static POLISHED_ANDESITE: int

    }
}

declare module "cn.nukkit.block.BlockStone" {
    declare const BlockStone = cn.nukkit.block.BlockStone;
}

declare namespace cn.nukkit.block {
    declare class BlockCandle extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        toCakeForm(): cn.nukkit.block.Block
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canBeActivated(): boolean
        public getName(): string
        public getId(): int
        public getLightLevel(): int
        public getHardness(): double
        public getResistance(): double
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        static LIT: cn.nukkit.blockproperty.IntBlockProperty
        static CANDLES: cn.nukkit.blockproperty.IntBlockProperty
        static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCandle" {
    declare const BlockCandle = cn.nukkit.block.BlockCandle;
}

declare namespace cn.nukkit.block {
    declare class BlockEndRod extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public getLightLevel(): int
        public getToolType(): int
        public getMinX(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxZ(): double
        public getWaterloggingLevel(): int
        public canBeFlowedInto(): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public toItem(): cn.nukkit.item.Item
        public getBlockFace(): cn.nukkit.math.BlockFace
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockEndRod" {
    declare const BlockEndRod = cn.nukkit.block.BlockEndRod;
}

declare namespace cn.nukkit.block {
    declare class BlockCandlePurple extends cn.nukkit.block.BlockCandle {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        toCakeForm(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockCandlePurple" {
    declare const BlockCandlePurple = cn.nukkit.block.BlockCandlePurple;
}

declare namespace cn.nukkit.block {
    declare class BlockSpruceWallSign extends cn.nukkit.block.BlockWallSign {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        getPostId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockSpruceWallSign" {
    declare const BlockSpruceWallSign = cn.nukkit.block.BlockSpruceWallSign;
}

declare namespace cn.nukkit.block {
    declare class BlockBricksNetherCracked extends cn.nukkit.block.BlockBricksNether {
        public constructor(): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockBricksNetherCracked" {
    declare const BlockBricksNetherCracked = cn.nukkit.block.BlockBricksNetherCracked;
}

declare namespace cn.nukkit.block {
    declare class BlockCropsStem extends cn.nukkit.block.BlockCrops implements cn.nukkit.utils.Faceable {
        constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getFruitId(): int
        public getSeedsId(): int
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public onUpdate(type: int): int
        public growFruit(): boolean
        public toItem(): cn.nukkit.item.Item
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public clone(): cn.nukkit.block.BlockCropsStem
        public clone(): cn.nukkit.block.Block
        public clone(): cn.nukkit.math.AxisAlignedBB
        public clone(): cn.nukkit.level.Position
        public clone(): cn.nukkit.positiontracking.NamedPosition
        public clone(): cn.nukkit.math.Vector3
        public clone(): java.lang.Object
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        static dropChances: double[][]
        static $assertionsDisabled: boolean

    }
}

declare module "cn.nukkit.block.BlockCropsStem" {
    declare const BlockCropsStem = cn.nukkit.block.BlockCropsStem;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsStoneBrick extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getToolType(): int
        public getToolTier(): int
        public getHardness(): double
        public getResistance(): double
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStairsStoneBrick" {
    declare const BlockStairsStoneBrick = cn.nukkit.block.BlockStairsStoneBrick;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabWarped extends cn.nukkit.block.BlockSlab {
        public constructor(): void
        public constructor(meta: int): void
        public getSlabName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean
        public getToolType(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getResistance(): double
        public toItem(): cn.nukkit.item.Item
        public getBurnChance(): int
        public getBurnAbility(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockSlabWarped" {
    declare const BlockSlabWarped = cn.nukkit.block.BlockSlabWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsSmoothSandstone extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsSmoothSandstone" {
    declare const BlockStairsSmoothSandstone = cn.nukkit.block.BlockStairsSmoothSandstone;
}

declare namespace cn.nukkit.block {
    declare class BlockCauldron extends cn.nukkit.block.BlockSolidMeta implements cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockEntityType(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityCauldron>
        public getName(): string
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public canBeActivated(): boolean
        public isFull(): boolean
        public isEmpty(): boolean
        public getFillLevel(): int
        public setFillLevel(fillLevel: int): void
        public getCauldronLiquid(): cn.nukkit.blockproperty.value.CauldronLiquid
        public setCauldronLiquid(liquid: cn.nukkit.blockproperty.value.CauldronLiquid): void
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        replaceBucket(oldBucket: cn.nukkit.item.Item, player: cn.nukkit.Player, newBucket: cn.nukkit.item.Item): void
        consumePotion(item: cn.nukkit.item.Item, player: cn.nukkit.Player): void
        public clearWithFizz(cauldron: cn.nukkit.blockentity.BlockEntityCauldron): void
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getToolTier(): int
        public toItem(): cn.nukkit.item.Item
        public hasComparatorInputOverride(): boolean
        public getComparatorInputOverride(): int
        public canHarvestWithHand(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public isTransparent(): boolean
        public getLightFilter(): int
        public static FILL_LEVEL: cn.nukkit.blockproperty.IntBlockProperty
        public static LIQUID: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.CauldronLiquid>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCauldron" {
    declare const BlockCauldron = cn.nukkit.block.BlockCauldron;
}

declare namespace cn.nukkit.block {
    declare class BlockBanner extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.Faceable, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockEntityType(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityBanner>
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getName(): string
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public canPassThrough(): boolean
        public getWaterloggingLevel(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public toItem(): cn.nukkit.item.Item
        public getDirection(): cn.nukkit.math.CompassRoseDirection
        public setDirection(direction: cn.nukkit.math.CompassRoseDirection): void
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public breaksWhenMoved(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getDyeColor(): cn.nukkit.utils.DyeColor
        public isSolid(): boolean
        static log: org.apache.logging.log4j.Logger

    }
}

declare module "cn.nukkit.block.BlockBanner" {
    declare const BlockBanner = cn.nukkit.block.BlockBanner;
}

declare namespace cn.nukkit.block {
    declare class BlockButtonMangrove extends cn.nukkit.block.BlockButtonWooden {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockButtonMangrove" {
    declare const BlockButtonMangrove = cn.nukkit.block.BlockButtonMangrove;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperCutWaxed extends cn.nukkit.block.BlockCopperCut {
        public constructor(): void
        public getName(): string
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockCopperCutWaxed" {
    declare const BlockCopperCutWaxed = cn.nukkit.block.BlockCopperCutWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabWood extends cn.nukkit.block.BlockDoubleSlabBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType
        public setWoodType(type: cn.nukkit.blockproperty.value.WoodType): void
        public getSlabName(): string
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getSingleSlabId(): int
        isCorrectTool(item: cn.nukkit.item.Item): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabWood" {
    declare const BlockDoubleSlabWood = cn.nukkit.block.BlockDoubleSlabWood;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazedLime extends cn.nukkit.block.BlockTerracottaGlazed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getDyeColor(): cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazedLime" {
    declare const BlockTerracottaGlazedLime = cn.nukkit.block.BlockTerracottaGlazedLime;
}

declare namespace cn.nukkit.block {
    declare class BlockNoteblock extends cn.nukkit.block.BlockSolid implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getToolType(): int
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityMusic>
        public getBlockEntityType(): string
        public getHardness(): double
        public getResistance(): double
        public canBeActivated(): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onTouch(player: cn.nukkit.Player, action: cn.nukkit.event.player.PlayerInteractEvent$Action): int
        public getStrength(): int
        public increaseStrength(): void
        public getInstrument(): cn.nukkit.block.BlockNoteblock$Instrument
        public emitSound(): void
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockNoteblock" {
    declare const BlockNoteblock = cn.nukkit.block.BlockNoteblock;
}

declare namespace cn.nukkit.block {
    declare class BlockGlassPane extends cn.nukkit.block.BlockThin {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getResistance(): double
        public getWaterloggingLevel(): int
        public getHardness(): double
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor
        public canSilkTouch(): boolean

    }
}

declare module "cn.nukkit.block.BlockGlassPane" {
    declare const BlockGlassPane = cn.nukkit.block.BlockGlassPane;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleGray extends cn.nukkit.block.BlockCandle {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        toCakeForm(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockCandleGray" {
    declare const BlockCandleGray = cn.nukkit.block.BlockCandleGray;
}

declare namespace cn.nukkit.block {
    declare class BlockStairMangrove extends cn.nukkit.block.BlockStairsWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStairMangrove" {
    declare const BlockStairMangrove = cn.nukkit.block.BlockStairMangrove;
}

declare namespace cn.nukkit.block {
    declare class BlockNetheriteBlock extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getToolType(): int
        public getHardness(): double
        public getResistance(): double
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean
        public isLavaResistant(): boolean

    }
}

declare module "cn.nukkit.block.BlockNetheriteBlock" {
    declare const BlockNetheriteBlock = cn.nukkit.block.BlockNetheriteBlock;
}

declare namespace cn.nukkit.block {
    declare class BlockBambooSapling extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public grow(up: cn.nukkit.block.Block): boolean
        isSupportInvalid(): boolean
        public getResistance(): double
        public getAge(): int
        public setAge(age: int): void
        public toItem(): cn.nukkit.item.Item
        public getMinX(): double
        public getMaxX(): double
        public getMinZ(): double
        public getMaxZ(): double
        public getMaxY(): double
        public getColor(): cn.nukkit.utils.BlockColor
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockBambooSapling" {
    declare const BlockBambooSapling = cn.nukkit.block.BlockBambooSapling;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabCopperCutWaxed extends cn.nukkit.block.BlockSlabCopperCut {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockSlabCopperCutWaxed" {
    declare const BlockSlabCopperCutWaxed = cn.nukkit.block.BlockSlabCopperCutWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockOreCopperDeepslate extends cn.nukkit.block.BlockOreCopper {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockOreCopperDeepslate" {
    declare const BlockOreCopperDeepslate = cn.nukkit.block.BlockOreCopperDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabStone4 extends cn.nukkit.block.BlockSlab {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getSlabType(): cn.nukkit.blockproperty.value.StoneSlab4Type
        public setSlabType(type: cn.nukkit.blockproperty.value.StoneSlab4Type): void
        public getSlabName(): string
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getToolTier(): int
        public getToolType(): int
        public canHarvestWithHand(): boolean
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static MOSSY_STONE_BRICKS: int
        public static SMOOTH_QUARTZ: int
        public static STONE: int
        public static CUT_SANDSTONE: int
        public static CUT_RED_SANDSTONE: int

    }
}

declare module "cn.nukkit.block.BlockSlabStone4" {
    declare const BlockSlabStone4 = cn.nukkit.block.BlockSlabStone4;
}

declare namespace cn.nukkit.block {
    declare class BlockCoralFan extends cn.nukkit.block.BlockFlowable implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public getWaterloggingLevel(): int
        public isDead(): boolean
        public getType(): int
        public getBlockFace(): cn.nukkit.math.BlockFace
        public getRootsFace(): cn.nukkit.math.BlockFace
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canSilkTouch(): boolean
        public toItem(): cn.nukkit.item.Item
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public static FAN_DIRECTION: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.math.BlockFace$Axis>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCoralFan" {
    declare const BlockCoralFan = cn.nukkit.block.BlockCoralFan;
}

declare namespace cn.nukkit.block {
    declare class BlockRedstoneRepeater extends cn.nukkit.block.BlockRedstoneDiode {
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public constructor(): void
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getFacing(): cn.nukkit.math.BlockFace
        isAlternateInput(block: cn.nukkit.block.Block): boolean
        public toItem(): cn.nukkit.item.Item
        getDelay(): int
        public isLocked(): boolean
        static REPEATER_DELAY: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockRedstoneRepeater" {
    declare const BlockRedstoneRepeater = cn.nukkit.block.BlockRedstoneRepeater;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabCopperCutOxidizedWaxed extends cn.nukkit.block.BlockDoubleSlabCopperCutOxidized {
        public constructor(): void
        public constructor(meta: int): void
        public getSingleSlabId(): int
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabCopperCutOxidizedWaxed" {
    declare const BlockDoubleSlabCopperCutOxidizedWaxed = cn.nukkit.block.BlockDoubleSlabCopperCutOxidizedWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockDeepslate extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canSilkTouch(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockDeepslate" {
    declare const BlockDeepslate = cn.nukkit.block.BlockDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockObsidian extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getToolType(): int
        public getToolTier(): int
        public getHardness(): double
        public getResistance(): double
        public onBreak(item: cn.nukkit.item.Item): boolean
        public afterRemoval(newBlock: cn.nukkit.block.Block, update: boolean): void
        public getColor(): cn.nukkit.utils.BlockColor
        public canBePushed(): boolean
        public canBePulled(): boolean
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockObsidian" {
    declare const BlockObsidian = cn.nukkit.block.BlockObsidian;
}

declare namespace cn.nukkit.block {
    declare class BlockHyphaeWarped extends cn.nukkit.block.BlockStem {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        getStrippedState(): cn.nukkit.blockstate.BlockState
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockHyphaeWarped" {
    declare const BlockHyphaeWarped = cn.nukkit.block.BlockHyphaeWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockCaveVinesHeadWithBerries extends cn.nukkit.block.BlockCaveVines {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public isTransparent(): boolean
        public getLightLevel(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public static AGE_PROPERTY: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCaveVinesHeadWithBerries" {
    declare const BlockCaveVinesHeadWithBerries = cn.nukkit.block.BlockCaveVinesHeadWithBerries;
}

declare namespace cn.nukkit.block {
    declare class BlockHyphaeStrippedCrimson extends cn.nukkit.block.BlockStemStripped {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockHyphaeStrippedCrimson" {
    declare const BlockHyphaeStrippedCrimson = cn.nukkit.block.BlockHyphaeStrippedCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabCopperCutOxidized extends cn.nukkit.block.BlockSlabCopperCut {
        public constructor(): void
        public constructor(meta: int): void
        constructor(meta: int, doubleSlab: int): void
        public getId(): int
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockSlabCopperCutOxidized" {
    declare const BlockSlabCopperCutOxidized = cn.nukkit.block.BlockSlabCopperCutOxidized;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsSmoothQuartz extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsSmoothQuartz" {
    declare const BlockStairsSmoothQuartz = cn.nukkit.block.BlockStairsSmoothQuartz;
}

declare namespace cn.nukkit.block {
    declare class BlockCoralFanHang2 extends cn.nukkit.block.BlockCoralFanHang {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getType(): int
        public static HANG2_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.CoralType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCoralFanHang2" {
    declare const BlockCoralFanHang2 = cn.nukkit.block.BlockCoralFanHang2;
}

declare namespace cn.nukkit.block {
    declare class BlockDoublePlant$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$blockproperty$value$DoublePlantType: int[]

    }
}

declare module "cn.nukkit.block.BlockDoublePlant$1" {
    declare const BlockDoublePlant$1 = cn.nukkit.block.BlockDoublePlant$1;
}

declare namespace cn.nukkit.block {
    declare class BlockWood$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$blockproperty$value$WoodType: int[]

    }
}

declare module "cn.nukkit.block.BlockWood$1" {
    declare const BlockWood$1 = cn.nukkit.block.BlockWood$1;
}

declare namespace cn.nukkit.block {
    declare class BlockInfestedDeepslate extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public getToolType(): int
        public getToolTier(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockInfestedDeepslate" {
    declare const BlockInfestedDeepslate = cn.nukkit.block.BlockInfestedDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsCobblestone extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsCobblestone" {
    declare const BlockStairsCobblestone = cn.nukkit.block.BlockStairsCobblestone;
}

declare namespace cn.nukkit.block {
    declare class BlockAcaciaSignPost extends cn.nukkit.block.BlockSignPost {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getWallId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockAcaciaSignPost" {
    declare const BlockAcaciaSignPost = cn.nukkit.block.BlockAcaciaSignPost;
}

declare namespace cn.nukkit.block {
    declare class BlockEndGateway extends cn.nukkit.block.BlockSolid implements cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityEndGateway>
        public getBlockEntityType(): string
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canPassThrough(): boolean
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public getHardness(): double
        public getResistance(): double
        public getLightLevel(): int
        public hasEntityCollision(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public toItem(): cn.nukkit.item.Item
        public canBePushed(): boolean
        public canBePulled(): boolean
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void

    }
}

declare module "cn.nukkit.block.BlockEndGateway" {
    declare const BlockEndGateway = cn.nukkit.block.BlockEndGateway;
}

declare namespace cn.nukkit.block {
    declare class BlockWallBlackstone extends cn.nukkit.block.BlockWallBase {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getResistance(): double
        public getHardness(): double
        public getToolTier(): int

    }
}

declare module "cn.nukkit.block.BlockWallBlackstone" {
    declare const BlockWallBlackstone = cn.nukkit.block.BlockWallBlackstone;
}

declare namespace cn.nukkit.block {
    declare class BlockJungleSignPost extends cn.nukkit.block.BlockSignPost {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getWallId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockJungleSignPost" {
    declare const BlockJungleSignPost = cn.nukkit.block.BlockJungleSignPost;
}

declare namespace cn.nukkit.block {
    declare class BlockConcretePowder extends cn.nukkit.block.BlockFallableMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, b: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getDyeColor(): cn.nukkit.utils.DyeColor
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockConcretePowder" {
    declare const BlockConcretePowder = cn.nukkit.block.BlockConcretePowder;
}

declare namespace cn.nukkit.block {
    declare class BlockRawCopper extends cn.nukkit.block.BlockRaw {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int

    }
}

declare module "cn.nukkit.block.BlockRawCopper" {
    declare const BlockRawCopper = cn.nukkit.block.BlockRawCopper;
}

declare namespace cn.nukkit.block {
    declare class BlockSapling$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$blockproperty$value$WoodType: int[]

    }
}

declare module "cn.nukkit.block.BlockSapling$1" {
    declare const BlockSapling$1 = cn.nukkit.block.BlockSapling$1;
}

declare namespace cn.nukkit.block {
    declare class BlockFrogSpawn extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public supportable(pos: cn.nukkit.level.Position): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canBePushed(): boolean
        public canBePulled(): boolean

    }
}

declare module "cn.nukkit.block.BlockFrogSpawn" {
    declare const BlockFrogSpawn = cn.nukkit.block.BlockFrogSpawn;
}

declare namespace cn.nukkit.block {
    declare class BlockGrassPath extends cn.nukkit.block.BlockGrass {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getToolType(): int
        public getMaxY(): double
        public getHardness(): double
        public getResistance(): double
        public getColor(): cn.nukkit.utils.BlockColor
        public canSilkTouch(): boolean
        public onUpdate(type: int): int
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public isTransparent(): boolean

    }
}

declare module "cn.nukkit.block.BlockGrassPath" {
    declare const BlockGrassPath = cn.nukkit.block.BlockGrassPath;
}

declare namespace cn.nukkit.block {
    declare class BlockMushroom extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public grow(): boolean
        public canStay(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public canSilkTouch(): boolean
        public getToolType(): int
        public getToolTier(): int
        getType(): int

    }
}

declare module "cn.nukkit.block.BlockMushroom" {
    declare const BlockMushroom = cn.nukkit.block.BlockMushroom;
}

declare namespace cn.nukkit.block {
    declare class BlockOreIronDeepslate extends cn.nukkit.block.BlockOreIron {
        public constructor(): void
        public getId(): int
        public getHardness(): double
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockOreIronDeepslate" {
    declare const BlockOreIronDeepslate = cn.nukkit.block.BlockOreIronDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockCaveVines extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public isTransparent(): boolean
        public isSolid(): boolean
        public static isValidSupport(block: cn.nukkit.block.Block): boolean
        public canBeActivated(): boolean
        public onUpdate(type: int): int
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        getMaxGrowth(): int
        getGrowth(): int
        setGrowth(growth: int): void
        public static AGE_PROPERTY: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCaveVines" {
    declare const BlockCaveVines = cn.nukkit.block.BlockCaveVines;
}

declare namespace cn.nukkit.block {
    declare class BlockRootsHanging extends cn.nukkit.block.BlockRoots {
        public constructor(): void
        public getName(): string
        public getId(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        isSupportValid(): boolean

    }
}

declare module "cn.nukkit.block.BlockRootsHanging" {
    declare const BlockRootsHanging = cn.nukkit.block.BlockRootsHanging;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazedPink extends cn.nukkit.block.BlockTerracottaGlazed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getDyeColor(): cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazedPink" {
    declare const BlockTerracottaGlazedPink = cn.nukkit.block.BlockTerracottaGlazedPink;
}

declare namespace cn.nukkit.block {
    declare class BlockGlowLichen extends cn.nukkit.block.BlockLichen {
        public constructor(): void
        public getName(): string
        public getId(): int
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        getCandidates(): java.util.Map<cn.nukkit.block.Block, cn.nukkit.math.BlockFace>
        public canBeActivated(): boolean
        public getLightLevel(): int
        isSupportNeighborAdded(candidates: java.util.Map<cn.nukkit.block.Block, cn.nukkit.math.BlockFace>, side: cn.nukkit.math.BlockFace, supportNeighbor: cn.nukkit.block.Block): boolean
        shouldAddSupportNeighborOppositeSide(side: cn.nukkit.math.BlockFace, supportNeighborOppositeSide: cn.nukkit.block.Block): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockGlowLichen" {
    declare const BlockGlowLichen = cn.nukkit.block.BlockGlowLichen;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperExposedWaxed extends cn.nukkit.block.BlockCopperExposed {
        public constructor(): void
        public getName(): string
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockCopperExposedWaxed" {
    declare const BlockCopperExposedWaxed = cn.nukkit.block.BlockCopperExposedWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockPressurePlateAcacia extends cn.nukkit.block.BlockPressurePlateWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockPressurePlateAcacia" {
    declare const BlockPressurePlateAcacia = cn.nukkit.block.BlockPressurePlateAcacia;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsRedNetherBrick extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsRedNetherBrick" {
    declare const BlockStairsRedNetherBrick = cn.nukkit.block.BlockStairsRedNetherBrick;
}

declare namespace cn.nukkit.block {
    declare class BlockRedstoneRepeaterPowered extends cn.nukkit.block.BlockRedstoneRepeater {
        public constructor(): void
        public getId(): int
        public getName(): string
        getPowered(): cn.nukkit.block.Block
        getUnpowered(): cn.nukkit.block.Block
        public getLightLevel(): int

    }
}

declare module "cn.nukkit.block.BlockRedstoneRepeaterPowered" {
    declare const BlockRedstoneRepeaterPowered = cn.nukkit.block.BlockRedstoneRepeaterPowered;
}

declare namespace cn.nukkit.block {
    declare class BlockItemFrame extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.block.BlockEntityHolder, cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public isStoringMap(): boolean
        public setStoringMap(map: boolean): void
        public isStoringPhoto(): boolean
        public setStoringPhoto(hasPhoto: boolean): void
        public getBlockEntityType(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityItemFrame>
        public getName(): string
        public onUpdate(type: int): int
        public canBeActivated(): boolean
        public getWaterloggingLevel(): int
        public onTouch(player: cn.nukkit.Player, action: cn.nukkit.event.player.PlayerInteractEvent$Action): int
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public toItem(): cn.nukkit.item.Item
        public canPassThrough(): boolean
        public hasComparatorInputOverride(): boolean
        public getComparatorInputOverride(): int
        public getFacing(): cn.nukkit.math.BlockFace
        public getHardness(): double
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public static HAS_MAP: cn.nukkit.blockproperty.BooleanBlockProperty
        public static HAS_PHOTO: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockItemFrame" {
    declare const BlockItemFrame = cn.nukkit.block.BlockItemFrame;
}

declare namespace cn.nukkit.block {
    declare class BlockFenceMangrove extends cn.nukkit.block.BlockFenceBase {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getBurnChance(): int
        public getBurnAbility(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockFenceMangrove" {
    declare const BlockFenceMangrove = cn.nukkit.block.BlockFenceMangrove;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabStone extends cn.nukkit.block.BlockSlab {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getSlabName(): string
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean
        public getToolTier(): int
        public getToolType(): int
        public getSlabType(): cn.nukkit.blockproperty.value.StoneSlab1Type
        public setSlabType(type: cn.nukkit.blockproperty.value.StoneSlab1Type): void
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static STONE: int
        public static SANDSTONE: int
        public static WOODEN: int
        public static COBBLESTONE: int
        public static BRICK: int
        public static STONE_BRICK: int
        public static QUARTZ: int
        public static NETHER_BRICK: int

    }
}

declare module "cn.nukkit.block.BlockSlabStone" {
    declare const BlockSlabStone = cn.nukkit.block.BlockSlabStone;
}

declare namespace cn.nukkit.block {
    declare class BlockDoorDarkOak extends cn.nukkit.block.BlockDoorWood {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoorDarkOak" {
    declare const BlockDoorDarkOak = cn.nukkit.block.BlockDoorDarkOak;
}

declare namespace cn.nukkit.block {
    declare class BlockRedstoneTorch extends cn.nukkit.block.BlockTorch implements cn.nukkit.utils.RedstoneComponent {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getLightLevel(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getWeakPower(side: cn.nukkit.math.BlockFace): int
        public getStrongPower(side: cn.nukkit.math.BlockFace): int
        public onBreak(item: cn.nukkit.item.Item): boolean
        public onUpdate(type: int): int
        checkState(): boolean
        isPoweredFromSide(): boolean
        public tickRate(): int
        public isPowerSource(): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockRedstoneTorch" {
    declare const BlockRedstoneTorch = cn.nukkit.block.BlockRedstoneTorch;
}

declare namespace cn.nukkit.block {
    declare class BlockIronBars extends cn.nukkit.block.BlockThin {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getWaterloggingLevel(): int
        public getResistance(): double
        public getToolType(): int
        public toItem(): cn.nukkit.item.Item
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockIronBars" {
    declare const BlockIronBars = cn.nukkit.block.BlockIronBars;
}

declare namespace cn.nukkit.block {
    declare class BlockAcaciaWallSign extends cn.nukkit.block.BlockWallSign {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        getPostId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockAcaciaWallSign" {
    declare const BlockAcaciaWallSign = cn.nukkit.block.BlockAcaciaWallSign;
}

declare namespace cn.nukkit.block {
    declare class BlockDragonEgg extends cn.nukkit.block.BlockFallable {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getLightLevel(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public isTransparent(): boolean
        public getWaterloggingLevel(): int
        public onUpdate(type: int): int
        public onTouch(player: cn.nukkit.Player, action: cn.nukkit.event.player.PlayerInteractEvent$Action): int
        public teleport(): void
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean

    }
}

declare module "cn.nukkit.block.BlockDragonEgg" {
    declare const BlockDragonEgg = cn.nukkit.block.BlockDragonEgg;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperOxidized extends cn.nukkit.block.BlockCopper {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel

    }
}

declare module "cn.nukkit.block.BlockCopperOxidized" {
    declare const BlockCopperOxidized = cn.nukkit.block.BlockCopperOxidized;
}

declare namespace cn.nukkit.block {
    declare class BlockEndPortalFrame extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getResistance(): double
        public getHardness(): double
        public getLightLevel(): int
        public getWaterloggingLevel(): int
        public getName(): string
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public getMaxY(): double
        public canBePushed(): boolean
        public canBePulled(): boolean
        public hasComparatorInputOverride(): boolean
        public getComparatorInputOverride(): int
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public createPortal(): void
        searchCenter(visited: java.util.List<cn.nukkit.block.Block>): cn.nukkit.math.Vector3
        checkFrame(block: cn.nukkit.block.Block): boolean
        checkFrame(block: cn.nukkit.block.Block, x: int, z: int): boolean
        public canHarvestWithHand(): boolean
        public toItem(): cn.nukkit.item.Item
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public isEndPortalEye(): boolean
        public setEndPortalEye(endPortalEye: boolean): void
        public static END_PORTAL_EYE: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        static FACES: int[]

    }
}

declare module "cn.nukkit.block.BlockEndPortalFrame" {
    declare const BlockEndPortalFrame = cn.nukkit.block.BlockEndPortalFrame;
}

declare namespace cn.nukkit.block {
    declare class BlockSculkShrieker extends cn.nukkit.block.BlockSolid implements cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public canBePulled(): boolean
        public canBePushed(): boolean
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntitySculkShrieker>
        public getBlockEntityType(): string
        public static ACTIVE: cn.nukkit.blockproperty.BooleanBlockProperty
        public static CAN_SUMMON: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockSculkShrieker" {
    declare const BlockSculkShrieker = cn.nukkit.block.BlockSculkShrieker;
}

declare namespace cn.nukkit.block {
    declare class BlockCommandBlockRepeating extends cn.nukkit.block.BlockCommandBlock {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockCommandBlockRepeating" {
    declare const BlockCommandBlockRepeating = cn.nukkit.block.BlockCommandBlockRepeating;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperCutOxidizedWaxed extends cn.nukkit.block.BlockCopperCutOxidized {
        public constructor(): void
        public getName(): string
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockCopperCutOxidizedWaxed" {
    declare const BlockCopperCutOxidizedWaxed = cn.nukkit.block.BlockCopperCutOxidizedWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockFenceGateWarped extends cn.nukkit.block.BlockFenceGate {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockFenceGateWarped" {
    declare const BlockFenceGateWarped = cn.nukkit.block.BlockFenceGateWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockOreIron extends cn.nukkit.block.BlockOre {
        public constructor(): void
        public getId(): int
        public getName(): string
        getRawMaterial(): cn.nukkit.item.MinecraftItemID

    }
}

declare module "cn.nukkit.block.BlockOreIron" {
    declare const BlockOreIron = cn.nukkit.block.BlockOreIron;
}

declare namespace cn.nukkit.block {
    declare class BlockDoorCrimson extends cn.nukkit.block.BlockDoorWood {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockDoorCrimson" {
    declare const BlockDoorCrimson = cn.nukkit.block.BlockDoorCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperBase$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$blockproperty$value$OxidizationLevel: int[]

    }
}

declare module "cn.nukkit.block.BlockCopperBase$1" {
    declare const BlockCopperBase$1 = cn.nukkit.block.BlockCopperBase$1;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabTileDeepslate extends cn.nukkit.block.BlockSlab {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getSlabName(): string
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public getToolTier(): int
        public getToolType(): int
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockSlabTileDeepslate" {
    declare const BlockSlabTileDeepslate = cn.nukkit.block.BlockSlabTileDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockStonecutter extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public getWaterloggingLevel(): int

    }
}

declare module "cn.nukkit.block.BlockStonecutter" {
    declare const BlockStonecutter = cn.nukkit.block.BlockStonecutter;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabMangrove extends cn.nukkit.block.BlockDoubleSlabBase {
        public constructor(): void
        constructor(meta: int): void
        public getSlabName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getSingleSlabId(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabMangrove" {
    declare const BlockDoubleSlabMangrove = cn.nukkit.block.BlockDoubleSlabMangrove;
}

declare namespace cn.nukkit.block {
    declare class BlockRedstoneWire extends cn.nukkit.block.BlockFlowable implements cn.nukkit.utils.RedstoneComponent {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        updateAround(pos: cn.nukkit.level.Position, face: cn.nukkit.math.BlockFace): void
        updateSurroundingRedstone(force: boolean): void
        calculateCurrentChanges(force: boolean): void
        getMaxCurrentStrength(pos: cn.nukkit.math.Vector3, maxStrength: int): int
        public onBreak(item: cn.nukkit.item.Item): boolean
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor
        public onUpdate(type: int): int
        public canBePlacedOn(support: cn.nukkit.block.Block): boolean
        public getStrongPower(side: cn.nukkit.math.BlockFace): int
        public getWeakPower(side: cn.nukkit.math.BlockFace): int
        isPowerSourceAt(side: cn.nukkit.math.BlockFace): boolean
        static canConnectUpwardsTo(level: cn.nukkit.level.Level, pos: cn.nukkit.math.Vector3): boolean
        static canConnectUpwardsTo(block: cn.nukkit.block.Block): boolean
        static canConnectTo(block: cn.nukkit.block.Block, side: cn.nukkit.math.BlockFace): boolean
        public isPowerSource(): boolean
        getIndirectPower(): int
        getIndirectPower(pos: cn.nukkit.math.Vector3, face: cn.nukkit.math.BlockFace): int
        getStrongPower(pos: cn.nukkit.math.Vector3): int
        getStrongPower(pos: cn.nukkit.math.Vector3, direction: cn.nukkit.math.BlockFace): int
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        canProvidePower: boolean
        blocksNeedingUpdate: java.util.Set<cn.nukkit.math.Vector3>

    }
}

declare module "cn.nukkit.block.BlockRedstoneWire" {
    declare const BlockRedstoneWire = cn.nukkit.block.BlockRedstoneWire;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazedCyan extends cn.nukkit.block.BlockTerracottaGlazed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getDyeColor(): cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazedCyan" {
    declare const BlockTerracottaGlazedCyan = cn.nukkit.block.BlockTerracottaGlazedCyan;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCakeLightBlue extends cn.nukkit.block.BlockCandleCake {
        public constructor(meta: int): void
        public constructor(): void
        getColorName(): string
        public getId(): int
        toCandleForm(): cn.nukkit.block.BlockCandle

    }
}

declare module "cn.nukkit.block.BlockCandleCakeLightBlue" {
    declare const BlockCandleCakeLightBlue = cn.nukkit.block.BlockCandleCakeLightBlue;
}

declare namespace cn.nukkit.block {
    declare class BlockMuddyMangroveRoots extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolTier(): int
        public getToolType(): int
        public isTransparent(): boolean

    }
}

declare module "cn.nukkit.block.BlockMuddyMangroveRoots" {
    declare const BlockMuddyMangroveRoots = cn.nukkit.block.BlockMuddyMangroveRoots;
}

declare namespace cn.nukkit.block {
    declare interface BlockConnectable {
        public getSideAtLayer(var0: int, var1: cn.nukkit.math.BlockFace): cn.nukkit.block.Block
        public canConnect(var0: cn.nukkit.block.Block): boolean
        public isStraight(): boolean
        public getConnections(): java.util.Set<cn.nukkit.math.BlockFace>
        public isConnected(face: cn.nukkit.math.BlockFace): boolean

    }
}

declare module "cn.nukkit.block.BlockConnectable" {
    declare type BlockConnectable = cn.nukkit.block.BlockConnectable;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabCopperCutWeatheredWaxed extends cn.nukkit.block.BlockDoubleSlabCopperCutWeathered {
        public constructor(): void
        public constructor(meta: int): void
        public getSingleSlabId(): int
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabCopperCutWeatheredWaxed" {
    declare const BlockDoubleSlabCopperCutWeatheredWaxed = cn.nukkit.block.BlockDoubleSlabCopperCutWeatheredWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabStone4 extends cn.nukkit.block.BlockDoubleSlabBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getSlabType(): cn.nukkit.blockproperty.value.StoneSlab4Type
        public setSlabType(type: cn.nukkit.blockproperty.value.StoneSlab4Type): void
        public getSlabName(): string
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public getSingleSlabId(): int
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean
        public static MOSSY_STONE_BRICKS: int
        public static SMOOTH_QUARTZ: int
        public static STONE: int
        public static CUT_SANDSTONE: int
        public static CUT_RED_SANDSTONE: int

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabStone4" {
    declare const BlockDoubleSlabStone4 = cn.nukkit.block.BlockDoubleSlabStone4;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleMagenta extends cn.nukkit.block.BlockCandle {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        toCakeForm(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockCandleMagenta" {
    declare const BlockCandleMagenta = cn.nukkit.block.BlockCandleMagenta;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperWeatheredWaxed extends cn.nukkit.block.BlockCopperWeathered {
        public constructor(): void
        public getName(): string
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockCopperWeatheredWaxed" {
    declare const BlockCopperWeatheredWaxed = cn.nukkit.block.BlockCopperWeatheredWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockMycelium extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getToolType(): int
        public getHardness(): double
        public getResistance(): double
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public onUpdate(type: int): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canSilkTouch(): boolean
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean

    }
}

declare module "cn.nukkit.block.BlockMycelium" {
    declare const BlockMycelium = cn.nukkit.block.BlockMycelium;
}

declare namespace cn.nukkit.block {
    declare class BlockGrindstone$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$math$BlockFace: int[]

    }
}

declare module "cn.nukkit.block.BlockGrindstone$1" {
    declare const BlockGrindstone$1 = cn.nukkit.block.BlockGrindstone$1;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperExposed extends cn.nukkit.block.BlockCopper {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel

    }
}

declare module "cn.nukkit.block.BlockCopperExposed" {
    declare const BlockCopperExposed = cn.nukkit.block.BlockCopperExposed;
}

declare namespace cn.nukkit.block {
    declare class BlockWaterLily extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getId(): int
        public getMinX(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxY(): double
        public getMaxZ(): double
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor
        public canPassThrough(): boolean
        public canBeFlowedInto(): boolean

    }
}

declare module "cn.nukkit.block.BlockWaterLily" {
    declare const BlockWaterLily = cn.nukkit.block.BlockWaterLily;
}

declare namespace cn.nukkit.block {
    declare class BlockItemFrameGlow extends cn.nukkit.block.BlockItemFrame {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockItemFrameGlow" {
    declare const BlockItemFrameGlow = cn.nukkit.block.BlockItemFrameGlow;
}

declare namespace cn.nukkit.block {
    declare class BlockBarrier extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getWaterloggingLevel(): int
        public canBeFlowedInto(): boolean
        public getHardness(): double
        public getResistance(): double
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public canBePushed(): boolean

    }
}

declare module "cn.nukkit.block.BlockBarrier" {
    declare const BlockBarrier = cn.nukkit.block.BlockBarrier;
}

declare namespace cn.nukkit.block {
    declare class BlockButtonWarped extends cn.nukkit.block.BlockButtonWooden {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockButtonWarped" {
    declare const BlockButtonWarped = cn.nukkit.block.BlockButtonWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockTrapdoor extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public canBeActivated(): boolean
        public getToolType(): int
        public getWaterloggingLevel(): int
        getRelativeBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getMinX(): double
        public getMaxX(): double
        public getMinY(): double
        public getMaxY(): double
        public getMinZ(): double
        public getMaxZ(): double
        public onUpdate(type: int): int
        public setManualOverride(val: boolean): void
        public getManualOverride(): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public toggle(player: cn.nukkit.Player): boolean
        public setOpen(player: cn.nukkit.Player, open: boolean): boolean
        public playOpenCloseSound(): void
        public playOpenSound(): void
        public playCloseSound(): void
        public getColor(): cn.nukkit.utils.BlockColor
        public isOpen(): boolean
        public setOpen(open: boolean): void
        public isTop(): boolean
        public setTop(top: boolean): void
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        static THICKNESS: double
        static manualOverrides: java.util.List<cn.nukkit.level.Location>
        public static TRAPDOOR_DIRECTION: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.math.BlockFace>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        static boundingBoxDamage: cn.nukkit.math.AxisAlignedBB[]
        public static TRAPDOOR_OPEN_BIT: int
        public static TRAPDOOR_TOP_BIT: int

    }
}

declare module "cn.nukkit.block.BlockTrapdoor" {
    declare const BlockTrapdoor = cn.nukkit.block.BlockTrapdoor;
}

declare namespace cn.nukkit.block {
    declare class BlockCalcite extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public isLavaResistant(): boolean
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCalcite" {
    declare const BlockCalcite = cn.nukkit.block.BlockCalcite;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsCopperCutWaxed extends cn.nukkit.block.BlockStairsCopperCut {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsCopperCutWaxed" {
    declare const BlockStairsCopperCutWaxed = cn.nukkit.block.BlockStairsCopperCutWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockPodzol extends cn.nukkit.block.BlockDirt {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getId(): int
        public getName(): string
        public getDirtType(): java.util.Optional<cn.nukkit.blockproperty.value.DirtType>
        public setDirtType(dirtType: cn.nukkit.blockproperty.value.DirtType): void
        public canSilkTouch(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockPodzol" {
    declare const BlockPodzol = cn.nukkit.block.BlockPodzol;
}

declare namespace cn.nukkit.block {
    declare class BlockPurpur extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getToolTier(): int
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static PURPUR_NORMAL: int
        public static PURPUR_PILLAR: int

    }
}

declare module "cn.nukkit.block.BlockPurpur" {
    declare const BlockPurpur = cn.nukkit.block.BlockPurpur;
}

declare namespace cn.nukkit.block {
    declare class BlockWallBanner extends cn.nukkit.block.BlockBanner {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public onUpdate(type: int): int
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setDirection(direction: cn.nukkit.math.CompassRoseDirection): void
        public getDirection(): cn.nukkit.math.CompassRoseDirection
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockWallBanner" {
    declare const BlockWallBanner = cn.nukkit.block.BlockWallBanner;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCakeRed extends cn.nukkit.block.BlockCandleCake {
        public constructor(meta: int): void
        public constructor(): void
        getColorName(): string
        public getId(): int
        toCandleForm(): cn.nukkit.block.BlockCandle

    }
}

declare module "cn.nukkit.block.BlockCandleCakeRed" {
    declare const BlockCandleCakeRed = cn.nukkit.block.BlockCandleCakeRed;
}

declare namespace cn.nukkit.block {
    declare class BlockLodestone extends cn.nukkit.block.BlockSolid implements cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public getId(): int
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityLodestone>
        public getBlockEntityType(): string
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public sticksToPiston(): boolean
        public canBePushed(): boolean
        static log: org.apache.logging.log4j.Logger

    }
}

declare module "cn.nukkit.block.BlockLodestone" {
    declare const BlockLodestone = cn.nukkit.block.BlockLodestone;
}

declare namespace cn.nukkit.block {
    declare class BlockPointedDripstone extends cn.nukkit.block.BlockFallableMeta {
        public isHanging(): int
        public setHanging(value: int): void
        public setThickness(value: string): void
        public getThickness(): string
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public canBeActivated(): boolean
        public getHardness(): double
        public getToolType(): int
        public getResistance(): double
        public getWaterloggingLevel(): int
        public canBePushed(): boolean
        public canBePulled(): boolean
        public onUpdate(type: int): int
        public tryDrop(hanging: int): void
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public onEntityFallOn(entity: cn.nukkit.entity.Entity, fallDistance: float): void
        public useDefaultFallDamage(): boolean
        setTipBlock(x: int, y: int, z: int, hanging: int): void
        setMergeBlock(x: int, y: int, z: int, hanging: int): void
        setBlockThicknessStateAt(x: int, y: int, z: int, hanging: int, thickness: string): void
        getPointedDripStoneLength(x: int, y: int, z: int, hanging: int): int
        setAddChange(x: int, y: int, z: int, hanging: int): void
        public grow(): void
        public drippingLiquid(): void
        static DRIPSTONE_THICKNESS: cn.nukkit.blockproperty.ArrayBlockProperty<string>
        static HANGING: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockPointedDripstone" {
    declare const BlockPointedDripstone = cn.nukkit.block.BlockPointedDripstone;
}

declare namespace cn.nukkit.block {
    declare class BlockGravel extends cn.nukkit.block.BlockFallable {
        public constructor(): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getName(): string
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canSilkTouch(): boolean

    }
}

declare module "cn.nukkit.block.BlockGravel" {
    declare const BlockGravel = cn.nukkit.block.BlockGravel;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsNetherBrick extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsNetherBrick" {
    declare const BlockStairsNetherBrick = cn.nukkit.block.BlockStairsNetherBrick;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabCrimson extends cn.nukkit.block.BlockDoubleSlabBase {
        public constructor(): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getSlabName(): string
        public getSingleSlabId(): int
        isCorrectTool(item: cn.nukkit.item.Item): boolean
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabCrimson" {
    declare const BlockDoubleSlabCrimson = cn.nukkit.block.BlockDoubleSlabCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaStained extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(dyeColor: cn.nukkit.utils.DyeColor): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getDyeColor(): cn.nukkit.utils.DyeColor
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockTerracottaStained" {
    declare const BlockTerracottaStained = cn.nukkit.block.BlockTerracottaStained;
}

declare namespace cn.nukkit.block {
    declare class BlockCartographyTable extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getToolType(): int
        public getResistance(): double
        public getHardness(): double
        public getColor(): cn.nukkit.utils.BlockColor
        public getBurnChance(): int
        public canHarvestWithHand(): boolean
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean

    }
}

declare module "cn.nukkit.block.BlockCartographyTable" {
    declare const BlockCartographyTable = cn.nukkit.block.BlockCartographyTable;
}

declare namespace cn.nukkit.block {
    declare class BlockBeetroot extends cn.nukkit.block.BlockCrops {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]

    }
}

declare module "cn.nukkit.block.BlockBeetroot" {
    declare const BlockBeetroot = cn.nukkit.block.BlockBeetroot;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleBrown extends cn.nukkit.block.BlockCandle {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        toCakeForm(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockCandleBrown" {
    declare const BlockCandleBrown = cn.nukkit.block.BlockCandleBrown;
}

declare namespace cn.nukkit.block {
    declare class BlockWall$WallType extends java.lang.Enum {
        public static values(): cn.nukkit.block.BlockWall$WallType[]
        public static valueOf(name: string): cn.nukkit.block.BlockWall$WallType
        constructor(var0: cn.nukkit.utils.BlockColor): void
        constructor(): void
        public getColor(): cn.nukkit.utils.BlockColor
        public getTypeName(): string
        static lambda$new$0(part: string): string
        static $values(): cn.nukkit.block.BlockWall$WallType[]
        public static COBBLESTONE: cn.nukkit.block.BlockWall$WallType
        public static MOSSY_COBBLESTONE: cn.nukkit.block.BlockWall$WallType
        public static GRANITE: cn.nukkit.block.BlockWall$WallType
        public static DIORITE: cn.nukkit.block.BlockWall$WallType
        public static ANDESITE: cn.nukkit.block.BlockWall$WallType
        public static SANDSTONE: cn.nukkit.block.BlockWall$WallType
        public static BRICK: cn.nukkit.block.BlockWall$WallType
        public static STONE_BRICK: cn.nukkit.block.BlockWall$WallType
        public static MOSSY_STONE_BRICK: cn.nukkit.block.BlockWall$WallType
        public static END_BRICK: cn.nukkit.block.BlockWall$WallType
        public static NETHER_BRICK: cn.nukkit.block.BlockWall$WallType
        public static PRISMARINE: cn.nukkit.block.BlockWall$WallType
        public static RED_SANDSTONE: cn.nukkit.block.BlockWall$WallType
        public static RED_NETHER_BRICK: cn.nukkit.block.BlockWall$WallType
        color: cn.nukkit.utils.BlockColor
        typeName: string
        static $VALUES: cn.nukkit.block.BlockWall$WallType[]

    }
}

declare module "cn.nukkit.block.BlockWall$WallType" {
    declare const BlockWall$WallType = cn.nukkit.block.BlockWall$WallType;
}

declare namespace cn.nukkit.block {
    declare class BlockWeightedPressurePlateHeavy extends cn.nukkit.block.BlockPressurePlateBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        computeRedstoneStrength(): int
        public getMaxWeight(): int

    }
}

declare module "cn.nukkit.block.BlockWeightedPressurePlateHeavy" {
    declare const BlockWeightedPressurePlateHeavy = cn.nukkit.block.BlockWeightedPressurePlateHeavy;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsBlackstone extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getResistance(): double
        public getToolType(): int
        public getHardness(): double
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsBlackstone" {
    declare const BlockStairsBlackstone = cn.nukkit.block.BlockStairsBlackstone;
}

declare namespace cn.nukkit.block {
    declare class BlockRawGold extends cn.nukkit.block.BlockRaw {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getToolTier(): int

    }
}

declare module "cn.nukkit.block.BlockRawGold" {
    declare const BlockRawGold = cn.nukkit.block.BlockRawGold;
}

declare namespace cn.nukkit.block {
    declare class BlockMud extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockMud" {
    declare const BlockMud = cn.nukkit.block.BlockMud;
}

declare namespace cn.nukkit.block {
    declare class BlockRedSandstone extends cn.nukkit.block.BlockSandstone {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item
        public canHarvestWithHand(): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockRedSandstone" {
    declare const BlockRedSandstone = cn.nukkit.block.BlockRedSandstone;
}

declare namespace cn.nukkit.block {
    declare class BlockDirtWithRoots extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public canBeActivated(): boolean
        public getToolType(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDirtWithRoots" {
    declare const BlockDirtWithRoots = cn.nukkit.block.BlockDirtWithRoots;
}

declare namespace cn.nukkit.block {
    declare class BlockSoulSoil extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public canHarvestWithHand(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public isSoulSpeedCompatible(): boolean

    }
}

declare module "cn.nukkit.block.BlockSoulSoil" {
    declare const BlockSoulSoil = cn.nukkit.block.BlockSoulSoil;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsBirch extends cn.nukkit.block.BlockStairsWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStairsBirch" {
    declare const BlockStairsBirch = cn.nukkit.block.BlockStairsBirch;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracotta extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(dyeColor: cn.nukkit.utils.TerracottaColor): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getToolType(): int
        public getHardness(): double
        public getResistance(): double
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getDyeColor(): cn.nukkit.utils.TerracottaColor

    }
}

declare module "cn.nukkit.block.BlockTerracotta" {
    declare const BlockTerracotta = cn.nukkit.block.BlockTerracotta;
}

declare namespace cn.nukkit.block {
    declare class BlockButtonJungle extends cn.nukkit.block.BlockButtonWooden {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockButtonJungle" {
    declare const BlockButtonJungle = cn.nukkit.block.BlockButtonJungle;
}

declare namespace cn.nukkit.block {
    declare class BlockGrass extends cn.nukkit.block.BlockDirt {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getName(): string
        public getDirtType(): java.util.Optional<cn.nukkit.blockproperty.value.DirtType>
        public setDirtType(dirtType: cn.nukkit.blockproperty.value.DirtType): void
        public onActivate(item: cn.nukkit.item.Item): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canSilkTouch(): boolean

    }
}

declare module "cn.nukkit.block.BlockGrass" {
    declare const BlockGrass = cn.nukkit.block.BlockGrass;
}

declare namespace cn.nukkit.block {
    declare class BlockAmethystCluster extends cn.nukkit.block.BlockAmethystBud {
        public constructor(): void
        getNamePrefix(): string
        public getId(): int
        public getLightLevel(): int
        public getToolTier(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        static RANDOM: cn.nukkit.math.NukkitRandom

    }
}

declare module "cn.nukkit.block.BlockAmethystCluster" {
    declare const BlockAmethystCluster = cn.nukkit.block.BlockAmethystCluster;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsSmoothRedSandstone extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsSmoothRedSandstone" {
    declare const BlockStairsSmoothRedSandstone = cn.nukkit.block.BlockStairsSmoothRedSandstone;
}

declare namespace cn.nukkit.block {
    declare class BlockBlackstoneGilded extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getToolType(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canSilkTouch(): boolean
        public canHarvestWithHand(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getHardness(): double
        public getResistance(): double

    }
}

declare module "cn.nukkit.block.BlockBlackstoneGilded" {
    declare const BlockBlackstoneGilded = cn.nukkit.block.BlockBlackstoneGilded;
}

declare namespace cn.nukkit.block {
    declare class BlockThin extends cn.nukkit.block.BlockTransparent implements cn.nukkit.block.BlockConnectable {
        constructor(): void
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public canConnect(block: cn.nukkit.block.Block): boolean

    }
}

declare module "cn.nukkit.block.BlockThin" {
    declare const BlockThin = cn.nukkit.block.BlockThin;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperOxidizedWaxed extends cn.nukkit.block.BlockCopperOxidized {
        public constructor(): void
        public getName(): string
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockCopperOxidizedWaxed" {
    declare const BlockCopperOxidizedWaxed = cn.nukkit.block.BlockCopperOxidizedWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockOreGold extends cn.nukkit.block.BlockOre {
        public constructor(): void
        public getId(): int
        public getToolTier(): int
        public getName(): string
        getRawMaterial(): cn.nukkit.item.MinecraftItemID

    }
}

declare module "cn.nukkit.block.BlockOreGold" {
    declare const BlockOreGold = cn.nukkit.block.BlockOreGold;
}

declare namespace cn.nukkit.block {
    declare class BlockNyliumCrimson extends cn.nukkit.block.BlockNylium {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockNyliumCrimson" {
    declare const BlockNyliumCrimson = cn.nukkit.block.BlockNyliumCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockCocoa extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getMinX(): double
        public getMaxX(): double
        public getMinY(): double
        public getMaxY(): double
        public getMinZ(): double
        public getMaxZ(): double
        getRelativeBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getGrowthStage(): int
        public grow(): boolean
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public getWaterloggingLevel(): int
        public canBeFlowedInto(): boolean
        public toItem(): cn.nukkit.item.Item
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getBlockFace(): cn.nukkit.math.BlockFace
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        public static AGE: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        static EAST: cn.nukkit.math.AxisAlignedBB[]
        static WEST: cn.nukkit.math.AxisAlignedBB[]
        static NORTH: cn.nukkit.math.AxisAlignedBB[]
        static SOUTH: cn.nukkit.math.AxisAlignedBB[]
        static ALL: cn.nukkit.math.AxisAlignedBB[]

    }
}

declare module "cn.nukkit.block.BlockCocoa" {
    declare const BlockCocoa = cn.nukkit.block.BlockCocoa;
}

declare namespace cn.nukkit.block {
    declare class BlockSolid extends cn.nukkit.block.Block {
        constructor(): void
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockSolid" {
    declare const BlockSolid = cn.nukkit.block.BlockSolid;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabBlackstonePolished extends cn.nukkit.block.BlockDoubleSlabBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getSingleSlabId(): int
        public getSlabName(): string
        public canHarvestWithHand(): boolean
        public getToolType(): int
        public getHardness(): double
        public getResistance(): double
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabBlackstonePolished" {
    declare const BlockDoubleSlabBlackstonePolished = cn.nukkit.block.BlockDoubleSlabBlackstonePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockDaylightDetector extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getBlockEntityType(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityDaylightDetector>
        public getHardness(): double
        public getWaterloggingLevel(): int
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public toItem(): cn.nukkit.item.Item
        public canBeActivated(): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public getWeakPower(face: cn.nukkit.math.BlockFace): int
        public isPowerSource(): boolean
        public isInverted(): boolean
        public updatePower(): void
        public isSolid(): boolean
        public getMaxY(): double
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockDaylightDetector" {
    declare const BlockDaylightDetector = cn.nukkit.block.BlockDaylightDetector;
}

declare namespace cn.nukkit.block {
    declare class BlockDoorIron extends cn.nukkit.block.BlockDoor {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public canBeActivated(): boolean
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockDoorIron" {
    declare const BlockDoorIron = cn.nukkit.block.BlockDoorIron;
}

declare namespace cn.nukkit.block {
    declare class BlockCopper extends cn.nukkit.block.BlockCopperBase {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel

    }
}

declare module "cn.nukkit.block.BlockCopper" {
    declare const BlockCopper = cn.nukkit.block.BlockCopper;
}

declare namespace cn.nukkit.block {
    declare class BlockTrapdoorWarped extends cn.nukkit.block.BlockTrapdoor {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getBurnChance(): int
        public getBurnAbility(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockTrapdoorWarped" {
    declare const BlockTrapdoorWarped = cn.nukkit.block.BlockTrapdoorWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockMangroveRoots extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getId(): int
        public getWaterloggingLevel(): int
        public getHardness(): double
        public getResistance(): double
        public getBurnChance(): int
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean

    }
}

declare module "cn.nukkit.block.BlockMangroveRoots" {
    declare const BlockMangroveRoots = cn.nukkit.block.BlockMangroveRoots;
}

declare namespace cn.nukkit.block {
    declare class BlockRedstoneDiode extends cn.nukkit.block.BlockFlowable implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getWaterloggingLevel(): int
        public canBeFlowedInto(): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        isSupportValid(support: cn.nukkit.block.Block): boolean
        public onUpdate(type: int): int
        public updateState(): void
        public isLocked(): boolean
        calculateInputStrength(): int
        getPowerOnSides(): int
        getPowerOnSide(pos: cn.nukkit.math.Vector3, side: cn.nukkit.math.BlockFace): int
        public isPowerSource(): boolean
        shouldBePowered(): boolean
        public getFacing(): cn.nukkit.math.BlockFace
        getDelay(): int
        getUnpowered(): cn.nukkit.block.Block
        getPowered(): cn.nukkit.block.Block
        public getMaxY(): double
        public canPassThrough(): boolean
        isAlternateInput(block: cn.nukkit.block.Block): boolean
        public static isDiode(block: cn.nukkit.block.Block): boolean
        getRedstoneSignal(): int
        public getStrongPower(side: cn.nukkit.math.BlockFace): int
        public getWeakPower(side: cn.nukkit.math.BlockFace): int
        public canBeActivated(): boolean
        public isPowered(): boolean
        public isFacingTowardsRepeater(): boolean
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getBlockFace(): cn.nukkit.math.BlockFace
        public getColor(): cn.nukkit.utils.BlockColor
        isPowered: boolean

    }
}

declare module "cn.nukkit.block.BlockRedstoneDiode" {
    declare const BlockRedstoneDiode = cn.nukkit.block.BlockRedstoneDiode;
}

declare namespace cn.nukkit.block {
    declare class BlockMagma extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getToolType(): int
        public getHardness(): double
        public getResistance(): double
        public getLightLevel(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public onUpdate(type: int): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockMagma" {
    declare const BlockMagma = cn.nukkit.block.BlockMagma;
}

declare namespace cn.nukkit.block {
    declare class BlockDoorBirch extends cn.nukkit.block.BlockDoorWood {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoorBirch" {
    declare const BlockDoorBirch = cn.nukkit.block.BlockDoorBirch;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperCutExposed extends cn.nukkit.block.BlockCopperCut {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel

    }
}

declare module "cn.nukkit.block.BlockCopperCutExposed" {
    declare const BlockCopperCutExposed = cn.nukkit.block.BlockCopperCutExposed;
}

declare namespace cn.nukkit.block {
    declare class BlockSkull$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$math$BlockFace: int[]

    }
}

declare module "cn.nukkit.block.BlockSkull$1" {
    declare const BlockSkull$1 = cn.nukkit.block.BlockSkull$1;
}

declare namespace cn.nukkit.block {
    declare class BlockDeny extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getName(): string
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public canBePushed(): boolean
        public canBePulled(): boolean
        public canHarvestWithHand(): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public isBreakable(vector: cn.nukkit.math.Vector3, layer: int, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item, player: cn.nukkit.Player, setBlockDestroy: boolean): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]

    }
}

declare module "cn.nukkit.block.BlockDeny" {
    declare const BlockDeny = cn.nukkit.block.BlockDeny;
}

declare namespace cn.nukkit.block {
    declare class BlockGlassPaneStained extends cn.nukkit.block.BlockGlassPane {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public getDyeColor(): cn.nukkit.utils.DyeColor
        public canSilkTouch(): boolean
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockGlassPaneStained" {
    declare const BlockGlassPaneStained = cn.nukkit.block.BlockGlassPaneStained;
}

declare namespace cn.nukkit.block {
    declare class BlockObsidianCrying extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getToolType(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getLightLevel(): int
        public getToolTier(): int
        public canBePushed(): boolean
        public canBePulled(): boolean
        public canHarvestWithHand(): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockObsidianCrying" {
    declare const BlockObsidianCrying = cn.nukkit.block.BlockObsidianCrying;
}

declare namespace cn.nukkit.block {
    declare class BlockWallTileDeepslate extends cn.nukkit.block.BlockWallBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockWallTileDeepslate" {
    declare const BlockWallTileDeepslate = cn.nukkit.block.BlockWallTileDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockBricksNether extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getToolType(): int
        public getToolTier(): int
        public getHardness(): double
        public getResistance(): double
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockBricksNether" {
    declare const BlockBricksNether = cn.nukkit.block.BlockBricksNether;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabCopperCut extends cn.nukkit.block.BlockSlabCopperBase {
        public constructor(): void
        public constructor(meta: int): void
        constructor(meta: int, doubleSlab: int): void
        public getId(): int
        public getSlabName(): string
        getCopperId(waxed: boolean, oxidizationLevel: cn.nukkit.blockproperty.value.OxidizationLevel): int
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel

    }
}

declare module "cn.nukkit.block.BlockSlabCopperCut" {
    declare const BlockSlabCopperCut = cn.nukkit.block.BlockSlabCopperCut;
}

declare namespace cn.nukkit.block {
    declare class BlockBlueIce extends cn.nukkit.block.BlockIcePacked {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getFrictionFactor(): double
        public getHardness(): double
        public getResistance(): double
        public isTransparent(): boolean
        public getLightLevel(): int

    }
}

declare module "cn.nukkit.block.BlockBlueIce" {
    declare const BlockBlueIce = cn.nukkit.block.BlockBlueIce;
}

declare namespace cn.nukkit.block {
    declare class BlockCommandBlock extends cn.nukkit.block.BlockSolidMeta implements cn.nukkit.utils.Faceable, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getId(): int
        public getName(): string
        public getResistance(): double
        public canBePushed(): boolean
        public toItem(): cn.nukkit.item.Item
        public canHarvestWithHand(): boolean
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public getBlockFace(): cn.nukkit.math.BlockFace
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public hasComparatorInputOverride(): boolean
        public getComparatorInputOverride(): int
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityCommandBlock>
        public getBlockEntityType(): string
        public static CONDITIONAL_BIT: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCommandBlock" {
    declare const BlockCommandBlock = cn.nukkit.block.BlockCommandBlock;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCake extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(meta: int): void
        public constructor(): void
        public getName(): string
        getColorName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public canBeActivated(): boolean
        public getHardness(): double
        public getResistance(): double
        public getWaterloggingLevel(): int
        public getMinX(): double
        public getMinY(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxY(): double
        public getMaxZ(): double
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        toCandleForm(): cn.nukkit.block.BlockCandle
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public toItem(): cn.nukkit.item.Item
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getComparatorInputOverride(): int
        public hasComparatorInputOverride(): boolean
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        static LIT: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCandleCake" {
    declare const BlockCandleCake = cn.nukkit.block.BlockCandleCake;
}

declare namespace cn.nukkit.block {
    declare class BlockWarpedWallSign extends cn.nukkit.block.BlockWallSign {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        getPostId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockWarpedWallSign" {
    declare const BlockWarpedWallSign = cn.nukkit.block.BlockWarpedWallSign;
}

declare namespace cn.nukkit.block {
    declare class BlockDriedKelpBlock extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDriedKelpBlock" {
    declare const BlockDriedKelpBlock = cn.nukkit.block.BlockDriedKelpBlock;
}

declare namespace cn.nukkit.block {
    declare class BlockBarrel extends cn.nukkit.block.BlockSolidMeta implements cn.nukkit.utils.Faceable, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockEntityType(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityBarrel>
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public canBeActivated(): boolean
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public toItem(): cn.nukkit.item.Item
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public isOpen(): boolean
        public setOpen(open: boolean): void
        public hasComparatorInputOverride(): boolean
        public getComparatorInputOverride(): int
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockBarrel" {
    declare const BlockBarrel = cn.nukkit.block.BlockBarrel;
}

declare namespace cn.nukkit.block {
    declare class BlockIce extends cn.nukkit.block.BlockTransparent {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getResistance(): double
        public getHardness(): double
        public getFrictionFactor(): double
        public getToolType(): int
        public onBreak(item: cn.nukkit.item.Item): boolean
        public onUpdate(type: int): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor
        public canSilkTouch(): boolean
        public getLightFilter(): int

    }
}

declare module "cn.nukkit.block.BlockIce" {
    declare const BlockIce = cn.nukkit.block.BlockIce;
}

declare namespace cn.nukkit.block {
    declare class BlockFenceGate$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$math$BlockFace: int[]

    }
}

declare module "cn.nukkit.block.BlockFenceGate$1" {
    declare const BlockFenceGate$1 = cn.nukkit.block.BlockFenceGate$1;
}

declare namespace cn.nukkit.block {
    declare class BlockRespawnAnchor extends cn.nukkit.block.BlockMeta {
        public getId(): int
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        attemptToSetSpawn(player: cn.nukkit.Player): boolean
        public explode(): void
        public getCharge(): int
        public setCharge(charge: int): void
        public getToolType(): int
        public getToolTier(): int
        public getResistance(): double
        public getHardness(): double
        public getLightLevel(): int
        public onUpdate(type: int): int
        public canSilkTouch(): boolean
        public canHarvestWithHand(): boolean
        public canBeActivated(): boolean
        public canBePushed(): boolean
        public canBePulled(): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor
        public static RESPAWN_ANCHOR_CHARGE: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockRespawnAnchor" {
    declare const BlockRespawnAnchor = cn.nukkit.block.BlockRespawnAnchor;
}

declare namespace cn.nukkit.block {
    declare class BlockWallBrickBlackstonePolished extends cn.nukkit.block.BlockWallBlackstonePolished {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double

    }
}

declare module "cn.nukkit.block.BlockWallBrickBlackstonePolished" {
    declare const BlockWallBrickBlackstonePolished = cn.nukkit.block.BlockWallBrickBlackstonePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockBell extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.utils.Faceable, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityBell>
        public getBlockEntityType(): string
        isConnectedTo(connectedFace: cn.nukkit.math.BlockFace, attachmentType: cn.nukkit.blockproperty.value.AttachmentType, blockFace: cn.nukkit.math.BlockFace): boolean
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public hasEntityCollision(): boolean
        recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public ring(causeEntity: cn.nukkit.entity.Entity, cause: cn.nukkit.event.block.BellRingEvent$RingCause): boolean
        public ring(causeEntity: cn.nukkit.entity.Entity, cause: cn.nukkit.event.block.BellRingEvent$RingCause, hitFace: cn.nukkit.math.BlockFace): boolean
        checkSupport(): boolean
        checkSupport(support: cn.nukkit.block.Block, attachmentFace: cn.nukkit.math.BlockFace): boolean
        public onUpdate(type: int): int
        public isGettingPower(): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onProjectileHit(projectile: cn.nukkit.entity.Entity, position: cn.nukkit.level.Position, motion: cn.nukkit.math.Vector3): boolean
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public getAttachment(): cn.nukkit.blockproperty.value.AttachmentType
        public setAttachment(attachmentType: cn.nukkit.blockproperty.value.AttachmentType): void
        public getAttachmentType(): int
        public setAttachmentType(attachmentType: int): void
        public isToggled(): boolean
        public setToggled(toggled: boolean): void
        public toItem(): cn.nukkit.item.Item
        public getWaterloggingLevel(): int
        public getToolType(): int
        public canHarvestWithHand(): boolean
        public getHardness(): double
        public getResistance(): double
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public static ATTACHMENT_TYPE: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.blockproperty.value.AttachmentType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static TYPE_ATTACHMENT_STANDING: int
        public static TYPE_ATTACHMENT_HANGING: int
        public static TYPE_ATTACHMENT_SIDE: int
        public static TYPE_ATTACHMENT_MULTIPLE: int

    }
}

declare module "cn.nukkit.block.BlockBell" {
    declare const BlockBell = cn.nukkit.block.BlockBell;
}

declare namespace cn.nukkit.block {
    declare class BlockConduit extends cn.nukkit.block.BlockTransparent implements cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityConduit>
        public getBlockEntityType(): string
        public getWaterloggingLevel(): int
        public getHardness(): double
        public getResistance(): double
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getLightLevel(): int
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getMinX(): double
        public getMinY(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxY(): double
        public getMaxZ(): double

    }
}

declare module "cn.nukkit.block.BlockConduit" {
    declare const BlockConduit = cn.nukkit.block.BlockConduit;
}

declare namespace cn.nukkit.block {
    declare class BlockMangrovePropaguleHanging extends cn.nukkit.block.BlockMangrovePropagule {
        public constructor(): void
        public getName(): string
        public getId(): int

    }
}

declare module "cn.nukkit.block.BlockMangrovePropaguleHanging" {
    declare const BlockMangrovePropaguleHanging = cn.nukkit.block.BlockMangrovePropaguleHanging;
}

declare namespace cn.nukkit.block {
    declare class BlockPackedMud extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int

    }
}

declare module "cn.nukkit.block.BlockPackedMud" {
    declare const BlockPackedMud = cn.nukkit.block.BlockPackedMud;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperCutWeathered extends cn.nukkit.block.BlockCopperCut {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel

    }
}

declare module "cn.nukkit.block.BlockCopperCutWeathered" {
    declare const BlockCopperCutWeathered = cn.nukkit.block.BlockCopperCutWeathered;
}

declare namespace cn.nukkit.block {
    declare class BlockAllow extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getName(): string
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public canBePushed(): boolean
        public canBePulled(): boolean
        public canHarvestWithHand(): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public isBreakable(vector: cn.nukkit.math.Vector3, layer: int, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item, player: cn.nukkit.Player, setBlockDestroy: boolean): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]

    }
}

declare module "cn.nukkit.block.BlockAllow" {
    declare const BlockAllow = cn.nukkit.block.BlockAllow;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsDeepslatePolished extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public getToolTier(): int
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStairsDeepslatePolished" {
    declare const BlockStairsDeepslatePolished = cn.nukkit.block.BlockStairsDeepslatePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockStemMelon extends cn.nukkit.block.BlockCropsStem implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getFruitId(): int
        public getSeedsId(): int
        public getName(): string
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void

    }
}

declare module "cn.nukkit.block.BlockStemMelon" {
    declare const BlockStemMelon = cn.nukkit.block.BlockStemMelon;
}

declare namespace cn.nukkit.block {
    declare class BlockSeaPickle extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public isDead(): boolean
        public setDead(dead: boolean): void
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getWaterloggingLevel(): int
        public getLightLevel(): int
        public toItem(): cn.nukkit.item.Item
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public static DEAD: cn.nukkit.blockproperty.BooleanBlockProperty
        public static CLUSTER_COUNT: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockSeaPickle" {
    declare const BlockSeaPickle = cn.nukkit.block.BlockSeaPickle;
}

declare namespace cn.nukkit.block {
    declare class BlockAncientDebris extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getToolTier(): int
        public getResistance(): double
        public getToolType(): int
        public getHardness(): double
        public getColor(): cn.nukkit.utils.BlockColor
        public isLavaResistant(): boolean
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockAncientDebris" {
    declare const BlockAncientDebris = cn.nukkit.block.BlockAncientDebris;
}

declare namespace cn.nukkit.block {
    declare class BlockButtonBlackstonePolished extends cn.nukkit.block.BlockButtonStone {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockButtonBlackstonePolished" {
    declare const BlockButtonBlackstonePolished = cn.nukkit.block.BlockButtonBlackstonePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockWoodStrippedAcacia extends cn.nukkit.block.BlockWoodStripped {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType

    }
}

declare module "cn.nukkit.block.BlockWoodStrippedAcacia" {
    declare const BlockWoodStrippedAcacia = cn.nukkit.block.BlockWoodStrippedAcacia;
}

declare namespace cn.nukkit.block {
    declare class BlockTuff extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockTuff" {
    declare const BlockTuff = cn.nukkit.block.BlockTuff;
}

declare namespace cn.nukkit.block {
    declare class BlockSnow extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean
        public canSilkTouch(): boolean
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean

    }
}

declare module "cn.nukkit.block.BlockSnow" {
    declare const BlockSnow = cn.nukkit.block.BlockSnow;
}

declare namespace cn.nukkit.block {
    declare class BlockPistonHead extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getResistance(): double
        public getHardness(): double
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public onBreak(item: cn.nukkit.item.Item): boolean
        public getFacing(): cn.nukkit.math.BlockFace
        public getBlockFace(): cn.nukkit.math.BlockFace
        public canBePushed(): boolean
        public canBePulled(): boolean
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public toItem(): cn.nukkit.item.Item
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockPistonHead" {
    declare const BlockPistonHead = cn.nukkit.block.BlockPistonHead;
}

declare namespace cn.nukkit.block {
    declare class BlockPiston extends cn.nukkit.block.BlockPistonBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getPistonHeadBlockId(): int

    }
}

declare module "cn.nukkit.block.BlockPiston" {
    declare const BlockPiston = cn.nukkit.block.BlockPiston;
}

declare namespace cn.nukkit.block {
    declare class BlockBlastFurnaceBurning extends cn.nukkit.block.BlockFurnaceBurning {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getBlockEntityType(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityBlastFurnace>
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockBlastFurnaceBurning" {
    declare const BlockBlastFurnaceBurning = cn.nukkit.block.BlockBlastFurnaceBurning;
}

declare namespace cn.nukkit.block {
    declare class BlockBeehive extends cn.nukkit.block.BlockSolidMeta implements cn.nukkit.utils.Faceable, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getBlockEntityType(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityBeehive>
        public getToolType(): int
        public getBurnChance(): int
        public getBurnAbility(): int
        public getHardness(): double
        public getResistance(): double
        public getColor(): cn.nukkit.utils.BlockColor
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public canBeActivated(): boolean
        public honeyCollected(player: cn.nukkit.Player): void
        public honeyCollected(player: cn.nukkit.Player, angerBees: boolean): void
        public angerBees(player: cn.nukkit.Player): void
        public toItem(): cn.nukkit.item.Item
        public canSilkTouch(): boolean
        public mustSilkTouch(vector: cn.nukkit.math.Vector3, layer: int, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public mustDrop(vector: cn.nukkit.math.Vector3, layer: int, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public canHarvestWithHand(): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public setHoneyLevel(honeyLevel: int): void
        public getHoneyLevel(): int
        public isEmpty(): boolean
        public isFull(): boolean
        public hasComparatorInputOverride(): boolean
        public getComparatorInputOverride(): int
        public static HONEY_LEVEL: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockBeehive" {
    declare const BlockBeehive = cn.nukkit.block.BlockBeehive;
}

declare namespace cn.nukkit.block {
    declare class BlockPistonHeadSticky extends cn.nukkit.block.BlockPistonHead {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockPistonHeadSticky" {
    declare const BlockPistonHeadSticky = cn.nukkit.block.BlockPistonHeadSticky;
}

declare namespace cn.nukkit.block {
    declare class BlockBricksEndStone extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getToolType(): int
        public getToolTier(): int
        public getHardness(): double
        public getResistance(): double
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockBricksEndStone" {
    declare const BlockBricksEndStone = cn.nukkit.block.BlockBricksEndStone;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsMossyCobblestone extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsMossyCobblestone" {
    declare const BlockStairsMossyCobblestone = cn.nukkit.block.BlockStairsMossyCobblestone;
}

declare namespace cn.nukkit.block {
    declare class BlockCoral extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public isDead(): boolean
        public setDead(dead: boolean): void
        public getWaterloggingLevel(): int
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canSilkTouch(): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public static COLOR: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.CoralType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static TYPE_TUBE: int
        public static TYPE_BRAIN: int
        public static TYPE_BUBBLE: int
        public static TYPE_FIRE: int
        public static TYPE_HORN: int

    }
}

declare module "cn.nukkit.block.BlockCoral" {
    declare const BlockCoral = cn.nukkit.block.BlockCoral;
}

declare namespace cn.nukkit.block {
    declare class BlockOreRedstoneDeepslateGlowing extends cn.nukkit.block.BlockOreRedstoneDeepslate implements cn.nukkit.block.IBlockOreRedstoneGlowing {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getLightLevel(): int
        public toItem(): cn.nukkit.item.Item
        public onUpdate(type: int): int

    }
}

declare module "cn.nukkit.block.BlockOreRedstoneDeepslateGlowing" {
    declare const BlockOreRedstoneDeepslateGlowing = cn.nukkit.block.BlockOreRedstoneDeepslateGlowing;
}

declare namespace cn.nukkit.block {
    declare class BlockMushroomBrown extends cn.nukkit.block.BlockMushroom {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getLightLevel(): int
        getType(): int

    }
}

declare module "cn.nukkit.block.BlockMushroomBrown" {
    declare const BlockMushroomBrown = cn.nukkit.block.BlockMushroomBrown;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCakeLightGray extends cn.nukkit.block.BlockCandleCake {
        public constructor(meta: int): void
        public constructor(): void
        getColorName(): string
        public getId(): int
        toCandleForm(): cn.nukkit.block.BlockCandle

    }
}

declare module "cn.nukkit.block.BlockCandleCakeLightGray" {
    declare const BlockCandleCakeLightGray = cn.nukkit.block.BlockCandleCakeLightGray;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleOrange extends cn.nukkit.block.BlockCandle {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        toCakeForm(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockCandleOrange" {
    declare const BlockCandleOrange = cn.nukkit.block.BlockCandleOrange;
}

declare namespace cn.nukkit.block {
    declare class BlockBricksQuartz extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolTier(): int
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockBricksQuartz" {
    declare const BlockBricksQuartz = cn.nukkit.block.BlockBricksQuartz;
}

declare namespace cn.nukkit.block {
    declare class BlockMediumAmethystBud extends cn.nukkit.block.BlockAmethystBud {
        public constructor(): void
        getNamePrefix(): string
        public getId(): int
        public getLightLevel(): int

    }
}

declare module "cn.nukkit.block.BlockMediumAmethystBud" {
    declare const BlockMediumAmethystBud = cn.nukkit.block.BlockMediumAmethystBud;
}

declare namespace cn.nukkit.block {
    declare class BlockMudBrick extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int

    }
}

declare module "cn.nukkit.block.BlockMudBrick" {
    declare const BlockMudBrick = cn.nukkit.block.BlockMudBrick;
}

declare namespace cn.nukkit.block {
    declare class BlockPressurePlateMangrove extends cn.nukkit.block.BlockPressurePlateWood {
        public constructor(meta: int): void
        public constructor(): void
        public getName(): string
        public getId(): int
        public getToolType(): int
        public getHardness(): double
        public getResistance(): double
        public getColor(): cn.nukkit.utils.BlockColor
        computeRedstoneStrength(): int

    }
}

declare module "cn.nukkit.block.BlockPressurePlateMangrove" {
    declare const BlockPressurePlateMangrove = cn.nukkit.block.BlockPressurePlateMangrove;
}

declare namespace cn.nukkit.block {
    declare class BlockDragonEgg$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$event$player$PlayerInteractEvent$Action: int[]

    }
}

declare module "cn.nukkit.block.BlockDragonEgg$1" {
    declare const BlockDragonEgg$1 = cn.nukkit.block.BlockDragonEgg$1;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleLightGray extends cn.nukkit.block.BlockCandle {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        toCakeForm(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockCandleLightGray" {
    declare const BlockCandleLightGray = cn.nukkit.block.BlockCandleLightGray;
}

declare namespace cn.nukkit.block {
    declare class BlockFungusWarped extends cn.nukkit.block.BlockFungus {
        public constructor(): void
        public getId(): int
        public getName(): string
        canGrowOn(support: cn.nukkit.block.Block): boolean
        public grow(cause: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockFungusWarped" {
    declare const BlockFungusWarped = cn.nukkit.block.BlockFungusWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockTrapdoorCrimson extends cn.nukkit.block.BlockTrapdoor {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getBurnChance(): int
        public getBurnAbility(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockTrapdoorCrimson" {
    declare const BlockTrapdoorCrimson = cn.nukkit.block.BlockTrapdoorCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperCut$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$blockproperty$value$OxidizationLevel: int[]

    }
}

declare module "cn.nukkit.block.BlockCopperCut$1" {
    declare const BlockCopperCut$1 = cn.nukkit.block.BlockCopperCut$1;
}

declare namespace cn.nukkit.block {
    declare interface Waxable {
        public getLocation(): cn.nukkit.level.Location
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public isWaxed(): boolean
        public setWaxed(var0: boolean): boolean

    }
}

declare module "cn.nukkit.block.Waxable" {
    declare type Waxable = cn.nukkit.block.Waxable;
}

declare namespace cn.nukkit.block {
    declare class BlockSoulSand extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getMaxY(): double
        public hasEntityCollision(): boolean
        public isSoulSpeedCompatible(): boolean
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public onUpdate(type: int): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockSoulSand" {
    declare const BlockSoulSand = cn.nukkit.block.BlockSoulSand;
}

declare namespace cn.nukkit.block {
    declare class BlockDoublePlant extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getDoublePlantType(): cn.nukkit.blockproperty.value.DoublePlantType
        public setDoublePlantType(type: cn.nukkit.blockproperty.value.DoublePlantType): void
        public isTopHalf(): boolean
        public setTopHalf(topHalf: boolean): void
        public canBeReplaced(): boolean
        public getName(): string
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        isSupportValid(support: cn.nukkit.block.Block): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public static DOUBLE_PLANT_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.DoublePlantType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static SUNFLOWER: int
        public static LILAC: int
        public static TALL_GRASS: int
        public static LARGE_FERN: int
        public static ROSE_BUSH: int
        public static PEONY: int
        public static TOP_HALF_BITMASK: int

    }
}

declare module "cn.nukkit.block.BlockDoublePlant" {
    declare const BlockDoublePlant = cn.nukkit.block.BlockDoublePlant;
}

declare namespace cn.nukkit.block {
    declare class BlockFletchingTable extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getToolType(): int
        public getResistance(): double
        public getHardness(): double
        public getColor(): cn.nukkit.utils.BlockColor
        public getBurnChance(): int
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockFletchingTable" {
    declare const BlockFletchingTable = cn.nukkit.block.BlockFletchingTable;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazedYellow extends cn.nukkit.block.BlockTerracottaGlazed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getDyeColor(): cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazedYellow" {
    declare const BlockTerracottaGlazedYellow = cn.nukkit.block.BlockTerracottaGlazedYellow;
}

declare namespace cn.nukkit.block {
    declare class BlockBorder extends cn.nukkit.block.BlockWallBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getName(): string
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public canBePushed(): boolean
        public canBePulled(): boolean
        public canHarvestWithHand(): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public isBreakable(vector: cn.nukkit.math.Vector3, layer: int, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item, player: cn.nukkit.Player, setBlockDestroy: boolean): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB

    }
}

declare module "cn.nukkit.block.BlockBorder" {
    declare const BlockBorder = cn.nukkit.block.BlockBorder;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperWaxed extends cn.nukkit.block.BlockCopper {
        public constructor(): void
        public getName(): string
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockCopperWaxed" {
    declare const BlockCopperWaxed = cn.nukkit.block.BlockCopperWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockWoodStrippedMangrove extends cn.nukkit.block.BlockWoodStripped {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType
        public setWoodType(woodType: cn.nukkit.blockproperty.value.WoodType): void

    }
}

declare module "cn.nukkit.block.BlockWoodStrippedMangrove" {
    declare const BlockWoodStrippedMangrove = cn.nukkit.block.BlockWoodStrippedMangrove;
}

declare namespace cn.nukkit.block {
    declare class BlockChorusPlant extends cn.nukkit.block.BlockTransparent {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        isPositionValid(): boolean
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockChorusPlant" {
    declare const BlockChorusPlant = cn.nukkit.block.BlockChorusPlant;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazedSilver extends cn.nukkit.block.BlockTerracottaGlazed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getDyeColor(): cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazedSilver" {
    declare const BlockTerracottaGlazedSilver = cn.nukkit.block.BlockTerracottaGlazedSilver;
}

declare namespace cn.nukkit.block {
    declare class BlockRootsCrimson extends cn.nukkit.block.BlockRoots {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockRootsCrimson" {
    declare const BlockRootsCrimson = cn.nukkit.block.BlockRootsCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockBamboo extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public onUpdate(type: int): int
        public grow(up: cn.nukkit.block.Block): boolean
        public countHeight(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public canPassThrough(): boolean
        isSupportInvalid(): boolean
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor
        public getHardness(): double
        public getResistance(): double
        public isThick(): boolean
        public setThick(thick: boolean): void
        public getBambooStalkThickness(): cn.nukkit.blockproperty.value.BambooStalkThickness
        public setBambooStalkThickness(value: cn.nukkit.blockproperty.value.BambooStalkThickness): void
        public getToolType(): int
        public getLeafSize(): int
        public getBambooLeafSize(): cn.nukkit.blockproperty.value.BambooLeafSize
        public setLeafSize(leafSize: int): void
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getAge(): int
        public setAge(age: int): void
        static lambda$onBreak$1(b: cn.nukkit.block.Block): boolean
        static lambda$countHeight$0(b: cn.nukkit.block.Block): boolean
        public static STALK_THICKNESS: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.BambooStalkThickness>
        public static LEAF_SIZE: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.BambooLeafSize>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static LEAF_SIZE_NONE: int
        public static LEAF_SIZE_SMALL: int
        public static LEAF_SIZE_LARGE: int

    }
}

declare module "cn.nukkit.block.BlockBamboo" {
    declare const BlockBamboo = cn.nukkit.block.BlockBamboo;
}

declare namespace cn.nukkit.block {
    declare class BlockSolidMeta extends cn.nukkit.block.BlockMeta {
        constructor(meta: int): void
        public constructor(): void
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockSolidMeta" {
    declare const BlockSolidMeta = cn.nukkit.block.BlockSolidMeta;
}

declare namespace cn.nukkit.block {
    declare class BlockIcePacked extends cn.nukkit.block.BlockIce {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getToolType(): int
        public onUpdate(type: int): int
        public canHarvestWithHand(): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public canSilkTouch(): boolean
        public isTransparent(): boolean
        public getLightFilter(): int

    }
}

declare module "cn.nukkit.block.BlockIcePacked" {
    declare const BlockIcePacked = cn.nukkit.block.BlockIcePacked;
}

declare namespace cn.nukkit.block {
    declare class BlockSlab extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(meta: int, doubleSlab: int): void
        public constructor(doubleSlab: int): void
        public getSlabName(): string
        public getName(): string
        public getMinY(): double
        public getMaxY(): double
        public getHardness(): double
        public getResistance(): double
        public getWaterloggingLevel(): int
        public isOnTop(): boolean
        public setOnTop(top: boolean): void
        public isSameType(var0: cn.nukkit.block.BlockSlab): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public static TOP_SLOT_PROPERTY: cn.nukkit.blockproperty.BooleanBlockProperty
        public static SIMPLE_SLAB_PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        doubleSlab: int

    }
}

declare module "cn.nukkit.block.BlockSlab" {
    declare const BlockSlab = cn.nukkit.block.BlockSlab;
}

declare namespace cn.nukkit.block {
    declare class BlockSculkCatalyst extends cn.nukkit.block.BlockSolid implements cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getId(): int
        public canBePulled(): boolean
        public canBePushed(): boolean
        public getLightLevel(): int
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntitySculkCatalyst>
        public getBlockEntityType(): string
        public static BLOOM: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockSculkCatalyst" {
    declare const BlockSculkCatalyst = cn.nukkit.block.BlockSculkCatalyst;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleGreen extends cn.nukkit.block.BlockCandle {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        toCakeForm(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockCandleGreen" {
    declare const BlockCandleGreen = cn.nukkit.block.BlockCandleGreen;
}

declare namespace cn.nukkit.block {
    declare class BlockSponge$Entry extends java.lang.Object {
        public constructor(block: cn.nukkit.block.Block, distance: int): void
        block: cn.nukkit.block.Block
        distance: int

    }
}

declare module "cn.nukkit.block.BlockSponge$Entry" {
    declare const BlockSponge$Entry = cn.nukkit.block.BlockSponge$Entry;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleYellow extends cn.nukkit.block.BlockCandle {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        toCakeForm(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockCandleYellow" {
    declare const BlockCandleYellow = cn.nukkit.block.BlockCandleYellow;
}

declare namespace cn.nukkit.block {
    declare class BlockPolishedBasalt extends cn.nukkit.block.BlockBasalt {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int

    }
}

declare module "cn.nukkit.block.BlockPolishedBasalt" {
    declare const BlockPolishedBasalt = cn.nukkit.block.BlockPolishedBasalt;
}

declare namespace cn.nukkit.block {
    declare class BlockEnderChest extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.Faceable, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public canBeActivated(): boolean
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockEntityType(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityEnderChest>
        public getLightLevel(): int
        public getWaterloggingLevel(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getMinX(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxY(): double
        public getMaxZ(): double
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getToolTier(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor
        public getViewers(): java.util.Set<cn.nukkit.Player>
        public canBePushed(): boolean
        public canBePulled(): boolean
        public canHarvestWithHand(): boolean
        public canSilkTouch(): boolean
        public toItem(): cn.nukkit.item.Item
        public getBlockFace(): cn.nukkit.math.BlockFace
        public getBlockEntity(): cn.nukkit.blockentity.BlockEntityEnderChest
        public getBlockEntity(): cn.nukkit.blockentity.BlockEntity
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        viewers: java.util.Set<cn.nukkit.Player>

    }
}

declare module "cn.nukkit.block.BlockEnderChest" {
    declare const BlockEnderChest = cn.nukkit.block.BlockEnderChest;
}

declare namespace cn.nukkit.block {
    declare class BlockSlime extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getHardness(): double
        public getName(): string
        public getId(): int
        public getResistance(): double
        public getColor(): cn.nukkit.utils.BlockColor
        public getLightFilter(): int

    }
}

declare module "cn.nukkit.block.BlockSlime" {
    declare const BlockSlime = cn.nukkit.block.BlockSlime;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsDioritePolished extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsDioritePolished" {
    declare const BlockStairsDioritePolished = cn.nukkit.block.BlockStairsDioritePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockBirchSignPost extends cn.nukkit.block.BlockSignPost {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getWallId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockBirchSignPost" {
    declare const BlockBirchSignPost = cn.nukkit.block.BlockBirchSignPost;
}

declare namespace cn.nukkit.block {
    declare class BlockClay extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getId(): int
        public getName(): string
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor
        public canSilkTouch(): boolean

    }
}

declare module "cn.nukkit.block.BlockClay" {
    declare const BlockClay = cn.nukkit.block.BlockClay;
}

declare namespace cn.nukkit.block {
    declare class BlockBasalt extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getPillarAxis(): cn.nukkit.math.BlockFace$Axis
        public setPillarAxis(axis: cn.nukkit.math.BlockFace$Axis): void
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockBasalt" {
    declare const BlockBasalt = cn.nukkit.block.BlockBasalt;
}

declare namespace cn.nukkit.block {
    declare class BlockCake extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(meta: int): void
        public constructor(): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public canBeActivated(): boolean
        public getHardness(): double
        public getResistance(): double
        public getWaterloggingLevel(): int
        public getMinX(): double
        public getMinY(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxY(): double
        public getMaxZ(): double
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public toItem(): cn.nukkit.item.Item
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getComparatorInputOverride(): int
        public hasComparatorInputOverride(): boolean
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        public static BITES: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCake" {
    declare const BlockCake = cn.nukkit.block.BlockCake;
}

declare namespace cn.nukkit.block {
    declare class BlockSmoothStone extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockSmoothStone" {
    declare const BlockSmoothStone = cn.nukkit.block.BlockSmoothStone;
}

declare namespace cn.nukkit.block {
    declare class BlockMangroveSignPost extends cn.nukkit.block.BlockSignPost {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getWallId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockMangroveSignPost" {
    declare const BlockMangroveSignPost = cn.nukkit.block.BlockMangroveSignPost;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsGranitePolished extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsGranitePolished" {
    declare const BlockStairsGranitePolished = cn.nukkit.block.BlockStairsGranitePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockHyphaeStrippedWarped extends cn.nukkit.block.BlockStemStripped {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockHyphaeStrippedWarped" {
    declare const BlockHyphaeStrippedWarped = cn.nukkit.block.BlockHyphaeStrippedWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabCopperCutExposedWaxed extends cn.nukkit.block.BlockSlabCopperCutExposed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockSlabCopperCutExposedWaxed" {
    declare const BlockSlabCopperCutExposedWaxed = cn.nukkit.block.BlockSlabCopperCutExposedWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockBrewingStand extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public canBeActivated(): boolean
        public getHardness(): double
        public getResistance(): double
        public getWaterloggingLevel(): int
        public getToolType(): int
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getLightLevel(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public toItem(): cn.nukkit.item.Item
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public isSolid(): boolean
        public getMinX(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxY(): double
        public getMaxZ(): double
        public hasComparatorInputOverride(): boolean
        public getComparatorInputOverride(): int
        public canHarvestWithHand(): boolean
        public static HAS_POTION_A: cn.nukkit.blockproperty.BooleanBlockProperty
        public static HAS_POTION_B: cn.nukkit.blockproperty.BooleanBlockProperty
        public static HAS_POTION_C: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockBrewingStand" {
    declare const BlockBrewingStand = cn.nukkit.block.BlockBrewingStand;
}

declare namespace cn.nukkit.block {
    declare class BlockCarvedPumpkin extends cn.nukkit.block.BlockPumpkin {
        public constructor(): void
        public getId(): int
        public getName(): string
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean

    }
}

declare module "cn.nukkit.block.BlockCarvedPumpkin" {
    declare const BlockCarvedPumpkin = cn.nukkit.block.BlockCarvedPumpkin;
}

declare namespace cn.nukkit.block {
    declare class BlockVerdantFrogLight extends cn.nukkit.block.BlockFrogLight {
        public constructor(): void
        public getName(): string
        public getId(): int

    }
}

declare module "cn.nukkit.block.BlockVerdantFrogLight" {
    declare const BlockVerdantFrogLight = cn.nukkit.block.BlockVerdantFrogLight;
}

declare namespace cn.nukkit.block {
    declare class BlockPotato extends cn.nukkit.block.BlockCrops {
        public constructor(meta: int): void
        public constructor(): void
        public getName(): string
        public getId(): int
        public toItem(): cn.nukkit.item.Item
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]

    }
}

declare module "cn.nukkit.block.BlockPotato" {
    declare const BlockPotato = cn.nukkit.block.BlockPotato;
}

declare namespace cn.nukkit.block {
    declare class BlockDeepslatePolished extends cn.nukkit.block.BlockDeepslateCobbled {
        public constructor(): void
        public getName(): string
        public getId(): int

    }
}

declare module "cn.nukkit.block.BlockDeepslatePolished" {
    declare const BlockDeepslatePolished = cn.nukkit.block.BlockDeepslatePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockButtonSpruce extends cn.nukkit.block.BlockButtonWooden {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockButtonSpruce" {
    declare const BlockButtonSpruce = cn.nukkit.block.BlockButtonSpruce;
}

declare namespace cn.nukkit.block {
    declare class BlockSculk extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockSculk" {
    declare const BlockSculk = cn.nukkit.block.BlockSculk;
}

declare namespace cn.nukkit.block {
    declare class BlockSoulLantern extends cn.nukkit.block.BlockLantern {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getLightLevel(): int

    }
}

declare module "cn.nukkit.block.BlockSoulLantern" {
    declare const BlockSoulLantern = cn.nukkit.block.BlockSoulLantern;
}

declare namespace cn.nukkit.block {
    declare class BlockStem extends cn.nukkit.block.BlockLog {
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double

    }
}

declare module "cn.nukkit.block.BlockStem" {
    declare const BlockStem = cn.nukkit.block.BlockStem;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCakeBlack extends cn.nukkit.block.BlockCandleCake {
        public constructor(meta: int): void
        public constructor(): void
        getColorName(): string
        public getId(): int
        toCandleForm(): cn.nukkit.block.BlockCandle

    }
}

declare module "cn.nukkit.block.BlockCandleCakeBlack" {
    declare const BlockCandleCakeBlack = cn.nukkit.block.BlockCandleCakeBlack;
}

declare namespace cn.nukkit.block {
    declare class BlockBricksStone extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public setBrickStoneType(stoneBrickType: cn.nukkit.blockproperty.value.StoneBrickType): void
        public getStoneBrickType(): cn.nukkit.blockproperty.value.StoneBrickType
        public getName(): string
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public static STONE_BRICK_TYPE: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.blockproperty.value.StoneBrickType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static NORMAL: int
        public static MOSSY: int
        public static CRACKED: int
        public static CHISELED: int

    }
}

declare module "cn.nukkit.block.BlockBricksStone" {
    declare const BlockBricksStone = cn.nukkit.block.BlockBricksStone;
}

declare namespace cn.nukkit.block {
    declare class BlockCrimsonSignPost extends cn.nukkit.block.BlockSignPost {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getWallId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockCrimsonSignPost" {
    declare const BlockCrimsonSignPost = cn.nukkit.block.BlockCrimsonSignPost;
}

declare namespace cn.nukkit.block {
    declare class BlockWallDeepslateCobbled extends cn.nukkit.block.BlockWallBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockWallDeepslateCobbled" {
    declare const BlockWallDeepslateCobbled = cn.nukkit.block.BlockWallDeepslateCobbled;
}

declare namespace cn.nukkit.block {
    declare class BlockBone extends cn.nukkit.block.BlockSolidMeta implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getBlockFace(): cn.nukkit.math.BlockFace
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        static SPECIAL_PILLAR_AXIS: cn.nukkit.blockproperty.ArrayBlockProperty<string>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        static FACES: int[]

    }
}

declare module "cn.nukkit.block.BlockBone" {
    declare const BlockBone = cn.nukkit.block.BlockBone;
}

declare namespace cn.nukkit.block {
    declare class BlockLapis extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getToolType(): int
        public getHardness(): double
        public getResistance(): double
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockLapis" {
    declare const BlockLapis = cn.nukkit.block.BlockLapis;
}

declare namespace cn.nukkit.block {
    declare class BlockRedstoneComparatorPowered extends cn.nukkit.block.BlockRedstoneComparator {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        getPowered(): cn.nukkit.block.BlockRedstoneComparator
        getPowered(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockRedstoneComparatorPowered" {
    declare const BlockRedstoneComparatorPowered = cn.nukkit.block.BlockRedstoneComparatorPowered;
}

declare namespace cn.nukkit.block {
    declare class BlockFenceGateJungle extends cn.nukkit.block.BlockFenceGate {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockFenceGateJungle" {
    declare const BlockFenceGateJungle = cn.nukkit.block.BlockFenceGateJungle;
}

declare namespace cn.nukkit.block {
    declare class BlockScaffolding extends cn.nukkit.block.BlockFallableMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getStability(): int
        public setStability(stability: int): void
        public getStabilityCheck(): boolean
        public setStabilityCheck(check: boolean): void
        public toItem(): cn.nukkit.item.Item
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        createFallingEntity(customNbt: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.entity.item.EntityFallingBlock
        public getHardness(): double
        public getResistance(): double
        public getBurnChance(): int
        public getBurnAbility(): int
        public getWaterloggingLevel(): int
        public canBeActivated(): boolean
        public canBeClimbed(): boolean
        public canBeFlowedInto(): boolean
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public hasEntityCollision(): boolean
        public getBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getMinY(): double
        recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public canPassThrough(): boolean
        public isTransparent(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public static STABILITY_CHECK: cn.nukkit.blockproperty.BooleanBlockProperty
        public static STABILITY: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockScaffolding" {
    declare const BlockScaffolding = cn.nukkit.block.BlockScaffolding;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleWhite extends cn.nukkit.block.BlockCandle {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        toCakeForm(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockCandleWhite" {
    declare const BlockCandleWhite = cn.nukkit.block.BlockCandleWhite;
}

declare namespace cn.nukkit.block {
    declare class BlockFenceGateSpruce extends cn.nukkit.block.BlockFenceGate {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockFenceGateSpruce" {
    declare const BlockFenceGateSpruce = cn.nukkit.block.BlockFenceGateSpruce;
}

declare namespace cn.nukkit.block {
    declare class BlockGrindstone extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public toItem(): cn.nukkit.item.Item
        public getWaterloggingLevel(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getHardness(): double
        public getResistance(): double
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public getAttachmentType(): int
        public setAttachmentType(attachmentType: int): void
        isConnectedTo(connectedFace: cn.nukkit.math.BlockFace, attachmentType: int, blockFace: cn.nukkit.math.BlockFace): boolean
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        checkSupport(): boolean
        checkSupport(support: cn.nukkit.block.Block): boolean
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static TYPE_ATTACHMENT_STANDING: int
        public static TYPE_ATTACHMENT_HANGING: int
        public static TYPE_ATTACHMENT_SIDE: int
        public static TYPE_ATTACHMENT_MULTIPLE: int

    }
}

declare module "cn.nukkit.block.BlockGrindstone" {
    declare const BlockGrindstone = cn.nukkit.block.BlockGrindstone;
}

declare namespace cn.nukkit.block {
    declare class BlockBricksDeepslateCracked extends cn.nukkit.block.BlockBricksDeepslate {
        public constructor(): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockBricksDeepslateCracked" {
    declare const BlockBricksDeepslateCracked = cn.nukkit.block.BlockBricksDeepslateCracked;
}

declare namespace cn.nukkit.block {
    declare class BlockPearlescentFrogLight extends cn.nukkit.block.BlockFrogLight {
        public constructor(): void
        public getName(): string
        public getId(): int

    }
}

declare module "cn.nukkit.block.BlockPearlescentFrogLight" {
    declare const BlockPearlescentFrogLight = cn.nukkit.block.BlockPearlescentFrogLight;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsStone extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsStone" {
    declare const BlockStairsStone = cn.nukkit.block.BlockStairsStone;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsCopperCutOxidizedWaxed extends cn.nukkit.block.BlockStairsCopperCutOxidized {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsCopperCutOxidizedWaxed" {
    declare const BlockStairsCopperCutOxidizedWaxed = cn.nukkit.block.BlockStairsCopperCutOxidizedWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockDripstone extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public isLavaResistant(): boolean
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockDripstone" {
    declare const BlockDripstone = cn.nukkit.block.BlockDripstone;
}

declare namespace cn.nukkit.block {
    declare class BlockEndPortal extends cn.nukkit.block.BlockFlowable implements cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityEndPortal>
        public getBlockEntityType(): string
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public canPassThrough(): boolean
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public getHardness(): double
        public getResistance(): double
        public getLightLevel(): int
        public hasEntityCollision(): boolean
        public getCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean
        public canBeFlowedInto(): boolean
        public toItem(): cn.nukkit.item.Item
        public canBePushed(): boolean
        public canBePulled(): boolean
        public getMaxY(): double
        public static spawnObsidianPlatform(position: cn.nukkit.level.Position): void
        static STATE_OBSIDIAN: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.block.BlockEndPortal" {
    declare const BlockEndPortal = cn.nukkit.block.BlockEndPortal;
}

declare namespace cn.nukkit.block {
    declare class BlockJigsaw extends cn.nukkit.block.BlockSolidMeta implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public canHarvestWithHand(): boolean
        public getResistance(): double
        public getHardness(): double
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public canBePushed(): boolean
        public getBlockFace(): cn.nukkit.math.BlockFace
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        static ROTATION: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockJigsaw" {
    declare const BlockJigsaw = cn.nukkit.block.BlockJigsaw;
}

declare namespace cn.nukkit.block {
    declare class BlockMoss extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public canConvertToMoss(block: cn.nukkit.block.Block): boolean
        public canBePopulated(pos: cn.nukkit.level.Position): boolean
        public canBePopulated2BlockAir(pos: cn.nukkit.level.Position): boolean
        public convertToMoss(pos: cn.nukkit.level.Position): void
        public populateRegion(pos: cn.nukkit.level.Position): void
        public canGrowPlant(pos: cn.nukkit.level.Position): boolean
        public getToolType(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockMoss" {
    declare const BlockMoss = cn.nukkit.block.BlockMoss;
}

declare namespace cn.nukkit.block {
    declare class BlockCandlePink extends cn.nukkit.block.BlockCandle {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        toCakeForm(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockCandlePink" {
    declare const BlockCandlePink = cn.nukkit.block.BlockCandlePink;
}

declare namespace cn.nukkit.block {
    declare class BlockOreLapis extends cn.nukkit.block.BlockOre {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        getRawMaterial(): cn.nukkit.item.MinecraftItemID
        public getDropExp(): int

    }
}

declare module "cn.nukkit.block.BlockOreLapis" {
    declare const BlockOreLapis = cn.nukkit.block.BlockOreLapis;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazedLightBlue extends cn.nukkit.block.BlockTerracottaGlazed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getDyeColor(): cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazedLightBlue" {
    declare const BlockTerracottaGlazedLightBlue = cn.nukkit.block.BlockTerracottaGlazedLightBlue;
}

declare namespace cn.nukkit.block {
    declare class BlockFenceCrimson extends cn.nukkit.block.BlockFenceBase {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getBurnChance(): int
        public getBurnAbility(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockFenceCrimson" {
    declare const BlockFenceCrimson = cn.nukkit.block.BlockFenceCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockSmallDripleaf extends cn.nukkit.block.BlockFlowable implements cn.nukkit.utils.Faceable {
        constructor(): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public isUpperBlock(): boolean
        public setUpperBlock(isUpperBlock: boolean): void
        public getWaterloggingLevel(): int
        public getToolType(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public onBreak(item: cn.nukkit.item.Item): boolean
        public onUpdate(type: int): int
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public canKeepAlive(pos: cn.nukkit.level.Position): boolean
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockSmallDripleaf" {
    declare const BlockSmallDripleaf = cn.nukkit.block.BlockSmallDripleaf;
}

declare namespace cn.nukkit.block {
    declare class BlockWall extends cn.nukkit.block.BlockWallBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getColor(): cn.nukkit.utils.BlockColor
        public getWallType(): cn.nukkit.block.BlockWall$WallType
        public setWallType(type: cn.nukkit.block.BlockWall$WallType): void
        public getName(): string
        public getToolTier(): int
        public static WALL_BLOCK_TYPE: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.block.BlockWall$WallType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static NONE_MOSSY_WALL: int
        public static MOSSY_WALL: int

    }
}

declare module "cn.nukkit.block.BlockWall" {
    declare const BlockWall = cn.nukkit.block.BlockWall;
}

declare namespace cn.nukkit.block {
    declare class BlockOreDiamond extends cn.nukkit.block.BlockOre {
        public constructor(): void
        public getId(): int
        public getToolTier(): int
        public getName(): string
        getRawMaterial(): cn.nukkit.item.MinecraftItemID
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getDropExp(): int

    }
}

declare module "cn.nukkit.block.BlockOreDiamond" {
    declare const BlockOreDiamond = cn.nukkit.block.BlockOreDiamond;
}

declare namespace cn.nukkit.block {
    declare class BlockFire extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public hasEntityCollision(): boolean
        public getName(): string
        public getLightLevel(): int
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public canBeReplaced(): boolean
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public onUpdate(type: int): int
        tryToCatchBlockOnFire(block: cn.nukkit.block.Block, bound: int, damage: int): void
        getChanceOfNeighborsEncouragingFire(block: cn.nukkit.block.Block): int
        public canNeighborBurn(): boolean
        public isBlockTopFacingSurfaceSolid(block: cn.nukkit.block.Block): boolean
        public tickRate(): int
        public getColor(): cn.nukkit.utils.BlockColor
        recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public toItem(): cn.nukkit.item.Item
        public static FIRE_AGE: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockFire" {
    declare const BlockFire = cn.nukkit.block.BlockFire;
}

declare namespace cn.nukkit.block {
    declare class BlockTrapdoorIron extends cn.nukkit.block.BlockTrapdoor {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public canHarvestWithHand(): boolean
        public getToolTier(): int

    }
}

declare module "cn.nukkit.block.BlockTrapdoorIron" {
    declare const BlockTrapdoorIron = cn.nukkit.block.BlockTrapdoorIron;
}

declare namespace cn.nukkit.block {
    declare class BlockObsidianGlowing extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getToolType(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getLightLevel(): int
        public toItem(): cn.nukkit.item.Item
        public getToolTier(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canBePushed(): boolean
        public canBePulled(): boolean
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockObsidianGlowing" {
    declare const BlockObsidianGlowing = cn.nukkit.block.BlockObsidianGlowing;
}

declare namespace cn.nukkit.block {
    declare class BlockFloweringAzalea extends cn.nukkit.block.BlockAzalea {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int

    }
}

declare module "cn.nukkit.block.BlockFloweringAzalea" {
    declare const BlockFloweringAzalea = cn.nukkit.block.BlockFloweringAzalea;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleBlack extends cn.nukkit.block.BlockCandle {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        toCakeForm(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockCandleBlack" {
    declare const BlockCandleBlack = cn.nukkit.block.BlockCandleBlack;
}

declare namespace cn.nukkit.block {
    declare class BlockOchreFrogLight extends cn.nukkit.block.BlockFrogLight {
        public constructor(): void
        public getName(): string
        public getId(): int

    }
}

declare module "cn.nukkit.block.BlockOchreFrogLight" {
    declare const BlockOchreFrogLight = cn.nukkit.block.BlockOchreFrogLight;
}

declare namespace cn.nukkit.block {
    declare class BlockBell$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$blockproperty$value$AttachmentType: int[]
        static $SwitchMap$cn$nukkit$math$BlockFace: int[]

    }
}

declare module "cn.nukkit.block.BlockBell$1" {
    declare const BlockBell$1 = cn.nukkit.block.BlockBell$1;
}

declare namespace cn.nukkit.block {
    declare class BlockWoodBark extends cn.nukkit.block.BlockWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType
        public setWoodType(woodType: cn.nukkit.blockproperty.value.WoodType): void
        public isStripped(): boolean
        public setStripped(stripped: boolean): void
        public static STRIPPED_BIT: string
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockWoodBark" {
    declare const BlockWoodBark = cn.nukkit.block.BlockWoodBark;
}

declare namespace cn.nukkit.block {
    declare class BlockBigDripleaf$Tilt extends java.lang.Enum {
        public static values(): cn.nukkit.block.BlockBigDripleaf$Tilt[]
        public static valueOf(name: string): cn.nukkit.block.BlockBigDripleaf$Tilt
        constructor(): void
        static $values(): cn.nukkit.block.BlockBigDripleaf$Tilt[]
        public static NONE: cn.nukkit.block.BlockBigDripleaf$Tilt
        public static PARTIAL_TILT: cn.nukkit.block.BlockBigDripleaf$Tilt
        public static FULL_TILT: cn.nukkit.block.BlockBigDripleaf$Tilt
        public static UNSTABLE: cn.nukkit.block.BlockBigDripleaf$Tilt
        static $VALUES: cn.nukkit.block.BlockBigDripleaf$Tilt[]

    }
}

declare module "cn.nukkit.block.BlockBigDripleaf$Tilt" {
    declare const BlockBigDripleaf$Tilt = cn.nukkit.block.BlockBigDripleaf$Tilt;
}

declare namespace cn.nukkit.block {
    declare class BlockBricks extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockBricks" {
    declare const BlockBricks = cn.nukkit.block.BlockBricks;
}

declare namespace cn.nukkit.block {
    declare class BlockDarkOakWallSign extends cn.nukkit.block.BlockWallSign {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        getPostId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockDarkOakWallSign" {
    declare const BlockDarkOakWallSign = cn.nukkit.block.BlockDarkOakWallSign;
}

declare namespace cn.nukkit.block {
    declare class BlockWallDeepslatePolished extends cn.nukkit.block.BlockWallBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockWallDeepslatePolished" {
    declare const BlockWallDeepslatePolished = cn.nukkit.block.BlockWallDeepslatePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockNetherBrick extends cn.nukkit.block.BlockBricksNether {
        public constructor(): void

    }
}

declare module "cn.nukkit.block.BlockNetherBrick" {
    declare const BlockNetherBrick = cn.nukkit.block.BlockNetherBrick;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazedPurple extends cn.nukkit.block.BlockTerracottaGlazed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getDyeColor(): cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazedPurple" {
    declare const BlockTerracottaGlazedPurple = cn.nukkit.block.BlockTerracottaGlazedPurple;
}

declare namespace cn.nukkit.block {
    declare class BlockWarpedWartBlock extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getToolType(): int
        public getResistance(): double
        public getHardness(): double
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockWarpedWartBlock" {
    declare const BlockWarpedWartBlock = cn.nukkit.block.BlockWarpedWartBlock;
}

declare namespace cn.nukkit.block {
    declare class BlockLiquid extends cn.nukkit.block.BlockTransparentMeta {
        constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public canBeFlowedInto(): boolean
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public hasEntityCollision(): boolean
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public canBeReplaced(): boolean
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public canHarvestWithHand(): boolean
        public getBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getMaxY(): double
        recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public usesWaterLogging(): boolean
        public getFluidHeightPercent(): float
        getFlowDecay(block: cn.nukkit.block.Block): int
        getEffectiveFlowDecay(block: cn.nukkit.block.Block): int
        public clearCaches(): void
        public getFlowVector(): cn.nukkit.math.Vector3
        public addVelocityToEntity(entity: cn.nukkit.entity.Entity, vector: cn.nukkit.math.Vector3): void
        public getFlowDecayPerBlock(): int
        public onUpdate(type: int): int
        flowIntoBlock(block: cn.nukkit.block.Block, newFlowDecay: int): void
        calculateFlowCost(blockX: int, blockY: int, blockZ: int, accumulatedCost: int, maxCost: int, originOpposite: int, lastOpposite: int): int
        public getHardness(): double
        public getResistance(): double
        getOptimalFlowDirections(): boolean[]
        getSmallestFlowDecay(block: cn.nukkit.block.Block, decay: int): int
        checkForHarden(): void
        triggerLavaMixEffects(pos: cn.nukkit.math.Vector3): void
        public getBlock(var0: int): cn.nukkit.block.BlockLiquid
        public canPassThrough(): boolean
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        liquidCollide(cause: cn.nukkit.block.Block, result: cn.nukkit.block.Block): boolean
        canFlowInto(block: cn.nukkit.block.Block): boolean
        public toItem(): cn.nukkit.item.Item
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        public getLiquidDepth(): int
        public setLiquidDepth(liquidDepth: int): void
        public isSource(): boolean
        public getDepthOnTop(): int
        public isFlowingDown(): boolean
        public isSourceOrFlowingDown(): boolean
        public getLightFilter(): int
        public static LIQUID_DEPTH: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        static CAN_FLOW_DOWN: byte
        static CAN_FLOW: byte
        static BLOCKED: byte
        public adjacentSources: int
        flowVector: cn.nukkit.math.Vector3
        flowCostVisited: it.unimi.dsi.fastutil.longs.Long2ByteMap

    }
}

declare module "cn.nukkit.block.BlockLiquid" {
    declare const BlockLiquid = cn.nukkit.block.BlockLiquid;
}

declare namespace cn.nukkit.block {
    declare class BlockTorch$TorchAttachment extends java.lang.Enum {
        public static values(): cn.nukkit.block.BlockTorch$TorchAttachment[]
        public static valueOf(name: string): cn.nukkit.block.BlockTorch$TorchAttachment
        public getTorchDirection(): cn.nukkit.math.BlockFace
        public static getByTorchDirection(face: cn.nukkit.math.BlockFace): cn.nukkit.block.BlockTorch$TorchAttachment
        public getAttachedFace(): cn.nukkit.math.BlockFace
        public static getByAttachedFace(face: cn.nukkit.math.BlockFace): cn.nukkit.block.BlockTorch$TorchAttachment
        constructor(var0: cn.nukkit.math.BlockFace): void
        static $values(): cn.nukkit.block.BlockTorch$TorchAttachment[]
        public static UNKNOWN: cn.nukkit.block.BlockTorch$TorchAttachment
        public static WEST: cn.nukkit.block.BlockTorch$TorchAttachment
        public static EAST: cn.nukkit.block.BlockTorch$TorchAttachment
        public static NORTH: cn.nukkit.block.BlockTorch$TorchAttachment
        public static SOUTH: cn.nukkit.block.BlockTorch$TorchAttachment
        public static TOP: cn.nukkit.block.BlockTorch$TorchAttachment
        torchDirection: cn.nukkit.math.BlockFace
        static $VALUES: cn.nukkit.block.BlockTorch$TorchAttachment[]

    }
}

declare module "cn.nukkit.block.BlockTorch$TorchAttachment" {
    declare const BlockTorch$TorchAttachment = cn.nukkit.block.BlockTorch$TorchAttachment;
}

declare namespace cn.nukkit.block {
    declare class BlockTripWireHook extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.RedstoneComponent {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getFacing(): cn.nukkit.math.BlockFace
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public calculateState(onBreak: boolean, updateAround: boolean, pos: int, block: cn.nukkit.block.Block): void
        addSound(pos: cn.nukkit.math.Vector3, canConnect: boolean, nextPowered: boolean, attached: boolean, powered: boolean): void
        public isAttached(): boolean
        public isPowered(): boolean
        public setPowered(value: boolean): void
        public setAttached(value: boolean): void
        public setFace(face: cn.nukkit.math.BlockFace): void
        public isPowerSource(): boolean
        public getWeakPower(face: cn.nukkit.math.BlockFace): int
        public getStrongPower(side: cn.nukkit.math.BlockFace): int
        public getWaterloggingLevel(): int
        public canBeFlowedInto(): boolean
        public toItem(): cn.nukkit.item.Item
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockTripWireHook" {
    declare const BlockTripWireHook = cn.nukkit.block.BlockTripWireHook;
}

declare namespace cn.nukkit.block {
    declare class BlockSnowLayer extends cn.nukkit.block.BlockFallableMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getSnowHeight(): int
        public setSnowHeight(snowHeight: int): void
        public isCovered(): boolean
        public setCovered(covered: boolean): void
        public getMaxY(): double
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public canBeReplaced(): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public afterRemoval(newBlock: cn.nukkit.block.Block, update: boolean): void
        public onUpdate(type: int): int
        public melt(): boolean
        public melt(layers: int): boolean
        public toItem(): cn.nukkit.item.Item
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean
        public isTransparent(): boolean
        public canBeFlowedInto(): boolean
        public canPassThrough(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        lambda$afterRemoval$3(level: cn.nukkit.level.Level): void
        static lambda$place$2(e: cn.nukkit.entity.Entity): boolean
        static lambda$place$1(b: cn.nukkit.block.BlockSnowLayer): boolean
        static lambda$place$0(b: cn.nukkit.block.Block): boolean
        public static SNOW_HEIGHT: cn.nukkit.blockproperty.IntBlockProperty
        public static COVERED: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockSnowLayer" {
    declare const BlockSnowLayer = cn.nukkit.block.BlockSnowLayer;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlab extends cn.nukkit.block.BlockDoubleSlabStone {
        public constructor(): void
        public constructor(meta: int): void
        public static STONE: int
        public static SANDSTONE: int
        public static WOODEN: int
        public static COBBLESTONE: int
        public static BRICK: int
        public static STONE_BRICK: int
        public static QUARTZ: int
        public static NETHER_BRICK: int

    }
}

declare module "cn.nukkit.block.BlockDoubleSlab" {
    declare const BlockDoubleSlab = cn.nukkit.block.BlockDoubleSlab;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsAndesite extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsAndesite" {
    declare const BlockStairsAndesite = cn.nukkit.block.BlockStairsAndesite;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabDeepslateCobbled extends cn.nukkit.block.BlockSlab {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getSlabName(): string
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean

    }
}

declare module "cn.nukkit.block.BlockSlabDeepslateCobbled" {
    declare const BlockSlabDeepslateCobbled = cn.nukkit.block.BlockSlabDeepslateCobbled;
}

declare namespace cn.nukkit.block {
    declare class BlockPressurePlateBlackstonePolished extends cn.nukkit.block.BlockPressurePlateStone {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockPressurePlateBlackstonePolished" {
    declare const BlockPressurePlateBlackstonePolished = cn.nukkit.block.BlockPressurePlateBlackstonePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockHopper extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.utils.Faceable, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityHopper>
        public getBlockEntityType(): string
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getWaterloggingLevel(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public canBeActivated(): boolean
        public hasComparatorInputOverride(): boolean
        public getComparatorInputOverride(): int
        public getFacing(): cn.nukkit.math.BlockFace
        public isEnabled(): boolean
        public setEnabled(enabled: boolean): void
        public onUpdate(type: int): int
        public getToolType(): int
        public getToolTier(): int
        public toItem(): cn.nukkit.item.Item
        public canHarvestWithHand(): boolean
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public getBlockFace(): cn.nukkit.math.BlockFace
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockHopper" {
    declare const BlockHopper = cn.nukkit.block.BlockHopper;
}

declare namespace cn.nukkit.block {
    declare class BlockBubbleColumn extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getWaterloggingLevel(): int
        public canPassThrough(): boolean
        public canBeFlowedInto(): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public toItem(): cn.nukkit.item.Item
        recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public canBePlaced(): boolean
        public canBeReplaced(): boolean
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public getBoundingBox(): cn.nukkit.math.AxisAlignedBB
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getHardness(): double
        public getResistance(): double
        public hasEntityCollision(): boolean
        public canHarvestWithHand(): boolean
        public onUpdate(type: int): int
        fadeOut(water: cn.nukkit.block.Block): void
        public static DRAG_DOWN: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockBubbleColumn" {
    declare const BlockBubbleColumn = cn.nukkit.block.BlockBubbleColumn;
}

declare namespace cn.nukkit.block {
    declare class BlockRedstoneLamp extends cn.nukkit.block.BlockSolid implements cn.nukkit.utils.RedstoneComponent {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockRedstoneLamp" {
    declare const BlockRedstoneLamp = cn.nukkit.block.BlockRedstoneLamp;
}

declare namespace cn.nukkit.block {
    declare class BlockWater extends cn.nukkit.block.BlockLiquid {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public afterRemoval(newBlock: cn.nukkit.block.Block, update: boolean): void
        public getColor(): cn.nukkit.utils.BlockColor
        public getBlock(meta: int): cn.nukkit.block.BlockLiquid
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public tickRate(): int
        public usesWaterLogging(): boolean

    }
}

declare module "cn.nukkit.block.BlockWater" {
    declare const BlockWater = cn.nukkit.block.BlockWater;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabCopperCutWaxed extends cn.nukkit.block.BlockDoubleSlabCopperCut {
        public constructor(): void
        public constructor(meta: int): void
        public getSingleSlabId(): int
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabCopperCutWaxed" {
    declare const BlockDoubleSlabCopperCutWaxed = cn.nukkit.block.BlockDoubleSlabCopperCutWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockFrogLight extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getLightLevel(): int
        public getResistance(): double
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockFrogLight" {
    declare const BlockFrogLight = cn.nukkit.block.BlockFrogLight;
}

declare namespace cn.nukkit.block {
    declare class BlockRedstoneRepeaterUnpowered extends cn.nukkit.block.BlockRedstoneRepeater {
        public constructor(): void
        public getId(): int
        public getName(): string
        getPowered(): cn.nukkit.block.Block
        getUnpowered(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockRedstoneRepeaterUnpowered" {
    declare const BlockRedstoneRepeaterUnpowered = cn.nukkit.block.BlockRedstoneRepeaterUnpowered;
}

declare namespace cn.nukkit.block {
    declare class BlockPlanksMangrove extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getBurnChance(): int
        public getBurnAbility(): int
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockPlanksMangrove" {
    declare const BlockPlanksMangrove = cn.nukkit.block.BlockPlanksMangrove;
}

declare namespace cn.nukkit.block {
    declare class BlockDoorAcacia extends cn.nukkit.block.BlockDoorWood {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoorAcacia" {
    declare const BlockDoorAcacia = cn.nukkit.block.BlockDoorAcacia;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsJungle extends cn.nukkit.block.BlockStairsWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStairsJungle" {
    declare const BlockStairsJungle = cn.nukkit.block.BlockStairsJungle;
}

declare namespace cn.nukkit.block {
    declare class BlockChest extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.Faceable, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityChest>
        public getBlockEntityType(): string
        public canBeActivated(): boolean
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getHardness(): double
        public getWaterloggingLevel(): int
        public getResistance(): double
        public getToolType(): int
        public getMinX(): double
        public getMinY(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxY(): double
        public getMaxZ(): double
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public hasComparatorInputOverride(): boolean
        public getComparatorInputOverride(): int
        public toItem(): cn.nukkit.item.Item
        public getBlockFace(): cn.nukkit.math.BlockFace
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockChest" {
    declare const BlockChest = cn.nukkit.block.BlockChest;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazedWhite extends cn.nukkit.block.BlockTerracottaGlazed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getDyeColor(): cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazedWhite" {
    declare const BlockTerracottaGlazedWhite = cn.nukkit.block.BlockTerracottaGlazedWhite;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCakeOrange extends cn.nukkit.block.BlockCandleCake {
        public constructor(meta: int): void
        public constructor(): void
        getColorName(): string
        public getId(): int
        toCandleForm(): cn.nukkit.block.BlockCandle

    }
}

declare module "cn.nukkit.block.BlockCandleCakeOrange" {
    declare const BlockCandleCakeOrange = cn.nukkit.block.BlockCandleCakeOrange;
}

declare namespace cn.nukkit.block {
    declare class BlockRaw extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public isLavaResistant(): boolean
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockRaw" {
    declare const BlockRaw = cn.nukkit.block.BlockRaw;
}

declare namespace cn.nukkit.block {
    declare class BlockTransparentMeta extends cn.nukkit.block.BlockMeta {
        constructor(): void
        constructor(meta: int): void
        public isTransparent(): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockTransparentMeta" {
    declare const BlockTransparentMeta = cn.nukkit.block.BlockTransparentMeta;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCakeGray extends cn.nukkit.block.BlockCandleCake {
        public constructor(meta: int): void
        public constructor(): void
        getColorName(): string
        public getId(): int
        toCandleForm(): cn.nukkit.block.BlockCandle

    }
}

declare module "cn.nukkit.block.BlockCandleCakeGray" {
    declare const BlockCandleCakeGray = cn.nukkit.block.BlockCandleCakeGray;
}

declare namespace cn.nukkit.block {
    declare class BlockCoralFanHang3 extends cn.nukkit.block.BlockCoralFanHang {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getType(): int
        public static HANG3_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.CoralType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCoralFanHang3" {
    declare const BlockCoralFanHang3 = cn.nukkit.block.BlockCoralFanHang3;
}

declare namespace cn.nukkit.block {
    declare class BlockDeepslateChiseled extends cn.nukkit.block.BlockDeepslateCobbled {
        public constructor(): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockDeepslateChiseled" {
    declare const BlockDeepslateChiseled = cn.nukkit.block.BlockDeepslateChiseled;
}

declare namespace cn.nukkit.block {
    declare class BlockPressurePlateCrimson extends cn.nukkit.block.BlockPressurePlateWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockPressurePlateCrimson" {
    declare const BlockPressurePlateCrimson = cn.nukkit.block.BlockPressurePlateCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockSapling extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType
        public setWoodType(woodType: cn.nukkit.blockproperty.value.WoodType): void
        public isAged(): boolean
        public setAged(aged: boolean): void
        public getName(): string
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        grow(): void
        findSaplings(type: cn.nukkit.blockproperty.value.WoodType): cn.nukkit.math.Vector2
        public isSameType(pos: cn.nukkit.math.Vector3, type: int): boolean
        public isSameType(pos: cn.nukkit.math.Vector3, type: cn.nukkit.blockproperty.value.WoodType): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public static SAPLING_TYPE: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.blockproperty.value.WoodType>
        public static AGED: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static OAK: int
        public static SPRUCE: int
        public static BIRCH: int
        public static BIRCH_TALL: int
        public static JUNGLE: int
        public static ACACIA: int
        public static DARK_OAK: int

    }
}

declare module "cn.nukkit.block.BlockSapling" {
    declare const BlockSapling = cn.nukkit.block.BlockSapling;
}

declare namespace cn.nukkit.block {
    declare class BlockQuartz extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public getName(): string
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getToolTier(): int
        public toItem(): cn.nukkit.item.Item
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static QUARTZ_NORMAL: int
        public static QUARTZ_CHISELED: int
        public static QUARTZ_PILLAR: int
        public static QUARTZ_PILLAR2: int

    }
}

declare module "cn.nukkit.block.BlockQuartz" {
    declare const BlockQuartz = cn.nukkit.block.BlockQuartz;
}

declare namespace cn.nukkit.block {
    declare class BlockVinesTwisting extends cn.nukkit.block.BlockVinesNether {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getId(): int
        public getName(): string
        public getGrowthDirection(): cn.nukkit.math.BlockFace
        public getVineAge(): int
        public setVineAge(vineAge: int): void
        public getMaxVineAge(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public static TWISTING_VINES_AGE: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockVinesTwisting" {
    declare const BlockVinesTwisting = cn.nukkit.block.BlockVinesTwisting;
}

declare namespace cn.nukkit.block {
    declare class BlockBookshelf extends cn.nukkit.block.BlockSolidMeta {
        public constructor(meta: int): void
        public constructor(): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getBurnChance(): int
        public getBurnAbility(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor
        public canSilkTouch(): boolean

    }
}

declare module "cn.nukkit.block.BlockBookshelf" {
    declare const BlockBookshelf = cn.nukkit.block.BlockBookshelf;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabCopperCutExposedWaxed extends cn.nukkit.block.BlockDoubleSlabCopperCutExposed {
        public constructor(): void
        public constructor(meta: int): void
        public getSingleSlabId(): int
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabCopperCutExposedWaxed" {
    declare const BlockDoubleSlabCopperCutExposedWaxed = cn.nukkit.block.BlockDoubleSlabCopperCutExposedWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsCopperCutOxidized extends cn.nukkit.block.BlockStairsCopperCut {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStairsCopperCutOxidized" {
    declare const BlockStairsCopperCutOxidized = cn.nukkit.block.BlockStairsCopperCutOxidized;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsBlackstonePolished extends cn.nukkit.block.BlockStairsBlackstone {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getHardness(): double

    }
}

declare module "cn.nukkit.block.BlockStairsBlackstonePolished" {
    declare const BlockStairsBlackstonePolished = cn.nukkit.block.BlockStairsBlackstonePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockWheat extends cn.nukkit.block.BlockCrops {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public toItem(): cn.nukkit.item.Item
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]

    }
}

declare module "cn.nukkit.block.BlockWheat" {
    declare const BlockWheat = cn.nukkit.block.BlockWheat;
}

declare namespace cn.nukkit.block {
    declare class BlockDispenser extends cn.nukkit.block.BlockSolidMeta implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.utils.Faceable, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public hasComparatorInputOverride(): boolean
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockEntityType(): string
        public getHardness(): double
        public getResistance(): double
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityEjectable>
        public toItem(): cn.nukkit.item.Item
        public getComparatorInputOverride(): int
        public isTriggered(): boolean
        public setTriggered(value: boolean): void
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public dispense(): void
        getDispenseBehavior(item: cn.nukkit.item.Item): cn.nukkit.dispenser.DispenseBehavior
        public canHarvestWithHand(): boolean
        public getToolType(): int
        public getToolTier(): int
        public getDispensePosition(): cn.nukkit.math.Vector3
        public getBlockFace(): cn.nukkit.math.BlockFace
        public static TRIGGERED: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockDispenser" {
    declare const BlockDispenser = cn.nukkit.block.BlockDispenser;
}

declare namespace cn.nukkit.block {
    declare class BlockWitherRose extends cn.nukkit.block.BlockFlower {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public canPlantOn(block: cn.nukkit.block.Block): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public hasEntityCollision(): boolean
        public setFlowerType(flowerType: cn.nukkit.blockproperty.value.SmallFlowerType): void
        public getFlowerType(): cn.nukkit.blockproperty.value.SmallFlowerType

    }
}

declare module "cn.nukkit.block.BlockWitherRose" {
    declare const BlockWitherRose = cn.nukkit.block.BlockWitherRose;
}

declare namespace cn.nukkit.block {
    declare class BlockMangroveLeaves extends cn.nukkit.block.BlockLeaves {
        public constructor(): void
        public getName(): string
        public getId(): int
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item): boolean
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockMangroveLeaves" {
    declare const BlockMangroveLeaves = cn.nukkit.block.BlockMangroveLeaves;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCakeBlue extends cn.nukkit.block.BlockCandleCake {
        public constructor(meta: int): void
        public constructor(): void
        getColorName(): string
        public getId(): int
        toCandleForm(): cn.nukkit.block.BlockCandle

    }
}

declare module "cn.nukkit.block.BlockCandleCakeBlue" {
    declare const BlockCandleCakeBlue = cn.nukkit.block.BlockCandleCakeBlue;
}

declare namespace cn.nukkit.block {
    declare class BlockLog extends cn.nukkit.block.BlockSolidMeta {
        constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        getStrippedState(): cn.nukkit.blockstate.BlockState
        public getPillarAxis(): cn.nukkit.math.BlockFace$Axis
        public setPillarAxis(axis: cn.nukkit.math.BlockFace$Axis): void
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getToolType(): int
        static PILLAR_PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockLog" {
    declare const BlockLog = cn.nukkit.block.BlockLog;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCakeLime extends cn.nukkit.block.BlockCandleCake {
        public constructor(meta: int): void
        public constructor(): void
        getColorName(): string
        public getId(): int
        toCandleForm(): cn.nukkit.block.BlockCandle

    }
}

declare module "cn.nukkit.block.BlockCandleCakeLime" {
    declare const BlockCandleCakeLime = cn.nukkit.block.BlockCandleCakeLime;
}

declare namespace cn.nukkit.block {
    declare class BlockHoneycombBlock extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public canHarvestWithHand(): boolean
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockHoneycombBlock" {
    declare const BlockHoneycombBlock = cn.nukkit.block.BlockHoneycombBlock;
}

declare namespace cn.nukkit.block {
    declare class BlockFenceGateBirch extends cn.nukkit.block.BlockFenceGate {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockFenceGateBirch" {
    declare const BlockFenceGateBirch = cn.nukkit.block.BlockFenceGateBirch;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabDeepslatePolished extends cn.nukkit.block.BlockSlab {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getSlabName(): string
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public getToolTier(): int
        public getToolType(): int
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockSlabDeepslatePolished" {
    declare const BlockSlabDeepslatePolished = cn.nukkit.block.BlockSlabDeepslatePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockButtonWooden extends cn.nukkit.block.BlockButton {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getToolType(): int

    }
}

declare module "cn.nukkit.block.BlockButtonWooden" {
    declare const BlockButtonWooden = cn.nukkit.block.BlockButtonWooden;
}

declare namespace cn.nukkit.block {
    declare class BlockBlackstonePolished extends cn.nukkit.block.BlockBlackstone {
        public constructor(): void
        public getName(): string
        public getId(): int
        public canHarvestWithHand(): boolean
        public getHardness(): double

    }
}

declare module "cn.nukkit.block.BlockBlackstonePolished" {
    declare const BlockBlackstonePolished = cn.nukkit.block.BlockBlackstonePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockOre extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        getRawMaterial(): cn.nukkit.item.MinecraftItemID
        getDropMultiplier(): float
        public canSilkTouch(): boolean
        public getToolType(): int
        public getToolTier(): int
        public getHardness(): double
        public getResistance(): double

    }
}

declare module "cn.nukkit.block.BlockOre" {
    declare const BlockOre = cn.nukkit.block.BlockOre;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsCopperBase extends cn.nukkit.block.BlockStairs implements cn.nukkit.block.Waxable, cn.nukkit.block.Oxidizable {
        public constructor(meta: int): void
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public canBeActivated(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public getStateWithOxidizationLevel(oxidizationLevel: cn.nukkit.blockproperty.value.OxidizationLevel): cn.nukkit.blockstate.BlockState
        public setOxidizationLevel(oxidizationLevel: cn.nukkit.blockproperty.value.OxidizationLevel): boolean
        public setWaxed(waxed: boolean): boolean
        public isWaxed(): boolean
        getCopperId(var0: boolean, var1: cn.nukkit.blockproperty.value.OxidizationLevel): int

    }
}

declare module "cn.nukkit.block.BlockStairsCopperBase" {
    declare const BlockStairsCopperBase = cn.nukkit.block.BlockStairsCopperBase;
}

declare namespace cn.nukkit.block {
    declare class BlockHugeMushroomRed extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getToolType(): int
        public getHardness(): double
        public getResistance(): double
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canSilkTouch(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockHugeMushroomRed" {
    declare const BlockHugeMushroomRed = cn.nukkit.block.BlockHugeMushroomRed;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsDeepslateCobbled extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public getToolTier(): int
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStairsDeepslateCobbled" {
    declare const BlockStairsDeepslateCobbled = cn.nukkit.block.BlockStairsDeepslateCobbled;
}

declare namespace cn.nukkit.block {
    declare class BlockMossCarpet extends cn.nukkit.block.BlockCarpet {
        public constructor(): void
        public getId(): int
        public getResistance(): double
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockMossCarpet" {
    declare const BlockMossCarpet = cn.nukkit.block.BlockMossCarpet;
}

declare namespace cn.nukkit.block {
    declare class BlockAmethyst extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public isLavaResistant(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockAmethyst" {
    declare const BlockAmethyst = cn.nukkit.block.BlockAmethyst;
}

declare namespace cn.nukkit.block {
    declare class BlockBigDripleaf extends cn.nukkit.block.BlockFlowable implements cn.nukkit.utils.Faceable {
        public static checkTiltAction(pos: cn.nukkit.level.Position): boolean
        public static addTiltAction(pos: cn.nukkit.level.Position, action: cn.nukkit.block.BlockBigDripleaf$TiltAction): void
        public static removeTiltAction(pos: cn.nukkit.level.Position): void
        constructor(): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public isHead(): boolean
        public setHead(isHead: boolean): void
        public getTilt(): cn.nukkit.block.BlockBigDripleaf$Tilt
        public setTilt(tilt: cn.nukkit.block.BlockBigDripleaf$Tilt): void
        public getWaterloggingLevel(): int
        public getToolType(): int
        public canBeActivated(): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public onUpdate(type: int): int
        public canKeepAlive(pos: cn.nukkit.level.Position): boolean
        public grow(pos: cn.nukkit.level.Position, heightIncreased: int): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public onProjectileHit(projectile: cn.nukkit.entity.Entity, position: cn.nukkit.level.Position, motion: cn.nukkit.math.Vector3): boolean
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public canPassThrough(): boolean
        public getMinY(): double
        lambda$onUpdate$2(hasEntityOn: java.util.concurrent.atomic.AtomicBoolean, entity: cn.nukkit.entity.Entity): void
        static lambda$static$1(): void
        static lambda$static$0(): void
        public static actions: java.util.Map<cn.nukkit.level.Position, cn.nukkit.block.BlockBigDripleaf$TiltAction>
        public static fullTiltBlocks: java.util.Set<cn.nukkit.level.Position>
        public static TILT: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.block.BlockBigDripleaf$Tilt>
        public static HEAD: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockBigDripleaf" {
    declare const BlockBigDripleaf = cn.nukkit.block.BlockBigDripleaf;
}

declare namespace cn.nukkit.block {
    declare class BlockAnvil extends cn.nukkit.block.BlockFallableMeta implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getAnvilDamage(): cn.nukkit.blockproperty.value.AnvilDamage
        public setAnvilDamage(anvilDamage: cn.nukkit.blockproperty.value.AnvilDamage): void
        public canBeActivated(): boolean
        public getWaterloggingLevel(): int
        public isTransparent(): boolean
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getName(): string
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public getBlockFace(): cn.nukkit.math.BlockFace
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public static DAMAGE: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.blockproperty.value.AnvilDamage>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockAnvil" {
    declare const BlockAnvil = cn.nukkit.block.BlockAnvil;
}

declare namespace cn.nukkit.block {
    declare class BlockWallBlackstonePolished extends cn.nukkit.block.BlockWallBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public canHarvestWithHand(): boolean
        public getToolType(): int
        public getToolTier(): int
        public getHardness(): double
        public getResistance(): double
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockWallBlackstonePolished" {
    declare const BlockWallBlackstonePolished = cn.nukkit.block.BlockWallBlackstonePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockWoodStrippedJungle extends cn.nukkit.block.BlockWoodStripped {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType

    }
}

declare module "cn.nukkit.block.BlockWoodStrippedJungle" {
    declare const BlockWoodStrippedJungle = cn.nukkit.block.BlockWoodStrippedJungle;
}

declare namespace cn.nukkit.block {
    declare class BlockStructureVoid extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getType(): cn.nukkit.blockproperty.value.StructureVoidType
        public setType(type: cn.nukkit.blockproperty.value.StructureVoidType): void
        public getHardness(): double
        public getResistance(): double
        public canPassThrough(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public canHarvestWithHand(): boolean
        public canBePushed(): boolean
        public canBePulled(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public static STRUCTURE_VOID_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.StructureVoidType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockStructureVoid" {
    declare const BlockStructureVoid = cn.nukkit.block.BlockStructureVoid;
}

declare namespace cn.nukkit.block {
    declare class BlockLeaves2 extends cn.nukkit.block.BlockLeaves {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getType(): cn.nukkit.blockproperty.value.WoodType
        public setType(type: cn.nukkit.blockproperty.value.WoodType): void
        public getId(): int
        canDropApple(): boolean
        getSapling(): cn.nukkit.item.Item
        public static NEW_LEAF_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.WoodType>
        public static NEW_LEAF_PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static ACACIA: int
        public static DARK_OAK: int

    }
}

declare module "cn.nukkit.block.BlockLeaves2" {
    declare const BlockLeaves2 = cn.nukkit.block.BlockLeaves2;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCakePink extends cn.nukkit.block.BlockCandleCake {
        public constructor(meta: int): void
        public constructor(): void
        getColorName(): string
        public getId(): int
        toCandleForm(): cn.nukkit.block.BlockCandle

    }
}

declare module "cn.nukkit.block.BlockCandleCakePink" {
    declare const BlockCandleCakePink = cn.nukkit.block.BlockCandleCakePink;
}

declare namespace cn.nukkit.block {
    declare class BlockWall$WallConnectionType extends java.lang.Enum {
        public static values(): cn.nukkit.block.BlockWall$WallConnectionType[]
        public static valueOf(name: string): cn.nukkit.block.BlockWall$WallConnectionType
        constructor(): void
        static $values(): cn.nukkit.block.BlockWall$WallConnectionType[]
        public static NONE: cn.nukkit.block.BlockWall$WallConnectionType
        public static SHORT: cn.nukkit.block.BlockWall$WallConnectionType
        public static TALL: cn.nukkit.block.BlockWall$WallConnectionType
        static $VALUES: cn.nukkit.block.BlockWall$WallConnectionType[]

    }
}

declare module "cn.nukkit.block.BlockWall$WallConnectionType" {
    declare const BlockWall$WallConnectionType = cn.nukkit.block.BlockWall$WallConnectionType;
}

declare namespace cn.nukkit.block {
    declare class BlockButton extends cn.nukkit.block.BlockFlowable implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getResistance(): double
        public getHardness(): double
        public getWaterloggingLevel(): int
        public canBeFlowedInto(): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public isActivated(): boolean
        public setActivated(activated: boolean): void
        public isPowerSource(): boolean
        public getWeakPower(side: cn.nukkit.math.BlockFace): int
        public getStrongPower(side: cn.nukkit.math.BlockFace): int
        public getFacing(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public onBreak(item: cn.nukkit.item.Item): boolean
        public toItem(): cn.nukkit.item.Item
        public getBlockFace(): cn.nukkit.math.BlockFace
        static BUTTON_PRESSED: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockButton" {
    declare const BlockButton = cn.nukkit.block.BlockButton;
}

declare namespace cn.nukkit.block {
    declare class BlockWallBrickDeepslate extends cn.nukkit.block.BlockWallBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockWallBrickDeepslate" {
    declare const BlockWallBrickDeepslate = cn.nukkit.block.BlockWallBrickDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleBlue extends cn.nukkit.block.BlockCandle {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        toCakeForm(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockCandleBlue" {
    declare const BlockCandleBlue = cn.nukkit.block.BlockCandleBlue;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperCutOxidized extends cn.nukkit.block.BlockCopperCut {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel

    }
}

declare module "cn.nukkit.block.BlockCopperCutOxidized" {
    declare const BlockCopperCutOxidized = cn.nukkit.block.BlockCopperCutOxidized;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabCopperCutExposed extends cn.nukkit.block.BlockSlabCopperCut {
        public constructor(): void
        public constructor(meta: int): void
        constructor(meta: int, doubleSlab: int): void
        public getId(): int
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockSlabCopperCutExposed" {
    declare const BlockSlabCopperCutExposed = cn.nukkit.block.BlockSlabCopperCutExposed;
}

declare namespace cn.nukkit.block {
    declare class BlockDoor extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.utils.Faceable {
        constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public canBeActivated(): boolean
        public getWaterloggingLevel(): int
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public getFullDamage(): int
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        recalculateBoundingBoxWithPos(pos: cn.nukkit.math.BlockFace): cn.nukkit.math.AxisAlignedBB
        public onUpdate(type: int): int
        onNormalUpdate(): void
        onRedstoneUpdate(): void
        public setManualOverride(val: boolean): void
        public getManualOverride(): boolean
        public isGettingPower(): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public playOpenCloseSound(): void
        public playOpenSound(): void
        public playCloseSound(): void
        public toggle(player: cn.nukkit.Player): boolean
        public setOpen(player: cn.nukkit.Player, open: boolean): boolean
        public setOpen(open: boolean): void
        public isOpen(): boolean
        public isTop(): boolean
        public setTop(top: boolean): void
        public isTop(meta: int): boolean
        public isRightHinged(): boolean
        public setRightHinged(rightHinged: boolean): void
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        static THICKNESS: double
        static manualOverrides: java.util.List<cn.nukkit.level.Location>
        public static DOOR_HINGE: cn.nukkit.blockproperty.BooleanBlockProperty
        public static DOOR_DIRECTION: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.math.BlockFace>
        static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static DOOR_OPEN_BIT: int
        public static DOOR_TOP_BIT: int
        public static DOOR_HINGE_BIT: int
        public static DOOR_POWERED_BIT: int

    }
}

declare module "cn.nukkit.block.BlockDoor" {
    declare const BlockDoor = cn.nukkit.block.BlockDoor;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsBrickDeepslate extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolTier(): int
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsBrickDeepslate" {
    declare const BlockStairsBrickDeepslate = cn.nukkit.block.BlockStairsBrickDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockCoal extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getBurnChance(): int
        public getBurnAbility(): int
        public getName(): string
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockCoal" {
    declare const BlockCoal = cn.nukkit.block.BlockCoal;
}

declare namespace cn.nukkit.block {
    declare class BlockWallSign extends cn.nukkit.block.BlockSignPost {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getWallId(): int
        getPostId(): int
        public getName(): string
        public onUpdate(type: int): int
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setSignDirection(direction: cn.nukkit.math.CompassRoseDirection): void
        public getSignDirection(): cn.nukkit.math.CompassRoseDirection
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockWallSign" {
    declare const BlockWallSign = cn.nukkit.block.BlockWallSign;
}

declare namespace cn.nukkit.block {
    declare class BlockOreRedstone extends cn.nukkit.block.BlockOre {
        public constructor(): void
        public getId(): int
        public getToolTier(): int
        public getName(): string
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public onUpdate(type: int): int
        getRawMaterial(): cn.nukkit.item.MinecraftItemID
        public getLitState(): cn.nukkit.blockstate.BlockState
        public getUnlitState(): cn.nukkit.blockstate.BlockState
        public getDropExp(): int

    }
}

declare module "cn.nukkit.block.BlockOreRedstone" {
    declare const BlockOreRedstone = cn.nukkit.block.BlockOreRedstone;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsEndBrick extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsEndBrick" {
    declare const BlockStairsEndBrick = cn.nukkit.block.BlockStairsEndBrick;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleMudBrickSlab extends cn.nukkit.block.BlockDoubleSlabBase {
        public constructor(): void
        public getId(): int
        public getSlabName(): string
        public getSingleSlabId(): int

    }
}

declare module "cn.nukkit.block.BlockDoubleMudBrickSlab" {
    declare const BlockDoubleMudBrickSlab = cn.nukkit.block.BlockDoubleMudBrickSlab;
}

declare namespace cn.nukkit.block {
    declare class BlockIron extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getToolType(): int
        public getHardness(): double
        public getResistance(): double
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockIron" {
    declare const BlockIron = cn.nukkit.block.BlockIron;
}

declare namespace cn.nukkit.block {
    declare class BlockDoorJungle extends cn.nukkit.block.BlockDoorWood {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoorJungle" {
    declare const BlockDoorJungle = cn.nukkit.block.BlockDoorJungle;
}

declare namespace cn.nukkit.block {
    declare class BlockCactus extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(meta: int): void
        public constructor(): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public getWaterloggingLevel(): int
        public hasEntityCollision(): boolean
        public getMinX(): double
        public getMinY(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxY(): double
        public getMaxZ(): double
        recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCactus" {
    declare const BlockCactus = cn.nukkit.block.BlockCactus;
}

declare namespace cn.nukkit.block {
    declare class BlockDiamond extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getId(): int
        public getName(): string
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockDiamond" {
    declare const BlockDiamond = cn.nukkit.block.BlockDiamond;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabCopperCutWeatheredWaxed extends cn.nukkit.block.BlockSlabCopperCutWeathered {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockSlabCopperCutWeatheredWaxed" {
    declare const BlockSlabCopperCutWeatheredWaxed = cn.nukkit.block.BlockSlabCopperCutWeatheredWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazedMagenta extends cn.nukkit.block.BlockTerracottaGlazed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getDyeColor(): cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazedMagenta" {
    declare const BlockTerracottaGlazedMagenta = cn.nukkit.block.BlockTerracottaGlazedMagenta;
}

declare namespace cn.nukkit.block {
    declare class BlockPistonSticky extends cn.nukkit.block.BlockPistonBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getPistonHeadBlockId(): int

    }
}

declare module "cn.nukkit.block.BlockPistonSticky" {
    declare const BlockPistonSticky = cn.nukkit.block.BlockPistonSticky;
}

declare namespace cn.nukkit.block {
    declare class BlockWool extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(dyeColor: cn.nukkit.utils.DyeColor): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getToolType(): int
        public getHardness(): double
        public getResistance(): double
        public getBurnChance(): int
        public getBurnAbility(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getDyeColor(): cn.nukkit.utils.DyeColor
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockWool" {
    declare const BlockWool = cn.nukkit.block.BlockWool;
}

declare namespace cn.nukkit.block {
    declare class BlockOreEmeraldDeepslate extends cn.nukkit.block.BlockOreEmerald {
        public constructor(): void
        public getId(): int
        public getHardness(): double
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockOreEmeraldDeepslate" {
    declare const BlockOreEmeraldDeepslate = cn.nukkit.block.BlockOreEmeraldDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCakeYellow extends cn.nukkit.block.BlockCandleCake {
        public constructor(meta: int): void
        public constructor(): void
        getColorName(): string
        public getId(): int
        toCandleForm(): cn.nukkit.block.BlockCandle

    }
}

declare module "cn.nukkit.block.BlockCandleCakeYellow" {
    declare const BlockCandleCakeYellow = cn.nukkit.block.BlockCandleCakeYellow;
}

declare namespace cn.nukkit.block {
    declare class BlockStemStripped extends cn.nukkit.block.BlockStem {
        public constructor(meta: int): void
        getStrippedState(): cn.nukkit.blockstate.BlockState
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean

    }
}

declare module "cn.nukkit.block.BlockStemStripped" {
    declare const BlockStemStripped = cn.nukkit.block.BlockStemStripped;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabCopperBase extends cn.nukkit.block.BlockSlab implements cn.nukkit.block.Waxable, cn.nukkit.block.Oxidizable {
        public constructor(meta: int, doubleSlab: int): void
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public canBeActivated(): boolean
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getColor(): cn.nukkit.utils.BlockColor
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public getStateWithOxidizationLevel(oxidizationLevel: cn.nukkit.blockproperty.value.OxidizationLevel): cn.nukkit.blockstate.BlockState
        public setOxidizationLevel(oxidizationLevel: cn.nukkit.blockproperty.value.OxidizationLevel): boolean
        public setWaxed(waxed: boolean): boolean
        public isWaxed(): boolean
        getCopperId(var0: boolean, var1: cn.nukkit.blockproperty.value.OxidizationLevel): int

    }
}

declare module "cn.nukkit.block.BlockSlabCopperBase" {
    declare const BlockSlabCopperBase = cn.nukkit.block.BlockSlabCopperBase;
}

declare namespace cn.nukkit.block {
    declare class BlockLever$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$math$BlockFace$Axis: int[]
        static $SwitchMap$cn$nukkit$math$BlockFace: int[]

    }
}

declare module "cn.nukkit.block.BlockLever$1" {
    declare const BlockLever$1 = cn.nukkit.block.BlockLever$1;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperCutWeatheredWaxed extends cn.nukkit.block.BlockCopperCutWeathered {
        public constructor(): void
        public getName(): string
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockCopperCutWeatheredWaxed" {
    declare const BlockCopperCutWeatheredWaxed = cn.nukkit.block.BlockCopperCutWeatheredWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazedGray extends cn.nukkit.block.BlockTerracottaGlazed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getDyeColor(): cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazedGray" {
    declare const BlockTerracottaGlazedGray = cn.nukkit.block.BlockTerracottaGlazedGray;
}

declare namespace cn.nukkit.block {
    declare class BlockMudBrickStairs extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public getName(): string
        public getId(): int

    }
}

declare module "cn.nukkit.block.BlockMudBrickStairs" {
    declare const BlockMudBrickStairs = cn.nukkit.block.BlockMudBrickStairs;
}

declare namespace cn.nukkit.block {
    declare class BlockMoving extends cn.nukkit.block.BlockTransparent implements cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getBlockEntityType(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityMovingBlock>
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canBePushed(): boolean
        public canBePulled(): boolean
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public canPassThrough(): boolean
        public isSolid(): boolean

    }
}

declare module "cn.nukkit.block.BlockMoving" {
    declare const BlockMoving = cn.nukkit.block.BlockMoving;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsQuartz extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsQuartz" {
    declare const BlockStairsQuartz = cn.nukkit.block.BlockStairsQuartz;
}

declare namespace cn.nukkit.block {
    declare class BlockMossStone extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockMossStone" {
    declare const BlockMossStone = cn.nukkit.block.BlockMossStone;
}

declare namespace cn.nukkit.block {
    declare class BlockWoodStrippedSpruce extends cn.nukkit.block.BlockWoodStripped {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType

    }
}

declare module "cn.nukkit.block.BlockWoodStrippedSpruce" {
    declare const BlockWoodStrippedSpruce = cn.nukkit.block.BlockWoodStrippedSpruce;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabCopperCut$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$blockproperty$value$OxidizationLevel: int[]

    }
}

declare module "cn.nukkit.block.BlockSlabCopperCut$1" {
    declare const BlockSlabCopperCut$1 = cn.nukkit.block.BlockSlabCopperCut$1;
}

declare namespace cn.nukkit.block {
    declare class BlockWoodStripped extends cn.nukkit.block.BlockWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        getStrippedState(): cn.nukkit.blockstate.BlockState
        public getName(): string
        public setWoodType(woodType: cn.nukkit.blockproperty.value.WoodType): void
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean

    }
}

declare module "cn.nukkit.block.BlockWoodStripped" {
    declare const BlockWoodStripped = cn.nukkit.block.BlockWoodStripped;
}

declare namespace cn.nukkit.block {
    declare class BlockRoots extends cn.nukkit.block.BlockFlowable {
        constructor(): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        isSupportValid(): boolean
        public getBurnChance(): int

    }
}

declare module "cn.nukkit.block.BlockRoots" {
    declare const BlockRoots = cn.nukkit.block.BlockRoots;
}

declare namespace cn.nukkit.scheduler {
    declare class NukkitRunnable extends java.lang.Object implements java.lang.Runnable {
        public constructor(): void
        public cancel(): void
        public runTask(plugin: cn.nukkit.plugin.Plugin): java.lang.Runnable
        public runTaskAsynchronously(plugin: cn.nukkit.plugin.Plugin): java.lang.Runnable
        public runTaskLater(plugin: cn.nukkit.plugin.Plugin, delay: int): java.lang.Runnable
        public runTaskLaterAsynchronously(plugin: cn.nukkit.plugin.Plugin, delay: int): java.lang.Runnable
        public runTaskTimer(plugin: cn.nukkit.plugin.Plugin, delay: int, period: int): java.lang.Runnable
        public runTaskTimerAsynchronously(plugin: cn.nukkit.plugin.Plugin, delay: int, period: int): java.lang.Runnable
        public getTaskId(): int
        checkState(): void
        taskHandler: cn.nukkit.scheduler.TaskHandler

    }
}

declare module "cn.nukkit.scheduler.NukkitRunnable" {
    declare const NukkitRunnable = cn.nukkit.scheduler.NukkitRunnable;
}

declare namespace cn.nukkit.scheduler {
    declare class ServerScheduler extends java.lang.Object {
        public constructor(): void
        public scheduleTask(task: cn.nukkit.scheduler.Task): cn.nukkit.scheduler.TaskHandler
        public scheduleTask(task: java.lang.Runnable): cn.nukkit.scheduler.TaskHandler
        public scheduleTask(plugin: cn.nukkit.plugin.Plugin, task: java.lang.Runnable): cn.nukkit.scheduler.TaskHandler
        public scheduleTask(task: java.lang.Runnable, asynchronous: boolean): cn.nukkit.scheduler.TaskHandler
        public scheduleTask(plugin: cn.nukkit.plugin.Plugin, task: java.lang.Runnable, asynchronous: boolean): cn.nukkit.scheduler.TaskHandler
        public scheduleAsyncTask(task: cn.nukkit.scheduler.AsyncTask): cn.nukkit.scheduler.TaskHandler
        public scheduleAsyncTask(plugin: cn.nukkit.plugin.Plugin, task: cn.nukkit.scheduler.AsyncTask): cn.nukkit.scheduler.TaskHandler
        public scheduleAsyncTaskToWorker(task: cn.nukkit.scheduler.AsyncTask, worker: int): void
        public getAsyncTaskPoolSize(): int
        public increaseAsyncTaskPoolSize(newSize: int): void
        public scheduleDelayedTask(task: cn.nukkit.scheduler.Task, delay: int): cn.nukkit.scheduler.TaskHandler
        public scheduleDelayedTask(task: cn.nukkit.scheduler.Task, delay: int, asynchronous: boolean): cn.nukkit.scheduler.TaskHandler
        public scheduleDelayedTask(task: java.lang.Runnable, delay: int): cn.nukkit.scheduler.TaskHandler
        public scheduleDelayedTask(plugin: cn.nukkit.plugin.Plugin, task: java.lang.Runnable, delay: int): cn.nukkit.scheduler.TaskHandler
        public scheduleDelayedTask(task: java.lang.Runnable, delay: int, asynchronous: boolean): cn.nukkit.scheduler.TaskHandler
        public scheduleDelayedTask(plugin: cn.nukkit.plugin.Plugin, task: java.lang.Runnable, delay: int, asynchronous: boolean): cn.nukkit.scheduler.TaskHandler
        public scheduleRepeatingTask(task: java.lang.Runnable, period: int): cn.nukkit.scheduler.TaskHandler
        public scheduleRepeatingTask(plugin: cn.nukkit.plugin.Plugin, task: java.lang.Runnable, period: int): cn.nukkit.scheduler.TaskHandler
        public scheduleRepeatingTask(task: java.lang.Runnable, period: int, asynchronous: boolean): cn.nukkit.scheduler.TaskHandler
        public scheduleRepeatingTask(plugin: cn.nukkit.plugin.Plugin, task: java.lang.Runnable, period: int, asynchronous: boolean): cn.nukkit.scheduler.TaskHandler
        public scheduleRepeatingTask(task: cn.nukkit.scheduler.Task, period: int): cn.nukkit.scheduler.TaskHandler
        public scheduleRepeatingTask(task: cn.nukkit.scheduler.Task, period: int, asynchronous: boolean): cn.nukkit.scheduler.TaskHandler
        public scheduleDelayedRepeatingTask(task: cn.nukkit.scheduler.Task, delay: int, period: int): cn.nukkit.scheduler.TaskHandler
        public scheduleDelayedRepeatingTask(task: cn.nukkit.scheduler.Task, delay: int, period: int, asynchronous: boolean): cn.nukkit.scheduler.TaskHandler
        public scheduleDelayedRepeatingTask(task: java.lang.Runnable, delay: int, period: int): cn.nukkit.scheduler.TaskHandler
        public scheduleDelayedRepeatingTask(plugin: cn.nukkit.plugin.Plugin, task: java.lang.Runnable, delay: int, period: int): cn.nukkit.scheduler.TaskHandler
        public scheduleDelayedRepeatingTask(task: java.lang.Runnable, delay: int, period: int, asynchronous: boolean): cn.nukkit.scheduler.TaskHandler
        public scheduleDelayedRepeatingTask(plugin: cn.nukkit.plugin.Plugin, task: java.lang.Runnable, delay: int, period: int, asynchronous: boolean): cn.nukkit.scheduler.TaskHandler
        public cancelTask(taskId: int): void
        public cancelTask(plugin: cn.nukkit.plugin.Plugin): void
        public cancelAllTasks(): void
        public isQueued(taskId: int): boolean
        addTask(task: cn.nukkit.scheduler.Task, delay: int, period: int, asynchronous: boolean): cn.nukkit.scheduler.TaskHandler
        addTask(plugin: cn.nukkit.plugin.Plugin, task: java.lang.Runnable, delay: int, period: int, asynchronous: boolean): cn.nukkit.scheduler.TaskHandler
        public mainThreadHeartbeat(currentTick: int): void
        runTasks(currentTick: int): void
        public getQueueSize(): int
        nextTaskId(): int
        static log: org.apache.logging.log4j.Logger
        public static WORKERS: int
        asyncPool: cn.nukkit.scheduler.AsyncPool
        pending: java.util.Queue<cn.nukkit.scheduler.TaskHandler>
        queueMap: java.util.Map<int, java.util.ArrayDeque<cn.nukkit.scheduler.TaskHandler>>
        taskMap: java.util.Map<int, cn.nukkit.scheduler.TaskHandler>
        currentTaskId: java.util.concurrent.atomic.AtomicInteger
        currentTick: int

    }
}

declare module "cn.nukkit.scheduler.ServerScheduler" {
    declare const ServerScheduler = cn.nukkit.scheduler.ServerScheduler;
}

declare namespace cn.nukkit.scheduler {
    declare class AsyncPool extends java.util.concurrent.ThreadPoolExecutor {
        public constructor(server: cn.nukkit.Server, size: int): void
        afterExecute(runnable: java.lang.Runnable, throwable: java.lang.Throwable): void
        public getServer(): cn.nukkit.Server
        lambda$new$0(runnable: java.lang.Runnable): java.lang.Thread
        static log: org.apache.logging.log4j.Logger
        server: cn.nukkit.Server

    }
}

declare module "cn.nukkit.scheduler.AsyncPool" {
    declare const AsyncPool = cn.nukkit.scheduler.AsyncPool;
}

declare namespace cn.nukkit.scheduler {
    declare class TaskHandler extends java.lang.Object {
        public constructor(plugin: cn.nukkit.plugin.Plugin, task: java.lang.Runnable, taskId: int, asynchronous: boolean): void
        public isCancelled(): boolean
        public getNextRunTick(): int
        public setNextRunTick(nextRunTick: int): void
        public getTaskId(): int
        public getTask(): java.lang.Runnable
        public getDelay(): int
        public isDelayed(): boolean
        public isRepeating(): boolean
        public getPeriod(): int
        public getPlugin(): cn.nukkit.plugin.Plugin
        public getLastRunTick(): int
        public setLastRunTick(lastRunTick: int): void
        public cancel(): void
        public remove(): void
        public run(currentTick: int): void
        public getTaskName(): string
        public isAsynchronous(): boolean
        public setDelay(delay: int): void
        public setPeriod(period: int): void
        static log: org.apache.logging.log4j.Logger
        taskId: int
        asynchronous: boolean
        plugin: cn.nukkit.plugin.Plugin
        task: java.lang.Runnable
        delay: int
        period: int
        lastRunTick: int
        nextRunTick: int
        cancelled: boolean
        public timing: co.aikar.timings.Timing

    }
}

declare module "cn.nukkit.scheduler.TaskHandler" {
    declare const TaskHandler = cn.nukkit.scheduler.TaskHandler;
}

declare namespace cn.nukkit.inventory {
    declare class PlayerUIInventory extends cn.nukkit.inventory.BaseInventory {
        public constructor(player: cn.nukkit.Player): void
        public getCursorInventory(): cn.nukkit.inventory.PlayerCursorInventory
        public getCraftingGrid(): cn.nukkit.inventory.CraftingGrid
        public getBigCraftingGrid(): cn.nukkit.inventory.BigCraftingGrid
        public onOpen(who: cn.nukkit.Player): void
        public onClose(who: cn.nukkit.Player): void
        public setSize(size: int): void
        public sendSlot(index: int, target: cn.nukkit.Player[]): void
        public sendContents(target: cn.nukkit.Player[]): void
        public onSlotChange(index: int, before: cn.nukkit.item.Item, send: boolean): void
        public onSlotChangeBase(index: int, before: cn.nukkit.item.Item, send: boolean): void
        public getSize(): int
        public getHolder(): cn.nukkit.Player
        public getHolder(): cn.nukkit.inventory.InventoryHolder
        player: cn.nukkit.Player
        cursorInventory: cn.nukkit.inventory.PlayerCursorInventory
        craftingGrid: cn.nukkit.inventory.CraftingGrid
        bigCraftingGrid: cn.nukkit.inventory.BigCraftingGrid

    }
}

declare module "cn.nukkit.inventory.PlayerUIInventory" {
    declare const PlayerUIInventory = cn.nukkit.inventory.PlayerUIInventory;
}

declare namespace cn.nukkit.inventory {
    declare class DispenserInventory extends cn.nukkit.inventory.EjectableInventory {
        public constructor(blockEntity: cn.nukkit.blockentity.BlockEntityDispenser): void
        public getHolder(): cn.nukkit.blockentity.BlockEntityDispenser
        public getHolder(): cn.nukkit.inventory.InventoryHolder

    }
}

declare module "cn.nukkit.inventory.DispenserInventory" {
    declare const DispenserInventory = cn.nukkit.inventory.DispenserInventory;
}

declare namespace cn.nukkit.inventory {
    declare class DoubleChestInventory extends cn.nukkit.inventory.ContainerInventory implements cn.nukkit.inventory.InventoryHolder {
        public constructor(left: cn.nukkit.blockentity.BlockEntityChest, right: cn.nukkit.blockentity.BlockEntityChest): void
        public getInventory(): cn.nukkit.inventory.Inventory
        public getHolder(): cn.nukkit.blockentity.BlockEntityChest
        public getItem(index: int): cn.nukkit.item.Item
        public setItem(index: int, item: cn.nukkit.item.Item, send: boolean): boolean
        public clear(index: int, send: boolean): boolean
        public getContents(): java.util.Map<int, cn.nukkit.item.Item>
        public setContents(items: java.util.Map<int, cn.nukkit.item.Item>): void
        public onOpen(who: cn.nukkit.Player): void
        public onClose(who: cn.nukkit.Player): void
        public getLeftSide(): cn.nukkit.inventory.ChestInventory
        public getRightSide(): cn.nukkit.inventory.ChestInventory
        public sendSlot(inv: cn.nukkit.inventory.Inventory, index: int, players: cn.nukkit.Player[]): void
        public getHolder(): cn.nukkit.inventory.InventoryHolder
        left: cn.nukkit.inventory.ChestInventory
        right: cn.nukkit.inventory.ChestInventory

    }
}

declare module "cn.nukkit.inventory.DoubleChestInventory" {
    declare const DoubleChestInventory = cn.nukkit.inventory.DoubleChestInventory;
}

declare namespace cn.nukkit.inventory {
    declare class ShulkerBoxInventory extends cn.nukkit.inventory.ContainerInventory {
        public constructor(box: cn.nukkit.blockentity.BlockEntityShulkerBox): void
        public getHolder(): cn.nukkit.blockentity.BlockEntityShulkerBox
        public onOpen(who: cn.nukkit.Player): void
        public onClose(who: cn.nukkit.Player): void
        public canAddItem(item: cn.nukkit.item.Item): boolean
        public sendSlot(index: int, players: cn.nukkit.Player[]): void
        public getHolder(): cn.nukkit.inventory.InventoryHolder

    }
}

declare module "cn.nukkit.inventory.ShulkerBoxInventory" {
    declare const ShulkerBoxInventory = cn.nukkit.inventory.ShulkerBoxInventory;
}

declare namespace cn.nukkit.inventory {
    declare class SmithingRecipe extends cn.nukkit.inventory.ShapelessRecipe {
        public constructor(recipeId: string, priority: int, ingredients: java.util.Collection<cn.nukkit.item.Item>, result: cn.nukkit.item.Item): void
        public getResult(): cn.nukkit.item.Item
        public getFinalResult(equip: cn.nukkit.item.Item): cn.nukkit.item.Item
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void
        public getType(): cn.nukkit.inventory.RecipeType
        public getEquipment(): cn.nukkit.item.Item
        public getIngredient(): cn.nukkit.item.Item
        public getIngredientsAggregate(): java.util.List<cn.nukkit.item.Item>
        public matchItems(inputList: java.util.List<cn.nukkit.item.Item>): boolean
        public matchItems(inputList: java.util.List<cn.nukkit.item.Item>, multiplier: int): boolean
        public toString(): string
        equipment: cn.nukkit.item.Item
        ingredient: cn.nukkit.item.Item
        result: cn.nukkit.item.Item
        ingredientsAggregate: java.util.List<cn.nukkit.item.Item>

    }
}

declare module "cn.nukkit.inventory.SmithingRecipe" {
    declare const SmithingRecipe = cn.nukkit.inventory.SmithingRecipe;
}

declare namespace cn.nukkit.inventory {
    declare class FurnaceRecipe extends java.lang.Object implements cn.nukkit.inventory.SmeltingRecipe {
        public constructor(result: cn.nukkit.item.Item, ingredient: cn.nukkit.item.Item): void
        public setInput(item: cn.nukkit.item.Item): void
        public getInput(): cn.nukkit.item.Item
        public getResult(): cn.nukkit.item.Item
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void
        public getType(): cn.nukkit.inventory.RecipeType
        output: cn.nukkit.item.Item
        ingredient: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.inventory.FurnaceRecipe" {
    declare const FurnaceRecipe = cn.nukkit.inventory.FurnaceRecipe;
}

declare namespace cn.nukkit.inventory {
    declare interface EntityInventoryHolder extends cn.nukkit.inventory.InventoryHolder {
        public getArmorInventory(): cn.nukkit.inventory.EntityArmorInventory
        public getEquipmentInventory(): cn.nukkit.inventory.EntityEquipmentInventory
        public canEquipByDispenser(): boolean
        public getHelmet(): cn.nukkit.item.Item
        public setHelmet(item: cn.nukkit.item.Item): boolean
        public getChestplate(): cn.nukkit.item.Item
        public setChestplate(item: cn.nukkit.item.Item): boolean
        public getLeggings(): cn.nukkit.item.Item
        public setLeggings(item: cn.nukkit.item.Item): boolean
        public getBoots(): cn.nukkit.item.Item
        public setBoots(item: cn.nukkit.item.Item): boolean
        public getItemInHand(): cn.nukkit.item.Item
        public setItemInHand(item: cn.nukkit.item.Item): boolean

    }
}

declare module "cn.nukkit.inventory.EntityInventoryHolder" {
    declare type EntityInventoryHolder = cn.nukkit.inventory.EntityInventoryHolder;
}

declare namespace cn.nukkit.inventory {
    declare class BrewingInventory extends cn.nukkit.inventory.ContainerInventory {
        public constructor(brewingStand: cn.nukkit.blockentity.BlockEntityBrewingStand): void
        public getHolder(): cn.nukkit.blockentity.BlockEntityBrewingStand
        public getIngredient(): cn.nukkit.item.Item
        public setIngredient(item: cn.nukkit.item.Item): void
        public setFuel(fuel: cn.nukkit.item.Item): void
        public getFuel(): cn.nukkit.item.Item
        public onSlotChange(index: int, before: cn.nukkit.item.Item, send: boolean): void
        public getHolder(): cn.nukkit.inventory.InventoryHolder

    }
}

declare module "cn.nukkit.inventory.BrewingInventory" {
    declare const BrewingInventory = cn.nukkit.inventory.BrewingInventory;
}

declare namespace cn.nukkit.inventory {
    declare class AnvilInventory extends cn.nukkit.inventory.FakeBlockUIComponent {
        public constructor(playerUI: cn.nukkit.inventory.PlayerUIInventory, position: cn.nukkit.level.Position): void
        public updateResult(): void
        public onClose(who: cn.nukkit.Player): void
        public onOpen(who: cn.nukkit.Player): void
        public getFirstItem(): cn.nukkit.item.Item
        public getInputSlot(): cn.nukkit.item.Item
        public getSecondItem(): cn.nukkit.item.Item
        public getMaterialSlot(): cn.nukkit.item.Item
        public getResult(): cn.nukkit.item.Item
        public getOutputSlot(): cn.nukkit.item.Item
        public setFirstItem(item: cn.nukkit.item.Item, send: boolean): boolean
        public setFirstItem(item: cn.nukkit.item.Item): boolean
        public setSecondItem(item: cn.nukkit.item.Item, send: boolean): boolean
        public setSecondItem(item: cn.nukkit.item.Item): boolean
        setResult(item: cn.nukkit.item.Item, send: boolean): boolean
        setResult(item: cn.nukkit.item.Item): boolean
        static getRepairCost(item: cn.nukkit.item.Item): int
        public getLevelCost(): int
        setLevelCost(levelCost: int): void
        public getCost(): int
        public setCost(cost: int): void
        public getNewItemName(): string
        public setNewItemName(newItemName: string): void
        static getRepairMaterial(target: cn.nukkit.item.Item): int
        public static ANVIL_INPUT_UI_SLOT: int
        public static ANVIL_MATERIAL_UI_SLOT: int
        public static ANVIL_OUTPUT_UI_SLOT: int
        public static OFFSET: int
        public static TARGET: int
        public static SACRIFICE: int
        public static RESULT: int
        cost: int
        newItemName: string
        currentResult: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.inventory.AnvilInventory" {
    declare const AnvilInventory = cn.nukkit.inventory.AnvilInventory;
}

declare namespace cn.nukkit.inventory {
    declare class BlastFurnaceRecipe extends java.lang.Object implements cn.nukkit.inventory.SmeltingRecipe {
        public constructor(result: cn.nukkit.item.Item, ingredient: cn.nukkit.item.Item): void
        public setInput(item: cn.nukkit.item.Item): void
        public getInput(): cn.nukkit.item.Item
        public getResult(): cn.nukkit.item.Item
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void
        public getType(): cn.nukkit.inventory.RecipeType
        output: cn.nukkit.item.Item
        ingredient: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.inventory.BlastFurnaceRecipe" {
    declare const BlastFurnaceRecipe = cn.nukkit.inventory.BlastFurnaceRecipe;
}

declare namespace cn.nukkit.inventory {
    declare interface SmeltingRecipe extends cn.nukkit.inventory.Recipe {
        public getInput(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.inventory.SmeltingRecipe" {
    declare type SmeltingRecipe = cn.nukkit.inventory.SmeltingRecipe;
}

declare namespace cn.nukkit.inventory {
    declare class CustomInventory extends cn.nukkit.inventory.ContainerInventory {
        public constructor(holder: cn.nukkit.inventory.InventoryHolder, type: cn.nukkit.inventory.InventoryType): void
        public constructor(holder: cn.nukkit.inventory.InventoryHolder, type: cn.nukkit.inventory.InventoryType, items: java.util.Map<int, cn.nukkit.item.Item>): void
        public constructor(holder: cn.nukkit.inventory.InventoryHolder, type: cn.nukkit.inventory.InventoryType, items: java.util.Map<int, cn.nukkit.item.Item>, overrideSize: int): void
        public constructor(holder: cn.nukkit.inventory.InventoryHolder, type: cn.nukkit.inventory.InventoryType, items: java.util.Map<int, cn.nukkit.item.Item>, overrideSize: int, overrideTitle: string): void

    }
}

declare module "cn.nukkit.inventory.CustomInventory" {
    declare const CustomInventory = cn.nukkit.inventory.CustomInventory;
}

declare namespace cn.nukkit.inventory {
    declare class FurnaceInventory extends cn.nukkit.inventory.ContainerInventory {
        public constructor(furnace: cn.nukkit.blockentity.BlockEntityFurnace): void
        public constructor(furnace: cn.nukkit.blockentity.BlockEntityFurnace, inventoryType: cn.nukkit.inventory.InventoryType): void
        public getHolder(): cn.nukkit.blockentity.BlockEntityFurnace
        public getResult(): cn.nukkit.item.Item
        public getFuel(): cn.nukkit.item.Item
        public getSmelting(): cn.nukkit.item.Item
        public setResult(item: cn.nukkit.item.Item): boolean
        public setFuel(item: cn.nukkit.item.Item): boolean
        public setSmelting(item: cn.nukkit.item.Item): boolean
        public onSlotChange(index: int, before: cn.nukkit.item.Item, send: boolean): void
        public getHolder(): cn.nukkit.inventory.InventoryHolder

    }
}

declare module "cn.nukkit.inventory.FurnaceInventory" {
    declare const FurnaceInventory = cn.nukkit.inventory.FurnaceInventory;
}

declare namespace cn.nukkit.inventory {
    declare class GrindstoneInventory extends cn.nukkit.inventory.FakeBlockUIComponent {
        public constructor(playerUI: cn.nukkit.inventory.PlayerUIInventory, position: cn.nukkit.level.Position): void
        public close(who: cn.nukkit.Player): void
        public onClose(who: cn.nukkit.Player): void
        public onOpen(who: cn.nukkit.Player): void
        public getFirstItem(): cn.nukkit.item.Item
        public getSecondItem(): cn.nukkit.item.Item
        public getResult(): cn.nukkit.item.Item
        public setFirstItem(item: cn.nukkit.item.Item, send: boolean): boolean
        public setFirstItem(item: cn.nukkit.item.Item): boolean
        public setSecondItem(item: cn.nukkit.item.Item, send: boolean): boolean
        public setSecondItem(item: cn.nukkit.item.Item): boolean
        public setResult(item: cn.nukkit.item.Item, send: boolean): boolean
        public setResult(item: cn.nukkit.item.Item): boolean
        public onSlotChange(index: int, before: cn.nukkit.item.Item, send: boolean): void
        public updateResult(send: boolean): boolean
        public recalculateResultExperience(): void
        public getItem(index: int): cn.nukkit.item.Item
        public setItem(index: int, item: cn.nukkit.item.Item, send: boolean): boolean
        public getResultExperience(): int
        public setResultExperience(returnLevels: int): void
        static lambda$recalculateResultExperience$1(enchantment: cn.nukkit.item.enchantment.Enchantment): int
        static lambda$recalculateResultExperience$0(item: cn.nukkit.item.Item): java.util.stream.Stream
        public static OFFSET: int
        static SLOT_FIRST_ITEM: int
        static SLOT_SECOND_ITEM: int
        static SLOT_RESULT: int
        public static GRINDSTONE_EQUIPMENT_UI_SLOT: int
        public static GRINDSTONE_INGREDIENT_UI_SLOT: int
        resultExperience: int

    }
}

declare module "cn.nukkit.inventory.GrindstoneInventory" {
    declare const GrindstoneInventory = cn.nukkit.inventory.GrindstoneInventory;
}

declare namespace cn.nukkit.inventory {
    declare class ShapelessRecipe extends java.lang.Object implements cn.nukkit.inventory.CraftingRecipe {
        public constructor(result: cn.nukkit.item.Item, ingredients: java.util.Collection<cn.nukkit.item.Item>): void
        public constructor(recipeId: string, priority: int, result: cn.nukkit.item.Item, ingredients: java.util.Collection<cn.nukkit.item.Item>): void
        public getResult(): cn.nukkit.item.Item
        public getRecipeId(): string
        public getId(): java.util.UUID
        public setId(uuid: java.util.UUID): void
        public getIngredientList(): java.util.List<cn.nukkit.item.Item>
        public getIngredientCount(): int
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void
        public getType(): cn.nukkit.inventory.RecipeType
        public requiresCraftingTable(): boolean
        public getExtraResults(): java.util.List<cn.nukkit.item.Item>
        public getAllResults(): java.util.List<cn.nukkit.item.Item>
        public getPriority(): int
        public matchItems(inputList: java.util.List<cn.nukkit.item.Item>, extraOutputList: java.util.List<cn.nukkit.item.Item>, multiplier: int): boolean
        public matchItems(inputList: java.util.List<cn.nukkit.item.Item>, extraOutputList: java.util.List<cn.nukkit.item.Item>): boolean
        public getIngredientsAggregate(): java.util.List<cn.nukkit.item.Item>
        recipeId: string
        output: cn.nukkit.item.Item
        least: long
        most: long
        ingredients: java.util.List<cn.nukkit.item.Item>
        ingredientsAggregate: java.util.List<cn.nukkit.item.Item>
        priority: int

    }
}

declare module "cn.nukkit.inventory.ShapelessRecipe" {
    declare const ShapelessRecipe = cn.nukkit.inventory.ShapelessRecipe;
}

declare namespace cn.nukkit.inventory {
    declare class MultiRecipe extends java.lang.Object implements cn.nukkit.inventory.Recipe {
        public constructor(id: java.util.UUID): void
        public getResult(): cn.nukkit.item.Item
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void
        public getType(): cn.nukkit.inventory.RecipeType
        public getId(): java.util.UUID
        public toString(): string
        id: java.util.UUID

    }
}

declare module "cn.nukkit.inventory.MultiRecipe" {
    declare const MultiRecipe = cn.nukkit.inventory.MultiRecipe;
}

declare namespace cn.nukkit.inventory {
    declare class EnchantInventory extends cn.nukkit.inventory.FakeBlockUIComponent {
        public constructor(playerUI: cn.nukkit.inventory.PlayerUIInventory, position: cn.nukkit.level.Position): void
        public onOpen(who: cn.nukkit.Player): void
        public onClose(who: cn.nukkit.Player): void
        public getInputSlot(): cn.nukkit.item.Item
        public getOutputSlot(): cn.nukkit.item.Item
        public getReagentSlot(): cn.nukkit.item.Item
        public static ENCHANT_INPUT_ITEM_UI_SLOT: int
        public static ENCHANT_REAGENT_UI_SLOT: int

    }
}

declare module "cn.nukkit.inventory.EnchantInventory" {
    declare const EnchantInventory = cn.nukkit.inventory.EnchantInventory;
}

declare namespace cn.nukkit.inventory {
    declare class ShapedRecipe$Entry extends java.lang.Object {
        public constructor(x: int, y: int): void
        public x: int
        public y: int

    }
}

declare module "cn.nukkit.inventory.ShapedRecipe$Entry" {
    declare const ShapedRecipe$Entry = cn.nukkit.inventory.ShapedRecipe$Entry;
}

declare namespace cn.nukkit.inventory {
    declare class BigCraftingGrid extends cn.nukkit.inventory.CraftingGrid {
        constructor(playerUI: cn.nukkit.inventory.PlayerUIInventory): void
        public getType(): cn.nukkit.inventory.InventoryType

    }
}

declare module "cn.nukkit.inventory.BigCraftingGrid" {
    declare const BigCraftingGrid = cn.nukkit.inventory.BigCraftingGrid;
}

declare namespace cn.nukkit.inventory {
    declare interface CraftingRecipe extends cn.nukkit.inventory.Recipe {
        public getRecipeId(): string
        public getId(): java.util.UUID
        public setId(var0: java.util.UUID): void
        public requiresCraftingTable(): boolean
        public getExtraResults(): java.util.List<cn.nukkit.item.Item>
        public getAllResults(): java.util.List<cn.nukkit.item.Item>
        public getPriority(): int
        public matchItems(var0: java.util.List<cn.nukkit.item.Item>, var1: java.util.List<cn.nukkit.item.Item>): boolean
        public matchItems(var0: java.util.List<cn.nukkit.item.Item>, var1: java.util.List<cn.nukkit.item.Item>, var2: int): boolean
        public getIngredientsAggregate(): java.util.List<cn.nukkit.item.Item>

    }
}

declare module "cn.nukkit.inventory.CraftingRecipe" {
    declare type CraftingRecipe = cn.nukkit.inventory.CraftingRecipe;
}

declare namespace cn.nukkit.inventory {
    declare class PlayerInventory extends cn.nukkit.inventory.BaseInventory {
        public constructor(player: cn.nukkit.entity.EntityHumanType): void
        public getSize(): int
        public setSize(size: int): void
        public equipItem(slot: int): boolean
        isHotbarSlot(slot: int): boolean
        public getHotbarSlotIndex(index: int): int
        public setHotbarSlotIndex(index: int, slot: int): void
        public getHeldItemIndex(): int
        public setHeldItemIndex(index: int): void
        public setHeldItemIndex(index: int, send: boolean): void
        public getItemInHand(): cn.nukkit.item.Item
        public setItemInHand(item: cn.nukkit.item.Item): boolean
        public getHeldItemSlot(): int
        public setHeldItemSlot(slot: int): void
        public sendHeldItem(players: cn.nukkit.Player[]): void
        public sendHeldItem(players: java.util.Collection<cn.nukkit.Player>): void
        public onSlotChange(index: int, before: cn.nukkit.item.Item, send: boolean): void
        public getHotbarSize(): int
        public getArmorItem(index: int): cn.nukkit.item.Item
        public setArmorItem(index: int, item: cn.nukkit.item.Item): boolean
        public setArmorItem(index: int, item: cn.nukkit.item.Item, ignoreArmorEvents: boolean): boolean
        public getHelmet(): cn.nukkit.item.Item
        public getChestplate(): cn.nukkit.item.Item
        public getLeggings(): cn.nukkit.item.Item
        public getBoots(): cn.nukkit.item.Item
        public setHelmet(helmet: cn.nukkit.item.Item): boolean
        public setChestplate(chestplate: cn.nukkit.item.Item): boolean
        public setLeggings(leggings: cn.nukkit.item.Item): boolean
        public setBoots(boots: cn.nukkit.item.Item): boolean
        public setItem(index: int, item: cn.nukkit.item.Item): boolean
        public setItem(index: int, item: cn.nukkit.item.Item, send: boolean): boolean
        setItem(index: int, item: cn.nukkit.item.Item, send: boolean, ignoreArmorEvents: boolean): boolean
        public clear(index: int, send: boolean): boolean
        public getArmorContents(): cn.nukkit.item.Item[]
        public clearAll(): void
        public sendArmorContents(player: cn.nukkit.Player): void
        public sendArmorContents(players: cn.nukkit.Player[]): void
        public setArmorContents(items: cn.nukkit.item.Item[]): void
        public sendArmorContents(players: java.util.Collection<cn.nukkit.Player>): void
        public sendArmorSlot(index: int, player: cn.nukkit.Player): void
        public sendArmorSlot(index: int, players: cn.nukkit.Player[]): void
        public sendArmorSlot(index: int, players: java.util.Collection<cn.nukkit.Player>): void
        public sendContents(player: cn.nukkit.Player): void
        public sendContents(players: java.util.Collection<cn.nukkit.Player>): void
        public sendContents(players: cn.nukkit.Player[]): void
        public sendSlot(index: int, player: cn.nukkit.Player): void
        public sendSlot(index: int, players: java.util.Collection<cn.nukkit.Player>): void
        public sendSlot(index: int, players: cn.nukkit.Player[]): void
        public sendCreativeContents(): void
        public getHolder(): cn.nukkit.entity.EntityHuman
        public onOpen(who: cn.nukkit.Player): void
        public onClose(who: cn.nukkit.Player): void
        public getHolder(): cn.nukkit.inventory.InventoryHolder
        itemInHandIndex: int
        hotbar: int[]

    }
}

declare module "cn.nukkit.inventory.PlayerInventory" {
    declare const PlayerInventory = cn.nukkit.inventory.PlayerInventory;
}

declare namespace cn.nukkit.inventory.transaction.data {
    declare interface TransactionData {

    }
}

declare module "cn.nukkit.inventory.transaction.data.TransactionData" {
    declare type TransactionData = cn.nukkit.inventory.transaction.data.TransactionData;
}

declare namespace cn.nukkit.inventory.transaction.data {
    declare class ReleaseItemData extends java.lang.Object implements cn.nukkit.inventory.transaction.data.TransactionData {
        public constructor(): void
        public toString(): string
        public actionType: int
        public hotbarSlot: int
        public itemInHand: cn.nukkit.item.Item
        public headRot: cn.nukkit.math.Vector3

    }
}

declare module "cn.nukkit.inventory.transaction.data.ReleaseItemData" {
    declare const ReleaseItemData = cn.nukkit.inventory.transaction.data.ReleaseItemData;
}

declare namespace cn.nukkit.inventory.transaction.data {
    declare class UseItemOnEntityData extends java.lang.Object implements cn.nukkit.inventory.transaction.data.TransactionData {
        public constructor(): void
        public toString(): string
        public entityRuntimeId: long
        public actionType: int
        public hotbarSlot: int
        public itemInHand: cn.nukkit.item.Item
        public playerPos: cn.nukkit.math.Vector3
        public clickPos: cn.nukkit.math.Vector3

    }
}

declare module "cn.nukkit.inventory.transaction.data.UseItemOnEntityData" {
    declare const UseItemOnEntityData = cn.nukkit.inventory.transaction.data.UseItemOnEntityData;
}

declare namespace cn.nukkit.inventory.transaction.data {
    declare class UseItemData extends java.lang.Object implements cn.nukkit.inventory.transaction.data.TransactionData {
        public constructor(): void
        public toString(): string
        public actionType: int
        public blockPos: cn.nukkit.math.BlockVector3
        public face: cn.nukkit.math.BlockFace
        public hotbarSlot: int
        public itemInHand: cn.nukkit.item.Item
        public playerPos: cn.nukkit.math.Vector3
        public clickPos: cn.nukkit.math.Vector3f
        public blockRuntimeId: int

    }
}

declare module "cn.nukkit.inventory.transaction.data.UseItemData" {
    declare const UseItemData = cn.nukkit.inventory.transaction.data.UseItemData;
}

declare namespace cn.nukkit.inventory.transaction {
    declare class GrindstoneTransaction extends cn.nukkit.inventory.transaction.InventoryTransaction {
        public constructor(source: cn.nukkit.Player, actions: java.util.List<cn.nukkit.inventory.transaction.action.InventoryAction>): void
        public addAction(action: cn.nukkit.inventory.transaction.action.InventoryAction): void
        public canExecute(): boolean
        public execute(): boolean
        public getFirstItem(): cn.nukkit.item.Item
        public getSecondItem(): cn.nukkit.item.Item
        public getOutputItem(): cn.nukkit.item.Item
        public static checkForItemPart(actions: java.util.List<cn.nukkit.inventory.transaction.action.InventoryAction>): boolean
        static lambda$checkForItemPart$0(it: cn.nukkit.inventory.transaction.action.InventoryAction): boolean
        firstItem: cn.nukkit.item.Item
        secondItem: cn.nukkit.item.Item
        outputItem: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.inventory.transaction.GrindstoneTransaction" {
    declare const GrindstoneTransaction = cn.nukkit.inventory.transaction.GrindstoneTransaction;
}

declare namespace cn.nukkit.inventory.transaction.action {
    declare class CraftingTransferMaterialAction extends cn.nukkit.inventory.transaction.action.InventoryAction {
        public constructor(sourceItem: cn.nukkit.item.Item, targetItem: cn.nukkit.item.Item, slot: int): void
        public onAddToTransaction(transaction: cn.nukkit.inventory.transaction.InventoryTransaction): void
        public isValid(source: cn.nukkit.Player): boolean
        public execute(source: cn.nukkit.Player): boolean
        public onExecuteSuccess($source: cn.nukkit.Player): void
        public onExecuteFail(source: cn.nukkit.Player): void
        public toString(): string
        slot: int

    }
}

declare module "cn.nukkit.inventory.transaction.action.CraftingTransferMaterialAction" {
    declare const CraftingTransferMaterialAction = cn.nukkit.inventory.transaction.action.CraftingTransferMaterialAction;
}

declare namespace cn.nukkit.inventory.transaction.action {
    declare class InventoryAction extends java.lang.Object {
        public constructor(sourceItem: cn.nukkit.item.Item, targetItem: cn.nukkit.item.Item): void
        public getCreationTime(): long
        public getSourceItem(): cn.nukkit.item.Item
        public getTargetItem(): cn.nukkit.item.Item
        public onPreExecute(source: cn.nukkit.Player): boolean
        public isValid(var0: cn.nukkit.Player): boolean
        public onAddToTransaction(transaction: cn.nukkit.inventory.transaction.InventoryTransaction): void
        public execute(var0: cn.nukkit.Player): boolean
        public onExecuteSuccess(var0: cn.nukkit.Player): void
        public onExecuteFail(var0: cn.nukkit.Player): void
        public toString(): string
        creationTime: long
        sourceItem: cn.nukkit.item.Item
        targetItem: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.inventory.transaction.action.InventoryAction" {
    declare const InventoryAction = cn.nukkit.inventory.transaction.action.InventoryAction;
}

declare namespace cn.nukkit.inventory.transaction.action {
    declare class SlotChangeAction extends cn.nukkit.inventory.transaction.action.InventoryAction {
        public constructor(inventory: cn.nukkit.inventory.Inventory, inventorySlot: int, sourceItem: cn.nukkit.item.Item, targetItem: cn.nukkit.item.Item): void
        public getInventory(): cn.nukkit.inventory.Inventory
        public getSlot(): int
        public isValid(source: cn.nukkit.Player): boolean
        public execute(source: cn.nukkit.Player): boolean
        public onExecuteSuccess(source: cn.nukkit.Player): void
        public onExecuteFail(source: cn.nukkit.Player): void
        public onAddToTransaction(transaction: cn.nukkit.inventory.transaction.InventoryTransaction): void
        public toString(): string
        inventory: cn.nukkit.inventory.Inventory
        inventorySlot: int

    }
}

declare module "cn.nukkit.inventory.transaction.action.SlotChangeAction" {
    declare const SlotChangeAction = cn.nukkit.inventory.transaction.action.SlotChangeAction;
}

declare namespace cn.nukkit.inventory.transaction.action {
    declare class TakeLevelAction extends cn.nukkit.inventory.transaction.action.InventoryAction {
        public constructor(levels: int): void
        public getLevels(): int
        public isValid(source: cn.nukkit.Player): boolean
        public execute(source: cn.nukkit.Player): boolean
        public onExecuteSuccess(source: cn.nukkit.Player): void
        public onExecuteFail(source: cn.nukkit.Player): void
        public toString(): string
        levels: int

    }
}

declare module "cn.nukkit.inventory.transaction.action.TakeLevelAction" {
    declare const TakeLevelAction = cn.nukkit.inventory.transaction.action.TakeLevelAction;
}

declare namespace cn.nukkit.inventory.transaction.action {
    declare class CreativeInventoryAction extends cn.nukkit.inventory.transaction.action.InventoryAction {
        public constructor(source: cn.nukkit.item.Item, target: cn.nukkit.item.Item, action: int): void
        public isValid(source: cn.nukkit.Player): boolean
        public getActionType(): int
        public execute(source: cn.nukkit.Player): boolean
        public onExecuteSuccess(source: cn.nukkit.Player): void
        public onExecuteFail(source: cn.nukkit.Player): void
        public toString(): string
        public static TYPE_DELETE_ITEM: int
        public static TYPE_CREATE_ITEM: int
        actionType: int

    }
}

declare module "cn.nukkit.inventory.transaction.action.CreativeInventoryAction" {
    declare const CreativeInventoryAction = cn.nukkit.inventory.transaction.action.CreativeInventoryAction;
}

declare namespace cn.nukkit.inventory.transaction.action {
    declare class SmithingItemAction extends cn.nukkit.inventory.transaction.action.InventoryAction {
        public constructor(sourceItem: cn.nukkit.item.Item, targetItem: cn.nukkit.item.Item, type: int): void
        public isValid(source: cn.nukkit.Player): boolean
        public execute(source: cn.nukkit.Player): boolean
        public onExecuteSuccess(source: cn.nukkit.Player): void
        public onExecuteFail(source: cn.nukkit.Player): void
        public getType(): int
        type: int

    }
}

declare module "cn.nukkit.inventory.transaction.action.SmithingItemAction" {
    declare const SmithingItemAction = cn.nukkit.inventory.transaction.action.SmithingItemAction;
}

declare namespace cn.nukkit.inventory.transaction.action {
    declare class NoOpIventoryAction extends cn.nukkit.inventory.transaction.action.InventoryAction {
        constructor(sourceItem: cn.nukkit.item.Item, targetItem: cn.nukkit.item.Item): void
        public execute(source: cn.nukkit.Player): boolean
        public onExecuteSuccess(source: cn.nukkit.Player): void
        public onExecuteFail(source: cn.nukkit.Player): void

    }
}

declare module "cn.nukkit.inventory.transaction.action.NoOpIventoryAction" {
    declare const NoOpIventoryAction = cn.nukkit.inventory.transaction.action.NoOpIventoryAction;
}

declare namespace cn.nukkit.inventory.transaction.action {
    declare class DamageAnvilAction extends cn.nukkit.inventory.transaction.action.InventoryAction {
        public constructor(anvil: cn.nukkit.inventory.AnvilInventory, shouldDamage: boolean, transaction: cn.nukkit.inventory.transaction.CraftingTransaction): void
        public isValid(source: cn.nukkit.Player): boolean
        public execute(source: cn.nukkit.Player): boolean
        public onExecuteSuccess(source: cn.nukkit.Player): void
        public onExecuteFail(source: cn.nukkit.Player): void
        public toString(): string
        anvil: cn.nukkit.inventory.AnvilInventory
        shouldDamage: boolean
        transaction: cn.nukkit.inventory.transaction.CraftingTransaction

    }
}

declare module "cn.nukkit.inventory.transaction.action.DamageAnvilAction" {
    declare const DamageAnvilAction = cn.nukkit.inventory.transaction.action.DamageAnvilAction;
}

declare namespace cn.nukkit.inventory.transaction.action {
    declare class DropItemAction extends cn.nukkit.inventory.transaction.action.InventoryAction {
        public constructor(source: cn.nukkit.item.Item, target: cn.nukkit.item.Item): void
        public isValid(source: cn.nukkit.Player): boolean
        public onPreExecute(source: cn.nukkit.Player): boolean
        public execute(source: cn.nukkit.Player): boolean
        public onExecuteSuccess(source: cn.nukkit.Player): void
        public onExecuteFail(source: cn.nukkit.Player): void
        public toString(): string

    }
}

declare module "cn.nukkit.inventory.transaction.action.DropItemAction" {
    declare const DropItemAction = cn.nukkit.inventory.transaction.action.DropItemAction;
}

declare namespace cn.nukkit.inventory.transaction {
    declare class EnchantTransaction extends cn.nukkit.inventory.transaction.InventoryTransaction {
        public constructor(source: cn.nukkit.Player, actions: java.util.List<cn.nukkit.inventory.transaction.action.InventoryAction>): void
        public canExecute(): boolean
        isLapisLazuli(item: cn.nukkit.item.Item): boolean
        public execute(): boolean
        public addAction(action: cn.nukkit.inventory.transaction.action.InventoryAction): void
        public checkForEnchantPart(actions: java.util.List<cn.nukkit.inventory.transaction.action.InventoryAction>): boolean
        public getInputItem(): cn.nukkit.item.Item
        public setInputItem(inputItem: cn.nukkit.item.Item): void
        public getOutputItem(): cn.nukkit.item.Item
        public setOutputItem(outputItem: cn.nukkit.item.Item): void
        public getCost(): int
        public setCost(cost: int): void
        inputItem: cn.nukkit.item.Item
        outputItem: cn.nukkit.item.Item
        cost: int

    }
}

declare module "cn.nukkit.inventory.transaction.EnchantTransaction" {
    declare const EnchantTransaction = cn.nukkit.inventory.transaction.EnchantTransaction;
}

declare namespace cn.nukkit.inventory.transaction {
    declare class RepairItemTransaction extends cn.nukkit.inventory.transaction.InventoryTransaction {
        public constructor(source: cn.nukkit.Player, actions: java.util.List<cn.nukkit.inventory.transaction.action.InventoryAction>): void
        public canExecute(): boolean
        public execute(): boolean
        public addAction(action: cn.nukkit.inventory.transaction.action.InventoryAction): void
        checkRecipeValid(): boolean
        hasMaterial(): boolean
        isMapRecipe(): boolean
        matchMapRecipe(): boolean
        matchRepairItem(): boolean
        public getInputItem(): cn.nukkit.item.Item
        public getMaterialItem(): cn.nukkit.item.Item
        public getOutputItem(): cn.nukkit.item.Item
        public getCost(): int
        public static checkForRepairItemPart(actions: java.util.List<cn.nukkit.inventory.transaction.action.InventoryAction>): boolean
        inputItem: cn.nukkit.item.Item
        materialItem: cn.nukkit.item.Item
        outputItem: cn.nukkit.item.Item
        cost: int

    }
}

declare module "cn.nukkit.inventory.transaction.RepairItemTransaction" {
    declare const RepairItemTransaction = cn.nukkit.inventory.transaction.RepairItemTransaction;
}

declare namespace cn.nukkit.inventory {
    declare class EjectableInventory extends cn.nukkit.inventory.ContainerInventory {
        public constructor(holder: cn.nukkit.inventory.InventoryHolder, type: cn.nukkit.inventory.InventoryType): void

    }
}

declare module "cn.nukkit.inventory.EjectableInventory" {
    declare const EjectableInventory = cn.nukkit.inventory.EjectableInventory;
}

declare namespace cn.nukkit.inventory {
    declare class BaseInventory extends java.lang.Object implements cn.nukkit.inventory.Inventory {
        public constructor(holder: cn.nukkit.inventory.InventoryHolder, type: cn.nukkit.inventory.InventoryType): void
        public constructor(holder: cn.nukkit.inventory.InventoryHolder, type: cn.nukkit.inventory.InventoryType, items: java.util.Map<int, cn.nukkit.item.Item>): void
        public constructor(holder: cn.nukkit.inventory.InventoryHolder, type: cn.nukkit.inventory.InventoryType, items: java.util.Map<int, cn.nukkit.item.Item>, overrideSize: int): void
        public constructor(holder: cn.nukkit.inventory.InventoryHolder, type: cn.nukkit.inventory.InventoryType, items: java.util.Map<int, cn.nukkit.item.Item>, overrideSize: int, overrideTitle: string): void
        public getSize(): int
        public setSize(size: int): void
        public getMaxStackSize(): int
        public getName(): string
        public getTitle(): string
        public getItem(index: int): cn.nukkit.item.Item
        public getContents(): java.util.Map<int, cn.nukkit.item.Item>
        public setContents(items: java.util.Map<int, cn.nukkit.item.Item>): void
        public setItem(index: int, item: cn.nukkit.item.Item, send: boolean): boolean
        public contains(item: cn.nukkit.item.Item): boolean
        public all(item: cn.nukkit.item.Item): java.util.Map<int, cn.nukkit.item.Item>
        public remove(item: cn.nukkit.item.Item): void
        public first(item: cn.nukkit.item.Item, exact: boolean): int
        public firstEmpty(item: cn.nukkit.item.Item): int
        public decreaseCount(slot: int): void
        public canAddItem(item: cn.nukkit.item.Item): boolean
        public addItem(slots: cn.nukkit.item.Item[]): cn.nukkit.item.Item[]
        public removeItem(slots: cn.nukkit.item.Item[]): cn.nukkit.item.Item[]
        public clear(index: int, send: boolean): boolean
        public clearAll(): void
        public getViewers(): java.util.Set<cn.nukkit.Player>
        public getHolder(): cn.nukkit.inventory.InventoryHolder
        public setMaxStackSize(maxStackSize: int): void
        public open(who: cn.nukkit.Player): boolean
        public close(who: cn.nukkit.Player): void
        public onOpen(who: cn.nukkit.Player): void
        public onClose(who: cn.nukkit.Player): void
        public onSlotChange(index: int, before: cn.nukkit.item.Item, send: boolean): void
        public sendContents(player: cn.nukkit.Player): void
        public sendContents(players: cn.nukkit.Player[]): void
        public isFull(): boolean
        public isEmpty(): boolean
        public getFreeSpace(item: cn.nukkit.item.Item): int
        public sendContents(players: java.util.Collection<cn.nukkit.Player>): void
        public sendSlot(index: int, player: cn.nukkit.Player): void
        public sendSlot(index: int, players: cn.nukkit.Player[]): void
        public sendSlot(index: int, players: java.util.Collection<cn.nukkit.Player>): void
        public addListener(listener: cn.nukkit.inventory.InventoryListener): void
        public removeListener(listener: cn.nukkit.inventory.InventoryListener): void
        public getType(): cn.nukkit.inventory.InventoryType
        static lambda$onSlotChange$0(p: cn.nukkit.Player): void
        public static AIR_ITEM: cn.nukkit.item.Item
        type: cn.nukkit.inventory.InventoryType
        maxStackSize: int
        size: int
        name: string
        title: string
        public slots: java.util.Map<int, cn.nukkit.item.Item>
        viewers: java.util.Set<cn.nukkit.Player>
        holder: cn.nukkit.inventory.InventoryHolder
        listeners: java.util.List<cn.nukkit.inventory.InventoryListener>

    }
}

declare module "cn.nukkit.inventory.BaseInventory" {
    declare const BaseInventory = cn.nukkit.inventory.BaseInventory;
}

declare namespace cn.nukkit.inventory {
    declare class CampfireRecipe extends java.lang.Object implements cn.nukkit.inventory.SmeltingRecipe {
        public constructor(result: cn.nukkit.item.Item, ingredient: cn.nukkit.item.Item): void
        public setInput(item: cn.nukkit.item.Item): void
        public getInput(): cn.nukkit.item.Item
        public getResult(): cn.nukkit.item.Item
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void
        public getType(): cn.nukkit.inventory.RecipeType
        output: cn.nukkit.item.Item
        ingredient: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.inventory.CampfireRecipe" {
    declare const CampfireRecipe = cn.nukkit.inventory.CampfireRecipe;
}

declare namespace cn.nukkit.inventory {
    declare class StonecutterInventory extends cn.nukkit.inventory.FakeBlockUIComponent {
        public constructor(playerUI: cn.nukkit.inventory.PlayerUIInventory, position: cn.nukkit.level.Position): void
        public onClose(who: cn.nukkit.Player): void

    }
}

declare module "cn.nukkit.inventory.StonecutterInventory" {
    declare const StonecutterInventory = cn.nukkit.inventory.StonecutterInventory;
}

declare namespace cn.nukkit.inventory {
    declare class FakeBlockMenu extends cn.nukkit.level.Position implements cn.nukkit.inventory.InventoryHolder {
        public constructor(inventory: cn.nukkit.inventory.Inventory, pos: cn.nukkit.level.Position): void
        public getInventory(): cn.nukkit.inventory.Inventory
        inventory: cn.nukkit.inventory.Inventory

    }
}

declare module "cn.nukkit.inventory.FakeBlockMenu" {
    declare const FakeBlockMenu = cn.nukkit.inventory.FakeBlockMenu;
}

declare namespace cn.nukkit.inventory {
    declare class MinecartHopperInventory extends cn.nukkit.inventory.ContainerInventory {
        public constructor(minecart: cn.nukkit.entity.item.EntityMinecartHopper): void
        public getHolder(): cn.nukkit.entity.item.EntityMinecartHopper
        public getHolder(): cn.nukkit.inventory.InventoryHolder

    }
}

declare module "cn.nukkit.inventory.MinecartHopperInventory" {
    declare const MinecartHopperInventory = cn.nukkit.inventory.MinecartHopperInventory;
}

declare namespace cn.nukkit.inventory {
    declare class Fuel extends java.lang.Object {
        public constructor(): void
        static addItem(itemID: int, fuelDuration: short): void
        static addBlock(blockID: int, fuelDuration: short): void
        public static duration: java.util.Map<int, java.lang.Short>

    }
}

declare module "cn.nukkit.inventory.Fuel" {
    declare const Fuel = cn.nukkit.inventory.Fuel;
}

declare namespace cn.nukkit.inventory {
    declare interface Inventory {
        public getSize(): int
        public getMaxStackSize(): int
        public setMaxStackSize(var0: int): void
        public getName(): string
        public getTitle(): string
        public getItem(var0: int): cn.nukkit.item.Item
        public setItem(index: int, item: cn.nukkit.item.Item): boolean
        public setItem(var0: int, var1: cn.nukkit.item.Item, var2: boolean): boolean
        public addItem(var0: cn.nukkit.item.Item[]): cn.nukkit.item.Item[]
        public canAddItem(var0: cn.nukkit.item.Item): boolean
        public removeItem(var0: cn.nukkit.item.Item[]): cn.nukkit.item.Item[]
        public getContents(): java.util.Map<int, cn.nukkit.item.Item>
        public setContents(var0: java.util.Map<int, cn.nukkit.item.Item>): void
        public sendContents(var0: cn.nukkit.Player): void
        public sendContents(var0: cn.nukkit.Player[]): void
        public sendContents(var0: java.util.Collection<cn.nukkit.Player>): void
        public sendSlot(var0: int, var1: cn.nukkit.Player): void
        public sendSlot(var0: int, var1: cn.nukkit.Player[]): void
        public sendSlot(var0: int, var1: java.util.Collection<cn.nukkit.Player>): void
        public contains(var0: cn.nukkit.item.Item): boolean
        public all(var0: cn.nukkit.item.Item): java.util.Map<int, cn.nukkit.item.Item>
        public first(item: cn.nukkit.item.Item): int
        public first(var0: cn.nukkit.item.Item, var1: boolean): int
        public firstEmpty(var0: cn.nukkit.item.Item): int
        public decreaseCount(var0: int): void
        public remove(var0: cn.nukkit.item.Item): void
        public clear(index: int): boolean
        public clear(var0: int, var1: boolean): boolean
        public clearAll(): void
        public isFull(): boolean
        public isEmpty(): boolean
        public getViewers(): java.util.Set<cn.nukkit.Player>
        public getType(): cn.nukkit.inventory.InventoryType
        public getHolder(): cn.nukkit.inventory.InventoryHolder
        public onOpen(var0: cn.nukkit.Player): void
        public open(var0: cn.nukkit.Player): boolean
        public close(var0: cn.nukkit.Player): void
        public onClose(var0: cn.nukkit.Player): void
        public onSlotChange(var0: int, var1: cn.nukkit.item.Item, var2: boolean): void
        public addListener(var0: cn.nukkit.inventory.InventoryListener): void
        public removeListener(var0: cn.nukkit.inventory.InventoryListener): void
        public static MAX_STACK: int

    }
}

declare module "cn.nukkit.inventory.Inventory" {
    declare type Inventory = cn.nukkit.inventory.Inventory;
}

declare namespace cn.nukkit.inventory {
    declare class BrewingRecipe extends cn.nukkit.inventory.MixRecipe {
        public constructor(input: cn.nukkit.item.Item, ingredient: cn.nukkit.item.Item, output: cn.nukkit.item.Item): void
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void
        public getType(): cn.nukkit.inventory.RecipeType

    }
}

declare module "cn.nukkit.inventory.BrewingRecipe" {
    declare const BrewingRecipe = cn.nukkit.inventory.BrewingRecipe;
}

declare namespace cn.nukkit.inventory {
    declare class PlayerOffhandInventory extends cn.nukkit.inventory.BaseInventory {
        public constructor(holder: cn.nukkit.entity.EntityHumanType): void
        public setSize(size: int): void
        public onSlotChange(index: int, before: cn.nukkit.item.Item, send: boolean): void
        public sendContents(players: cn.nukkit.Player[]): void
        public sendSlot(index: int, players: cn.nukkit.Player[]): void
        createMobEquipmentPacket(item: cn.nukkit.item.Item): cn.nukkit.network.protocol.MobEquipmentPacket
        public getHolder(): cn.nukkit.entity.EntityHuman
        public getHolder(): cn.nukkit.inventory.InventoryHolder

    }
}

declare module "cn.nukkit.inventory.PlayerOffhandInventory" {
    declare const PlayerOffhandInventory = cn.nukkit.inventory.PlayerOffhandInventory;
}

declare namespace cn.nukkit.inventory {
    declare class EntityArmorInventory extends cn.nukkit.inventory.BaseInventory {
        public constructor(entity: cn.nukkit.entity.Entity): void
        public getEntity(): cn.nukkit.entity.Entity
        public getHolder(): cn.nukkit.inventory.InventoryHolder
        public getName(): string
        public getSize(): int
        public getHelmet(): cn.nukkit.item.Item
        public getChestplate(): cn.nukkit.item.Item
        public getLeggings(): cn.nukkit.item.Item
        public getBoots(): cn.nukkit.item.Item
        public setHelmet(item: cn.nukkit.item.Item): boolean
        public setChestplate(item: cn.nukkit.item.Item): boolean
        public setLeggings(item: cn.nukkit.item.Item): boolean
        public setBoots(item: cn.nukkit.item.Item): boolean
        public sendSlot(index: int, players: cn.nukkit.Player[]): void
        public sendSlot(index: int, player: cn.nukkit.Player): void
        public sendContents(players: cn.nukkit.Player[]): void
        public sendContents(player: cn.nukkit.Player): void
        public onOpen(who: cn.nukkit.Player): void
        public onClose(who: cn.nukkit.Player): void
        public getViewers(): java.util.Set<cn.nukkit.Player>
        entity: cn.nukkit.entity.Entity
        public static SLOT_HEAD: int
        public static SLOT_CHEST: int
        public static SLOT_LEGS: int
        public static SLOT_FEET: int

    }
}

declare module "cn.nukkit.inventory.EntityArmorInventory" {
    declare const EntityArmorInventory = cn.nukkit.inventory.EntityArmorInventory;
}

declare namespace cn.nukkit.inventory {
    declare interface Recipe {
        public getResult(): cn.nukkit.item.Item
        public registerToCraftingManager(var0: cn.nukkit.inventory.CraftingManager): void
        public getType(): cn.nukkit.inventory.RecipeType
        public static matchItemList(haveItems: java.util.List<cn.nukkit.item.Item>, needItems: java.util.List<cn.nukkit.item.Item>): boolean

    }
}

declare module "cn.nukkit.inventory.Recipe" {
    declare type Recipe = cn.nukkit.inventory.Recipe;
}

declare namespace cn.nukkit {
    declare class Server$2 extends cn.nukkit.utils.ConfigSection {
        constructor(this$0: cn.nukkit.Server): void
        this$0: cn.nukkit.Server

    }
}

declare module "cn.nukkit.Server$2" {
    declare const Server$2 = cn.nukkit.Server$2;
}

declare namespace cn.nukkit.level {
    declare class EnumLevel extends java.lang.Enum {
        public static values(): cn.nukkit.level.EnumLevel[]
        public static valueOf(name: string): cn.nukkit.level.EnumLevel
        constructor(): void
        public getLevel(): cn.nukkit.level.Level
        public static initLevels(): void
        public static getOtherNetherPair(current: cn.nukkit.level.Level): cn.nukkit.level.Level
        public static convertPosBetweenNetherAndOverworld(current: cn.nukkit.level.Position): cn.nukkit.level.Position
        static mRound(value: int, factor: int): int
        public static getOtherTheEndPair(current: cn.nukkit.level.Level): cn.nukkit.level.Level
        public static moveToTheEnd(current: cn.nukkit.level.Position): cn.nukkit.level.Position
        static $values(): cn.nukkit.level.EnumLevel[]
        public static OVERWORLD: cn.nukkit.level.EnumLevel
        public static NETHER: cn.nukkit.level.EnumLevel
        public static THE_END: cn.nukkit.level.EnumLevel
        static log: org.apache.logging.log4j.Logger
        level: cn.nukkit.level.Level
        static $VALUES: cn.nukkit.level.EnumLevel[]

    }
}

declare module "cn.nukkit.level.EnumLevel" {
    declare const EnumLevel = cn.nukkit.level.EnumLevel;
}

declare namespace cn.nukkit.level {
    declare class ParticleEffect extends java.lang.Enum {
        public static values(): cn.nukkit.level.ParticleEffect[]
        public static valueOf(name: string): cn.nukkit.level.ParticleEffect
        constructor(var0: string): void
        public getIdentifier(): string
        static $values(): cn.nukkit.level.ParticleEffect[]
        public static ARROWSPELL: cn.nukkit.level.ParticleEffect
        public static BALLOON_GAS: cn.nukkit.level.ParticleEffect
        public static BASIC_BUBBLE: cn.nukkit.level.ParticleEffect
        public static BASIC_BUBBLE_MANUAL: cn.nukkit.level.ParticleEffect
        public static BASIC_CRIT: cn.nukkit.level.ParticleEffect
        public static BASIC_FLAME: cn.nukkit.level.ParticleEffect
        public static BASIC_PORTAL: cn.nukkit.level.ParticleEffect
        public static BASIC_SMOKE: cn.nukkit.level.ParticleEffect
        public static BLEACH: cn.nukkit.level.ParticleEffect
        public static BLOCK_DESTRUCT: cn.nukkit.level.ParticleEffect
        public static BLOCK_SLIDE: cn.nukkit.level.ParticleEffect
        public static BLUE_FLAME: cn.nukkit.level.ParticleEffect
        public static BREAKING_ITEM_ICON: cn.nukkit.level.ParticleEffect
        public static BREAKING_ITEM_TERRAIN: cn.nukkit.level.ParticleEffect
        public static BUBBLE_COLUMN_BUBBLE: cn.nukkit.level.ParticleEffect
        public static BUBBLE_COLUMN_DOWN: cn.nukkit.level.ParticleEffect
        public static BUBBLE_COLUMN_UP: cn.nukkit.level.ParticleEffect
        public static CAMERA_SHOOT_EXPLOSION: cn.nukkit.level.ParticleEffect
        public static CAMPFIRE_SMOKE: cn.nukkit.level.ParticleEffect
        public static CAMPFIRE_SMOKE_TALL: cn.nukkit.level.ParticleEffect
        public static CANDLE_FLAME: cn.nukkit.level.ParticleEffect
        public static CAULDRONSPELL: cn.nukkit.level.ParticleEffect
        public static CAULDRON_BUBBLE: cn.nukkit.level.ParticleEffect
        public static CAULDRON_SPLASH: cn.nukkit.level.ParticleEffect
        public static COLORED_FLAME: cn.nukkit.level.ParticleEffect
        public static CONDUIT: cn.nukkit.level.ParticleEffect
        public static CONDUIT_ABSORB: cn.nukkit.level.ParticleEffect
        public static CONDUIT_ATTACK: cn.nukkit.level.ParticleEffect
        public static CRITICAL_HIT: cn.nukkit.level.ParticleEffect
        public static CROP_GROWTH: cn.nukkit.level.ParticleEffect
        public static CROP_GROWTH_AREA: cn.nukkit.level.ParticleEffect
        public static DOLPHIN_MOVE: cn.nukkit.level.ParticleEffect
        public static DRAGON_BREATH_FIRE: cn.nukkit.level.ParticleEffect
        public static DRAGON_BREATH_LINGERING: cn.nukkit.level.ParticleEffect
        public static DRAGON_BREATH_TRAIL: cn.nukkit.level.ParticleEffect
        public static DRAGON_DEATH_EXPLOSION: cn.nukkit.level.ParticleEffect
        public static DRAGON_DESTROY_BLOCK: cn.nukkit.level.ParticleEffect
        public static DRAGON_DYING_EXPLOSION: cn.nukkit.level.ParticleEffect
        public static DRIPSTONE_LAVA_DRIP: cn.nukkit.level.ParticleEffect
        public static DRIPSTONE_WATER_DRIP: cn.nukkit.level.ParticleEffect
        public static ELECTRIC_SPARK: cn.nukkit.level.ParticleEffect
        public static ENCHANTING_TABLE_PARTICLE: cn.nukkit.level.ParticleEffect
        public static ENDROD: cn.nukkit.level.ParticleEffect
        public static END_CHEST: cn.nukkit.level.ParticleEffect
        public static EVAPORATION_ELEPHANT_TOOTHPASTE: cn.nukkit.level.ParticleEffect
        public static EVOCATION_FANG: cn.nukkit.level.ParticleEffect
        public static EVOKER_SPELL: cn.nukkit.level.ParticleEffect
        public static EXPLOSION_CAULDRON: cn.nukkit.level.ParticleEffect
        public static EXPLOSION_DEATH: cn.nukkit.level.ParticleEffect
        public static EXPLOSION_EGG_DESTROY: cn.nukkit.level.ParticleEffect
        public static EXPLOSION_EYEOFENDER_DEATH: cn.nukkit.level.ParticleEffect
        public static EXPLOSION_LABTABLE_FIRE: cn.nukkit.level.ParticleEffect
        public static EXPLOSION_LEVEL: cn.nukkit.level.ParticleEffect
        public static EXPLOSION_MANUAL: cn.nukkit.level.ParticleEffect
        public static EYE_OF_ENDER_BUBBLE: cn.nukkit.level.ParticleEffect
        public static FALLING_BORDER_DUST: cn.nukkit.level.ParticleEffect
        public static FALLING_DUST: cn.nukkit.level.ParticleEffect
        public static FALLING_DUST_CONCRETE_POWDER: cn.nukkit.level.ParticleEffect
        public static FALLING_DUST_DRAGON_EGG: cn.nukkit.level.ParticleEffect
        public static FALLING_DUST_GRAVEL: cn.nukkit.level.ParticleEffect
        public static FALLING_DUST_RED_SAND: cn.nukkit.level.ParticleEffect
        public static FALLING_DUST_SAND: cn.nukkit.level.ParticleEffect
        public static FALLING_DUST_SCAFFOLDING: cn.nukkit.level.ParticleEffect
        public static FALLING_DUST_TOP_SNOW: cn.nukkit.level.ParticleEffect
        public static FISH_HOOK: cn.nukkit.level.ParticleEffect
        public static FISH_POS: cn.nukkit.level.ParticleEffect
        public static GLOW: cn.nukkit.level.ParticleEffect
        public static GUARDIAN_ATTACK: cn.nukkit.level.ParticleEffect
        public static GUARDIAN_WATER_MOVE: cn.nukkit.level.ParticleEffect
        public static HEART: cn.nukkit.level.ParticleEffect
        public static HONEY_DRIP: cn.nukkit.level.ParticleEffect
        public static HUGE_EXPLOSION_LAB_MISC: cn.nukkit.level.ParticleEffect
        public static HUGE_EXPLOSION_LEVEL: cn.nukkit.level.ParticleEffect
        public static ICE_EVAPORATION: cn.nukkit.level.ParticleEffect
        public static INK: cn.nukkit.level.ParticleEffect
        public static KNOCKBACK_ROAR: cn.nukkit.level.ParticleEffect
        public static LAB_TABLE_HEATBLOCK_DUST: cn.nukkit.level.ParticleEffect
        public static LAB_TABLE_MISC_MYSTICAL: cn.nukkit.level.ParticleEffect
        public static LARGE_EXPLOSION_LEVEL: cn.nukkit.level.ParticleEffect
        public static LAVA_DRIP: cn.nukkit.level.ParticleEffect
        public static LAVA_PARTICLE: cn.nukkit.level.ParticleEffect
        public static LLAMA_SPIT: cn.nukkit.level.ParticleEffect
        public static MAGNESIUM_SALTS: cn.nukkit.level.ParticleEffect
        public static MOBFLAME: cn.nukkit.level.ParticleEffect
        public static MOBFLAME_SINGLE: cn.nukkit.level.ParticleEffect
        public static MOBSPELL: cn.nukkit.level.ParticleEffect
        public static MOB_BLOCK_SPAWN: cn.nukkit.level.ParticleEffect
        public static MOB_PORTAL: cn.nukkit.level.ParticleEffect
        public static MYCELIUM_DUST: cn.nukkit.level.ParticleEffect
        public static NECTAR_DRIP: cn.nukkit.level.ParticleEffect
        public static NOTE: cn.nukkit.level.ParticleEffect
        public static OBSIDIAN_GLOW_DUST: cn.nukkit.level.ParticleEffect
        public static OBSIDIAN_TEAR: cn.nukkit.level.ParticleEffect
        public static PHANTOM_TRAIL: cn.nukkit.level.ParticleEffect
        public static PORTAL_DIRECTIONAL: cn.nukkit.level.ParticleEffect
        public static PORTAL_EAST_WEST: cn.nukkit.level.ParticleEffect
        public static PORTAL_NORTH_SOUTH: cn.nukkit.level.ParticleEffect
        public static PORTAL_REVERSE: cn.nukkit.level.ParticleEffect
        public static RAIN_SPLASH: cn.nukkit.level.ParticleEffect
        public static REDSTONE_ORE_DUST: cn.nukkit.level.ParticleEffect
        public static REDSTONE_REPEATER_DUST: cn.nukkit.level.ParticleEffect
        public static REDSTONE_TORCH_DUST: cn.nukkit.level.ParticleEffect
        public static REDSTONE_WIRE_DUST: cn.nukkit.level.ParticleEffect
        public static RISING_BORDER_DUST: cn.nukkit.level.ParticleEffect
        public static SCULK_CHARGE: cn.nukkit.level.ParticleEffect
        public static SCULK_CHARGE_POP: cn.nukkit.level.ParticleEffect
        public static SCULK_SENSOR_REDSTONE_PARTICLE: cn.nukkit.level.ParticleEffect
        public static SCULK_SOUL: cn.nukkit.level.ParticleEffect
        public static SHRIEK: cn.nukkit.level.ParticleEffect
        public static SHULKER_BULLET: cn.nukkit.level.ParticleEffect
        public static SILVERFISH_GRIEF: cn.nukkit.level.ParticleEffect
        public static SNOWFLAKE: cn.nukkit.level.ParticleEffect
        public static SOUL: cn.nukkit.level.ParticleEffect
        public static SONIC_EXPLOSION: cn.nukkit.level.ParticleEffect
        public static SPARKLER: cn.nukkit.level.ParticleEffect
        public static SPLASHPOTIONSPELL: cn.nukkit.level.ParticleEffect
        public static SPONGE_ABSORB_BUBBLE: cn.nukkit.level.ParticleEffect
        public static SPORE_BLOSSOM_AMBIENT_BLOCK_ACTOR: cn.nukkit.level.ParticleEffect
        public static SPORE_BLOSSOM_SHOWER: cn.nukkit.level.ParticleEffect
        public static SQUID_FLEE: cn.nukkit.level.ParticleEffect
        public static SQUID_INK_BUBBLE: cn.nukkit.level.ParticleEffect
        public static SQUID_MOVE: cn.nukkit.level.ParticleEffect
        public static STUNNED: cn.nukkit.level.ParticleEffect
        public static TOTEM: cn.nukkit.level.ParticleEffect
        public static TOTEM_MANUAL: cn.nukkit.level.ParticleEffect
        public static UNDERWATER_TORCH_BUBBLE: cn.nukkit.level.ParticleEffect
        public static VIBRATION_SIGNAL: cn.nukkit.level.ParticleEffect
        public static VILLAGER_ANGRY: cn.nukkit.level.ParticleEffect
        public static VILLAGER_HAPPY: cn.nukkit.level.ParticleEffect
        public static WARDEN_DIG_PARTICLE: cn.nukkit.level.ParticleEffect
        public static WATER_DRIP: cn.nukkit.level.ParticleEffect
        public static WATER_EVAPORATION_ACTOR: cn.nukkit.level.ParticleEffect
        public static WATER_EVAPORATION_BUCKET: cn.nukkit.level.ParticleEffect
        public static WATER_EVAPORATION_MANUAL: cn.nukkit.level.ParticleEffect
        public static WATER_SPASH_MANUAL: cn.nukkit.level.ParticleEffect
        public static WATER_SPLASH: cn.nukkit.level.ParticleEffect
        public static WATER_WAKE: cn.nukkit.level.ParticleEffect
        public static WAX: cn.nukkit.level.ParticleEffect
        public static WITHER_BOSS_INVULNERABLE: cn.nukkit.level.ParticleEffect
        identifier: string
        static $VALUES: cn.nukkit.level.ParticleEffect[]

    }
}

declare module "cn.nukkit.level.ParticleEffect" {
    declare const ParticleEffect = cn.nukkit.level.ParticleEffect;
}

declare namespace cn.nukkit.level {
    declare class Explosion extends java.lang.Object {
        public constructor(center: cn.nukkit.level.Position, size: double, var2: cn.nukkit.entity.Entity): void
        public constructor(center: cn.nukkit.level.Position, size: double, var2: cn.nukkit.block.Block): void
        constructor(center: cn.nukkit.level.Position, size: double, var2: java.lang.Object): void
        public setFireChance(fireChance: double): void
        public getFireChance(): double
        public isIncendiary(): boolean
        public setIncendiary(incendiary: boolean): void
        public explode(): boolean
        public explodeA(): boolean
        public explodeB(): boolean
        rays: int
        level: cn.nukkit.level.Level
        source: cn.nukkit.level.Position
        size: double
        fireChance: double
        affectedBlocks: java.util.Set<cn.nukkit.block.Block>
        fireIgnitions: java.util.Set<cn.nukkit.block.Block>
        stepLen: double
        what: java.lang.Object
        doesDamage: boolean

    }
}

declare module "cn.nukkit.level.Explosion" {
    declare const Explosion = cn.nukkit.level.Explosion;
}

declare namespace cn.nukkit.level {
    declare class GameRule extends java.lang.Enum {
        public static values(): cn.nukkit.level.GameRule[]
        public static valueOf(name: string): cn.nukkit.level.GameRule
        constructor(var0: string): void
        constructor(var0: string, var1: boolean): void
        public static parseString(gameRuleString: string): java.util.Optional<cn.nukkit.level.GameRule>
        public static getNames(): string[]
        public getName(): string
        public isDeprecated(): boolean
        static $values(): cn.nukkit.level.GameRule[]
        public static COMMAND_BLOCKS_ENABLED: cn.nukkit.level.GameRule
        public static COMMAND_BLOCK_OUTPUT: cn.nukkit.level.GameRule
        public static DO_DAYLIGHT_CYCLE: cn.nukkit.level.GameRule
        public static DO_ENTITY_DROPS: cn.nukkit.level.GameRule
        public static DO_FIRE_TICK: cn.nukkit.level.GameRule
        public static DO_INSOMNIA: cn.nukkit.level.GameRule
        public static DO_IMMEDIATE_RESPAWN: cn.nukkit.level.GameRule
        public static DO_MOB_LOOT: cn.nukkit.level.GameRule
        public static DO_MOB_SPAWNING: cn.nukkit.level.GameRule
        public static DO_TILE_DROPS: cn.nukkit.level.GameRule
        public static DO_WEATHER_CYCLE: cn.nukkit.level.GameRule
        public static DROWNING_DAMAGE: cn.nukkit.level.GameRule
        public static FALL_DAMAGE: cn.nukkit.level.GameRule
        public static FIRE_DAMAGE: cn.nukkit.level.GameRule
        public static FREEZE_DAMAGE: cn.nukkit.level.GameRule
        public static FUNCTION_COMMAND_LIMIT: cn.nukkit.level.GameRule
        public static KEEP_INVENTORY: cn.nukkit.level.GameRule
        public static MAX_COMMAND_CHAIN_LENGTH: cn.nukkit.level.GameRule
        public static MOB_GRIEFING: cn.nukkit.level.GameRule
        public static NATURAL_REGENERATION: cn.nukkit.level.GameRule
        public static PVP: cn.nukkit.level.GameRule
        public static RANDOM_TICK_SPEED: cn.nukkit.level.GameRule
        public static SEND_COMMAND_FEEDBACK: cn.nukkit.level.GameRule
        public static SHOW_COORDINATES: cn.nukkit.level.GameRule
        public static SHOW_DEATH_MESSAGES: cn.nukkit.level.GameRule
        public static SHOW_DEATH_MESSAGE: cn.nukkit.level.GameRule
        public static SPAWN_RADIUS: cn.nukkit.level.GameRule
        public static TNT_EXPLODES: cn.nukkit.level.GameRule
        public static EXPERIMENTAL_GAMEPLAY: cn.nukkit.level.GameRule
        public static SHOW_TAGS: cn.nukkit.level.GameRule
        name: string
        deprecated: boolean
        public static EMPTY_ARRAY: cn.nukkit.level.GameRule[]
        static $VALUES: cn.nukkit.level.GameRule[]

    }
}

declare module "cn.nukkit.level.GameRule" {
    declare const GameRule = cn.nukkit.level.GameRule;
}

declare namespace cn.nukkit.level {
    declare class Location extends cn.nukkit.level.Position {
        public constructor(): void
        public constructor(x: double): void
        public constructor(x: double, var1: double): void
        public constructor(x: double, var1: double, y: double): void
        public constructor(x: double, var1: double, y: double, var3: cn.nukkit.level.Level): void
        public constructor(x: double, var1: double, y: double, var3: double): void
        public constructor(x: double, var1: double, y: double, var3: double, z: double): void
        public constructor(x: double, var1: double, y: double, var3: double, z: double, var5: cn.nukkit.level.Level): void
        public constructor(x: double, var1: double, y: double, var3: double, z: double, var5: double): void
        public constructor(x: double, var1: double, y: double, var3: double, z: double, var5: double, yaw: cn.nukkit.level.Level): void
        public static fromObject(pos: cn.nukkit.math.Vector3): cn.nukkit.level.Location
        public static fromObject(pos: cn.nukkit.math.Vector3, level: cn.nukkit.level.Level): cn.nukkit.level.Location
        public static fromObject(pos: cn.nukkit.math.Vector3, level: cn.nukkit.level.Level, yaw: double): cn.nukkit.level.Location
        public static fromObject(pos: cn.nukkit.math.Vector3, level: cn.nukkit.level.Level, yaw: double, var3: double): cn.nukkit.level.Location
        public static fromObject(pos: cn.nukkit.math.Vector3, level: cn.nukkit.level.Level, yaw: double, var3: double, pitch: double): cn.nukkit.level.Location
        public getYaw(): double
        public getPitch(): double
        public getHeadYaw(): double
        public setYaw(yaw: double): cn.nukkit.level.Location
        public setPitch(pitch: double): cn.nukkit.level.Location
        public toString(): string
        public getLocation(): cn.nukkit.level.Location
        public add(x: double): cn.nukkit.level.Location
        public add(x: double, var1: double): cn.nukkit.level.Location
        public add(x: double, var1: double, y: double): cn.nukkit.level.Location
        public add(x: cn.nukkit.math.Vector3): cn.nukkit.level.Location
        public subtract(): cn.nukkit.level.Location
        public subtract(x: double): cn.nukkit.level.Location
        public subtract(x: double, var1: double): cn.nukkit.level.Location
        public subtract(x: double, var1: double, y: double): cn.nukkit.level.Location
        public subtract(x: cn.nukkit.math.Vector3): cn.nukkit.level.Location
        public multiply(number: double): cn.nukkit.level.Location
        public divide(number: double): cn.nukkit.level.Location
        public ceil(): cn.nukkit.level.Location
        public floor(): cn.nukkit.level.Location
        public round(): cn.nukkit.level.Location
        public abs(): cn.nukkit.level.Location
        public getDirectionVector(): cn.nukkit.math.Vector3
        public clone(): cn.nukkit.level.Location
        public clone(): cn.nukkit.level.Position
        public abs(): cn.nukkit.level.Position
        public round(): cn.nukkit.level.Position
        public floor(): cn.nukkit.level.Position
        public ceil(): cn.nukkit.level.Position
        public divide(var0: double): cn.nukkit.level.Position
        public multiply(var0: double): cn.nukkit.level.Position
        public subtract(var0: cn.nukkit.math.Vector3): cn.nukkit.level.Position
        public subtract(var0: double, var1: double, var2: double): cn.nukkit.level.Position
        public subtract(var0: double, var1: double): cn.nukkit.level.Position
        public subtract(var0: double): cn.nukkit.level.Position
        public subtract(): cn.nukkit.level.Position
        public add(var0: cn.nukkit.math.Vector3): cn.nukkit.level.Position
        public add(var0: double, var1: double, var2: double): cn.nukkit.level.Position
        public add(var0: double, var1: double): cn.nukkit.level.Position
        public add(var0: double): cn.nukkit.level.Position
        public clone(): cn.nukkit.positiontracking.NamedPosition
        public clone(): cn.nukkit.math.Vector3
        public abs(): cn.nukkit.math.Vector3
        public round(): cn.nukkit.math.Vector3
        public floor(): cn.nukkit.math.Vector3
        public ceil(): cn.nukkit.math.Vector3
        public divide(var0: double): cn.nukkit.math.Vector3
        public multiply(var0: double): cn.nukkit.math.Vector3
        public subtract(var0: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public subtract(var0: double, var1: double, var2: double): cn.nukkit.math.Vector3
        public subtract(var0: double, var1: double): cn.nukkit.math.Vector3
        public subtract(var0: double): cn.nukkit.math.Vector3
        public subtract(): cn.nukkit.math.Vector3
        public add(var0: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public add(var0: double, var1: double, var2: double): cn.nukkit.math.Vector3
        public add(var0: double, var1: double): cn.nukkit.math.Vector3
        public add(var0: double): cn.nukkit.math.Vector3
        public clone(): java.lang.Object
        public yaw: double
        public pitch: double
        public headYaw: double

    }
}

declare module "cn.nukkit.level.Location" {
    declare const Location = cn.nukkit.level.Location;
}

declare namespace cn.nukkit.level {
    declare class Level$QueuedUpdate extends java.lang.Object {
        public constructor(block: cn.nukkit.block.Block, neighbor: cn.nukkit.math.BlockFace): void
        public getBlock(): cn.nukkit.block.Block
        public getNeighbor(): cn.nukkit.math.BlockFace
        public setBlock(block: cn.nukkit.block.Block): void
        public setNeighbor(neighbor: cn.nukkit.math.BlockFace): void
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        public toString(): string
        block: cn.nukkit.block.Block
        neighbor: cn.nukkit.math.BlockFace

    }
}

declare module "cn.nukkit.level.Level$QueuedUpdate" {
    declare const Level$QueuedUpdate = cn.nukkit.level.Level$QueuedUpdate;
}

declare namespace cn.nukkit.level {
    declare class GameRules$Value extends java.lang.Object {
        public constructor(type: cn.nukkit.level.GameRules$Type): void
        setValue(value: cn.nukkit.level.GameRules$Type): void
        public isCanBeChanged(): boolean
        public setCanBeChanged(canBeChanged: boolean): void
        public getType(): cn.nukkit.level.GameRules$Type
        getValueAsBoolean(): boolean
        getValueAsInteger(): int
        getValueAsFloat(): float
        public write(stream: cn.nukkit.utils.BinaryStream): void
        type: cn.nukkit.level.GameRules$Type
        value: any
        canBeChanged: boolean

    }
}

declare module "cn.nukkit.level.GameRules$Value" {
    declare const GameRules$Value = cn.nukkit.level.GameRules$Value;
}

declare namespace cn.nukkit.level {
    declare class GameRules$Type$1 extends cn.nukkit.level.GameRules$Type {
        constructor(var0: string, var1: int): void
        write(pk: cn.nukkit.utils.BinaryStream, value: cn.nukkit.level.GameRules$Value): void

    }
}

declare module "cn.nukkit.level.GameRules$Type$1" {
    declare const GameRules$Type$1 = cn.nukkit.level.GameRules$Type$1;
}

declare namespace cn.nukkit.level {
    declare class Level$1 extends it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap {
        constructor(this$0: cn.nukkit.level.Level): void
        public size(): int
        this$0: cn.nukkit.level.Level

    }
}

declare module "cn.nukkit.level.Level$1" {
    declare const Level$1 = cn.nukkit.level.Level$1;
}

declare namespace cn.nukkit.level {
    declare class DimensionEnum extends java.lang.Enum {
        public static values(): cn.nukkit.level.DimensionEnum[]
        public static valueOf(name: string): cn.nukkit.level.DimensionEnum
        constructor(var0: cn.nukkit.level.DimensionData): void
        public getDimensionData(): cn.nukkit.level.DimensionData
        public static getDataFromId(dimension: int): cn.nukkit.level.DimensionData
        static $values(): cn.nukkit.level.DimensionEnum[]
        public static OVERWORLD: cn.nukkit.level.DimensionEnum
        public static NETHER: cn.nukkit.level.DimensionEnum
        public static END: cn.nukkit.level.DimensionEnum
        dimensionData: cn.nukkit.level.DimensionData
        static $VALUES: cn.nukkit.level.DimensionEnum[]

    }
}

declare module "cn.nukkit.level.DimensionEnum" {
    declare const DimensionEnum = cn.nukkit.level.DimensionEnum;
}

declare namespace cn.nukkit.level {
    declare class GlobalBlockPalette extends java.lang.Object {
        public constructor(): void
        public static getOrCreateRuntimeId(id: int, meta: int): int
        public static getOrCreateRuntimeId(legacyId: int): int
        public static getName(blockId: int): string
        public static getLegacyFullId(runtimeId: int): int
        static log: org.apache.logging.log4j.Logger
        public static BLOCK_PALETTE: byte[]

    }
}

declare module "cn.nukkit.level.GlobalBlockPalette" {
    declare const GlobalBlockPalette = cn.nukkit.level.GlobalBlockPalette;
}

declare namespace cn.nukkit.level.biome.type {
    declare class WateryBiome extends cn.nukkit.level.biome.type.CoveredBiome {
        public constructor(): void
        public getSurfaceDepth(y: int): int
        public getSurfaceBlock(y: int): int
        public getGroundDepth(y: int): int
        public getGroundBlock(y: int): int

    }
}

declare module "cn.nukkit.level.biome.type.WateryBiome" {
    declare const WateryBiome = cn.nukkit.level.biome.type.WateryBiome;
}

declare namespace cn.nukkit.level.biome.type {
    declare class SnowyBiome extends cn.nukkit.level.biome.type.GrassyBiome {
        public constructor(): void
        public getCoverBlock(): int
        public canRain(): boolean

    }
}

declare module "cn.nukkit.level.biome.type.SnowyBiome" {
    declare const SnowyBiome = cn.nukkit.level.biome.type.SnowyBiome;
}

declare namespace cn.nukkit.level.biome.type {
    declare class GrassyBiome extends cn.nukkit.level.biome.type.CoveredBiome {
        public constructor(): void
        public getSurfaceBlock(y: int): int
        public getGroundBlock(y: int): int

    }
}

declare module "cn.nukkit.level.biome.type.GrassyBiome" {
    declare const GrassyBiome = cn.nukkit.level.biome.type.GrassyBiome;
}

declare namespace cn.nukkit.level.biome.type {
    declare class SandyBiome extends cn.nukkit.level.biome.type.CoveredBiome {
        public constructor(): void
        public getSurfaceDepth(y: int): int
        public getSurfaceBlock(y: int): int
        public getGroundDepth(y: int): int
        public getGroundBlock(y: int): int

    }
}

declare module "cn.nukkit.level.biome.type.SandyBiome" {
    declare const SandyBiome = cn.nukkit.level.biome.type.SandyBiome;
}

declare namespace cn.nukkit.level.biome.type {
    declare class CoveredBiome extends cn.nukkit.level.biome.Biome {
        public constructor(): void
        public getCoverId(x: int, z: int): int
        public getCoverBlock(): int
        public getCoverState(x: int, z: int): cn.nukkit.blockstate.BlockState
        public getSurfaceDepth(x: int, y: int, z: int): int
        public getSurfaceDepth(y: int): int
        public getSurfaceId(x: int, y: int, z: int): int
        public getSurfaceBlock(y: int): int
        public getSurfaceMeta(y: int): int
        public getSurfaceState(x: int, y: int, z: int): cn.nukkit.blockstate.BlockState
        public getGroundDepth(x: int, y: int, z: int): int
        public getGroundDepth(y: int): int
        public getGroundId(x: int, y: int, z: int): int
        public getGroundBlock(y: int): int
        public getGroundMeta(y: int): int
        public getGroundState(x: int, y: int, z: int): cn.nukkit.blockstate.BlockState
        public getStoneBlock(): int
        public preCover(x: int, z: int): void
        public doCover(x: int, z: int, chunk: cn.nukkit.level.format.FullChunk): void
        useNewRakNetCover(): boolean
        useNewRakNetSurfaceDepth(): boolean
        useNewRakNetSurface(): boolean
        useNewRakNetGroundDepth(): boolean
        useNewRakNetGround(): boolean
        attemptToUseNewRakNet(method: java.lang.Runnable, flagGetter: java.util.function.Supplier<boolean>, flagSetter: java.util.function.Consumer<boolean>): boolean
        lambda$useNewRakNetGround$14(val: boolean): void
        lambda$useNewRakNetGround$13(): boolean
        lambda$useNewRakNetGround$12(): void
        lambda$useNewRakNetGroundDepth$11(val: boolean): void
        lambda$useNewRakNetGroundDepth$10(): boolean
        lambda$useNewRakNetGroundDepth$9(): void
        lambda$useNewRakNetSurface$8(val: boolean): void
        lambda$useNewRakNetSurface$7(): boolean
        lambda$useNewRakNetSurface$6(): void
        lambda$useNewRakNetSurfaceDepth$5(val: boolean): void
        lambda$useNewRakNetSurfaceDepth$4(): boolean
        lambda$useNewRakNetSurfaceDepth$3(): void
        lambda$useNewRakNetCover$2(val: boolean): void
        lambda$useNewRakNetCover$1(): boolean
        lambda$useNewRakNetCover$0(): void
        static STATE_STONE: cn.nukkit.blockstate.BlockState
        useNewRakNetCover: boolean
        useNewRakNetSurfaceDepth: boolean
        useNewRakNetSurface: boolean
        useNewRakNetGroundDepth: boolean
        useNewRakNetGroundBlock: boolean
        public synchronizeCover: java.lang.Object

    }
}

declare module "cn.nukkit.level.biome.type.CoveredBiome" {
    declare const CoveredBiome = cn.nukkit.level.biome.type.CoveredBiome;
}

declare namespace cn.nukkit.level.biome {
    declare class BiomeSelector extends java.lang.Object {
        public constructor(random: cn.nukkit.math.NukkitRandom): void
        public pickBiome(x: int, z: int): cn.nukkit.level.biome.Biome
        temperature: cn.nukkit.level.generator.noise.nukkit.f.SimplexF
        rainfall: cn.nukkit.level.generator.noise.nukkit.f.SimplexF
        river: cn.nukkit.level.generator.noise.nukkit.f.SimplexF
        ocean: cn.nukkit.level.generator.noise.nukkit.f.SimplexF
        hills: cn.nukkit.level.generator.noise.nukkit.f.SimplexF

    }
}

declare module "cn.nukkit.level.biome.BiomeSelector" {
    declare const BiomeSelector = cn.nukkit.level.biome.BiomeSelector;
}

declare namespace cn.nukkit.level.biome {
    declare class EnumBiome extends java.lang.Enum {
        public static values(): cn.nukkit.level.biome.EnumBiome[]
        public static valueOf(name: string): cn.nukkit.level.biome.EnumBiome
        constructor(var0: int, var1: cn.nukkit.level.biome.Biome): void
        public static getBiome(id: int): cn.nukkit.level.biome.Biome
        public static getBiome(name: string): cn.nukkit.level.biome.Biome
        static $values(): cn.nukkit.level.biome.EnumBiome[]
        public static PLAINS: cn.nukkit.level.biome.EnumBiome
        public static DESERT: cn.nukkit.level.biome.EnumBiome
        public static EXTREME_HILLS: cn.nukkit.level.biome.EnumBiome
        public static FOREST: cn.nukkit.level.biome.EnumBiome
        public static TAIGA: cn.nukkit.level.biome.EnumBiome
        public static SWAMP: cn.nukkit.level.biome.EnumBiome
        public static RIVER: cn.nukkit.level.biome.EnumBiome
        public static HELL: cn.nukkit.level.biome.EnumBiome
        public static THE_END: cn.nukkit.level.biome.EnumBiome
        public static FROZEN_OCEAN: cn.nukkit.level.biome.EnumBiome
        public static FROZEN_RIVER: cn.nukkit.level.biome.EnumBiome
        public static ICE_PLAINS: cn.nukkit.level.biome.EnumBiome
        public static MUSHROOM_ISLAND: cn.nukkit.level.biome.EnumBiome
        public static MUSHROOM_ISLAND_SHORE: cn.nukkit.level.biome.EnumBiome
        public static BEACH: cn.nukkit.level.biome.EnumBiome
        public static DESERT_HILLS: cn.nukkit.level.biome.EnumBiome
        public static FOREST_HILLS: cn.nukkit.level.biome.EnumBiome
        public static TAIGA_HILLS: cn.nukkit.level.biome.EnumBiome
        public static EXTREME_HILLS_EDGE: cn.nukkit.level.biome.EnumBiome
        public static JUNGLE: cn.nukkit.level.biome.EnumBiome
        public static JUNGLE_HILLS: cn.nukkit.level.biome.EnumBiome
        public static JUNGLE_EDGE: cn.nukkit.level.biome.EnumBiome
        public static DEEP_OCEAN: cn.nukkit.level.biome.EnumBiome
        public static STONE_BEACH: cn.nukkit.level.biome.EnumBiome
        public static COLD_BEACH: cn.nukkit.level.biome.EnumBiome
        public static BIRCH_FOREST: cn.nukkit.level.biome.EnumBiome
        public static BIRCH_FOREST_HILLS: cn.nukkit.level.biome.EnumBiome
        public static ROOFED_FOREST: cn.nukkit.level.biome.EnumBiome
        public static COLD_TAIGA: cn.nukkit.level.biome.EnumBiome
        public static COLD_TAIGA_HILLS: cn.nukkit.level.biome.EnumBiome
        public static MEGA_TAIGA: cn.nukkit.level.biome.EnumBiome
        public static MEGA_TAIGA_HILLS: cn.nukkit.level.biome.EnumBiome
        public static EXTREME_HILLS_PLUS: cn.nukkit.level.biome.EnumBiome
        public static SAVANNA: cn.nukkit.level.biome.EnumBiome
        public static SAVANNA_PLATEAU: cn.nukkit.level.biome.EnumBiome
        public static MESA: cn.nukkit.level.biome.EnumBiome
        public static MESA_PLATEAU_F: cn.nukkit.level.biome.EnumBiome
        public static MESA_PLATEAU: cn.nukkit.level.biome.EnumBiome
        public static OCEAN: cn.nukkit.level.biome.EnumBiome
        public static LEGACY_FROZEN_OCEAN: cn.nukkit.level.biome.EnumBiome
        public static WARM_OCEAN: cn.nukkit.level.biome.EnumBiome
        public static LUKEWARM_OCEAN: cn.nukkit.level.biome.EnumBiome
        public static COLD_OCEAN: cn.nukkit.level.biome.EnumBiome
        public static DEEP_WARM_OCEAN: cn.nukkit.level.biome.EnumBiome
        public static DEEP_LUKEWARM_OCEAN: cn.nukkit.level.biome.EnumBiome
        public static DEEP_COLD_OCEAN: cn.nukkit.level.biome.EnumBiome
        public static DEEP_FROZEN_OCEAN: cn.nukkit.level.biome.EnumBiome
        public static SUNFLOWER_PLAINS: cn.nukkit.level.biome.EnumBiome
        public static DESERT_M: cn.nukkit.level.biome.EnumBiome
        public static EXTREME_HILLS_M: cn.nukkit.level.biome.EnumBiome
        public static FLOWER_FOREST: cn.nukkit.level.biome.EnumBiome
        public static TAIGA_M: cn.nukkit.level.biome.EnumBiome
        public static SWAMPLAND_M: cn.nukkit.level.biome.EnumBiome
        public static ICE_PLAINS_SPIKES: cn.nukkit.level.biome.EnumBiome
        public static JUNGLE_M: cn.nukkit.level.biome.EnumBiome
        public static JUNGLE_EDGE_M: cn.nukkit.level.biome.EnumBiome
        public static BIRCH_FOREST_M: cn.nukkit.level.biome.EnumBiome
        public static BIRCH_FOREST_HILLS_M: cn.nukkit.level.biome.EnumBiome
        public static ROOFED_FOREST_M: cn.nukkit.level.biome.EnumBiome
        public static COLD_TAIGA_M: cn.nukkit.level.biome.EnumBiome
        public static MEGA_SPRUCE_TAIGA: cn.nukkit.level.biome.EnumBiome
        public static EXTREME_HILLS_PLUS_M: cn.nukkit.level.biome.EnumBiome
        public static SAVANNA_M: cn.nukkit.level.biome.EnumBiome
        public static SAVANNA_PLATEAU_M: cn.nukkit.level.biome.EnumBiome
        public static MESA_BRYCE: cn.nukkit.level.biome.EnumBiome
        public static MESA_PLATEAU_F_M: cn.nukkit.level.biome.EnumBiome
        public static MESA_PLATEAU_M: cn.nukkit.level.biome.EnumBiome
        public static BAMBOO_JUNGLE: cn.nukkit.level.biome.EnumBiome
        public static BAMBOO_JUNGLE_HILLS: cn.nukkit.level.biome.EnumBiome
        public static SOUL_SAND_VALLEY: cn.nukkit.level.biome.EnumBiome
        public static CRIMSON_FOREST: cn.nukkit.level.biome.EnumBiome
        public static WARPED_FOREST: cn.nukkit.level.biome.EnumBiome
        public static BASALT_DELTAS: cn.nukkit.level.biome.EnumBiome
        public id: int
        public biome: cn.nukkit.level.biome.Biome
        static $VALUES: cn.nukkit.level.biome.EnumBiome[]

    }
}

declare module "cn.nukkit.level.biome.EnumBiome" {
    declare const EnumBiome = cn.nukkit.level.biome.EnumBiome;
}

declare namespace cn.nukkit.level.biome {
    declare class Biome extends java.lang.Object implements cn.nukkit.block.BlockID {
        public constructor(): void
        public static getBiomeNameFromId(biomeId: int): string
        public static getBiomeIdOrCorrect(biomeId: int): int
        static register(id: int, biome: cn.nukkit.level.biome.Biome): void
        public static getBiome(id: int): cn.nukkit.level.biome.Biome
        public static getBiome(name: string): cn.nukkit.level.biome.Biome
        public clearPopulators(): void
        public addPopulator(populator: cn.nukkit.level.generator.populator.type.Populator): void
        public populateChunk(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom): void
        public getPopulators(): java.util.ArrayList<cn.nukkit.level.generator.populator.type.Populator>
        public getId(): int
        public setId(id: int): void
        public getName(): string
        public setBaseHeight(baseHeight: float): void
        public setHeightVariation(heightVariation: float): void
        public getBaseHeight(): float
        public getHeightVariation(): float
        public hashCode(): int
        public equals(obj: java.lang.Object): boolean
        public isFreezing(): boolean
        public doesOverhang(): boolean
        public getHeightOffset(x: int, z: int): int
        public canRain(): boolean
        public isDry(): boolean
        public static MAX_BIOMES: int
        public static biomes: cn.nukkit.level.biome.Biome[]
        public static unorderedBiomes: java.util.List<cn.nukkit.level.biome.Biome>
        populators: java.util.ArrayList<cn.nukkit.level.generator.populator.type.Populator>
        id: int
        baseHeight: float
        heightVariation: float

    }
}

declare module "cn.nukkit.level.biome.Biome" {
    declare const Biome = cn.nukkit.level.biome.Biome;
}

declare namespace cn.nukkit.level.biome.impl.end {
    declare class TheEndBiome extends cn.nukkit.level.biome.Biome {
        public constructor(): void
        public getName(): string
        public canRain(): boolean

    }
}

declare module "cn.nukkit.level.biome.impl.end.TheEndBiome" {
    declare const TheEndBiome = cn.nukkit.level.biome.impl.end.TheEndBiome;
}

declare namespace cn.nukkit.level.biome.impl.iceplains {
    declare class IcePlainsSpikesBiome extends cn.nukkit.level.biome.impl.iceplains.IcePlainsBiome {
        public constructor(): void
        public getSurfaceBlock(y: int): int
        public getName(): string
        public isFreezing(): boolean

    }
}

declare module "cn.nukkit.level.biome.impl.iceplains.IcePlainsSpikesBiome" {
    declare const IcePlainsSpikesBiome = cn.nukkit.level.biome.impl.iceplains.IcePlainsSpikesBiome;
}

declare namespace cn.nukkit.level.biome.impl.iceplains {
    declare class IcePlainsSpikesBiome$PopulatorIceSpikes extends cn.nukkit.level.generator.populator.type.Populator {
        constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        public getHighestWorkableBlock(x: int, z: int, chunk: cn.nukkit.level.format.FullChunk): int

    }
}

declare module "cn.nukkit.level.biome.impl.iceplains.IcePlainsSpikesBiome$PopulatorIceSpikes" {
    declare const IcePlainsSpikesBiome$PopulatorIceSpikes = cn.nukkit.level.biome.impl.iceplains.IcePlainsSpikesBiome$PopulatorIceSpikes;
}

declare namespace cn.nukkit.level.biome.impl.iceplains {
    declare class IcePlainsBiome extends cn.nukkit.level.biome.type.SnowyBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.iceplains.IcePlainsBiome" {
    declare const IcePlainsBiome = cn.nukkit.level.biome.impl.iceplains.IcePlainsBiome;
}

declare namespace cn.nukkit.level.biome.impl.beach {
    declare class BeachBiome extends cn.nukkit.level.biome.type.SandyBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.beach.BeachBiome" {
    declare const BeachBiome = cn.nukkit.level.biome.impl.beach.BeachBiome;
}

declare namespace cn.nukkit.level.biome.impl.beach {
    declare class ColdBeachBiome extends cn.nukkit.level.biome.type.SandyBiome {
        public constructor(): void
        public getCoverBlock(): int
        public getName(): string
        public isFreezing(): boolean
        public canRain(): boolean

    }
}

declare module "cn.nukkit.level.biome.impl.beach.ColdBeachBiome" {
    declare const ColdBeachBiome = cn.nukkit.level.biome.impl.beach.ColdBeachBiome;
}

declare namespace cn.nukkit.level.biome.impl.roofedforest {
    declare class RoofedForestBiome extends cn.nukkit.level.biome.type.GrassyBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.roofedforest.RoofedForestBiome" {
    declare const RoofedForestBiome = cn.nukkit.level.biome.impl.roofedforest.RoofedForestBiome;
}

declare namespace cn.nukkit.level.biome.impl.roofedforest {
    declare class RoofedForestMBiome extends cn.nukkit.level.biome.impl.roofedforest.RoofedForestBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.roofedforest.RoofedForestMBiome" {
    declare const RoofedForestMBiome = cn.nukkit.level.biome.impl.roofedforest.RoofedForestMBiome;
}

declare namespace cn.nukkit.level.biome.impl.taiga {
    declare class TaigaBiome extends cn.nukkit.level.biome.type.GrassyBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.taiga.TaigaBiome" {
    declare const TaigaBiome = cn.nukkit.level.biome.impl.taiga.TaigaBiome;
}

declare namespace cn.nukkit.level.biome.impl.taiga {
    declare class ColdTaigaMBiome extends cn.nukkit.level.biome.impl.taiga.ColdTaigaBiome {
        public constructor(): void
        public getName(): string
        public doesOverhang(): boolean

    }
}

declare module "cn.nukkit.level.biome.impl.taiga.ColdTaigaMBiome" {
    declare const ColdTaigaMBiome = cn.nukkit.level.biome.impl.taiga.ColdTaigaMBiome;
}

declare namespace cn.nukkit.level.biome.impl.taiga {
    declare class TaigaHillsBiome extends cn.nukkit.level.biome.impl.taiga.TaigaBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.taiga.TaigaHillsBiome" {
    declare const TaigaHillsBiome = cn.nukkit.level.biome.impl.taiga.TaigaHillsBiome;
}

declare namespace cn.nukkit.level.biome.impl.taiga {
    declare class ColdTaigaHillsBiome extends cn.nukkit.level.biome.impl.taiga.ColdTaigaBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.taiga.ColdTaigaHillsBiome" {
    declare const ColdTaigaHillsBiome = cn.nukkit.level.biome.impl.taiga.ColdTaigaHillsBiome;
}

declare namespace cn.nukkit.level.biome.impl.taiga {
    declare class MegaTaigaBiome extends cn.nukkit.level.biome.impl.taiga.TaigaBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.taiga.MegaTaigaBiome" {
    declare const MegaTaigaBiome = cn.nukkit.level.biome.impl.taiga.MegaTaigaBiome;
}

declare namespace cn.nukkit.level.biome.impl.taiga {
    declare class MegaTaigaHillsBiome extends cn.nukkit.level.biome.impl.taiga.MegaTaigaBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.taiga.MegaTaigaHillsBiome" {
    declare const MegaTaigaHillsBiome = cn.nukkit.level.biome.impl.taiga.MegaTaigaHillsBiome;
}

declare namespace cn.nukkit.level.biome.impl.taiga {
    declare class ColdTaigaBiome extends cn.nukkit.level.biome.impl.taiga.TaigaBiome {
        public constructor(): void
        public getName(): string
        public getCoverBlock(): int
        public isFreezing(): boolean
        public canRain(): boolean

    }
}

declare module "cn.nukkit.level.biome.impl.taiga.ColdTaigaBiome" {
    declare const ColdTaigaBiome = cn.nukkit.level.biome.impl.taiga.ColdTaigaBiome;
}

declare namespace cn.nukkit.level.biome.impl.taiga {
    declare class MegaSpruceTaigaBiome extends cn.nukkit.level.biome.impl.taiga.TaigaBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.taiga.MegaSpruceTaigaBiome" {
    declare const MegaSpruceTaigaBiome = cn.nukkit.level.biome.impl.taiga.MegaSpruceTaigaBiome;
}

declare namespace cn.nukkit.level.biome.impl.taiga {
    declare class TaigaMBiome extends cn.nukkit.level.biome.impl.taiga.TaigaBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.taiga.TaigaMBiome" {
    declare const TaigaMBiome = cn.nukkit.level.biome.impl.taiga.TaigaMBiome;
}

declare namespace cn.nukkit.level.biome.impl.river {
    declare class FrozenRiverBiome extends cn.nukkit.level.biome.impl.river.RiverBiome {
        public constructor(): void
        public getName(): string
        public isFreezing(): boolean
        public canRain(): boolean

    }
}

declare module "cn.nukkit.level.biome.impl.river.FrozenRiverBiome" {
    declare const FrozenRiverBiome = cn.nukkit.level.biome.impl.river.FrozenRiverBiome;
}

declare namespace cn.nukkit.level.biome.impl.river {
    declare class RiverBiome extends cn.nukkit.level.biome.type.WateryBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.river.RiverBiome" {
    declare const RiverBiome = cn.nukkit.level.biome.impl.river.RiverBiome;
}

declare namespace cn.nukkit.level.biome.impl.jungle {
    declare class JungleEdgeMBiome extends cn.nukkit.level.biome.impl.jungle.JungleEdgeBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.jungle.JungleEdgeMBiome" {
    declare const JungleEdgeMBiome = cn.nukkit.level.biome.impl.jungle.JungleEdgeMBiome;
}

declare namespace cn.nukkit.level.biome.impl.jungle {
    declare class BambooJungleHillsBiome extends cn.nukkit.level.biome.impl.jungle.BambooJungleBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.jungle.BambooJungleHillsBiome" {
    declare const BambooJungleHillsBiome = cn.nukkit.level.biome.impl.jungle.BambooJungleHillsBiome;
}

declare namespace cn.nukkit.level.biome.impl.jungle {
    declare class JungleMBiome extends cn.nukkit.level.biome.impl.jungle.JungleBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.jungle.JungleMBiome" {
    declare const JungleMBiome = cn.nukkit.level.biome.impl.jungle.JungleMBiome;
}

declare namespace cn.nukkit.level.biome.impl.jungle {
    declare class JungleBiome extends cn.nukkit.level.biome.type.GrassyBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.jungle.JungleBiome" {
    declare const JungleBiome = cn.nukkit.level.biome.impl.jungle.JungleBiome;
}

declare namespace cn.nukkit.level.biome.impl.jungle {
    declare class JungleEdgeBiome extends cn.nukkit.level.biome.impl.jungle.JungleBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.jungle.JungleEdgeBiome" {
    declare const JungleEdgeBiome = cn.nukkit.level.biome.impl.jungle.JungleEdgeBiome;
}

declare namespace cn.nukkit.level.biome.impl.jungle {
    declare class JungleHillsBiome extends cn.nukkit.level.biome.impl.jungle.JungleBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.jungle.JungleHillsBiome" {
    declare const JungleHillsBiome = cn.nukkit.level.biome.impl.jungle.JungleHillsBiome;
}

declare namespace cn.nukkit.level.biome.impl.jungle {
    declare class BambooJungleBiome extends cn.nukkit.level.biome.impl.jungle.JungleBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.jungle.BambooJungleBiome" {
    declare const BambooJungleBiome = cn.nukkit.level.biome.impl.jungle.BambooJungleBiome;
}

declare namespace cn.nukkit.level.biome.impl.swamp {
    declare class SwamplandMBiome extends cn.nukkit.level.biome.impl.swamp.SwampBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.swamp.SwamplandMBiome" {
    declare const SwamplandMBiome = cn.nukkit.level.biome.impl.swamp.SwamplandMBiome;
}

declare namespace cn.nukkit.level.biome.impl.swamp {
    declare class SwampBiome extends cn.nukkit.level.biome.type.GrassyBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.swamp.SwampBiome" {
    declare const SwampBiome = cn.nukkit.level.biome.impl.swamp.SwampBiome;
}

declare namespace cn.nukkit.level.biome.impl.forest {
    declare class ForestHillsBiome extends cn.nukkit.level.biome.impl.forest.ForestBiome {
        public constructor(): void
        public constructor(type: int): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.forest.ForestHillsBiome" {
    declare const ForestHillsBiome = cn.nukkit.level.biome.impl.forest.ForestHillsBiome;
}

declare namespace cn.nukkit.level.biome.impl.forest {
    declare class ForestBiome extends cn.nukkit.level.biome.type.GrassyBiome {
        public constructor(): void
        public constructor(type: int): void
        public getName(): string
        public static TYPE_NORMAL: int
        public static TYPE_BIRCH: int
        public static TYPE_BIRCH_TALL: int
        public type: int

    }
}

declare module "cn.nukkit.level.biome.impl.forest.ForestBiome" {
    declare const ForestBiome = cn.nukkit.level.biome.impl.forest.ForestBiome;
}

declare namespace cn.nukkit.level.biome.impl.forest {
    declare class FlowerForestBiome extends cn.nukkit.level.biome.impl.forest.ForestBiome {
        public constructor(): void
        public constructor(type: int): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.forest.FlowerForestBiome" {
    declare const FlowerForestBiome = cn.nukkit.level.biome.impl.forest.FlowerForestBiome;
}

declare namespace cn.nukkit.level.biome.impl.nether {
    declare class WastelandsBiome extends cn.nukkit.level.biome.impl.nether.NetherBiome {
        public constructor(): void
        public getName(): string
        public getCoverBlock(): int
        public getMiddleBlock(): int

    }
}

declare module "cn.nukkit.level.biome.impl.nether.WastelandsBiome" {
    declare const WastelandsBiome = cn.nukkit.level.biome.impl.nether.WastelandsBiome;
}

declare namespace cn.nukkit.level.biome.impl.nether {
    declare class CrimsonForestBiome extends cn.nukkit.level.biome.impl.nether.NetherBiome {
        public constructor(): void
        public getName(): string
        public getCoverBlock(): int
        public getMiddleBlock(): int

    }
}

declare module "cn.nukkit.level.biome.impl.nether.CrimsonForestBiome" {
    declare const CrimsonForestBiome = cn.nukkit.level.biome.impl.nether.CrimsonForestBiome;
}

declare namespace cn.nukkit.level.biome.impl.nether {
    declare class WarpedForestBiome extends cn.nukkit.level.biome.impl.nether.NetherBiome {
        public constructor(): void
        public getName(): string
        public getCoverBlock(): int
        public getMiddleBlock(): int

    }
}

declare module "cn.nukkit.level.biome.impl.nether.WarpedForestBiome" {
    declare const WarpedForestBiome = cn.nukkit.level.biome.impl.nether.WarpedForestBiome;
}

declare namespace cn.nukkit.level.biome.impl.nether {
    declare class BasaltDeltasBiome extends cn.nukkit.level.biome.impl.nether.NetherBiome {
        public constructor(): void
        public getName(): string
        public getCoverBlock(): int
        public getMiddleBlock(): int

    }
}

declare module "cn.nukkit.level.biome.impl.nether.BasaltDeltasBiome" {
    declare const BasaltDeltasBiome = cn.nukkit.level.biome.impl.nether.BasaltDeltasBiome;
}

declare namespace cn.nukkit.level.biome.impl.nether {
    declare class NetherBiome extends cn.nukkit.level.biome.Biome {
        public constructor(): void
        public canRain(): boolean
        public isDry(): boolean
        public getCoverBlock(): int
        public getMiddleBlock(): int

    }
}

declare module "cn.nukkit.level.biome.impl.nether.NetherBiome" {
    declare const NetherBiome = cn.nukkit.level.biome.impl.nether.NetherBiome;
}

declare namespace cn.nukkit.level.biome.impl.nether {
    declare class SoulSandValleyBiome extends cn.nukkit.level.biome.impl.nether.NetherBiome {
        public constructor(): void
        public getName(): string
        public getCoverBlock(): int
        public getMiddleBlock(): int

    }
}

declare module "cn.nukkit.level.biome.impl.nether.SoulSandValleyBiome" {
    declare const SoulSandValleyBiome = cn.nukkit.level.biome.impl.nether.SoulSandValleyBiome;
}

declare namespace cn.nukkit.level.biome.impl.savanna {
    declare class SavannaMBiome extends cn.nukkit.level.biome.impl.savanna.SavannaBiome {
        public constructor(): void
        public getName(): string
        public doesOverhang(): boolean

    }
}

declare module "cn.nukkit.level.biome.impl.savanna.SavannaMBiome" {
    declare const SavannaMBiome = cn.nukkit.level.biome.impl.savanna.SavannaMBiome;
}

declare namespace cn.nukkit.level.biome.impl.savanna {
    declare class SavannaBiome extends cn.nukkit.level.biome.type.GrassyBiome {
        public constructor(): void
        public getName(): string
        public canRain(): boolean
        public isDry(): boolean

    }
}

declare module "cn.nukkit.level.biome.impl.savanna.SavannaBiome" {
    declare const SavannaBiome = cn.nukkit.level.biome.impl.savanna.SavannaBiome;
}

declare namespace cn.nukkit.level.biome.impl.savanna {
    declare class SavannaPlateauMBiome extends cn.nukkit.level.biome.impl.savanna.SavannaPlateauBiome {
        public constructor(): void
        public getName(): string
        public doesOverhang(): boolean

    }
}

declare module "cn.nukkit.level.biome.impl.savanna.SavannaPlateauMBiome" {
    declare const SavannaPlateauMBiome = cn.nukkit.level.biome.impl.savanna.SavannaPlateauMBiome;
}

declare namespace cn.nukkit.level.biome.impl.savanna {
    declare class SavannaPlateauBiome extends cn.nukkit.level.biome.impl.savanna.SavannaBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.savanna.SavannaPlateauBiome" {
    declare const SavannaPlateauBiome = cn.nukkit.level.biome.impl.savanna.SavannaPlateauBiome;
}

declare namespace cn.nukkit.level.biome.impl.desert {
    declare class DesertBiome extends cn.nukkit.level.biome.type.SandyBiome {
        public constructor(): void
        public getName(): string
        public canRain(): boolean
        public isDry(): boolean

    }
}

declare module "cn.nukkit.level.biome.impl.desert.DesertBiome" {
    declare const DesertBiome = cn.nukkit.level.biome.impl.desert.DesertBiome;
}

declare namespace cn.nukkit.level.biome.impl.desert {
    declare class DesertHillsBiome extends cn.nukkit.level.biome.impl.desert.DesertBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.desert.DesertHillsBiome" {
    declare const DesertHillsBiome = cn.nukkit.level.biome.impl.desert.DesertHillsBiome;
}

declare namespace cn.nukkit.level.biome.impl.desert {
    declare class DesertMBiome extends cn.nukkit.level.biome.impl.desert.DesertBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.desert.DesertMBiome" {
    declare const DesertMBiome = cn.nukkit.level.biome.impl.desert.DesertMBiome;
}

declare namespace cn.nukkit.level.biome.impl.ocean {
    declare class DeepFrozenOceanBiome extends cn.nukkit.level.biome.impl.ocean.FrozenOceanBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.ocean.DeepFrozenOceanBiome" {
    declare const DeepFrozenOceanBiome = cn.nukkit.level.biome.impl.ocean.DeepFrozenOceanBiome;
}

declare namespace cn.nukkit.level.biome.impl.ocean {
    declare class DeepColdOceanBiome extends cn.nukkit.level.biome.impl.ocean.ColdOceanBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.ocean.DeepColdOceanBiome" {
    declare const DeepColdOceanBiome = cn.nukkit.level.biome.impl.ocean.DeepColdOceanBiome;
}

declare namespace cn.nukkit.level.biome.impl.ocean {
    declare class LegacyFrozenOceanBiome extends cn.nukkit.level.biome.impl.ocean.OceanBiome {
        public constructor(): void
        public getName(): string
        public isFreezing(): boolean
        public canRain(): boolean

    }
}

declare module "cn.nukkit.level.biome.impl.ocean.LegacyFrozenOceanBiome" {
    declare const LegacyFrozenOceanBiome = cn.nukkit.level.biome.impl.ocean.LegacyFrozenOceanBiome;
}

declare namespace cn.nukkit.level.biome.impl.ocean {
    declare class DeepOceanBiome extends cn.nukkit.level.biome.impl.ocean.OceanBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.ocean.DeepOceanBiome" {
    declare const DeepOceanBiome = cn.nukkit.level.biome.impl.ocean.DeepOceanBiome;
}

declare namespace cn.nukkit.level.biome.impl.ocean {
    declare class ColdOceanBiome extends cn.nukkit.level.biome.impl.ocean.OceanBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.ocean.ColdOceanBiome" {
    declare const ColdOceanBiome = cn.nukkit.level.biome.impl.ocean.ColdOceanBiome;
}

declare namespace cn.nukkit.level.biome.impl.ocean {
    declare class WarmOceanBiome extends cn.nukkit.level.biome.impl.ocean.OceanBiome {
        public constructor(): void
        public getName(): string
        public getGroundState(x: int, y: int, z: int): cn.nukkit.blockstate.BlockState
        public getGroundDepth(x: int, y: int, z: int): int
        static STATE_SAND: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.level.biome.impl.ocean.WarmOceanBiome" {
    declare const WarmOceanBiome = cn.nukkit.level.biome.impl.ocean.WarmOceanBiome;
}

declare namespace cn.nukkit.level.biome.impl.ocean {
    declare class LukewarmOceanBiome extends cn.nukkit.level.biome.impl.ocean.OceanBiome {
        public constructor(): void
        public getName(): string
        public getGroundState(x: int, y: int, z: int): cn.nukkit.blockstate.BlockState
        public getGroundDepth(x: int, y: int, z: int): int
        static STATE_SAND: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.level.biome.impl.ocean.LukewarmOceanBiome" {
    declare const LukewarmOceanBiome = cn.nukkit.level.biome.impl.ocean.LukewarmOceanBiome;
}

declare namespace cn.nukkit.level.biome.impl.ocean {
    declare class OceanBiome extends cn.nukkit.level.biome.type.WateryBiome {
        public constructor(): void
        public getName(): string
        public getGroundBlock(y: int): int

    }
}

declare module "cn.nukkit.level.biome.impl.ocean.OceanBiome" {
    declare const OceanBiome = cn.nukkit.level.biome.impl.ocean.OceanBiome;
}

declare namespace cn.nukkit.level.biome.impl.ocean {
    declare class DeepLukewarmOceanBiome extends cn.nukkit.level.biome.impl.ocean.LukewarmOceanBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.ocean.DeepLukewarmOceanBiome" {
    declare const DeepLukewarmOceanBiome = cn.nukkit.level.biome.impl.ocean.DeepLukewarmOceanBiome;
}

declare namespace cn.nukkit.level.biome.impl.ocean {
    declare class FrozenOceanBiome extends cn.nukkit.level.biome.impl.ocean.OceanBiome {
        public constructor(): void
        public getName(): string
        public isFreezing(): boolean
        public canRain(): boolean

    }
}

declare module "cn.nukkit.level.biome.impl.ocean.FrozenOceanBiome" {
    declare const FrozenOceanBiome = cn.nukkit.level.biome.impl.ocean.FrozenOceanBiome;
}

declare namespace cn.nukkit.level.biome.impl.ocean {
    declare class DeepWarmOceanBiome extends cn.nukkit.level.biome.impl.ocean.WarmOceanBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.ocean.DeepWarmOceanBiome" {
    declare const DeepWarmOceanBiome = cn.nukkit.level.biome.impl.ocean.DeepWarmOceanBiome;
}

declare namespace cn.nukkit.level.biome.impl.extremehills {
    declare class ExtremeHillsBiome extends cn.nukkit.level.biome.type.GrassyBiome {
        public constructor(): void
        public constructor(tree: boolean): void
        public getName(): string
        public doesOverhang(): boolean

    }
}

declare module "cn.nukkit.level.biome.impl.extremehills.ExtremeHillsBiome" {
    declare const ExtremeHillsBiome = cn.nukkit.level.biome.impl.extremehills.ExtremeHillsBiome;
}

declare namespace cn.nukkit.level.biome.impl.extremehills {
    declare class ExtremeHillsPlusBiome extends cn.nukkit.level.biome.impl.extremehills.ExtremeHillsBiome {
        public constructor(): void
        public constructor(tree: boolean): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.extremehills.ExtremeHillsPlusBiome" {
    declare const ExtremeHillsPlusBiome = cn.nukkit.level.biome.impl.extremehills.ExtremeHillsPlusBiome;
}

declare namespace cn.nukkit.level.biome.impl.extremehills {
    declare class ExtremeHillsEdgeBiome extends cn.nukkit.level.biome.impl.extremehills.ExtremeHillsBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.extremehills.ExtremeHillsEdgeBiome" {
    declare const ExtremeHillsEdgeBiome = cn.nukkit.level.biome.impl.extremehills.ExtremeHillsEdgeBiome;
}

declare namespace cn.nukkit.level.biome.impl.extremehills {
    declare class StoneBeachBiome extends cn.nukkit.level.biome.type.CoveredBiome {
        public constructor(): void
        public getSurfaceDepth(y: int): int
        public getSurfaceBlock(y: int): int
        public getGroundDepth(y: int): int
        public getGroundBlock(y: int): int
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.extremehills.StoneBeachBiome" {
    declare const StoneBeachBiome = cn.nukkit.level.biome.impl.extremehills.StoneBeachBiome;
}

declare namespace cn.nukkit.level.biome.impl.extremehills {
    declare class ExtremeHillsMBiome extends cn.nukkit.level.biome.impl.extremehills.ExtremeHillsPlusBiome {
        public constructor(): void
        public constructor(tree: boolean): void
        public getName(): string
        public getSurfaceState(x: int, y: int, z: int): cn.nukkit.blockstate.BlockState
        public getSurfaceDepth(x: int, y: int, z: int): int
        public getGroundDepth(x: int, y: int, z: int): int
        public doesOverhang(): boolean
        static STATE_GRAVEL: cn.nukkit.blockstate.BlockState
        static STATE_GRASS: cn.nukkit.blockstate.BlockState
        static gravelNoise: cn.nukkit.level.generator.noise.nukkit.f.SimplexF

    }
}

declare module "cn.nukkit.level.biome.impl.extremehills.ExtremeHillsMBiome" {
    declare const ExtremeHillsMBiome = cn.nukkit.level.biome.impl.extremehills.ExtremeHillsMBiome;
}

declare namespace cn.nukkit.level.biome.impl.extremehills {
    declare class ExtremeHillsPlusMBiome extends cn.nukkit.level.biome.impl.extremehills.ExtremeHillsMBiome {
        public constructor(): void
        public getName(): string
        public doesOverhang(): boolean

    }
}

declare module "cn.nukkit.level.biome.impl.extremehills.ExtremeHillsPlusMBiome" {
    declare const ExtremeHillsPlusMBiome = cn.nukkit.level.biome.impl.extremehills.ExtremeHillsPlusMBiome;
}

declare namespace cn.nukkit.level.biome.impl {
    declare class HellBiome extends cn.nukkit.level.biome.Biome {
        public constructor(): void
        public getName(): string
        public canRain(): boolean
        public isDry(): boolean

    }
}

declare module "cn.nukkit.level.biome.impl.HellBiome" {
    declare const HellBiome = cn.nukkit.level.biome.impl.HellBiome;
}

declare namespace cn.nukkit.level.biome.impl.plains {
    declare class PlainsBiome extends cn.nukkit.level.biome.type.GrassyBiome {
        public constructor(): void
        public getName(): string
        public isDry(): boolean

    }
}

declare module "cn.nukkit.level.biome.impl.plains.PlainsBiome" {
    declare const PlainsBiome = cn.nukkit.level.biome.impl.plains.PlainsBiome;
}

declare namespace cn.nukkit.level.biome.impl.plains {
    declare class SunflowerPlainsBiome extends cn.nukkit.level.biome.impl.plains.PlainsBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.plains.SunflowerPlainsBiome" {
    declare const SunflowerPlainsBiome = cn.nukkit.level.biome.impl.plains.SunflowerPlainsBiome;
}

declare namespace cn.nukkit.level.biome.impl.mesa {
    declare class MesaPlateauFBiome extends cn.nukkit.level.biome.impl.mesa.MesaPlateauBiome {
        public constructor(): void
        public getCoverBlock(): int
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.mesa.MesaPlateauFBiome" {
    declare const MesaPlateauFBiome = cn.nukkit.level.biome.impl.mesa.MesaPlateauFBiome;
}

declare namespace cn.nukkit.level.biome.impl.mesa {
    declare class MesaPlateauBiome extends cn.nukkit.level.biome.impl.mesa.MesaBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.mesa.MesaPlateauBiome" {
    declare const MesaPlateauBiome = cn.nukkit.level.biome.impl.mesa.MesaPlateauBiome;
}

declare namespace cn.nukkit.level.biome.impl.mesa {
    declare class MesaPlateauFMBiome extends cn.nukkit.level.biome.impl.mesa.MesaPlateauFBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.mesa.MesaPlateauFMBiome" {
    declare const MesaPlateauFMBiome = cn.nukkit.level.biome.impl.mesa.MesaPlateauFMBiome;
}

declare namespace cn.nukkit.level.biome.impl.mesa {
    declare class MesaBryceBiome extends cn.nukkit.level.biome.impl.mesa.MesaBiome {
        public constructor(): void
        public getName(): string
        getMoundFrequency(): float
        minHill(): float

    }
}

declare module "cn.nukkit.level.biome.impl.mesa.MesaBryceBiome" {
    declare const MesaBryceBiome = cn.nukkit.level.biome.impl.mesa.MesaBryceBiome;
}

declare namespace cn.nukkit.level.biome.impl.mesa {
    declare class MesaPlateauMBiome extends cn.nukkit.level.biome.impl.mesa.MesaBiome {
        public constructor(): void
        public getName(): string
        getMoundFrequency(): float
        minHill(): float

    }
}

declare module "cn.nukkit.level.biome.impl.mesa.MesaPlateauMBiome" {
    declare const MesaPlateauMBiome = cn.nukkit.level.biome.impl.mesa.MesaPlateauMBiome;
}

declare namespace cn.nukkit.level.biome.impl.mesa {
    declare class MesaBiome extends cn.nukkit.level.biome.type.CoveredBiome {
        static setRandomLayerColor(random: java.util.Random, sliceCount: int, color: int): void
        public constructor(): void
        public setMoundHeight(height: int): void
        public getSurfaceDepth(x: int, y: int, z: int): int
        public getSurfaceState(x: int, y: int, z: int): cn.nukkit.blockstate.BlockState
        public getGroundDepth(x: int, y: int, z: int): int
        public getGroundState(x: int, y: int, z: int): cn.nukkit.blockstate.BlockState
        public getName(): string
        getMoundFrequency(): float
        public getHeightOffset(x: int, z: int): int
        minHill(): float
        public canRain(): boolean
        static STATE_TERRACOTTA: cn.nukkit.blockstate.BlockState
        static STATE_RED_SAND: cn.nukkit.blockstate.BlockState
        static STATE_RED_SANDSTONE: cn.nukkit.blockstate.BlockState
        static STATE_STAINED_TERRACOTTA: cn.nukkit.blockstate.BlockState[]
        static colorLayer: int[]
        static redSandNoise: cn.nukkit.level.generator.noise.nukkit.f.SimplexF
        static colorNoise: cn.nukkit.level.generator.noise.nukkit.f.SimplexF
        moundNoise: cn.nukkit.level.generator.noise.nukkit.f.SimplexF
        moundHeight: int

    }
}

declare module "cn.nukkit.level.biome.impl.mesa.MesaBiome" {
    declare const MesaBiome = cn.nukkit.level.biome.impl.mesa.MesaBiome;
}

declare namespace cn.nukkit.level.biome.impl.mushroom {
    declare class MushroomIslandBiome extends cn.nukkit.level.biome.type.GrassyBiome {
        public constructor(): void
        public getName(): string
        public getSurfaceBlock(y: int): int

    }
}

declare module "cn.nukkit.level.biome.impl.mushroom.MushroomIslandBiome" {
    declare const MushroomIslandBiome = cn.nukkit.level.biome.impl.mushroom.MushroomIslandBiome;
}

declare namespace cn.nukkit.level.biome.impl.mushroom {
    declare class MushroomIslandShoreBiome extends cn.nukkit.level.biome.impl.mushroom.MushroomIslandBiome {
        public constructor(): void
        public getName(): string

    }
}

declare module "cn.nukkit.level.biome.impl.mushroom.MushroomIslandShoreBiome" {
    declare const MushroomIslandShoreBiome = cn.nukkit.level.biome.impl.mushroom.MushroomIslandShoreBiome;
}

declare namespace cn.nukkit.level.biome {
    declare class BiomeLegacyId2StringIdMap extends java.lang.Object {
        constructor(): void
        public legacy2String(legacyBiomeID: int): string
        public string2Legacy(stringBiomeID: string): int
        static log: org.apache.logging.log4j.Logger
        public static INSTANCE: cn.nukkit.level.biome.BiomeLegacyId2StringIdMap
        legacy2StringMap: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap<string>
        string2LegacyMap: it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap<string>

    }
}

declare module "cn.nukkit.level.biome.BiomeLegacyId2StringIdMap" {
    declare const BiomeLegacyId2StringIdMap = cn.nukkit.level.biome.BiomeLegacyId2StringIdMap;
}

declare namespace cn.nukkit.level.util {
    declare class Pow2BitArray extends java.lang.Object implements cn.nukkit.level.util.BitArray {
        constructor(version: cn.nukkit.level.util.BitArrayVersion, size: int, words: int[]): void
        public set(index: int, value: int): void
        public get(index: int): int
        public size(): int
        public getWords(): int[]
        public getVersion(): cn.nukkit.level.util.BitArrayVersion
        public copy(): cn.nukkit.level.util.BitArray
        words: int[]
        version: cn.nukkit.level.util.BitArrayVersion
        size: int

    }
}

declare module "cn.nukkit.level.util.Pow2BitArray" {
    declare const Pow2BitArray = cn.nukkit.level.util.Pow2BitArray;
}

declare namespace cn.nukkit.level.util {
    declare class PaddedBitArray extends java.lang.Object implements cn.nukkit.level.util.BitArray {
        constructor(version: cn.nukkit.level.util.BitArrayVersion, size: int, words: int[]): void
        public set(index: int, value: int): void
        public get(index: int): int
        public size(): int
        public getWords(): int[]
        public getVersion(): cn.nukkit.level.util.BitArrayVersion
        public copy(): cn.nukkit.level.util.BitArray
        words: int[]
        version: cn.nukkit.level.util.BitArrayVersion
        size: int

    }
}

declare module "cn.nukkit.level.util.PaddedBitArray" {
    declare const PaddedBitArray = cn.nukkit.level.util.PaddedBitArray;
}

declare namespace cn.nukkit.level.util {
    declare interface BitArray {
        public set(var0: int, var1: int): void
        public get(var0: int): int
        public size(): int
        public getWords(): int[]
        public getVersion(): cn.nukkit.level.util.BitArrayVersion
        public copy(): cn.nukkit.level.util.BitArray

    }
}

declare module "cn.nukkit.level.util.BitArray" {
    declare type BitArray = cn.nukkit.level.util.BitArray;
}

declare namespace cn.nukkit.level.util {
    declare class PalettedBlockStorage extends java.lang.Object {
        public constructor(): void
        public constructor(version: cn.nukkit.level.util.BitArrayVersion): void
        public constructor(bitArray: cn.nukkit.level.util.BitArray, palette: it.unimi.dsi.fastutil.ints.IntList): void
        constructor(version: cn.nukkit.level.util.BitArrayVersion, defaultState: int): void
        public static createFromBlockPalette(version: cn.nukkit.level.util.BitArrayVersion): cn.nukkit.level.util.PalettedBlockStorage
        public static createWithDefaultState(defaultState: int): cn.nukkit.level.util.PalettedBlockStorage
        public static createWithDefaultState(version: cn.nukkit.level.util.BitArrayVersion, defaultState: int): cn.nukkit.level.util.PalettedBlockStorage
        getPaletteHeader(version: cn.nukkit.level.util.BitArrayVersion, runtime: boolean): int
        public setBlock(index: int, runtimeId: int): void
        public writeTo(stream: cn.nukkit.utils.BinaryStream): void
        onResize(version: cn.nukkit.level.util.BitArrayVersion): void
        idFor(runtimeId: int): int
        public isEmpty(): boolean
        public copy(): cn.nukkit.level.util.PalettedBlockStorage
        public setBlock(x: int, y: int, z: int, runtimeId: int): void
        static SIZE: int
        public palette: it.unimi.dsi.fastutil.ints.IntList
        public bitArray: cn.nukkit.level.util.BitArray

    }
}

declare module "cn.nukkit.level.util.PalettedBlockStorage" {
    declare const PalettedBlockStorage = cn.nukkit.level.util.PalettedBlockStorage;
}

declare namespace cn.nukkit.level.util {
    declare class BitArrayVersion extends java.lang.Enum {
        public static values(): cn.nukkit.level.util.BitArrayVersion[]
        public static valueOf(name: string): cn.nukkit.level.util.BitArrayVersion
        constructor(var0: int, var1: int, bits: cn.nukkit.level.util.BitArrayVersion): void
        public static get(version: int, read: boolean): cn.nukkit.level.util.BitArrayVersion
        public createPalette(size: int): cn.nukkit.level.util.BitArray
        public getId(): byte
        public getWordsForSize(size: int): int
        public getMaxEntryValue(): int
        public next(): cn.nukkit.level.util.BitArrayVersion
        public createPalette(size: int, words: int[]): cn.nukkit.level.util.BitArray
        static $values(): cn.nukkit.level.util.BitArrayVersion[]
        public static V16: cn.nukkit.level.util.BitArrayVersion
        public static V8: cn.nukkit.level.util.BitArrayVersion
        public static V6: cn.nukkit.level.util.BitArrayVersion
        public static V5: cn.nukkit.level.util.BitArrayVersion
        public static V4: cn.nukkit.level.util.BitArrayVersion
        public static V3: cn.nukkit.level.util.BitArrayVersion
        public static V2: cn.nukkit.level.util.BitArrayVersion
        public static V1: cn.nukkit.level.util.BitArrayVersion
        public static V0: cn.nukkit.level.util.BitArrayVersion
        bits: byte
        entriesPerWord: byte
        maxEntryValue: int
        next: cn.nukkit.level.util.BitArrayVersion
        static $VALUES: cn.nukkit.level.util.BitArrayVersion[]

    }
}

declare module "cn.nukkit.level.util.BitArrayVersion" {
    declare const BitArrayVersion = cn.nukkit.level.util.BitArrayVersion;
}

declare namespace cn.nukkit.level {
    declare class GameRules$Type$2 extends cn.nukkit.level.GameRules$Type {
        constructor(var0: string, var1: int): void
        write(pk: cn.nukkit.utils.BinaryStream, value: cn.nukkit.level.GameRules$Value): void

    }
}

declare module "cn.nukkit.level.GameRules$Type$2" {
    declare const GameRules$Type$2 = cn.nukkit.level.GameRules$Type$2;
}

declare namespace cn.nukkit.level {
    declare class GameRules$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$level$GameRules$Type: int[]

    }
}

declare module "cn.nukkit.level.GameRules$1" {
    declare const GameRules$1 = cn.nukkit.level.GameRules$1;
}

declare namespace cn.nukkit.level {
    declare class GameRules$Type$4 extends cn.nukkit.level.GameRules$Type {
        constructor(var0: string, var1: int): void
        write(pk: cn.nukkit.utils.BinaryStream, value: cn.nukkit.level.GameRules$Value): void

    }
}

declare module "cn.nukkit.level.GameRules$Type$4" {
    declare const GameRules$Type$4 = cn.nukkit.level.GameRules$Type$4;
}

declare namespace cn.nukkit.level {
    declare class DimensionData extends java.lang.Object {
        public constructor(dimensionId: int, minHeight: int, maxHeight: int): void
        public getDimensionId(): int
        public getMinHeight(): int
        public getMaxHeight(): int
        public getHeight(): int
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        public toString(): string
        dimensionId: int
        minHeight: int
        maxHeight: int
        height: int

    }
}

declare module "cn.nukkit.level.DimensionData" {
    declare const DimensionData = cn.nukkit.level.DimensionData;
}

declare namespace cn.nukkit.level {
    declare class GameRules$Type extends java.lang.Enum {
        public static values(): cn.nukkit.level.GameRules$Type[]
        public static valueOf(name: string): cn.nukkit.level.GameRules$Type
        constructor(): void
        write(var0: cn.nukkit.utils.BinaryStream, var1: cn.nukkit.level.GameRules$Value): void
        static $values(): cn.nukkit.level.GameRules$Type[]
        public static UNKNOWN: cn.nukkit.level.GameRules$Type
        public static BOOLEAN: cn.nukkit.level.GameRules$Type
        public static INTEGER: cn.nukkit.level.GameRules$Type
        public static FLOAT: cn.nukkit.level.GameRules$Type
        static $VALUES: cn.nukkit.level.GameRules$Type[]

    }
}

declare module "cn.nukkit.level.GameRules$Type" {
    declare const GameRules$Type = cn.nukkit.level.GameRules$Type;
}

declare namespace cn.nukkit.level.particle {
    declare class InstantSpellParticle extends cn.nukkit.level.particle.SpellParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void
        public constructor(pos: cn.nukkit.math.Vector3, data: int): void
        public constructor(pos: cn.nukkit.math.Vector3, blockColor: cn.nukkit.utils.BlockColor): void
        public constructor(pos: cn.nukkit.math.Vector3, r: int, g: int, b: int): void
        data: int

    }
}

declare module "cn.nukkit.level.particle.InstantSpellParticle" {
    declare const InstantSpellParticle = cn.nukkit.level.particle.InstantSpellParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class WaxOffParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void
        public encode(): cn.nukkit.network.protocol.DataPacket[]

    }
}

declare module "cn.nukkit.level.particle.WaxOffParticle" {
    declare const WaxOffParticle = cn.nukkit.level.particle.WaxOffParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class RainSplashParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.RainSplashParticle" {
    declare const RainSplashParticle = cn.nukkit.level.particle.RainSplashParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class HugeExplodeParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.HugeExplodeParticle" {
    declare const HugeExplodeParticle = cn.nukkit.level.particle.HugeExplodeParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class CriticalParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void
        public constructor(pos: cn.nukkit.math.Vector3, scale: int): void

    }
}

declare module "cn.nukkit.level.particle.CriticalParticle" {
    declare const CriticalParticle = cn.nukkit.level.particle.CriticalParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class ExplodeParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.ExplodeParticle" {
    declare const ExplodeParticle = cn.nukkit.level.particle.ExplodeParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class SmokeParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void
        public constructor(pos: cn.nukkit.math.Vector3, scale: int): void

    }
}

declare module "cn.nukkit.level.particle.SmokeParticle" {
    declare const SmokeParticle = cn.nukkit.level.particle.SmokeParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class RedstoneParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void
        public constructor(pos: cn.nukkit.math.Vector3, lifetime: int): void

    }
}

declare module "cn.nukkit.level.particle.RedstoneParticle" {
    declare const RedstoneParticle = cn.nukkit.level.particle.RedstoneParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class HappyVillagerParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.HappyVillagerParticle" {
    declare const HappyVillagerParticle = cn.nukkit.level.particle.HappyVillagerParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class InstantEnchantParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.InstantEnchantParticle" {
    declare const InstantEnchantParticle = cn.nukkit.level.particle.InstantEnchantParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class WaxOnParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void
        public encode(): cn.nukkit.network.protocol.DataPacket[]

    }
}

declare module "cn.nukkit.level.particle.WaxOnParticle" {
    declare const WaxOnParticle = cn.nukkit.level.particle.WaxOnParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class GenericParticle extends cn.nukkit.level.particle.Particle {
        public constructor(pos: cn.nukkit.math.Vector3, id: int): void
        public constructor(pos: cn.nukkit.math.Vector3, id: int, data: int): void
        public encode(): cn.nukkit.network.protocol.DataPacket[]
        id: int
        data: int

    }
}

declare module "cn.nukkit.level.particle.GenericParticle" {
    declare const GenericParticle = cn.nukkit.level.particle.GenericParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class WaterParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.WaterParticle" {
    declare const WaterParticle = cn.nukkit.level.particle.WaterParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class PunchBlockParticle extends cn.nukkit.level.particle.Particle {
        public constructor(pos: cn.nukkit.math.Vector3, block: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace): void
        public constructor(pos: cn.nukkit.math.Vector3, blockId: int, blockDamage: int, face: cn.nukkit.math.BlockFace): void
        public encode(): cn.nukkit.network.protocol.DataPacket[]
        data: int

    }
}

declare module "cn.nukkit.level.particle.PunchBlockParticle" {
    declare const PunchBlockParticle = cn.nukkit.level.particle.PunchBlockParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class HeartParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void
        public constructor(pos: cn.nukkit.math.Vector3, scale: int): void

    }
}

declare module "cn.nukkit.level.particle.HeartParticle" {
    declare const HeartParticle = cn.nukkit.level.particle.HeartParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class DestroyBlockParticle extends cn.nukkit.level.particle.Particle {
        public constructor(pos: cn.nukkit.math.Vector3, block: cn.nukkit.block.Block): void
        public encode(): cn.nukkit.network.protocol.DataPacket[]
        data: int

    }
}

declare module "cn.nukkit.level.particle.DestroyBlockParticle" {
    declare const DestroyBlockParticle = cn.nukkit.level.particle.DestroyBlockParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class FloatingTextParticle extends cn.nukkit.level.particle.Particle {
        public constructor(location: cn.nukkit.level.Location, title: string): void
        public constructor(location: cn.nukkit.level.Location, title: string, text: string): void
        public constructor(pos: cn.nukkit.math.Vector3, title: string): void
        public constructor(pos: cn.nukkit.math.Vector3, title: string, text: string): void
        constructor(level: cn.nukkit.level.Level, pos: cn.nukkit.math.Vector3, title: string, text: string): void
        public getText(): string
        public setText(text: string): void
        public getTitle(): string
        public setTitle(title: string): void
        sendMetadata(): void
        public isInvisible(): boolean
        public setInvisible(invisible: boolean): void
        public setInvisible(): void
        public getEntityId(): long
        public encode(): cn.nukkit.network.protocol.DataPacket[]
        static EMPTY_SKIN: cn.nukkit.entity.data.Skin
        static SKIN_DATA: cn.nukkit.utils.SerializedImage
        uuid: java.util.UUID
        level: cn.nukkit.level.Level
        entityId: long
        invisible: boolean
        metadata: cn.nukkit.entity.data.EntityMetadata

    }
}

declare module "cn.nukkit.level.particle.FloatingTextParticle" {
    declare const FloatingTextParticle = cn.nukkit.level.particle.FloatingTextParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class Particle extends cn.nukkit.math.Vector3 {
        public static getParticleIdByName(name: string): int
        public static particleExists(name: string): boolean
        public constructor(): void
        public constructor(x: double): void
        public constructor(x: double, var1: double): void
        public constructor(x: double, var1: double, y: double): void
        public encode(): cn.nukkit.network.protocol.DataPacket[]
        public static TYPE_BUBBLE: int
        public static TYPE_BUBBLE_MANUAL: int
        public static TYPE_CRITICAL: int
        public static TYPE_BLOCK_FORCE_FIELD: int
        public static TYPE_SMOKE: int
        public static TYPE_EXPLODE: int
        public static TYPE_EVAPORATION: int
        public static TYPE_FLAME: int
        public static TYPE_CANDLE_FLAME: int
        public static TYPE_LAVA: int
        public static TYPE_LARGE_SMOKE: int
        public static TYPE_REDSTONE: int
        public static TYPE_RISING_RED_DUST: int
        public static TYPE_ITEM_BREAK: int
        public static TYPE_SNOWBALL_POOF: int
        public static TYPE_HUGE_EXPLODE: int
        public static TYPE_HUGE_EXPLODE_SEED: int
        public static TYPE_MOB_FLAME: int
        public static TYPE_HEART: int
        public static TYPE_TERRAIN: int
        public static TYPE_TOWN_AURA: int
        public static TYPE_SUSPENDED_TOWN: int
        public static TYPE_PORTAL: int
        public static TYPE_MOB_PORTAL: int
        public static TYPE_SPLASH: int
        public static TYPE_WATER_SPLASH: int
        public static TYPE_WATER_SPLASH_MANUAL: int
        public static TYPE_WATER_WAKE: int
        public static TYPE_DRIP_WATER: int
        public static TYPE_DRIP_LAVA: int
        public static TYPE_DRIP_HONEY: int
        public static TYPE_STALACTITE_DRIP_WATER: int
        public static TYPE_STALACTITE_DRIP_LAVA: int
        public static TYPE_FALLING_DUST: int
        public static TYPE_DUST: int
        public static TYPE_MOB_SPELL: int
        public static TYPE_MOB_SPELL_AMBIENT: int
        public static TYPE_MOB_SPELL_INSTANTANEOUS: int
        public static TYPE_INK: int
        public static TYPE_SLIME: int
        public static TYPE_RAIN_SPLASH: int
        public static TYPE_VILLAGER_ANGRY: int
        public static TYPE_VILLAGER_HAPPY: int
        public static TYPE_ENCHANTMENT_TABLE: int
        public static TYPE_TRACKING_EMITTER: int
        public static TYPE_NOTE: int
        public static TYPE_WITCH_SPELL: int
        public static TYPE_CARROT: int
        public static TYPE_MOB_APPEARANCE: int
        public static TYPE_END_ROD: int
        public static TYPE_RISING_DRAGONS_BREATH: int
        public static TYPE_SPIT: int
        public static TYPE_TOTEM: int
        public static TYPE_FOOD: int
        public static TYPE_FIREWORKS_STARTER: int
        public static TYPE_FIREWORKS_SPARK: int
        public static TYPE_FIREWORKS_OVERLAY: int
        public static TYPE_BALLOON_GAS: int
        public static TYPE_COLORED_FLAME: int
        public static TYPE_SPARKLER: int
        public static TYPE_CONDUIT: int
        public static TYPE_BUBBLE_COLUMN_UP: int
        public static TYPE_BUBBLE_COLUMN_DOWN: int
        public static TYPE_SNEEZE: int
        public static TYPE_SHULKER_BULLET: int
        public static TYPE_BLEACH: int
        public static TYPE_LARGE_EXPLOSION: int
        public static TYPE_MYCELIUM_DUST: int
        public static TYPE_FALLING_RED_DUST: int
        public static TYPE_CAMPFIRE_SMOKE: int
        public static TYPE_TALL_CAMPFIRE_SMOKE: int
        public static TYPE_FALLING_DRAGONS_BREATH: int
        public static TYPE_DRAGONS_BREATH: int
        public static TYPE_BLUE_FLAME: int
        public static TYPE_SOUL: int
        public static TYPE_OBSIDIAN_TEAR: int
        public static TYPE_PORTAL_REVERSE: int
        public static TYPE_SNOWFLAKE: int
        public static TYPE_VIBRATION_SIGNAL: int
        public static TYPE_SCULK_SENSOR_REDSTONE: int
        public static TYPE_SPORE_BLOSSOM_SHOWER: int
        public static TYPE_SPORE_BLOSSOM_AMBIENT: int
        public static TYPE_WAX: int
        public static TYPE_ELECTRIC_SPARK: int
        public static TYPE_SHRIEK: int
        public static TYPE_SCULK_SOUL: int
        public static TYPE_SONIC_EXPLOSION: int

    }
}

declare module "cn.nukkit.level.particle.Particle" {
    declare const Particle = cn.nukkit.level.particle.Particle;
}

declare namespace cn.nukkit.level.particle {
    declare class TerrainParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3, block: cn.nukkit.block.Block): void

    }
}

declare module "cn.nukkit.level.particle.TerrainParticle" {
    declare const TerrainParticle = cn.nukkit.level.particle.TerrainParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class EntityFlameParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.EntityFlameParticle" {
    declare const EntityFlameParticle = cn.nukkit.level.particle.EntityFlameParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class EnchantmentTableParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.EnchantmentTableParticle" {
    declare const EnchantmentTableParticle = cn.nukkit.level.particle.EnchantmentTableParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class DustParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3, blockColor: cn.nukkit.utils.BlockColor): void
        public constructor(pos: cn.nukkit.math.Vector3, r: int, g: int, b: int): void
        public constructor(pos: cn.nukkit.math.Vector3, r: int, g: int, b: int, a: int): void

    }
}

declare module "cn.nukkit.level.particle.DustParticle" {
    declare const DustParticle = cn.nukkit.level.particle.DustParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class HugeExplodeSeedParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.HugeExplodeSeedParticle" {
    declare const HugeExplodeSeedParticle = cn.nukkit.level.particle.HugeExplodeSeedParticle;
}

declare namespace cn.nukkit.level.generator.populator.impl.tree {
    declare class JungleTreePopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public constructor(type: int): void
        public setRandomAmount(randomAmount: int): void
        public setBaseAmount(baseAmount: int): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlock(x: int, z: int): int
        level: cn.nukkit.level.ChunkManager
        randomAmount: int
        baseAmount: int
        type: int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.tree.JungleTreePopulator" {
    declare const JungleTreePopulator = cn.nukkit.level.generator.populator.impl.tree.JungleTreePopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl.tree {
    declare class JungleFloorPopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public constructor(type: int): void
        public setRandomAmount(randomAmount: int): void
        public setBaseAmount(baseAmount: int): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlock(x: int, z: int): int
        level: cn.nukkit.level.ChunkManager
        randomAmount: int
        baseAmount: int
        type: int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.tree.JungleFloorPopulator" {
    declare const JungleFloorPopulator = cn.nukkit.level.generator.populator.impl.tree.JungleFloorPopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl.tree {
    declare class SavannaTreePopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public constructor(type: int): void
        public setRandomAmount(randomAmount: int): void
        public setBaseAmount(baseAmount: int): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlock(x: int, z: int): int
        level: cn.nukkit.level.ChunkManager
        randomAmount: int
        baseAmount: int
        type: int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.tree.SavannaTreePopulator" {
    declare const SavannaTreePopulator = cn.nukkit.level.generator.populator.impl.tree.SavannaTreePopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl.tree {
    declare class DarkOakTreePopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public constructor(type: int): void
        public setRandomAmount(randomAmount: int): void
        public setBaseAmount(baseAmount: int): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlock(x: int, z: int): int
        level: cn.nukkit.level.ChunkManager
        randomAmount: int
        baseAmount: int
        type: int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.tree.DarkOakTreePopulator" {
    declare const DarkOakTreePopulator = cn.nukkit.level.generator.populator.impl.tree.DarkOakTreePopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl.tree {
    declare class SwampTreePopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public constructor(type: int): void
        public setRandomAmount(randomAmount: int): void
        public setBaseAmount(baseAmount: int): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlock(x: int, z: int): int
        level: cn.nukkit.level.ChunkManager
        randomAmount: int
        baseAmount: int
        type: int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.tree.SwampTreePopulator" {
    declare const SwampTreePopulator = cn.nukkit.level.generator.populator.impl.tree.SwampTreePopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorEndSpike extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(theEnd: cn.nukkit.level.generator.TheEnd): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        theEnd: cn.nukkit.level.generator.TheEnd

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorEndSpike" {
    declare const PopulatorEndSpike = cn.nukkit.level.generator.populator.impl.PopulatorEndSpike;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorLilyPad extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock {
        public constructor(): void
        canStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean
        getBlockId(x: int, z: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorLilyPad" {
    declare const PopulatorLilyPad = cn.nukkit.level.generator.populator.impl.PopulatorLilyPad;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorEndIsland extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(theEnd: cn.nukkit.level.generator.TheEnd): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        theEnd: cn.nukkit.level.generator.TheEnd
        objectEndIsland: cn.nukkit.level.generator.object.end.ObjectEndIsland

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorEndIsland" {
    declare const PopulatorEndIsland = cn.nukkit.level.generator.populator.impl.PopulatorEndIsland;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class WaterIcePopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void

    }
}

declare module "cn.nukkit.level.generator.populator.impl.WaterIcePopulator" {
    declare const WaterIcePopulator = cn.nukkit.level.generator.populator.impl.WaterIcePopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorSmallMushroom extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock {
        public constructor(): void
        canStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean
        getBlockId(x: int, z: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorSmallMushroom" {
    declare const PopulatorSmallMushroom = cn.nukkit.level.generator.populator.impl.PopulatorSmallMushroom;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorRavines extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        generateChunk(chunkX: int, chunkZ: int, generatingChunkBuffer: cn.nukkit.level.format.FullChunk): void
        createRavine(paramLong: long, var1: cn.nukkit.level.format.FullChunk, generatingChunkBuffer: double, paramDouble1: double, var4: double, paramDouble2: float, var6: float, paramDouble3: float, var8: int, paramFloat1: double): void
        public static numberInRange(random: java.util.Random, min: int, max: int): int
        checkAreaSize: int
        random: java.util.Random
        worldLong1: long
        worldLong2: long
        ravineRarity: int
        ravineMinAltitude: int
        ravineMaxAltitude: int
        ravineMinLength: int
        ravineMaxLength: int
        ravineDepth: double
        worldHeightCap: int
        a: float[]

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorRavines" {
    declare const PopulatorRavines = cn.nukkit.level.generator.populator.impl.PopulatorRavines;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorCactus extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock {
        public constructor(): void
        populateCount(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        canStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean
        getBlockId(x: int, z: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorCactus" {
    declare const PopulatorCactus = cn.nukkit.level.generator.populator.impl.PopulatorCactus;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorGroundCover extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        public static STONE: int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorGroundCover" {
    declare const PopulatorGroundCover = cn.nukkit.level.generator.populator.impl.PopulatorGroundCover;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorSugarcane extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock {
        public constructor(): void
        findWater(x: int, y: int, z: int, level: cn.nukkit.level.Level): boolean
        canStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean
        getBlockId(x: int, z: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorSugarcane" {
    declare const PopulatorSugarcane = cn.nukkit.level.generator.populator.impl.PopulatorSugarcane;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorDoublePlant extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock {
        public constructor(type: int): void
        canStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean
        getBlockId(x: int, z: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): int
        placeBlock(x: int, y: int, z: int, id: int, chunk: cn.nukkit.level.format.FullChunk, random: cn.nukkit.math.NukkitRandom): void
        type: int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorDoublePlant" {
    declare const PopulatorDoublePlant = cn.nukkit.level.generator.populator.impl.PopulatorDoublePlant;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorVines extends cn.nukkit.level.generator.populator.type.PopulatorCount {
        public constructor(): void
        generateVines(level: cn.nukkit.level.ChunkManager, x: int, z: int, random: cn.nukkit.math.NukkitRandom): void
        getHighestWorkableBlock(level: cn.nukkit.level.ChunkManager, x: int, z: int, chunk: cn.nukkit.level.format.FullChunk): int
        populateCount(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorVines" {
    declare const PopulatorVines = cn.nukkit.level.generator.populator.impl.PopulatorVines;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorEndGateway extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(theEnd: cn.nukkit.level.generator.TheEnd): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        public getExitPortalPosition(): cn.nukkit.math.BlockVector3
        public setExitPortalPosition(exitPortalPosition: cn.nukkit.math.BlockVector3): void
        theEnd: cn.nukkit.level.generator.TheEnd
        objectEndGateway: cn.nukkit.level.generator.object.end.ObjectEndGateway
        exitPortalPosition: cn.nukkit.math.BlockVector3

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorEndGateway" {
    declare const PopulatorEndGateway = cn.nukkit.level.generator.populator.impl.PopulatorEndGateway;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorOreEmerald extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        static STATE_STONE: cn.nukkit.blockstate.BlockState
        static STATE_EMERALD_ORE: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorOreEmerald" {
    declare const PopulatorOreEmerald = cn.nukkit.level.generator.populator.impl.PopulatorOreEmerald;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorTallSugarcane extends cn.nukkit.level.generator.populator.impl.PopulatorSugarcane {
        public constructor(): void
        placeBlock(x: int, y: int, z: int, id: int, chunk: cn.nukkit.level.format.FullChunk, random: cn.nukkit.math.NukkitRandom): void

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorTallSugarcane" {
    declare const PopulatorTallSugarcane = cn.nukkit.level.generator.populator.impl.PopulatorTallSugarcane;
}

declare namespace cn.nukkit.level.generator.populator.helper {
    declare interface EnsureBelow {
        public static ensureBelow(x: int, y: int, z: int, id: int, chunk: cn.nukkit.level.format.FullChunk): boolean

    }
}

declare module "cn.nukkit.level.generator.populator.helper.EnsureBelow" {
    declare type EnsureBelow = cn.nukkit.level.generator.populator.helper.EnsureBelow;
}

declare namespace cn.nukkit.level.generator.populator.helper {
    declare interface package-info {

    }
}

declare module "cn.nukkit.level.generator.populator.helper.package-info" {
    declare type package-info = cn.nukkit.level.generator.populator.helper.package-info;
}

declare namespace cn.nukkit.level.generator.populator.helper {
    declare interface EnsureAround {
        public static ensureAroundAir(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean

    }
}

declare module "cn.nukkit.level.generator.populator.helper.EnsureAround" {
    declare type EnsureAround = cn.nukkit.level.generator.populator.helper.EnsureAround;
}

declare namespace cn.nukkit.level.generator.populator.helper {
    declare interface EnsureCover {
        public static ensureCover(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean

    }
}

declare module "cn.nukkit.level.generator.populator.helper.EnsureCover" {
    declare type EnsureCover = cn.nukkit.level.generator.populator.helper.EnsureCover;
}

declare namespace cn.nukkit.level.generator.populator.helper {
    declare interface EnsureGrassBelow {
        public static ensureGrassBelow(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean

    }
}

declare module "cn.nukkit.level.generator.populator.helper.EnsureGrassBelow" {
    declare type EnsureGrassBelow = cn.nukkit.level.generator.populator.helper.EnsureGrassBelow;
}

declare namespace cn.nukkit.level.generator.populator.helper {
    declare class PopulatorHelpers extends java.lang.Object implements cn.nukkit.block.BlockID {
        constructor(): void
        public static canGrassStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean
        public static isNonSolid(id: int): boolean
        public static isNonOceanSolid(blockState: cn.nukkit.blockstate.BlockState): boolean
        static nonSolidBlocks: it.unimi.dsi.fastutil.ints.IntSet
        static nonOceanSolidBlocks: java.util.HashSet<cn.nukkit.blockstate.BlockState>

    }
}

declare module "cn.nukkit.level.generator.populator.helper.PopulatorHelpers" {
    declare const PopulatorHelpers = cn.nukkit.level.generator.populator.helper.PopulatorHelpers;
}

declare namespace cn.nukkit.level.generator {
    declare class Nether extends cn.nukkit.level.generator.Generator {
        public constructor(): void
        public constructor(options: java.util.Map<string, java.lang.Object>): void
        public getId(): int
        public getDimension(): int
        public getName(): string
        public getSettings(): java.util.Map<string, java.lang.Object>
        public getChunkManager(): cn.nukkit.level.ChunkManager
        public init(level: cn.nukkit.level.ChunkManager, random: cn.nukkit.math.NukkitRandom): void
        public generateChunk(chunkX: int, chunkZ: int): void
        public populateChunk(chunkX: int, chunkZ: int): void
        public getSpawn(): cn.nukkit.math.Vector3
        public getNoise(x: int, y: int, z: int): float
        public pickBiome(x: int, z: int): cn.nukkit.level.biome.EnumBiome
        public pickBiomeExperimental(x: int, z: int): cn.nukkit.level.biome.EnumBiome
        level: cn.nukkit.level.ChunkManager
        nukkitRandom: cn.nukkit.math.NukkitRandom
        random: java.util.Random
        lavaHeight: double
        bedrockDepth: double
        noiseGen: cn.nukkit.level.generator.noise.nukkit.f.SimplexF[]
        biomeGen: cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S
        populators: java.util.List<cn.nukkit.level.generator.populator.type.Populator>
        generationPopulators: java.util.List<cn.nukkit.level.generator.populator.type.Populator>
        localSeed1: long
        localSeed2: long
        static BIOME_AMPLIFICATION: double

    }
}

declare module "cn.nukkit.level.generator.Nether" {
    declare const Nether = cn.nukkit.level.generator.Nether;
}

declare namespace cn.nukkit.level.generator.task {
    declare class LightPopulationTask extends cn.nukkit.scheduler.AsyncTask {
        public constructor(level: cn.nukkit.level.Level, chunk: cn.nukkit.level.format.generic.BaseFullChunk): void
        public onRun(): void
        public onCompletion(server: cn.nukkit.Server): void
        public levelId: int
        public chunk: cn.nukkit.level.format.generic.BaseFullChunk

    }
}

declare module "cn.nukkit.level.generator.task.LightPopulationTask" {
    declare const LightPopulationTask = cn.nukkit.level.generator.task.LightPopulationTask;
}

declare namespace cn.nukkit.level.generator.task {
    declare class GenerationTask extends cn.nukkit.scheduler.AsyncTask {
        public constructor(level: cn.nukkit.level.Level, chunk: cn.nukkit.level.format.generic.BaseFullChunk): void
        public onRun(): void
        public onCompletion(server: cn.nukkit.Server): void
        level: cn.nukkit.level.Level
        public state: boolean
        chunk: cn.nukkit.level.format.generic.BaseFullChunk

    }
}

declare module "cn.nukkit.level.generator.task.GenerationTask" {
    declare const GenerationTask = cn.nukkit.level.generator.task.GenerationTask;
}

declare namespace cn.nukkit.level.generator.task {
    declare class PopulationTask extends cn.nukkit.scheduler.AsyncTask {
        public constructor(level: cn.nukkit.level.Level, chunk: cn.nukkit.level.format.generic.BaseFullChunk): void
        public onRun(): void
        syncGen(i: int): void
        generationTask(): void
        public onCompletion(server: cn.nukkit.Server): void
        seed: long
        level: cn.nukkit.level.Level
        state: boolean
        centerChunk: cn.nukkit.level.format.generic.BaseFullChunk
        isPopulated: boolean
        public chunks: cn.nukkit.level.format.generic.BaseFullChunk[]

    }
}

declare module "cn.nukkit.level.generator.task.PopulationTask" {
    declare const PopulationTask = cn.nukkit.level.generator.task.PopulationTask;
}

declare namespace cn.nukkit.level.generator.noise.nukkit {
    declare class OpenSimplex2S$Grad4 extends java.lang.Object {
        public constructor(dx: double, var1: double, dy: double, var3: double): void
        dx: double
        dy: double
        dz: double
        dw: double

    }
}

declare module "cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$Grad4" {
    declare const OpenSimplex2S$Grad4 = cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$Grad4;
}

declare namespace cn.nukkit.level.generator.noise.nukkit {
    declare class OpenSimplex2S$Grad2 extends java.lang.Object {
        public constructor(dx: double, var1: double): void
        dx: double
        dy: double

    }
}

declare module "cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$Grad2" {
    declare const OpenSimplex2S$Grad2 = cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$Grad2;
}

declare namespace cn.nukkit.level.generator.noise.nukkit {
    declare class OpenSimplex2S$LatticePoint4D extends java.lang.Object {
        public constructor(xsv: int, ysv: int, zsv: int, wsv: int): void
        xsv: int
        ysv: int
        zsv: int
        wsv: int
        dx: double
        dy: double
        dz: double
        dw: double

    }
}

declare module "cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$LatticePoint4D" {
    declare const OpenSimplex2S$LatticePoint4D = cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$LatticePoint4D;
}

declare namespace cn.nukkit.level.generator.noise.nukkit.f {
    declare class PerlinF extends cn.nukkit.level.generator.noise.nukkit.f.NoiseF {
        public constructor(random: cn.nukkit.math.NukkitRandom, octaves: float, persistence: float): void
        public constructor(random: cn.nukkit.math.NukkitRandom, octaves: float, persistence: float, expansion: float): void
        public getNoise2D(x: float, y: float): float
        public getNoise3D(x: float, y: float, z: float): float

    }
}

declare module "cn.nukkit.level.generator.noise.nukkit.f.PerlinF" {
    declare const PerlinF = cn.nukkit.level.generator.noise.nukkit.f.PerlinF;
}

declare namespace cn.nukkit.level.generator.noise.nukkit.f {
    declare class NoiseF extends java.lang.Object {
        public constructor(): void
        public static floor(x: float): int
        public static fade(x: float): float
        public static lerp(x: float, y: float, z: float): float
        public static linearLerp(x: float, x1: float, x2: float, q0: float, q1: float): float
        public static bilinearLerp(x: float, y: float, q00: float, q01: float, q10: float, q11: float, x1: float, x2: float, y1: float, y2: float): float
        public static trilinearLerp(x: float, y: float, z: float, q000: float, q001: float, q010: float, q011: float, q100: float, q101: float, q110: float, q111: float, x1: float, x2: float, y1: float, y2: float, z1: float, z2: float): float
        public static grad(hash: int, x: float, y: float, z: float): float
        public getNoise2D(var0: float, var1: float): float
        public getNoise3D(var0: float, var1: float, var2: float): float
        public noise2D(x: float, z: float): float
        public noise2D(x: float, z: float, normalized: boolean): float
        public noise3D(x: float, y: float, z: float): float
        public noise3D(x: float, y: float, z: float, normalized: boolean): float
        public setOffset(x: float, y: float, z: float): void
        perm: int[]
        offsetX: float
        offsetY: float
        offsetZ: float
        octaves: float
        persistence: float
        expansion: float

    }
}

declare module "cn.nukkit.level.generator.noise.nukkit.f.NoiseF" {
    declare const NoiseF = cn.nukkit.level.generator.noise.nukkit.f.NoiseF;
}

declare namespace cn.nukkit.level.generator.noise.nukkit.f {
    declare class SimplexF extends cn.nukkit.level.generator.noise.nukkit.f.PerlinF {
        public constructor(random: cn.nukkit.math.NukkitRandom, octaves: float, persistence: float): void
        public constructor(random: cn.nukkit.math.NukkitRandom, octaves: float, persistence: float, expansion: float): void
        static dot2D(g: int[], x: float, y: float): float
        static dot3D(g: int[], x: float, y: float, z: float): float
        static dot4D(g: int[], x: float, y: float, z: float, w: float): float
        public getNoise3D(x: float, y: float, z: float): float
        public getNoise2D(x: float, y: float): float
        static SQRT_3: float
        static SQRT_5: float
        static F2: float
        static G2: float
        static G22: float
        static F3: float
        static G3: float
        static F4: float
        static G4: float
        static G42: float
        static G43: float
        static G44: float
        public static grad3: int[][]
        offsetW: float

    }
}

declare module "cn.nukkit.level.generator.noise.nukkit.f.SimplexF" {
    declare const SimplexF = cn.nukkit.level.generator.noise.nukkit.f.SimplexF;
}

declare namespace cn.nukkit.level.generator.noise.nukkit {
    declare class OpenSimplex2S$Grad3 extends java.lang.Object {
        public constructor(dx: double, var1: double, dy: double): void
        dx: double
        dy: double
        dz: double

    }
}

declare module "cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$Grad3" {
    declare const OpenSimplex2S$Grad3 = cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$Grad3;
}

declare namespace cn.nukkit.level.generator.noise.nukkit.d {
    declare class PerlinD extends cn.nukkit.level.generator.noise.nukkit.d.NoiseD {
        public constructor(random: cn.nukkit.math.NukkitRandom, octaves: double, var2: double): void
        public constructor(random: cn.nukkit.math.NukkitRandom, octaves: double, var2: double, persistence: double): void
        public getNoise2D(x: double, var1: double): double
        public getNoise3D(x: double, var1: double, y: double): double

    }
}

declare module "cn.nukkit.level.generator.noise.nukkit.d.PerlinD" {
    declare const PerlinD = cn.nukkit.level.generator.noise.nukkit.d.PerlinD;
}

declare namespace cn.nukkit.level.generator.noise.nukkit.d {
    declare class NoiseD extends java.lang.Object {
        public constructor(): void
        public static floor(x: double): int
        public static fade(x: double): double
        public static lerp(x: double, var1: double, y: double): double
        public static linearLerp(x: double, var1: double, x1: double, var3: double, x2: double): double
        public static bilinearLerp(x: double, var1: double, y: double, var3: double, q00: double, var5: double, q01: double, var7: double, q10: double, var9: double): double
        public static trilinearLerp(x: double, var1: double, y: double, var3: double, z: double, var5: double, q000: double, var7: double, q001: double, var9: double, q010: double, var11: double, q011: double, var13: double, q100: double, var15: double, q101: double): double
        public static grad(hash: int, x: double, var2: double, y: double): double
        public getNoise2D(var0: double, var1: double): double
        public getNoise3D(var0: double, var1: double, var2: double): double
        public noise2D(x: double, var1: double): double
        public noise2D(x: double, var1: double, z: boolean): double
        public noise3D(x: double, var1: double, y: double): double
        public noise3D(x: double, var1: double, y: double, var3: boolean): double
        public setOffset(x: double, var1: double, y: double): void
        perm: int[]
        offsetX: double
        offsetY: double
        offsetZ: double
        octaves: double
        persistence: double
        expansion: double

    }
}

declare module "cn.nukkit.level.generator.noise.nukkit.d.NoiseD" {
    declare const NoiseD = cn.nukkit.level.generator.noise.nukkit.d.NoiseD;
}

declare namespace cn.nukkit.level.generator.noise.nukkit.d {
    declare class SimplexD extends cn.nukkit.level.generator.noise.nukkit.d.PerlinD {
        public constructor(random: cn.nukkit.math.NukkitRandom, octaves: double, var2: double): void
        public constructor(random: cn.nukkit.math.NukkitRandom, octaves: double, var2: double, persistence: double): void
        static dot2D(g: int[], x: double, var2: double): double
        static dot3D(g: int[], x: double, var2: double, y: double): double
        static dot4D(g: int[], x: double, var2: double, y: double, var4: double): double
        public getNoise3D(x: double, var1: double, y: double): double
        public getNoise2D(x: double, var1: double): double
        static SQRT_3: double
        static SQRT_5: double
        static F2: double
        static G2: double
        static G22: double
        static F3: double
        static G3: double
        static F4: double
        static G4: double
        static G42: double
        static G43: double
        static G44: double
        public static grad3: int[][]
        offsetW: double

    }
}

declare module "cn.nukkit.level.generator.noise.nukkit.d.SimplexD" {
    declare const SimplexD = cn.nukkit.level.generator.noise.nukkit.d.SimplexD;
}

declare namespace cn.nukkit.level.generator.noise.nukkit {
    declare class OpenSimplex2S$LatticePoint2D extends java.lang.Object {
        public constructor(xsv: int, ysv: int): void
        xsv: int
        ysv: int
        dx: double
        dy: double

    }
}

declare module "cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$LatticePoint2D" {
    declare const OpenSimplex2S$LatticePoint2D = cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$LatticePoint2D;
}

declare namespace cn.nukkit.level.generator.noise.nukkit {
    declare class OpenSimplex2S$LatticePoint3D extends java.lang.Object {
        public constructor(xrv: int, yrv: int, zrv: int, lattice: int): void
        public dxr: double
        public dyr: double
        public dzr: double
        public xrv: int
        public yrv: int
        public zrv: int
        nextOnFailure: cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$LatticePoint3D
        nextOnSuccess: cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$LatticePoint3D

    }
}

declare module "cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$LatticePoint3D" {
    declare const OpenSimplex2S$LatticePoint3D = cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$LatticePoint3D;
}

declare namespace cn.nukkit.level.generator.noise.nukkit {
    declare class OpenSimplex2S extends java.lang.Object {
        public constructor(seed: long): void
        public noise2(x: double, var1: double): double
        public noise2_XBeforeY(x: double, var1: double): double
        noise2_Base(xs: double, var1: double): double
        public noise3_Classic(x: double, var1: double, y: double): double
        public noise3_XYBeforeZ(x: double, var1: double, y: double): double
        public noise3_XZBeforeY(x: double, var1: double, y: double): double
        noise3_BCC(xr: double, var1: double, yr: double): double
        public noise4_Classic(x: double, var1: double, y: double, var3: double): double
        public noise4_XYBeforeZW(x: double, var1: double, y: double, var3: double): double
        public noise4_XZBeforeYW(x: double, var1: double, y: double, var3: double): double
        public noise4_XYZBeforeW(x: double, var1: double, y: double, var3: double): double
        noise4_Base(xs: double, var1: double, ys: double, var3: double): double
        static fastFloor(x: double): int
        static PSIZE: int
        static PMASK: int
        perm: short[]
        permGrad2: cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$Grad2[]
        permGrad3: cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$Grad3[]
        permGrad4: cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$Grad4[]
        static LOOKUP_2D: cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$LatticePoint2D[]
        static LOOKUP_3D: cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$LatticePoint3D[]
        static LOOKUP_4D: cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$LatticePoint4D[][]
        static N2: double
        static N3: double
        static N4: double
        static GRADIENTS_2D: cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$Grad2[]
        static GRADIENTS_3D: cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$Grad3[]
        static GRADIENTS_4D: cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S$Grad4[]

    }
}

declare module "cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S" {
    declare const OpenSimplex2S = cn.nukkit.level.generator.noise.nukkit.OpenSimplex2S;
}

declare namespace cn.nukkit.level.generator.noise.vanilla.f {
    declare class NoiseGeneratorOctavesF extends java.lang.Object {
        public constructor(seed: cn.nukkit.math.NukkitRandom, octavesIn: int): void
        public generateNoiseOctaves(noiseArray: float[], xOffset: int, yOffset: int, zOffset: int, xSize: int, ySize: int, zSize: int, xScale: float, yScale: float, zScale: float): float[]
        public generateNoiseOctaves(noiseArray: float[], xOffset: int, zOffset: int, xSize: int, zSize: int, xScale: float, zScale: float, p_76305_10_: float): float[]
        generatorCollection: cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorImprovedF[]
        octaves: int

    }
}

declare module "cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorOctavesF" {
    declare const NoiseGeneratorOctavesF = cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorOctavesF;
}

declare namespace cn.nukkit.level.generator.noise.vanilla.f {
    declare class NoiseGeneratorPerlinF extends java.lang.Object {
        public constructor(p_i45470_1_: cn.nukkit.math.NukkitRandom, p_i45470_2_: int): void
        public getValue(p_151601_1_: float, p_151601_3_: float): float
        public getRegion(p_151599_1_: float[], p_151599_2_: float, p_151599_4_: float, p_151599_6_: int, p_151599_7_: int, p_151599_8_: float, p_151599_10_: float, p_151599_12_: float): float[]
        public getRegion(p_151600_1_: float[], p_151600_2_: float, p_151600_4_: float, p_151600_6_: int, p_151600_7_: int, p_151600_8_: float, p_151600_10_: float, p_151600_12_: float, p_151600_14_: float): float[]
        noiseLevels: cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorSimplexF[]
        levels: int

    }
}

declare module "cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorPerlinF" {
    declare const NoiseGeneratorPerlinF = cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorPerlinF;
}

declare namespace cn.nukkit.level.generator.noise.vanilla.f {
    declare class NoiseGeneratorSimplexF extends java.lang.Object {
        public constructor(): void
        public constructor(p_i45471_1_: cn.nukkit.math.NukkitRandom): void
        static fastFloor(value: float): int
        static dot(p_151604_0_: int[], p_151604_1_: float, p_151604_3_: float): float
        public getValue(p_151605_1_: float, p_151605_3_: float): float
        public add(p_151606_1_: float[], p_151606_2_: float, p_151606_4_: float, p_151606_6_: int, p_151606_7_: int, p_151606_8_: float, p_151606_10_: float, p_151606_12_: float): void
        public static SQRT_3: float
        static grad3: int[][]
        static F2: float
        static G2: float
        p: int[]
        public xo: float
        public yo: float
        public zo: float

    }
}

declare module "cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorSimplexF" {
    declare const NoiseGeneratorSimplexF = cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorSimplexF;
}

declare namespace cn.nukkit.level.generator.noise.vanilla.f {
    declare class NoiseGeneratorImprovedF extends java.lang.Object {
        public constructor(): void
        public constructor(p_i45469_1_: cn.nukkit.math.NukkitRandom): void
        public lerp(p_76311_1_: float, p_76311_3_: float, p_76311_5_: float): float
        public grad2(p_76309_1_: int, p_76309_2_: float, p_76309_4_: float): float
        public grad(p_76310_1_: int, p_76310_2_: float, p_76310_4_: float, p_76310_6_: float): float
        public populateNoiseArray(noiseArray: float[], xOffset: float, yOffset: float, zOffset: float, xSize: int, ySize: int, zSize: int, xScale: float, yScale: float, zScale: float, noiseScale: float): void
        static GRAD_X: float[]
        static GRAD_Y: float[]
        static GRAD_Z: float[]
        static GRAD_2X: float[]
        static GRAD_2Z: float[]
        permutations: int[]
        public xCoord: float
        public yCoord: float
        public zCoord: float

    }
}

declare module "cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorImprovedF" {
    declare const NoiseGeneratorImprovedF = cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorImprovedF;
}

declare namespace cn.nukkit.level.generator.noise.vanilla.d {
    declare class NoiseGeneratorOctavesD extends java.lang.Object {
        public constructor(seed: cn.nukkit.math.NukkitRandom, octavesIn: int): void
        public generateNoiseOctaves(noiseArray: double[], xOffset: int, yOffset: int, zOffset: int, xSize: int, ySize: int, zSize: int, xScale: double, var8: double, yScale: double): double[]
        public generateNoiseOctaves(noiseArray: double[], xOffset: int, zOffset: int, xSize: int, zSize: int, xScale: double, var6: double, zScale: double): double[]
        generatorCollection: cn.nukkit.level.generator.noise.vanilla.d.NoiseGeneratorImprovedD[]
        octaves: int

    }
}

declare module "cn.nukkit.level.generator.noise.vanilla.d.NoiseGeneratorOctavesD" {
    declare const NoiseGeneratorOctavesD = cn.nukkit.level.generator.noise.vanilla.d.NoiseGeneratorOctavesD;
}

declare namespace cn.nukkit.level.generator.noise.vanilla.d {
    declare class NoiseGeneratorSimplexD extends java.lang.Object {
        public constructor(): void
        public constructor(p_i45471_1_: cn.nukkit.math.NukkitRandom): void
        static fastFloor(value: double): int
        static dot(p_151604_0_: int[], p_151604_1_: double, var2: double): double
        public getValue(p_151605_1_: double, var1: double): double
        public add(p_151606_1_: double[], p_151606_2_: double, var2: double, p_151606_4_: int, var4: int, p_151606_6_: double, p_151606_7_: double, p_151606_8_: double): void
        public static SQRT_3: double
        static grad3: int[][]
        static F2: double
        static G2: double
        p: int[]
        public xo: double
        public yo: double
        public zo: double

    }
}

declare module "cn.nukkit.level.generator.noise.vanilla.d.NoiseGeneratorSimplexD" {
    declare const NoiseGeneratorSimplexD = cn.nukkit.level.generator.noise.vanilla.d.NoiseGeneratorSimplexD;
}

declare namespace cn.nukkit.level.generator.noise.vanilla.d {
    declare class NoiseGeneratorImprovedD extends java.lang.Object {
        public constructor(): void
        public constructor(random: cn.nukkit.math.NukkitRandom): void
        public lerp(p_76311_1_: double, var1: double, p_76311_3_: double): double
        public grad2(p_76309_1_: int, p_76309_2_: double, var2: double): double
        public grad(p_76310_1_: int, p_76310_2_: double, var2: double, p_76310_4_: double): double
        public populateNoiseArray(noiseArray: double[], xOffset: double, var2: double, yOffset: double, var4: int, zOffset: int, var6: int, xSize: double, ySize: double, zSize: double, xScale: double): void
        static GRAD_X: double[]
        static GRAD_Y: double[]
        static GRAD_Z: double[]
        static GRAD_2X: double[]
        static GRAD_2Z: double[]
        permutations: int[]
        public xCoord: double
        public yCoord: double
        public zCoord: double

    }
}

declare module "cn.nukkit.level.generator.noise.vanilla.d.NoiseGeneratorImprovedD" {
    declare const NoiseGeneratorImprovedD = cn.nukkit.level.generator.noise.vanilla.d.NoiseGeneratorImprovedD;
}

declare namespace cn.nukkit.level.generator.noise.vanilla.d {
    declare class NoiseGeneratorPerlinD extends java.lang.Object {
        public constructor(p_i45470_1_: cn.nukkit.math.NukkitRandom, p_i45470_2_: int): void
        public getValue(p_151601_1_: double, var1: double): double
        public getRegion(p_151599_1_: double[], p_151599_2_: double, var2: double, p_151599_4_: int, var4: int, p_151599_6_: double, p_151599_7_: double, p_151599_8_: double): double[]
        public getRegion(p_151600_1_: double[], p_151600_2_: double, var2: double, p_151600_4_: int, var4: int, p_151600_6_: double, p_151600_7_: double, p_151600_8_: double, var8: double): double[]
        noiseLevels: cn.nukkit.level.generator.noise.vanilla.d.NoiseGeneratorSimplexD[]
        levels: int

    }
}

declare module "cn.nukkit.level.generator.noise.vanilla.d.NoiseGeneratorPerlinD" {
    declare const NoiseGeneratorPerlinD = cn.nukkit.level.generator.noise.vanilla.d.NoiseGeneratorPerlinD;
}

declare namespace cn.nukkit.level.generator {
    declare class Normal extends cn.nukkit.level.generator.Generator {
        public constructor(): void
        public constructor(options: java.util.Map<string, java.lang.Object>): void
        public getId(): int
        public getChunkManager(): cn.nukkit.level.ChunkManager
        public getName(): string
        public getSettings(): java.util.Map<string, java.lang.Object>
        public pickBiome(x: int, z: int): cn.nukkit.level.biome.Biome
        public init(level: cn.nukkit.level.ChunkManager, random: cn.nukkit.math.NukkitRandom): void
        public generateChunk(chunkX: int, chunkZ: int): void
        public populateChunk(chunkX: int, chunkZ: int): void
        public getSpawn(): cn.nukkit.math.Vector3
        static lambda$new$5(): float[]
        static lambda$new$4(): float[]
        static lambda$new$3(): float[]
        static lambda$new$2(): float[]
        static lambda$new$1(): float[]
        static lambda$new$0(): cn.nukkit.level.biome.Biome[]
        static biomeWeights: float[]
        populators: java.util.List<cn.nukkit.level.generator.populator.type.Populator>
        generationPopulators: java.util.List<cn.nukkit.level.generator.populator.type.Populator>
        public static seaHeight: int
        public scaleNoise: cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorOctavesF
        public depthNoise: cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorOctavesF
        level: cn.nukkit.level.ChunkManager
        random: java.util.Random
        nukkitRandom: cn.nukkit.math.NukkitRandom
        localSeed1: long
        localSeed2: long
        selector: cn.nukkit.level.biome.BiomeSelector
        biomes: java.lang.ThreadLocal<cn.nukkit.level.biome.Biome[]>
        depthRegion: float[]
        mainNoiseRegion: float[]
        minLimitRegion: float[]
        maxLimitRegion: float[]
        heightMap: float[]
        minLimitPerlinNoise: cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorOctavesF
        maxLimitPerlinNoise: cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorOctavesF
        mainPerlinNoise: cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorOctavesF
        surfaceNoise: cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorPerlinF

    }
}

declare module "cn.nukkit.level.generator.Normal" {
    declare const Normal = cn.nukkit.level.generator.Normal;
}

declare namespace cn.nukkit.level.generator {
    declare class PNXChunkGeneratorWrapper$2 extends java.lang.Object implements com.dfsek.terra.api.world.info.WorldProperties {
        constructor(this$0: cn.nukkit.level.generator.PNXChunkGeneratorWrapper): void
        public getSeed(): long
        public getMaxHeight(): int
        public getMinHeight(): int
        public getHandle(): java.lang.Object
        this$0: cn.nukkit.level.generator.PNXChunkGeneratorWrapper

    }
}

declare module "cn.nukkit.level.generator.PNXChunkGeneratorWrapper$2" {
    declare const PNXChunkGeneratorWrapper$2 = cn.nukkit.level.generator.PNXChunkGeneratorWrapper$2;
}

declare namespace cn.nukkit.level.generator {
    declare class SingleChunkManager extends cn.nukkit.level.generator.SimpleChunkManager {
        public constructor(seed: long): void
        public getChunk(chunkX: int, chunkZ: int): cn.nukkit.level.format.generic.BaseFullChunk
        public setChunk(chunkX: int, chunkZ: int, chunk: cn.nukkit.level.format.generic.BaseFullChunk): void
        public cleanChunks(seed: long): void
        CX: int
        CZ: int
        chunk: cn.nukkit.level.format.generic.BaseFullChunk

    }
}

declare module "cn.nukkit.level.generator.SingleChunkManager" {
    declare const SingleChunkManager = cn.nukkit.level.generator.SingleChunkManager;
}

declare namespace cn.nukkit.level.generator {
    declare class SimpleChunkManager extends java.lang.Object implements cn.nukkit.level.ChunkManager {
        public constructor(seed: long): void
        public getBlockIdAt(x: int, y: int, z: int): int
        public getBlockIdAt(x: int, y: int, z: int, layer: int): int
        public getBlockStateAt(x: int, y: int, z: int, layer: int): cn.nukkit.blockstate.BlockState
        public setBlockIdAt(x: int, y: int, z: int, id: int): void
        public setBlockIdAt(x: int, y: int, z: int, layer: int, id: int): void
        public setBlockAt(x: int, y: int, z: int, id: int, data: int): void
        public setBlockAtLayer(x: int, y: int, z: int, layer: int, id: int, data: int): boolean
        public setBlockFullIdAt(x: int, y: int, z: int, fullId: int): void
        public setBlockFullIdAt(x: int, y: int, z: int, layer: int, fullId: int): void
        public setBlockStateAt(x: int, y: int, z: int, layer: int, state: cn.nukkit.blockstate.BlockState): boolean
        public getBlockDataAt(x: int, y: int, z: int): int
        public getBlockDataAt(x: int, y: int, z: int, layer: int): int
        public setBlockDataAt(x: int, y: int, z: int, data: int): void
        public setBlockDataAt(x: int, y: int, z: int, layer: int, data: int): void
        public setChunk(chunkX: int, chunkZ: int): void
        public getSeed(): long
        public setSeed(seed: long): void
        public cleanChunks(seed: long): void
        ensureY(y: int, chunk: cn.nukkit.level.format.FullChunk): int
        seed: long

    }
}

declare module "cn.nukkit.level.generator.SimpleChunkManager" {
    declare const SimpleChunkManager = cn.nukkit.level.generator.SimpleChunkManager;
}

declare namespace cn.nukkit.level.generator {
    declare class Flat extends cn.nukkit.level.generator.Generator {
        public getId(): int
        public getChunkManager(): cn.nukkit.level.ChunkManager
        public getSettings(): java.util.Map<string, java.lang.Object>
        public getName(): string
        public constructor(): void
        public constructor(options: java.util.Map<string, java.lang.Object>): void
        parsePreset(preset: string, chunkX: int, chunkZ: int): void
        public init(level: cn.nukkit.level.ChunkManager, random: cn.nukkit.math.NukkitRandom): void
        public generateChunk(chunkX: int, chunkZ: int): void
        generateChunk(chunk: cn.nukkit.level.format.FullChunk): void
        public populateChunk(chunkX: int, chunkZ: int): void
        public getSpawn(): cn.nukkit.math.Vector3
        static log: org.apache.logging.log4j.Logger
        level: cn.nukkit.level.ChunkManager
        random: cn.nukkit.math.NukkitRandom
        populators: java.util.List<cn.nukkit.level.generator.populator.type.Populator>
        structure: int[][]
        options: java.util.Map<string, java.lang.Object>
        floorLevel: int
        preset: string
        init: boolean
        biome: int

    }
}

declare module "cn.nukkit.level.generator.Flat" {
    declare const Flat = cn.nukkit.level.generator.Flat;
}

declare namespace cn.nukkit.level.generator {
    declare class Generator extends java.lang.Object implements cn.nukkit.block.BlockID {
        public constructor(): void
        public getId(): int
        public getDimensionData(): cn.nukkit.level.DimensionData
        public getDimension(): int
        public static addGenerator(clazz: java.lang.Class<cn.nukkit.level.generator.Generator>, name: string, type: int): boolean
        public static getGeneratorList(): string[]
        public static getGenerator(name: string): java.lang.Class<cn.nukkit.level.generator.Generator>
        public static getGenerator(type: int): java.lang.Class<cn.nukkit.level.generator.Generator>
        public static getGeneratorName(c: java.lang.Class<cn.nukkit.level.generator.Generator>): string
        public static getGeneratorType(c: java.lang.Class<cn.nukkit.level.generator.Generator>): int
        public init(var0: cn.nukkit.level.ChunkManager, var1: cn.nukkit.math.NukkitRandom): void
        public generateChunk(var0: int, var1: int): void
        public populateChunk(var0: int, var1: int): void
        public getSettings(): java.util.Map<string, java.lang.Object>
        public getName(): string
        public getSpawn(): cn.nukkit.math.Vector3
        public getChunkManager(): cn.nukkit.level.ChunkManager
        public static TYPE_OLD: int
        public static TYPE_INFINITE: int
        public static TYPE_FLAT: int
        public static TYPE_NETHER: int
        public static TYPE_THE_END: int
        static nameList: java.util.Map<string, java.lang.Class<cn.nukkit.level.generator.Generator>>
        static typeList: java.util.Map<int, java.lang.Class<cn.nukkit.level.generator.Generator>>

    }
}

declare module "cn.nukkit.level.generator.Generator" {
    declare const Generator = cn.nukkit.level.generator.Generator;
}

declare namespace cn.nukkit.level.generator {
    declare class PNXChunkGeneratorWrapper$1 extends java.lang.Object implements com.dfsek.terra.api.world.info.WorldProperties {
        constructor(this$0: cn.nukkit.level.generator.PNXChunkGeneratorWrapper): void
        public getSeed(): long
        public getMaxHeight(): int
        public getMinHeight(): int
        public getHandle(): java.lang.Object
        this$0: cn.nukkit.level.generator.PNXChunkGeneratorWrapper

    }
}

declare module "cn.nukkit.level.generator.PNXChunkGeneratorWrapper$1" {
    declare const PNXChunkGeneratorWrapper$1 = cn.nukkit.level.generator.PNXChunkGeneratorWrapper$1;
}

declare namespace cn.nukkit.level.generator {
    declare class TheEnd extends cn.nukkit.level.generator.Generator {
        public constructor(): void
        public constructor(options: java.util.Map<string, java.lang.Object>): void
        public getId(): int
        public getDimension(): int
        public getName(): string
        public getSettings(): java.util.Map<string, java.lang.Object>
        public getChunkManager(): cn.nukkit.level.ChunkManager
        public init(level: cn.nukkit.level.ChunkManager, random: cn.nukkit.math.NukkitRandom): void
        public generateChunk(chunkX: int, chunkZ: int): void
        public populateChunk(chunkX: int, chunkZ: int): void
        public getSpawn(): cn.nukkit.math.Vector3
        public getIslandHeight(chunkX: int, chunkZ: int, x: int, z: int): float
        level: cn.nukkit.level.ChunkManager
        nukkitRandom: cn.nukkit.math.NukkitRandom
        random: java.util.Random
        static STATE_END_STONE: cn.nukkit.blockstate.BlockState
        static coordinateScale: double
        static detailNoiseScaleX: double
        static detailNoiseScaleZ: double
        roughnessNoiseOctaves: cn.nukkit.level.generator.noise.vanilla.d.NoiseGeneratorOctavesD
        roughnessNoiseOctaves2: cn.nukkit.level.generator.noise.vanilla.d.NoiseGeneratorOctavesD
        detailNoiseOctaves: cn.nukkit.level.generator.noise.vanilla.d.NoiseGeneratorOctavesD
        islandNoise: cn.nukkit.level.generator.noise.vanilla.d.NoiseGeneratorSimplexD
        detailNoise: double[]
        roughnessNoise: double[]
        roughnessNoise2: double[]
        density: double[][][]
        populators: java.util.List<cn.nukkit.level.generator.populator.type.Populator>
        generationPopulators: java.util.List<cn.nukkit.level.generator.populator.type.Populator>
        localSeed1: long
        localSeed2: long

    }
}

declare module "cn.nukkit.level.generator.TheEnd" {
    declare const TheEnd = cn.nukkit.level.generator.TheEnd;
}

declare namespace cn.nukkit.level.generator {
    declare class PNXChunkGeneratorWrapper extends cn.nukkit.level.generator.Generator implements com.dfsek.terra.api.world.chunk.generation.util.GeneratorWrapper {
        public constructor(): void
        public constructor(option: java.util.Map<string, java.lang.Object>): void
        static createConfigPack(): com.dfsek.terra.api.config.ConfigPack
        static createConfigPack(packName: string): com.dfsek.terra.api.config.ConfigPack
        static createGenerator(): com.dfsek.terra.api.world.chunk.generation.ChunkGenerator
        static createGenerator(config: com.dfsek.terra.api.config.ConfigPack): com.dfsek.terra.api.world.chunk.generation.ChunkGenerator
        static createGenerator(packName: string): com.dfsek.terra.api.world.chunk.generation.ChunkGenerator
        public constructor(delegate: com.dfsek.terra.api.world.chunk.generation.ChunkGenerator, pack: com.dfsek.terra.api.config.ConfigPack, air: com.dfsek.terra.api.block.state.BlockState): void
        public setDelegate(delegate: com.dfsek.terra.api.world.chunk.generation.ChunkGenerator): void
        public setPack(pack: com.dfsek.terra.api.config.ConfigPack): void
        getChunkGeneratorDelegate(): com.dfsek.terra.api.world.chunk.generation.ChunkGenerator
        getBiomeProviderDelegate(): com.dfsek.terra.api.world.biome.generation.BiomeProvider
        public getId(): int
        public init(level: cn.nukkit.level.ChunkManager, random: cn.nukkit.math.NukkitRandom): void
        public generateChunk(chunkX: int, chunkZ: int): void
        public populateChunk(chunkX: int, chunkZ: int): void
        public getSettings(): java.util.Map<string, java.lang.Object>
        public getName(): string
        public getSpawn(): cn.nukkit.math.Vector3
        public getChunkManager(): cn.nukkit.level.ChunkManager
        public getHandle(): com.dfsek.terra.api.world.chunk.generation.ChunkGenerator
        public getHandle(): java.lang.Object
        static lambda$createConfigPack$1(packName: string): com.dfsek.terra.api.config.ConfigPack
        static lambda$createConfigPack$0(): com.dfsek.terra.api.config.ConfigPack
        delegate: java.lang.ref.WeakReference<com.dfsek.terra.api.world.chunk.generation.ChunkGenerator>
        pack: com.dfsek.terra.api.config.ConfigPack
        air: com.dfsek.terra.api.block.state.BlockState
        biomeProvider: java.lang.ref.WeakReference<cn.nukkit.level.terra.delegate.PNXBiomeProviderDelegate>
        chunkManager: cn.nukkit.level.ChunkManager
        nukkitRandom: cn.nukkit.math.NukkitRandom
        worldProperties: com.dfsek.terra.api.world.info.WorldProperties

    }
}

declare module "cn.nukkit.level.generator.PNXChunkGeneratorWrapper" {
    declare const PNXChunkGeneratorWrapper = cn.nukkit.level.generator.PNXChunkGeneratorWrapper;
}

declare namespace cn.nukkit.level {
    declare class Level$2 extends cn.nukkit.utils.IterableThreadLocal {
        constructor(this$0: cn.nukkit.level.Level): void
        public init(): cn.nukkit.level.generator.Generator
        public init(): java.lang.Object
        this$0: cn.nukkit.level.Level

    }
}

declare module "cn.nukkit.level.Level$2" {
    declare const Level$2 = cn.nukkit.level.Level$2;
}

declare namespace cn.nukkit.level {
    declare class Position extends cn.nukkit.positiontracking.NamedPosition {
        public constructor(): void
        public constructor(x: double): void
        public constructor(x: double, var1: double): void
        public constructor(x: double, var1: double, y: double): void
        public constructor(x: double, var1: double, y: double, var3: cn.nukkit.level.Level): void
        public static fromObject(pos: cn.nukkit.math.Vector3): cn.nukkit.level.Position
        public static fromObject(pos: cn.nukkit.math.Vector3, level: cn.nukkit.level.Level): cn.nukkit.level.Position
        public getLevel(): cn.nukkit.level.Level
        public setLevel(level: cn.nukkit.level.Level): cn.nukkit.level.Position
        public isValid(): boolean
        public setStrong(): boolean
        public setWeak(): boolean
        public getSide(face: cn.nukkit.math.BlockFace): cn.nukkit.level.Position
        public getSide(face: cn.nukkit.math.BlockFace, step: int): cn.nukkit.level.Position
        public toString(): string
        public setComponents(x: double, var1: double, y: double): cn.nukkit.level.Position
        public setComponents(pos: cn.nukkit.math.Vector3): cn.nukkit.level.Position
        public getLevelBlockEntity(): cn.nukkit.blockentity.BlockEntity
        public getTypedBlockEntity(type: cn.nukkit.blockentity.BlockEntity): java.lang.Class<any>
        public getLevelBlockState(): cn.nukkit.blockstate.BlockState
        public getLevelBlockState(layer: int): cn.nukkit.blockstate.BlockState
        public getLevelBlock(): cn.nukkit.block.Block
        public getLevelBlockAround(): java.util.Set<cn.nukkit.block.Block>
        public getLevelBlockAtLayer(layer: int): cn.nukkit.block.Block
        public getLocation(): cn.nukkit.level.Location
        public getLevelName(): string
        public getValidLevel(): cn.nukkit.level.Level
        public add(x: double): cn.nukkit.level.Position
        public add(x: double, var1: double): cn.nukkit.level.Position
        public add(x: double, var1: double, y: double): cn.nukkit.level.Position
        public add(x: cn.nukkit.math.Vector3): cn.nukkit.level.Position
        public subtract(): cn.nukkit.level.Position
        public subtract(x: double): cn.nukkit.level.Position
        public subtract(x: double, var1: double): cn.nukkit.level.Position
        public subtract(x: double, var1: double, y: double): cn.nukkit.level.Position
        public subtract(x: cn.nukkit.math.Vector3): cn.nukkit.level.Position
        public multiply(number: double): cn.nukkit.level.Position
        public divide(number: double): cn.nukkit.level.Position
        public ceil(): cn.nukkit.level.Position
        public floor(): cn.nukkit.level.Position
        public round(): cn.nukkit.level.Position
        public abs(): cn.nukkit.level.Position
        public clone(): cn.nukkit.level.Position
        public getChunk(): cn.nukkit.level.format.FullChunk
        public clone(): cn.nukkit.positiontracking.NamedPosition
        public clone(): cn.nukkit.math.Vector3
        public setComponents(var0: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public setComponents(var0: double, var1: double, var2: double): cn.nukkit.math.Vector3
        public getSide(var0: cn.nukkit.math.BlockFace, var1: int): cn.nukkit.math.Vector3
        public getSide(var0: cn.nukkit.math.BlockFace): cn.nukkit.math.Vector3
        public abs(): cn.nukkit.math.Vector3
        public round(): cn.nukkit.math.Vector3
        public floor(): cn.nukkit.math.Vector3
        public ceil(): cn.nukkit.math.Vector3
        public divide(var0: double): cn.nukkit.math.Vector3
        public multiply(var0: double): cn.nukkit.math.Vector3
        public subtract(var0: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public subtract(var0: double, var1: double, var2: double): cn.nukkit.math.Vector3
        public subtract(var0: double, var1: double): cn.nukkit.math.Vector3
        public subtract(var0: double): cn.nukkit.math.Vector3
        public subtract(): cn.nukkit.math.Vector3
        public add(var0: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public add(var0: double, var1: double, var2: double): cn.nukkit.math.Vector3
        public add(var0: double, var1: double): cn.nukkit.math.Vector3
        public add(var0: double): cn.nukkit.math.Vector3
        public clone(): java.lang.Object
        public level: cn.nukkit.level.Level

    }
}

declare module "cn.nukkit.level.Position" {
    declare const Position = cn.nukkit.level.Position;
}

declare namespace cn.nukkit.level {
    declare class GameRules extends java.lang.Object {
        constructor(): void
        public static getDefault(): cn.nukkit.level.GameRules
        public getGameRules(): java.util.Map<cn.nukkit.level.GameRule, cn.nukkit.level.GameRules$Value>
        public isStale(): boolean
        public refresh(): void
        public setGameRule(gameRule: cn.nukkit.level.GameRule, value: boolean): void
        public setGameRule(gameRule: cn.nukkit.level.GameRule, value: int): void
        public setGameRule(gameRule: cn.nukkit.level.GameRule, value: float): void
        public setGameRules(gameRule: cn.nukkit.level.GameRule, value: string): void
        public getBoolean(gameRule: cn.nukkit.level.GameRule): boolean
        public getInteger(gameRule: cn.nukkit.level.GameRule): int
        public getFloat(gameRule: cn.nukkit.level.GameRule): float
        public getString(gameRule: cn.nukkit.level.GameRule): string
        public getGameRuleType(gameRule: cn.nukkit.level.GameRule): cn.nukkit.level.GameRules$Type
        public hasRule(gameRule: cn.nukkit.level.GameRule): boolean
        public getRules(): cn.nukkit.level.GameRule[]
        public writeNBT(): cn.nukkit.nbt.tag.CompoundTag
        public readNBT(nbt: cn.nukkit.nbt.tag.CompoundTag): void
        gameRules: java.util.EnumMap<cn.nukkit.level.GameRule, cn.nukkit.level.GameRules$Value>
        stale: boolean

    }
}

declare module "cn.nukkit.level.GameRules" {
    declare const GameRules = cn.nukkit.level.GameRules;
}

declare namespace cn.nukkit.level.terra.delegate {
    declare class PNXItemStack extends java.lang.Record implements com.dfsek.terra.api.inventory.ItemStack, com.dfsek.terra.api.inventory.item.Damageable {
        public constructor(innerItem: cn.nukkit.item.Item): void
        public getAmount(): int
        public setAmount(i: int): void
        public getType(): com.dfsek.terra.api.inventory.Item
        public getItemMeta(): com.dfsek.terra.api.inventory.item.ItemMeta
        public setItemMeta(itemMeta: com.dfsek.terra.api.inventory.item.ItemMeta): void
        public getHandle(): cn.nukkit.item.Item
        public isDamageable(): boolean
        public getDamage(): int
        public setDamage(i: int): void
        public hasDamage(): boolean
        public toString(): string
        public hashCode(): int
        public equals(o: java.lang.Object): boolean
        public innerItem(): cn.nukkit.item.Item
        public getHandle(): java.lang.Object
        innerItem: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.level.terra.delegate.PNXItemStack" {
    declare const PNXItemStack = cn.nukkit.level.terra.delegate.PNXItemStack;
}

declare namespace cn.nukkit.level.terra.delegate {
    declare class PNXBiomeProviderDelegate extends java.lang.Object implements com.dfsek.terra.api.world.biome.generation.BiomeProvider {
        public constructor(delegate: com.dfsek.terra.api.world.biome.generation.BiomeProvider): void
        public getBiome(x: int, y: int, z: int, seed: long): com.dfsek.terra.api.world.biome.Biome
        public getBiomes(): java.lang.Iterable<com.dfsek.terra.api.world.biome.Biome>
        delegate: com.dfsek.terra.api.world.biome.generation.BiomeProvider
        cacheMap: java.util.WeakHashMap<long, com.dfsek.terra.api.world.biome.Biome>

    }
}

declare module "cn.nukkit.level.terra.delegate.PNXBiomeProviderDelegate" {
    declare const PNXBiomeProviderDelegate = cn.nukkit.level.terra.delegate.PNXBiomeProviderDelegate;
}

declare namespace cn.nukkit.level.terra.delegate {
    declare class PNXBlockStateDelegate extends java.lang.Record implements com.dfsek.terra.api.block.state.BlockState {
        public constructor(innerBlockState: cn.nukkit.blockstate.BlockState): void
        public matches(blockState: com.dfsek.terra.api.block.state.BlockState): boolean
        public has(property: java.lang.Comparable<any>, var1: com.dfsek.terra.api.block.state.properties.Property<any>): boolean
        public get(property: java.lang.Comparable<any>): com.dfsek.terra.api.block.state.properties.Property<any>
        public set(property: java.lang.Comparable<any>, t: com.dfsek.terra.api.block.state.properties.Property<any>): com.dfsek.terra.api.block.state.BlockState
        public getBlockType(): com.dfsek.terra.api.block.BlockType
        public getAsString(b: boolean): string
        public isAir(): boolean
        public getHandle(): cn.nukkit.blockstate.BlockState
        public toString(): string
        public hashCode(): int
        public equals(o: java.lang.Object): boolean
        public innerBlockState(): cn.nukkit.blockstate.BlockState
        public getHandle(): java.lang.Object
        innerBlockState: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.level.terra.delegate.PNXBlockStateDelegate" {
    declare const PNXBlockStateDelegate = cn.nukkit.level.terra.delegate.PNXBlockStateDelegate;
}

declare namespace cn.nukkit.level.terra.delegate {
    declare class PNXBiomeDelegate extends java.lang.Record implements com.dfsek.terra.api.world.biome.PlatformBiome {
        public constructor(innerBiome: cn.nukkit.level.biome.Biome): void
        public getHandle(): cn.nukkit.level.biome.Biome
        public toString(): string
        public hashCode(): int
        public equals(o: java.lang.Object): boolean
        public innerBiome(): cn.nukkit.level.biome.Biome
        public getHandle(): java.lang.Object
        innerBiome: cn.nukkit.level.biome.Biome

    }
}

declare module "cn.nukkit.level.terra.delegate.PNXBiomeDelegate" {
    declare const PNXBiomeDelegate = cn.nukkit.level.terra.delegate.PNXBiomeDelegate;
}

declare namespace cn.nukkit.level.terra.delegate {
    declare class PNXServerWorld extends java.lang.Record implements com.dfsek.terra.api.world.ServerWorld {
        public constructor(chunkManager: cn.nukkit.level.ChunkManager, chunkGenerator: com.dfsek.terra.api.world.chunk.generation.ChunkGenerator, configPack: com.dfsek.terra.api.config.ConfigPack, biomeProvider: com.dfsek.terra.api.world.biome.generation.BiomeProvider): void
        public setBlockState(i: int, i1: int, i2: int, blockState: com.dfsek.terra.api.block.state.BlockState, b: boolean): void
        public spawnEntity(v: double, var1: double, v1: double, var3: com.dfsek.terra.api.entity.EntityType): com.dfsek.terra.api.entity.Entity
        public getBlockState(i: int, i1: int, i2: int): com.dfsek.terra.api.block.state.BlockState
        public getBlockEntity(i: int, i1: int, i2: int): com.dfsek.terra.api.block.entity.BlockEntity
        public getGenerator(): com.dfsek.terra.api.world.chunk.generation.ChunkGenerator
        public getBiomeProvider(): com.dfsek.terra.api.world.biome.generation.BiomeProvider
        public getPack(): com.dfsek.terra.api.config.ConfigPack
        public getSeed(): long
        public getMaxHeight(): int
        public getMinHeight(): int
        public getHandle(): cn.nukkit.level.ChunkManager
        public getChunkAt(i: int, i1: int): com.dfsek.terra.api.world.chunk.Chunk
        public toString(): string
        public hashCode(): int
        public equals(o: java.lang.Object): boolean
        public chunkManager(): cn.nukkit.level.ChunkManager
        public chunkGenerator(): com.dfsek.terra.api.world.chunk.generation.ChunkGenerator
        public configPack(): com.dfsek.terra.api.config.ConfigPack
        public biomeProvider(): com.dfsek.terra.api.world.biome.generation.BiomeProvider
        public getHandle(): java.lang.Object
        chunkManager: cn.nukkit.level.ChunkManager
        chunkGenerator: com.dfsek.terra.api.world.chunk.generation.ChunkGenerator
        configPack: com.dfsek.terra.api.config.ConfigPack
        biomeProvider: com.dfsek.terra.api.world.biome.generation.BiomeProvider

    }
}

declare module "cn.nukkit.level.terra.delegate.PNXServerWorld" {
    declare const PNXServerWorld = cn.nukkit.level.terra.delegate.PNXServerWorld;
}

declare namespace cn.nukkit.level.terra {
    declare class PNXAdapter extends java.lang.Object {
        public constructor(): void
        public static adapt(pnxItem: cn.nukkit.item.Item): cn.nukkit.level.terra.delegate.PNXItemDelegate
        public static adapt(biome: cn.nukkit.level.biome.Biome): cn.nukkit.level.terra.delegate.PNXBiomeDelegate
        public static adapt(blockState: cn.nukkit.blockstate.BlockState): cn.nukkit.level.terra.delegate.PNXBlockStateDelegate
        static stateDelegateStore: java.util.Map<cn.nukkit.blockstate.BlockState, cn.nukkit.level.terra.delegate.PNXBlockStateDelegate>

    }
}

declare module "cn.nukkit.level.terra.PNXAdapter" {
    declare const PNXAdapter = cn.nukkit.level.terra.PNXAdapter;
}

declare namespace cn.nukkit.level.terra.handles {
    declare class PNXItemHandle extends java.lang.Object implements com.dfsek.terra.api.handle.ItemHandle {
        public constructor(): void
        public createItem(s: string): com.dfsek.terra.api.inventory.Item
        public getEnchantment(s: string): com.dfsek.terra.api.inventory.item.Enchantment
        public getEnchantments(): java.util.Set<com.dfsek.terra.api.inventory.item.Enchantment>

    }
}

declare module "cn.nukkit.level.terra.handles.PNXItemHandle" {
    declare const PNXItemHandle = cn.nukkit.level.terra.handles.PNXItemHandle;
}

declare namespace cn.nukkit.level.terra {
    declare class PNXPlatform extends com.dfsek.terra.AbstractPlatform {
        public constructor(): void
        public static getInstance(): cn.nukkit.level.terra.PNXPlatform
        public reload(): boolean
        public platformName(): string
        public runPossiblyUnsafeTask(task: java.lang.Runnable): void
        public getWorldHandle(): com.dfsek.terra.api.handle.WorldHandle
        public getDataFolder(): java.io.File
        public getItemHandle(): com.dfsek.terra.api.handle.ItemHandle
        public getVersion(): string
        public register(registry: com.dfsek.tectonic.api.TypeRegistry): void
        static parseBiome(str: string): cn.nukkit.level.terra.delegate.PNXBiomeDelegate
        static lambda$register$1(type: java.lang.reflect.AnnotatedType, o: java.lang.Object, loader: com.dfsek.tectonic.api.loader.ConfigLoader, depthTracker: com.dfsek.tectonic.api.depth.DepthTracker): java.lang.Object
        static lambda$register$0(type: java.lang.reflect.AnnotatedType, o: java.lang.Object, loader: com.dfsek.tectonic.api.loader.ConfigLoader, depthTracker: com.dfsek.tectonic.api.depth.DepthTracker): java.lang.Object
        static log: org.apache.logging.log4j.Logger
        public static DATA_PATH: java.io.File
        static INSTANCE: cn.nukkit.level.terra.PNXPlatform
        static pnxWorldHandle: cn.nukkit.level.terra.handles.PNXWorldHandle
        static pnxItemHandle: cn.nukkit.level.terra.handles.PNXItemHandle

    }
}

declare module "cn.nukkit.level.terra.PNXPlatform" {
    declare const PNXPlatform = cn.nukkit.level.terra.PNXPlatform;
}

declare namespace cn.nukkit.network {
    declare interface AdvancedSourceInterface extends cn.nukkit.network.SourceInterface {
        public blockAddress(var0: java.net.InetAddress): void
        public blockAddress(var0: java.net.InetAddress, var1: int): void
        public unblockAddress(var0: java.net.InetAddress): void
        public setNetwork(var0: cn.nukkit.network.Network): void
        public sendRawPacket(var0: java.net.InetSocketAddress, var1: io.netty.buffer.ByteBuf): void

    }
}

declare module "cn.nukkit.network.AdvancedSourceInterface" {
    declare type AdvancedSourceInterface = cn.nukkit.network.AdvancedSourceInterface;
}

declare namespace cn.nukkit.network {
    declare class LittleEndianByteBufInputStream extends io.netty.buffer.ByteBufInputStream {
        public constructor(buffer: io.netty.buffer.ByteBuf): void
        public readChar(): char
        public readDouble(): double
        public readFloat(): float
        public readShort(): short
        public readUnsignedShort(): int
        public readLong(): long
        public readInt(): int
        buffer: io.netty.buffer.ByteBuf

    }
}

declare module "cn.nukkit.network.LittleEndianByteBufInputStream" {
    declare const LittleEndianByteBufInputStream = cn.nukkit.network.LittleEndianByteBufInputStream;
}

declare namespace cn.nukkit.network.query {
    declare class QueryHandler extends java.lang.Object {
        public constructor(): void
        public regenerateInfo(): void
        public regenerateToken(): void
        public static getTokenString(token: string, address: java.net.InetAddress): byte[]
        public static getTokenString(token: byte[], address: java.net.InetAddress): byte[]
        public handle(address: java.net.InetSocketAddress, packet: io.netty.buffer.ByteBuf): void
        static log: org.apache.logging.log4j.Logger
        public static HANDSHAKE: byte
        public static STATISTICS: byte
        server: cn.nukkit.Server
        lastToken: byte[]
        token: byte[]
        longData: byte[]
        shortData: byte[]
        timeout: long

    }
}

declare module "cn.nukkit.network.query.QueryHandler" {
    declare const QueryHandler = cn.nukkit.network.query.QueryHandler;
}

declare namespace cn.nukkit.network.rcon {
    declare class RCON extends java.lang.Object {
        public constructor(server: cn.nukkit.Server, password: string, address: string, port: int): void
        public check(): void
        public close(): void
        static log: org.apache.logging.log4j.Logger
        server: cn.nukkit.Server
        serverThread: cn.nukkit.network.rcon.RCONServer

    }
}

declare module "cn.nukkit.network.rcon.RCON" {
    declare const RCON = cn.nukkit.network.rcon.RCON;
}

declare namespace cn.nukkit.network.rcon {
    declare class RCONCommand extends java.lang.Object {
        public constructor(sender: java.nio.channels.SocketChannel, id: int, command: string): void
        public getSender(): java.nio.channels.SocketChannel
        public getId(): int
        public getCommand(): string
        sender: java.nio.channels.SocketChannel
        id: int
        command: string

    }
}

declare module "cn.nukkit.network.rcon.RCONCommand" {
    declare const RCONCommand = cn.nukkit.network.rcon.RCONCommand;
}

declare namespace cn.nukkit.network.rcon {
    declare class RCONPacket extends java.lang.Object {
        public constructor(id: int, type: int, payload: byte[]): void
        public constructor(buffer: java.nio.ByteBuffer): void
        public toBuffer(): java.nio.ByteBuffer
        public getId(): int
        public getType(): int
        public getPayload(): byte[]
        id: int
        type: int
        payload: byte[]

    }
}

declare module "cn.nukkit.network.rcon.RCONPacket" {
    declare const RCONPacket = cn.nukkit.network.rcon.RCONPacket;
}

declare namespace cn.nukkit.network {
    declare class Network extends java.lang.Object {
        public constructor(server: cn.nukkit.Server): void
        public static inflateRaw(data: byte[]): byte[]
        public static deflateRaw(data: byte[], level: int): byte[]
        public static deflateRaw(datas: byte[][], level: int): byte[]
        public addStatistics(upload: double, var1: double): void
        public getUpload(): double
        public getDownload(): double
        public resetStatistics(): void
        public getInterfaces(): java.util.Set<cn.nukkit.network.SourceInterface>
        public processInterfaces(): void
        public registerInterface(interfaz: cn.nukkit.network.SourceInterface): void
        public unregisterInterface(sourceInterface: cn.nukkit.network.SourceInterface): void
        public setName(name: string): void
        public getName(): string
        public getSubName(): string
        public setSubName(subName: string): void
        public updateName(): void
        public registerPacket(id: byte, clazz: java.lang.Class<cn.nukkit.network.protocol.DataPacket>): void
        public getServer(): cn.nukkit.Server
        public processBatch(packet: cn.nukkit.network.protocol.BatchPacket, player: cn.nukkit.Player): void
        public unpackBatchedPackets(packet: cn.nukkit.network.protocol.BatchPacket): java.util.List<cn.nukkit.network.protocol.DataPacket>
        public processBatch(payload: byte[], packets: java.util.Collection<cn.nukkit.network.protocol.DataPacket>): void
        public processPackets(player: cn.nukkit.Player, packets: java.util.List<cn.nukkit.network.protocol.DataPacket>): void
        public getPacket(id: byte): cn.nukkit.network.protocol.DataPacket
        public getPacket(id: int): cn.nukkit.network.protocol.DataPacket
        public sendPacket(socketAddress: java.net.InetSocketAddress, payload: io.netty.buffer.ByteBuf): void
        public blockAddress(address: java.net.InetAddress): void
        public blockAddress(address: java.net.InetAddress, timeout: int): void
        public unblockAddress(address: java.net.InetAddress): void
        registerPackets(): void
        static lambda$processPackets$3(player: cn.nukkit.Player, p: cn.nukkit.network.protocol.DataPacket): void
        static lambda$static$2(): byte[]
        static lambda$static$1(): java.util.zip.Deflater
        static lambda$static$0(): java.util.zip.Inflater
        static log: org.apache.logging.log4j.Logger
        static INFLATER_RAW: java.lang.ThreadLocal<java.util.zip.Inflater>
        static DEFLATER_RAW: java.lang.ThreadLocal<java.util.zip.Deflater>
        static BUFFER: byte[]
        public static CHANNEL_NONE: byte
        public static CHANNEL_PRIORITY: byte
        public static CHANNEL_WORLD_CHUNKS: byte
        public static CHANNEL_MOVEMENT: byte
        public static CHANNEL_BLOCKS: byte
        public static CHANNEL_WORLD_EVENTS: byte
        public static CHANNEL_ENTITY_SPAWNING: byte
        public static CHANNEL_TEXT: byte
        public static CHANNEL_END: byte
        packetPool: java.lang.Class<cn.nukkit.network.protocol.DataPacket>[]
        server: cn.nukkit.Server
        interfaces: java.util.Set<cn.nukkit.network.SourceInterface>
        advancedInterfaces: java.util.Set<cn.nukkit.network.AdvancedSourceInterface>
        upload: double
        download: double
        name: string
        subName: string

    }
}

declare module "cn.nukkit.network.Network" {
    declare const Network = cn.nukkit.network.Network;
}

declare namespace cn.nukkit.network {
    declare class CompressBatchedPacket extends cn.nukkit.scheduler.AsyncTask {
        public constructor(data: byte[], targets: java.util.List<java.net.InetSocketAddress>): void
        public constructor(data: byte[], targets: java.util.List<java.net.InetSocketAddress>, level: int): void
        public constructor(data: byte[], targets: java.util.List<java.net.InetSocketAddress>, level: int, channel: int): void
        public onRun(): void
        public onCompletion(server: cn.nukkit.Server): void
        public level: int
        public data: byte[]
        public finalData: byte[]
        public channel: int
        public targets: java.util.List<java.net.InetSocketAddress>

    }
}

declare module "cn.nukkit.network.CompressBatchedPacket" {
    declare const CompressBatchedPacket = cn.nukkit.network.CompressBatchedPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PlayerArmorDamagePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public flags: java.util.Set<cn.nukkit.network.protocol.PlayerArmorDamagePacket$PlayerArmorDamageFlag>
        public damage: int[]

    }
}

declare module "cn.nukkit.network.protocol.PlayerArmorDamagePacket" {
    declare const PlayerArmorDamagePacket = cn.nukkit.network.protocol.PlayerArmorDamagePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class AnimatePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public eid: long
        public action: cn.nukkit.network.protocol.AnimatePacket$Action
        public rowingTime: float

    }
}

declare module "cn.nukkit.network.protocol.AnimatePacket" {
    declare const AnimatePacket = cn.nukkit.network.protocol.AnimatePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class TransferPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public address: string
        public port: int

    }
}

declare module "cn.nukkit.network.protocol.TransferPacket" {
    declare const TransferPacket = cn.nukkit.network.protocol.TransferPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class LevelEventGenericPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public static NETWORK_ID: byte
        public eventId: int
        public tag: cn.nukkit.nbt.tag.CompoundTag

    }
}

declare module "cn.nukkit.network.protocol.LevelEventGenericPacket" {
    declare const LevelEventGenericPacket = cn.nukkit.network.protocol.LevelEventGenericPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class AbstractResourcePackDataPacket extends cn.nukkit.network.protocol.DataPacket {
        public getPackVersion(): org.powernukkit.version.Version
        public setPackVersion(var0: org.powernukkit.version.Version): void
        public getPackId(): java.util.UUID
        public setPackId(var0: java.util.UUID): void
        decodePackInfo(): void
        encodePackInfo(): void
        public constructor(): void

    }
}

declare module "cn.nukkit.network.protocol.AbstractResourcePackDataPacket" {
    declare const AbstractResourcePackDataPacket = cn.nukkit.network.protocol.AbstractResourcePackDataPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PlayerSkinPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public uuid: java.util.UUID
        public skin: cn.nukkit.entity.data.Skin
        public newSkinName: string
        public oldSkinName: string

    }
}

declare module "cn.nukkit.network.protocol.PlayerSkinPacket" {
    declare const PlayerSkinPacket = cn.nukkit.network.protocol.PlayerSkinPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class AnimatePacket$Action extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.AnimatePacket$Action[]
        public static valueOf(name: string): cn.nukkit.network.protocol.AnimatePacket$Action
        constructor(var0: int): void
        public getId(): int
        public static fromId(id: int): cn.nukkit.network.protocol.AnimatePacket$Action
        static $values(): cn.nukkit.network.protocol.AnimatePacket$Action[]
        public static NO_ACTION: cn.nukkit.network.protocol.AnimatePacket$Action
        public static SWING_ARM: cn.nukkit.network.protocol.AnimatePacket$Action
        public static WAKE_UP: cn.nukkit.network.protocol.AnimatePacket$Action
        public static CRITICAL_HIT: cn.nukkit.network.protocol.AnimatePacket$Action
        public static MAGIC_CRITICAL_HIT: cn.nukkit.network.protocol.AnimatePacket$Action
        public static ROW_RIGHT: cn.nukkit.network.protocol.AnimatePacket$Action
        public static ROW_LEFT: cn.nukkit.network.protocol.AnimatePacket$Action
        static ID_LOOKUP: it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.network.protocol.AnimatePacket$Action>
        id: int
        static $VALUES: cn.nukkit.network.protocol.AnimatePacket$Action[]

    }
}

declare module "cn.nukkit.network.protocol.AnimatePacket$Action" {
    declare const AnimatePacket$Action = cn.nukkit.network.protocol.AnimatePacket$Action;
}

declare namespace cn.nukkit.network.protocol {
    declare class CreativeContentPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public entries: cn.nukkit.item.Item[]

    }
}

declare module "cn.nukkit.network.protocol.CreativeContentPacket" {
    declare const CreativeContentPacket = cn.nukkit.network.protocol.CreativeContentPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ServerToClientHandshakePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public publicKey: string
        public serverToken: string
        public privateKey: string

    }
}

declare module "cn.nukkit.network.protocol.ServerToClientHandshakePacket" {
    declare const ServerToClientHandshakePacket = cn.nukkit.network.protocol.ServerToClientHandshakePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class RespawnPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public static STATE_SEARCHING_FOR_SPAWN: int
        public static STATE_READY_TO_SPAWN: int
        public static STATE_CLIENT_READY_TO_SPAWN: int
        public x: float
        public y: float
        public z: float
        public respawnState: int
        public runtimeEntityId: long

    }
}

declare module "cn.nukkit.network.protocol.RespawnPacket" {
    declare const RespawnPacket = cn.nukkit.network.protocol.RespawnPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class NetworkStackLatencyPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public timestamp: long
        public unknownBool: boolean

    }
}

declare module "cn.nukkit.network.protocol.NetworkStackLatencyPacket" {
    declare const NetworkStackLatencyPacket = cn.nukkit.network.protocol.NetworkStackLatencyPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class TickingAreasLoadStatusPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        waitingForPreload: boolean

    }
}

declare module "cn.nukkit.network.protocol.TickingAreasLoadStatusPacket" {
    declare const TickingAreasLoadStatusPacket = cn.nukkit.network.protocol.TickingAreasLoadStatusPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ResourcePackChunkRequestPacket extends cn.nukkit.network.protocol.AbstractResourcePackDataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public getPackVersion(): org.powernukkit.version.Version
        public setPackVersion(packVersion: org.powernukkit.version.Version): void
        public getPackId(): java.util.UUID
        public setPackId(packId: java.util.UUID): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public packId: java.util.UUID
        packVersion: org.powernukkit.version.Version
        public chunkIndex: int

    }
}

declare module "cn.nukkit.network.protocol.ResourcePackChunkRequestPacket" {
    declare const ResourcePackChunkRequestPacket = cn.nukkit.network.protocol.ResourcePackChunkRequestPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class LevelSoundEventPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public static SOUND_ITEM_USE_ON: int
        public static SOUND_HIT: int
        public static SOUND_STEP: int
        public static SOUND_FLY: int
        public static SOUND_JUMP: int
        public static SOUND_BREAK: int
        public static SOUND_PLACE: int
        public static SOUND_HEAVY_STEP: int
        public static SOUND_GALLOP: int
        public static SOUND_FALL: int
        public static SOUND_AMBIENT: int
        public static SOUND_AMBIENT_BABY: int
        public static SOUND_AMBIENT_IN_WATER: int
        public static SOUND_BREATHE: int
        public static SOUND_DEATH: int
        public static SOUND_DEATH_IN_WATER: int
        public static SOUND_DEATH_TO_ZOMBIE: int
        public static SOUND_HURT: int
        public static SOUND_HURT_IN_WATER: int
        public static SOUND_MAD: int
        public static SOUND_BOOST: int
        public static SOUND_BOW: int
        public static SOUND_SQUISH_BIG: int
        public static SOUND_SQUISH_SMALL: int
        public static SOUND_FALL_BIG: int
        public static SOUND_FALL_SMALL: int
        public static SOUND_SPLASH: int
        public static SOUND_FIZZ: int
        public static SOUND_FLAP: int
        public static SOUND_SWIM: int
        public static SOUND_DRINK: int
        public static SOUND_EAT: int
        public static SOUND_TAKEOFF: int
        public static SOUND_SHAKE: int
        public static SOUND_PLOP: int
        public static SOUND_LAND: int
        public static SOUND_SADDLE: int
        public static SOUND_ARMOR: int
        public static SOUND_MOB_ARMOR_STAND_PLACE: int
        public static SOUND_ADD_CHEST: int
        public static SOUND_THROW: int
        public static SOUND_ATTACK: int
        public static SOUND_ATTACK_NODAMAGE: int
        public static SOUND_ATTACK_STRONG: int
        public static SOUND_WARN: int
        public static SOUND_SHEAR: int
        public static SOUND_MILK: int
        public static SOUND_THUNDER: int
        public static SOUND_EXPLODE: int
        public static SOUND_FIRE: int
        public static SOUND_IGNITE: int
        public static SOUND_FUSE: int
        public static SOUND_STARE: int
        public static SOUND_SPAWN: int
        public static SOUND_SHOOT: int
        public static SOUND_BREAK_BLOCK: int
        public static SOUND_LAUNCH: int
        public static SOUND_BLAST: int
        public static SOUND_LARGE_BLAST: int
        public static SOUND_TWINKLE: int
        public static SOUND_REMEDY: int
        public static SOUND_UNFECT: int
        public static SOUND_LEVELUP: int
        public static SOUND_BOW_HIT: int
        public static SOUND_BULLET_HIT: int
        public static SOUND_EXTINGUISH_FIRE: int
        public static SOUND_ITEM_FIZZ: int
        public static SOUND_CHEST_OPEN: int
        public static SOUND_CHEST_CLOSED: int
        public static SOUND_SHULKERBOX_OPEN: int
        public static SOUND_SHULKERBOX_CLOSED: int
        public static SOUND_ENDERCHEST_OPEN: int
        public static SOUND_ENDERCHEST_CLOSED: int
        public static SOUND_POWER_ON: int
        public static SOUND_POWER_OFF: int
        public static SOUND_ATTACH: int
        public static SOUND_DETACH: int
        public static SOUND_DENY: int
        public static SOUND_TRIPOD: int
        public static SOUND_POP: int
        public static SOUND_DROP_SLOT: int
        public static SOUND_NOTE: int
        public static SOUND_THORNS: int
        public static SOUND_PISTON_IN: int
        public static SOUND_PISTON_OUT: int
        public static SOUND_PORTAL: int
        public static SOUND_WATER: int
        public static SOUND_LAVA_POP: int
        public static SOUND_LAVA: int
        public static SOUND_BURP: int
        public static SOUND_BUCKET_FILL_WATER: int
        public static SOUND_BUCKET_FILL_LAVA: int
        public static SOUND_BUCKET_EMPTY_WATER: int
        public static SOUND_BUCKET_EMPTY_LAVA: int
        public static SOUND_ARMOR_EQUIP_CHAIN: int
        public static SOUND_ARMOR_EQUIP_DIAMOND: int
        public static SOUND_ARMOR_EQUIP_GENERIC: int
        public static SOUND_ARMOR_EQUIP_GOLD: int
        public static SOUND_ARMOR_EQUIP_IRON: int
        public static SOUND_ARMOR_EQUIP_LEATHER: int
        public static SOUND_ARMOR_EQUIP_ELYTRA: int
        public static SOUND_RECORD_13: int
        public static SOUND_RECORD_CAT: int
        public static SOUND_RECORD_BLOCKS: int
        public static SOUND_RECORD_CHIRP: int
        public static SOUND_RECORD_FAR: int
        public static SOUND_RECORD_MALL: int
        public static SOUND_RECORD_MELLOHI: int
        public static SOUND_RECORD_STAL: int
        public static SOUND_RECORD_STRAD: int
        public static SOUND_RECORD_WARD: int
        public static SOUND_RECORD_11: int
        public static SOUND_RECORD_WAIT: int
        public static SOUND_STOP_RECORD: int
        public static SOUND_GUARDIAN_FLOP: int
        public static SOUND_ELDERGUARDIAN_CURSE: int
        public static SOUND_MOB_WARNING: int
        public static SOUND_MOB_WARNING_BABY: int
        public static SOUND_TELEPORT: int
        public static SOUND_SHULKER_OPEN: int
        public static SOUND_SHULKER_CLOSE: int
        public static SOUND_HAGGLE: int
        public static SOUND_HAGGLE_YES: int
        public static SOUND_HAGGLE_NO: int
        public static SOUND_HAGGLE_IDLE: int
        public static SOUND_CHORUSGROW: int
        public static SOUND_CHORUSDEATH: int
        public static SOUND_GLASS: int
        public static SOUND_POTION_BREWED: int
        public static SOUND_CAST_SPELL: int
        public static SOUND_PREPARE_ATTACK: int
        public static SOUND_PREPARE_SUMMON: int
        public static SOUND_PREPARE_WOLOLO: int
        public static SOUND_FANG: int
        public static SOUND_CHARGE: int
        public static SOUND_CAMERA_TAKE_PICTURE: int
        public static SOUND_LEASHKNOT_PLACE: int
        public static SOUND_LEASHKNOT_BREAK: int
        public static SOUND_GROWL: int
        public static SOUND_WHINE: int
        public static SOUND_PANT: int
        public static SOUND_PURR: int
        public static SOUND_PURREOW: int
        public static SOUND_DEATH_MIN_VOLUME: int
        public static SOUND_DEATH_MID_VOLUME: int
        public static SOUND_IMITATE_BLAZE: int
        public static SOUND_IMITATE_CAVE_SPIDER: int
        public static SOUND_IMITATE_CREEPER: int
        public static SOUND_IMITATE_ELDER_GUARDIAN: int
        public static SOUND_IMITATE_ENDER_DRAGON: int
        public static SOUND_IMITATE_ENDERMAN: int
        public static SOUND_IMITATE_ENDERMITE: int
        public static SOUND_IMITATE_EVOCATION_ILLAGER: int
        public static SOUND_IMITATE_GHAST: int
        public static SOUND_IMITATE_HUSK: int
        public static SOUND_IMITATE_ILLUSION_ILLAGER: int
        public static SOUND_IMITATE_MAGMA_CUBE: int
        public static SOUND_IMITATE_POLAR_BEAR: int
        public static SOUND_IMITATE_SHULKER: int
        public static SOUND_IMITATE_SILVERFISH: int
        public static SOUND_IMITATE_SKELETON: int
        public static SOUND_IMITATE_SLIME: int
        public static SOUND_IMITATE_SPIDER: int
        public static SOUND_IMITATE_STRAY: int
        public static SOUND_IMITATE_VEX: int
        public static SOUND_IMITATE_VINDICATION_ILLAGER: int
        public static SOUND_IMITATE_WITCH: int
        public static SOUND_IMITATE_WITHER: int
        public static SOUND_IMITATE_WITHER_SKELETON: int
        public static SOUND_IMITATE_WOLF: int
        public static SOUND_IMITATE_ZOMBIE: int
        public static SOUND_IMITATE_ZOMBIE_PIGMAN: int
        public static SOUND_IMITATE_ZOMBIE_VILLAGER: int
        public static SOUND_BLOCK_END_PORTAL_FRAME_FILL: int
        public static SOUND_BLOCK_END_PORTAL_SPAWN: int
        public static SOUND_RANDOM_ANVIL_USE: int
        public static SOUND_BOTTLE_DRAGONBREATH: int
        public static SOUND_PORTAL_TRAVEL: int
        public static SOUND_ITEM_TRIDENT_HIT: int
        public static SOUND_ITEM_TRIDENT_RETURN: int
        public static SOUND_ITEM_TRIDENT_RIPTIDE_1: int
        public static SOUND_ITEM_TRIDENT_RIPTIDE_2: int
        public static SOUND_ITEM_TRIDENT_RIPTIDE_3: int
        public static SOUND_ITEM_TRIDENT_THROW: int
        public static SOUND_ITEM_TRIDENT_THUNDER: int
        public static SOUND_ITEM_TRIDENT_HIT_GROUND: int
        public static SOUND_DEFAULT: int
        public static SOUND_BLOCK_FLETCHING_TABLE_USE: int
        public static SOUND_ELEMCONSTRUCT_OPEN: int
        public static SOUND_ICEBOMB_HIT: int
        public static SOUND_BALLOONPOP: int
        public static SOUND_LT_REACTION_ICEBOMB: int
        public static SOUND_LT_REACTION_BLEACH: int
        public static SOUND_LT_REACTION_EPASTE: int
        public static SOUND_LT_REACTION_EPASTE2: int
        public static SOUND_LT_REACTION_GLOW_STICK: int
        public static SOUND_LT_REACTION_GLOW_STICK_2: int
        public static SOUND_LT_REACTION_LUMINOL: int
        public static SOUND_LT_REACTION_SALT: int
        public static SOUND_LT_REACTION_FERTILIZER: int
        public static SOUND_LT_REACTION_FIREBALL: int
        public static SOUND_LT_REACTION_MGSALT: int
        public static SOUND_LT_REACTION_MISCFIRE: int
        public static SOUND_LT_REACTION_FIRE: int
        public static SOUND_LT_REACTION_MISCEXPLOSION: int
        public static SOUND_LT_REACTION_MISCMYSTICAL: int
        public static SOUND_LT_REACTION_MISCMYSTICAL2: int
        public static SOUND_LT_REACTION_PRODUCT: int
        public static SOUND_SPARKLER_USE: int
        public static SOUND_GLOWSTICK_USE: int
        public static SOUND_SPARKLER_ACTIVE: int
        public static SOUND_CONVERT_TO_DROWNED: int
        public static SOUND_BUCKET_FILL_FISH: int
        public static SOUND_BUCKET_EMPTY_FISH: int
        public static SOUND_BUBBLE_UP: int
        public static SOUND_BUBBLE_DOWN: int
        public static SOUND_BUBBLE_POP: int
        public static SOUND_BUBBLE_UPINSIDE: int
        public static SOUND_BUBBLE_DOWNINSIDE: int
        public static SOUND_HURT_BABY: int
        public static SOUND_DEATH_BABY: int
        public static SOUND_STEP_BABY: int
        public static SOUND_BABY_SPAWN: int
        public static SOUND_BORN: int
        public static SOUND_BLOCK_TURTLE_EGG_BREAK: int
        public static SOUND_BLOCK_TURTLE_EGG_CRACK: int
        public static SOUND_BLOCK_TURTLE_EGG_HATCH: int
        public static SOUND_TURTLE_LAY_EGG: int
        public static SOUND_BLOCK_TURTLE_EGG_ATTACK: int
        public static SOUND_BEACON_ACTIVATE: int
        public static SOUND_BEACON_AMBIENT: int
        public static SOUND_BEACON_DEACTIVATE: int
        public static SOUND_BEACON_POWER: int
        public static SOUND_CONDUIT_ACTIVATE: int
        public static SOUND_CONDUIT_AMBIENT: int
        public static SOUND_CONDUIT_ATTACK: int
        public static SOUND_CONDUIT_DEACTIVATE: int
        public static SOUND_CONDUIT_SHORT: int
        public static SOUND_SWOOP: int
        public static SOUND_BLOCK_BAMBOO_SAPLING_PLACE: int
        public static SOUND_PRESNEEZE: int
        public static SOUND_SNEEZE: int
        public static SOUND_AMBIENT_TAME: int
        public static SOUND_SCARED: int
        public static SOUND_BLOCK_SCAFFOLDING_CLIMB: int
        public static SOUND_CROSSBOW_LOADING_START: int
        public static SOUND_CROSSBOW_LOADING_MIDDLE: int
        public static SOUND_CROSSBOW_LOADING_END: int
        public static SOUND_CROSSBOW_SHOOT: int
        public static SOUND_CROSSBOW_QUICK_CHARGE_START: int
        public static SOUND_CROSSBOW_QUICK_CHARGE_MIDDLE: int
        public static SOUND_CROSSBOW_QUICK_CHARGE_END: int
        public static SOUND_AMBIENT_AGGRESSIVE: int
        public static SOUND_AMBIENT_WORRIED: int
        public static SOUND_CANT_BREED: int
        public static SOUND_SHIELD_BLOCK: int
        public static SOUND_LECTERN_BOOK_PLACE: int
        public static SOUND_GRINDSTONE_USE: int
        public static SOUND_BELL: int
        public static SOUND_CAMPFIRE_CRACKLE: int
        public static SOUND_ROAR: int
        public static SOUND_STUN: int
        public static SOUND_SWEET_BERRY_BUSH_HURT: int
        public static SOUND_SWEET_BERRY_BUSH_PICK: int
        public static SOUND_CARTOGRAPHY_TABLE_USE: int
        public static SOUND_STONECUTTER_USE: int
        public static SOUND_COMPOSTER_EMPTY: int
        public static SOUND_COMPOSTER_FILL: int
        public static SOUND_COMPOSTER_FILL_LAYER: int
        public static SOUND_COMPOSTER_READY: int
        public static SOUND_BARREL_OPEN: int
        public static SOUND_BARREL_CLOSE: int
        public static SOUND_RAID_HORN: int
        public static SOUND_LOOM_USE: int
        public static SOUND_AMBIENT_IN_RAID: int
        public static SOUND_UI_CARTOGRAPHY_TABLE_USE: int
        public static SOUND_UI_STONECUTTER_USE: int
        public static SOUND_UI_LOOM_USE: int
        public static SOUND_SMOKER_USE: int
        public static SOUND_BLAST_FURNACE_USE: int
        public static SOUND_SMITHING_TABLE_USE: int
        public static SOUND_SCREECH: int
        public static SOUND_SLEEP: int
        public static SOUND_FURNACE_USE: int
        public static SOUND_MOOSHROOM_CONVERT: int
        public static SOUND_MILK_SUSPICIOUSLY: int
        public static SOUND_CELEBRATE: int
        public static SOUND_JUMP_PREVENT: int
        public static SOUND_AMBIENT_POLLINATE: int
        public static SOUND_BEEHIVE_DRIP: int
        public static SOUND_BEEHIVE_ENTER: int
        public static SOUND_BEEHIVE_EXIT: int
        public static SOUND_BEEHIVE_WORK: int
        public static SOUND_BEEHIVE_SHEAR: int
        public static SOUND_HONEYBOTTLE_DRINK: int
        public static SOUND_AMBIENT_CAVE: int
        public static SOUND_RETREAT: int
        public static SOUND_CONVERT_TO_ZOMBIFIED: int
        public static SOUND_ADMIRE: int
        public static SOUND_STEP_LAVA: int
        public static SOUND_TEMPT: int
        public static SOUND_PANIC: int
        public static SOUND_ANGRY: int
        public static SOUND_AMBIENT_WARPED_FOREST: int
        public static SOUND_AMBIENT_SOULSAND_VALLEY: int
        public static SOUND_AMBIENT_NETHER_WASTES: int
        public static SOUND_AMBIENT_BASALT_DELTAS: int
        public static SOUND_AMBIENT_CRIMSON_FOREST: int
        public static SOUND_RESPAWN_ANCHOR_CHARGE: int
        public static SOUND_RESPAWN_ANCHOR_DEPLETE: int
        public static SOUND_RESPAWN_ANCHOR_SET_SPAWN: int
        public static SOUND_RESPAWN_ANCHOR_AMBIENT: int
        public static SOUND_SOUL_ESCAPE_QUIET: int
        public static SOUND_SOUL_ESCAPE_LOUD: int
        public static SOUND_RECORD_PIGSTEP: int
        public static SOUND_LINK_COMPASS_TO_LODESTONE: int
        public static SOUND_USE_SMITHING_TABLE: int
        public static SOUND_EQUIP_NETHERITE: int
        public static SOUND_AMBIENT_LOOP_WARPED_FOREST: int
        public static SOUND_AMBIENT_LOOP_SOULSAND_VALLEY: int
        public static SOUND_AMBIENT_LOOP_NETHER_WASTES: int
        public static SOUND_AMBIENT_LOOP_BASALT_DELTAS: int
        public static SOUND_AMBIENT_LOOP_CRIMSON_FOREST: int
        public static SOUND_AMBIENT_ADDITION_WARPED_FOREST: int
        public static SOUND_AMBIENT_ADDITION_SOULSAND_VALLEY: int
        public static SOUND_AMBIENT_ADDITION_NETHER_WASTES: int
        public static SOUND_AMBIENT_ADDITION_BASALT_DELTAS: int
        public static SOUND_AMBIENT_ADDITION_CRIMSON_FOREST: int
        public static SOUND_SCULK_SENSOR_POWER_ON: int
        public static SOUND_SCULK_SENSOR_POWER_OFF: int
        public static SOUND_BUCKET_FILL_POWDER_SNOW: int
        public static SOUND_BUCKET_EMPTY_POWDER_SNOW: int
        public static SOUND_POINTED_DRIPSTONE_CAULDRON_DRIP_LAVA: int
        public static SOUND_POINTED_DRIPSTONE_CAULDRON_DRIP_WATER: int
        public static SOUND_POINTED_DRIPSTONE_DRIP_LAVA: int
        public static SOUND_POINTED_DRIPSTONE_DRIP_WATER: int
        public static SOUND_CAVE_VINES_PICK_BERRIES: int
        public static SOUND_BIG_DRIPLEAF_TILT_DOWN: int
        public static SOUND_BIG_DRIPLEAF_TILT_UP: int
        public static SOUND_COPPER_WAX_ON: int
        public static SOUND_COPPER_WAX_OFF: int
        public static SOUND_SCRAPE: int
        public static SOUND_PLAYER_HURT_DROWN: int
        public static SOUND_PLAYER_HURT_ON_FIRE: int
        public static SOUND_PLAYER_HURT_FREEZE: int
        public static SOUND_USE_SPYGLASS: int
        public static SOUND_STOP_USING_SPYGLASS: int
        public static SOUND_AMETHYST_BLOCK_CHIME: int
        public static SOUND_AMBIENT_SCREAMER: int
        public static SOUND_HURT_SCREAMER: int
        public static SOUND_DEATH_SCREAMER: int
        public static SOUND_MILK_SCREAMER: int
        public static SOUND_JUMP_TO_BLOCK: int
        public static SOUND_PRE_RAM: int
        public static SOUND_PRE_RAM_SCREAMER: int
        public static SOUND_RAM_IMPACT: int
        public static SOUND_RAM_IMPACT_SCREAMER: int
        public static SOUND_SQUID_INK_SQUIRT: int
        public static SOUND_GLOW_SQUID_INK_SQUIRT: int
        public static SOUND_CONVERT_TO_STRAY: int
        public static SOUND_CAKE_ADD_CANDLE: int
        public static SOUND_EXTINGUISH_CANDLE: int
        public static SOUND_AMBIENT_CANDLE: int
        public static SOUND_BLOCK_CLICK: int
        public static SOUND_BLOCK_CLICK_FAIL: int
        public static SOUND_SCULK_CATALYST_BLOOM: int
        public static SOUND_SCULK_SHRIEKER_SHRIEK: int
        public static SOUND_WARDEN_NEARBY_CLOSE: int
        public static SOUND_WARDEN_NEARBY_CLOSER: int
        public static SOUND_WARDEN_NEARBY_CLOSEST: int
        public static SOUND_WARDEN_SLIGHTLY_ANGRY: int
        public static SOUND_RECORD_OTHERSIDE: int
        public static SOUND_TONGUE: int
        public static SOUND_CRACK_IRON_GOLEM: int
        public static SOUND_REPAIR_IRON_GOLEM: int
        public static SOUND_LISTENING: int
        public static SOUND_HEARTBEAT: int
        public static SOUND_HORN_BREAK: int
        public static SOUND_SCULK_PLACE: int
        public static SOUND_SCULK_SPREAD: int
        public static SOUND_SCULK_CHARGE: int
        public static SOUND_SCULK_SENSOR_PLACE: int
        public static SOUND_SCULK_SHRIEKER_PLACE: int
        public static SOUND_GOAT_CALL_0: int
        public static SOUND_GOAT_CALL_1: int
        public static SOUND_GOAT_CALL_2: int
        public static SOUND_GOAT_CALL_3: int
        public static SOUND_GOAT_CALL_4: int
        public static SOUND_GOAT_CALL_5: int
        public static SOUND_GOAT_CALL_6: int
        public static SOUND_GOAT_CALL_7: int
        public static SOUND_GOAT_CALL_8: int
        public static SOUND_GOAT_CALL_9: int
        public static SOUND_GOAT_HARMONY_0: int
        public static SOUND_GOAT_HARMONY_1: int
        public static SOUND_GOAT_HARMONY_2: int
        public static SOUND_GOAT_HARMONY_3: int
        public static SOUND_GOAT_HARMONY_4: int
        public static SOUND_GOAT_HARMONY_5: int
        public static SOUND_GOAT_HARMONY_6: int
        public static SOUND_GOAT_HARMONY_7: int
        public static SOUND_GOAT_HARMONY_8: int
        public static SOUND_GOAT_HARMONY_9: int
        public static SOUND_GOAT_MELODY_0: int
        public static SOUND_GOAT_MELODY_1: int
        public static SOUND_GOAT_MELODY_2: int
        public static SOUND_GOAT_MELODY_3: int
        public static SOUND_GOAT_MELODY_4: int
        public static SOUND_GOAT_MELODY_5: int
        public static SOUND_GOAT_MELODY_6: int
        public static SOUND_GOAT_MELODY_7: int
        public static SOUND_GOAT_MELODY_8: int
        public static SOUND_GOAT_MELODY_9: int
        public static SOUND_GOAT_BASS_0: int
        public static SOUND_GOAT_BASS_1: int
        public static SOUND_GOAT_BASS_2: int
        public static SOUND_GOAT_BASS_3: int
        public static SOUND_GOAT_BASS_4: int
        public static SOUND_GOAT_BASS_5: int
        public static SOUND_GOAT_BASS_6: int
        public static SOUND_GOAT_BASS_7: int
        public static SOUND_GOAT_BASS_8: int
        public static SOUND_GOAT_BASS_9: int
        public static SOUND_IMITATE_WARDEN: int
        public static SOUND_LISTENING_ANGRY: int
        public static SOUND_ITEM_GIVEN: int
        public static SOUND_ITEM_TAKEN: int
        public static SOUND_DISAPPEARED: int
        public static SOUND_REAPPEARED: int
        public static SOUND_FROGSPAWN_HATCHED: int
        public static SOUND_LAY_SPAWN: int
        public static SOUND_FROGSPAWN_BREAK: int
        public static SOUND_SONIC_BOOM: int
        public static SOUND_SONIC_CHARGE: int
        public static SOUND_ITEM_THROWN: int
        public static SOUND_RECORD_5: int
        public static SOUND_CONVERT_TO_FROG: int
        public static SOUND_UNDEFINED: int
        public sound: int
        public x: float
        public y: float
        public z: float
        public extraData: int
        public entityIdentifier: string
        public isBabyMob: boolean
        public isGlobal: boolean

    }
}

declare module "cn.nukkit.network.protocol.LevelSoundEventPacket" {
    declare const LevelSoundEventPacket = cn.nukkit.network.protocol.LevelSoundEventPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PlayerStartItemCoolDownPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public getItemCategory(): string
        public setItemCategory(itemCategory: string): void
        public getCoolDownDuration(): int
        public setCoolDownDuration(coolDownDuration: int): void
        itemCategory: string
        coolDownDuration: int

    }
}

declare module "cn.nukkit.network.protocol.PlayerStartItemCoolDownPacket" {
    declare const PlayerStartItemCoolDownPacket = cn.nukkit.network.protocol.PlayerStartItemCoolDownPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ItemStackRequestPacket$ItemStackAction extends java.lang.Object {
        public toString(): string
        public constructor(type: byte, bool0: boolean, byte0: byte, varInt0: int, varInt1: int, baseByte0: byte, baseByte1: byte, baseByte2: byte, baseVarInt0: int, flagsByte0: byte, flagsByte1: byte, flagsVarInt0: int, items: java.util.List<cn.nukkit.item.Item>): void
        public getType(): byte
        public isBool0(): boolean
        public getByte0(): byte
        public getVarInt0(): int
        public getVarInt1(): int
        public getBaseByte0(): byte
        public getBaseByte1(): byte
        public getBaseByte2(): byte
        public getBaseVarInt0(): int
        public getFlagsByte0(): byte
        public getFlagsByte1(): byte
        public getFlagsVarInt0(): int
        public getItems(): java.util.List<cn.nukkit.item.Item>
        public equals(o: java.lang.Object): boolean
        public hashCode(): int
        type: byte
        bool0: boolean
        byte0: byte
        varInt0: int
        varInt1: int
        baseByte0: byte
        baseByte1: byte
        baseByte2: byte
        baseVarInt0: int
        flagsByte0: byte
        flagsByte1: byte
        flagsVarInt0: int
        items: java.util.List<cn.nukkit.item.Item>

    }
}

declare module "cn.nukkit.network.protocol.ItemStackRequestPacket$ItemStackAction" {
    declare const ItemStackRequestPacket$ItemStackAction = cn.nukkit.network.protocol.ItemStackRequestPacket$ItemStackAction;
}

declare namespace cn.nukkit.network.protocol {
    declare class ClientCacheStatusPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public static NETWORK_ID: byte
        public supported: boolean

    }
}

declare module "cn.nukkit.network.protocol.ClientCacheStatusPacket" {
    declare const ClientCacheStatusPacket = cn.nukkit.network.protocol.ClientCacheStatusPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetScoreboardIdentityPacket$Entry extends java.lang.Object {
        public constructor(): void
        public scoreboardId: long
        public uuid: java.util.UUID

    }
}

declare module "cn.nukkit.network.protocol.SetScoreboardIdentityPacket$Entry" {
    declare const SetScoreboardIdentityPacket$Entry = cn.nukkit.network.protocol.SetScoreboardIdentityPacket$Entry;
}

declare namespace cn.nukkit.network.protocol.types {
    declare class CodeBuilderOperationType extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.types.CodeBuilderOperationType[]
        public static valueOf(name: string): cn.nukkit.network.protocol.types.CodeBuilderOperationType
        constructor(): void
        static $values(): cn.nukkit.network.protocol.types.CodeBuilderOperationType[]
        public static NONE: cn.nukkit.network.protocol.types.CodeBuilderOperationType
        public static GET: cn.nukkit.network.protocol.types.CodeBuilderOperationType
        public static SET: cn.nukkit.network.protocol.types.CodeBuilderOperationType
        public static RESET: cn.nukkit.network.protocol.types.CodeBuilderOperationType
        static $VALUES: cn.nukkit.network.protocol.types.CodeBuilderOperationType[]

    }
}

declare module "cn.nukkit.network.protocol.types.CodeBuilderOperationType" {
    declare const CodeBuilderOperationType = cn.nukkit.network.protocol.types.CodeBuilderOperationType;
}

declare namespace cn.nukkit.network.protocol.types {
    declare class AgentActionType extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.types.AgentActionType[]
        public static valueOf(name: string): cn.nukkit.network.protocol.types.AgentActionType
        constructor(): void
        static $values(): cn.nukkit.network.protocol.types.AgentActionType[]
        public static NONE: cn.nukkit.network.protocol.types.AgentActionType
        public static ATTACK: cn.nukkit.network.protocol.types.AgentActionType
        public static COLLECT: cn.nukkit.network.protocol.types.AgentActionType
        public static DESTROY: cn.nukkit.network.protocol.types.AgentActionType
        public static DETECT_REDSTONE: cn.nukkit.network.protocol.types.AgentActionType
        public static DETECT_OBSTACLE: cn.nukkit.network.protocol.types.AgentActionType
        public static DROP: cn.nukkit.network.protocol.types.AgentActionType
        public static DROP_ALL: cn.nukkit.network.protocol.types.AgentActionType
        public static INSPECT: cn.nukkit.network.protocol.types.AgentActionType
        public static INSPECT_DATA: cn.nukkit.network.protocol.types.AgentActionType
        public static INSPECT_ITEM_COUNT: cn.nukkit.network.protocol.types.AgentActionType
        public static INSPECT_ITEM_DETAIL: cn.nukkit.network.protocol.types.AgentActionType
        public static INSPECT_ITEM_SPACE: cn.nukkit.network.protocol.types.AgentActionType
        public static INTERACT: cn.nukkit.network.protocol.types.AgentActionType
        public static MOVE: cn.nukkit.network.protocol.types.AgentActionType
        public static PLACE_BLOCK: cn.nukkit.network.protocol.types.AgentActionType
        public static TILL: cn.nukkit.network.protocol.types.AgentActionType
        public static TRANSFER_ITEM_TO: cn.nukkit.network.protocol.types.AgentActionType
        public static TURN: cn.nukkit.network.protocol.types.AgentActionType
        static $VALUES: cn.nukkit.network.protocol.types.AgentActionType[]

    }
}

declare module "cn.nukkit.network.protocol.types.AgentActionType" {
    declare const AgentActionType = cn.nukkit.network.protocol.types.AgentActionType;
}

declare namespace cn.nukkit.network.protocol.types {
    declare class CodeBuilderCategoryType extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.types.CodeBuilderCategoryType[]
        public static valueOf(name: string): cn.nukkit.network.protocol.types.CodeBuilderCategoryType
        constructor(): void
        static $values(): cn.nukkit.network.protocol.types.CodeBuilderCategoryType[]
        public static NONE: cn.nukkit.network.protocol.types.CodeBuilderCategoryType
        public static CODE_STATUS: cn.nukkit.network.protocol.types.CodeBuilderCategoryType
        public static INSTANTIATION: cn.nukkit.network.protocol.types.CodeBuilderCategoryType
        static $VALUES: cn.nukkit.network.protocol.types.CodeBuilderCategoryType[]

    }
}

declare module "cn.nukkit.network.protocol.types.CodeBuilderCategoryType" {
    declare const CodeBuilderCategoryType = cn.nukkit.network.protocol.types.CodeBuilderCategoryType;
}

declare namespace cn.nukkit.network.protocol.types {
    declare class GameType extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.types.GameType[]
        public static valueOf(name: string): cn.nukkit.network.protocol.types.GameType
        constructor(): void
        public static from(id: int): cn.nukkit.network.protocol.types.GameType
        static $values(): cn.nukkit.network.protocol.types.GameType[]
        public static SURVIVAL: cn.nukkit.network.protocol.types.GameType
        public static CREATIVE: cn.nukkit.network.protocol.types.GameType
        public static ADVENTURE: cn.nukkit.network.protocol.types.GameType
        public static SURVIVAL_VIEWER: cn.nukkit.network.protocol.types.GameType
        public static CREATIVE_VIEWER: cn.nukkit.network.protocol.types.GameType
        public static DEFAULT: cn.nukkit.network.protocol.types.GameType
        public static SPECTATOR: cn.nukkit.network.protocol.types.GameType
        static VALUES: cn.nukkit.network.protocol.types.GameType[]
        static $VALUES: cn.nukkit.network.protocol.types.GameType[]

    }
}

declare module "cn.nukkit.network.protocol.types.GameType" {
    declare const GameType = cn.nukkit.network.protocol.types.GameType;
}

declare namespace cn.nukkit.network.protocol.types {
    declare class CommandOriginData$Origin extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.types.CommandOriginData$Origin[]
        public static valueOf(name: string): cn.nukkit.network.protocol.types.CommandOriginData$Origin
        constructor(): void
        static $values(): cn.nukkit.network.protocol.types.CommandOriginData$Origin[]
        public static PLAYER: cn.nukkit.network.protocol.types.CommandOriginData$Origin
        public static BLOCK: cn.nukkit.network.protocol.types.CommandOriginData$Origin
        public static MINECART_BLOCK: cn.nukkit.network.protocol.types.CommandOriginData$Origin
        public static DEV_CONSOLE: cn.nukkit.network.protocol.types.CommandOriginData$Origin
        public static TEST: cn.nukkit.network.protocol.types.CommandOriginData$Origin
        public static AUTOMATION_PLAYER: cn.nukkit.network.protocol.types.CommandOriginData$Origin
        public static CLIENT_AUTOMATION: cn.nukkit.network.protocol.types.CommandOriginData$Origin
        public static DEDICATED_SERVER: cn.nukkit.network.protocol.types.CommandOriginData$Origin
        public static ENTITY: cn.nukkit.network.protocol.types.CommandOriginData$Origin
        public static VIRTUAL: cn.nukkit.network.protocol.types.CommandOriginData$Origin
        public static GAME_ARGUMENT: cn.nukkit.network.protocol.types.CommandOriginData$Origin
        public static ENTITY_SERVER: cn.nukkit.network.protocol.types.CommandOriginData$Origin
        static $VALUES: cn.nukkit.network.protocol.types.CommandOriginData$Origin[]

    }
}

declare module "cn.nukkit.network.protocol.types.CommandOriginData$Origin" {
    declare const CommandOriginData$Origin = cn.nukkit.network.protocol.types.CommandOriginData$Origin;
}

declare namespace cn.nukkit.network.protocol {
    declare class UpdateAttributesPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public entries: cn.nukkit.entity.Attribute[]
        public entityId: long
        public frame: long

    }
}

declare module "cn.nukkit.network.protocol.UpdateAttributesPacket" {
    declare const UpdateAttributesPacket = cn.nukkit.network.protocol.UpdateAttributesPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetLastHurtByPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string

    }
}

declare module "cn.nukkit.network.protocol.SetLastHurtByPacket" {
    declare const SetLastHurtByPacket = cn.nukkit.network.protocol.SetLastHurtByPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetEntityLinkPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public static TYPE_REMOVE: byte
        public static TYPE_RIDE: byte
        public static TYPE_PASSENGER: byte
        public vehicleUniqueId: long
        public riderUniqueId: long
        public type: byte
        public immediate: byte
        public riderInitiated: boolean

    }
}

declare module "cn.nukkit.network.protocol.SetEntityLinkPacket" {
    declare const SetEntityLinkPacket = cn.nukkit.network.protocol.SetEntityLinkPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetCommandsEnabledPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public enabled: boolean

    }
}

declare module "cn.nukkit.network.protocol.SetCommandsEnabledPacket" {
    declare const SetCommandsEnabledPacket = cn.nukkit.network.protocol.SetCommandsEnabledPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class DebugInfoPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public entityId: long
        public data: string

    }
}

declare module "cn.nukkit.network.protocol.DebugInfoPacket" {
    declare const DebugInfoPacket = cn.nukkit.network.protocol.DebugInfoPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class TickSyncPacket extends cn.nukkit.network.protocol.DataPacket {
        public pid(): byte
        public decode(): void
        public encode(): void
        public getRequestTimestamp(): long
        public setRequestTimestamp(requestTimestamp: long): void
        public getResponseTimestamp(): long
        public setResponseTimestamp(responseTimestamp: long): void
        public toString(): string
        public constructor(): void
        public static NETWORK_ID: byte
        requestTimestamp: long
        responseTimestamp: long

    }
}

declare module "cn.nukkit.network.protocol.TickSyncPacket" {
    declare const TickSyncPacket = cn.nukkit.network.protocol.TickSyncPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class OnScreenTextureAnimationPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public effectId: int

    }
}

declare module "cn.nukkit.network.protocol.OnScreenTextureAnimationPacket" {
    declare const OnScreenTextureAnimationPacket = cn.nukkit.network.protocol.OnScreenTextureAnimationPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class CommandBlockUpdatePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public isBlock: boolean
        public x: int
        public y: int
        public z: int
        public commandBlockMode: int
        public isRedstoneMode: boolean
        public isConditional: boolean
        public minecartEid: long
        public command: string
        public lastOutput: string
        public name: string
        public shouldTrackOutput: boolean
        public tickDelay: int
        public executingOnFirstTick: boolean

    }
}

declare module "cn.nukkit.network.protocol.CommandBlockUpdatePacket" {
    declare const CommandBlockUpdatePacket = cn.nukkit.network.protocol.CommandBlockUpdatePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ClientboundMapItemDataPacket$MapDecorator extends java.lang.Object {
        public constructor(): void
        public static EMPTY_ARRAY: cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapDecorator[]
        public rotation: byte
        public icon: byte
        public offsetX: byte
        public offsetZ: byte
        public label: string
        public color: java.awt.Color

    }
}

declare module "cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapDecorator" {
    declare const ClientboundMapItemDataPacket$MapDecorator = cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapDecorator;
}

declare namespace cn.nukkit.network.protocol {
    declare class ChangeMobPropertyPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        uniqueEntityId: long
        property: string
        boolValue: boolean
        stringValue: string
        intValue: int
        floatValue: float

    }
}

declare module "cn.nukkit.network.protocol.ChangeMobPropertyPacket" {
    declare const ChangeMobPropertyPacket = cn.nukkit.network.protocol.ChangeMobPropertyPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class UpdateSubChunkBlocksPacket extends cn.nukkit.network.protocol.DataPacket {
        public pid(): byte
        public decode(): void
        public encode(): void
        public constructor(chunkX: int, chunkY: int, chunkZ: int): void
        public getChunkX(): int
        public getChunkY(): int
        public getChunkZ(): int
        public getStandardBlocks(): java.util.List<cn.nukkit.network.protocol.types.BlockChangeEntry>
        public getExtraBlocks(): java.util.List<cn.nukkit.network.protocol.types.BlockChangeEntry>
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        public toString(): string
        public chunkX: int
        public chunkY: int
        public chunkZ: int
        public standardBlocks: java.util.List<cn.nukkit.network.protocol.types.BlockChangeEntry>
        public extraBlocks: java.util.List<cn.nukkit.network.protocol.types.BlockChangeEntry>

    }
}

declare module "cn.nukkit.network.protocol.UpdateSubChunkBlocksPacket" {
    declare const UpdateSubChunkBlocksPacket = cn.nukkit.network.protocol.UpdateSubChunkBlocksPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class TextPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public static TYPE_RAW: byte
        public static TYPE_CHAT: byte
        public static TYPE_TRANSLATION: byte
        public static TYPE_POPUP: byte
        public static TYPE_JUKEBOX_POPUP: byte
        public static TYPE_TIP: byte
        public static TYPE_SYSTEM: byte
        public static TYPE_WHISPER: byte
        public static TYPE_ANNOUNCEMENT: byte
        public static TYPE_OBJECT: byte
        public static TYPE_OBJECT_WHISPER: byte
        public type: byte
        public source: string
        public message: string
        public parameters: string[]
        public isLocalized: boolean
        public xboxUserId: string
        public platformChatId: string

    }
}

declare module "cn.nukkit.network.protocol.TextPacket" {
    declare const TextPacket = cn.nukkit.network.protocol.TextPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class LecternUpdatePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public page: int
        public totalPages: int
        public blockPosition: cn.nukkit.math.BlockVector3
        public dropBook: boolean

    }
}

declare module "cn.nukkit.network.protocol.LecternUpdatePacket" {
    declare const LecternUpdatePacket = cn.nukkit.network.protocol.LecternUpdatePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetHealthPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public health: int

    }
}

declare module "cn.nukkit.network.protocol.SetHealthPacket" {
    declare const SetHealthPacket = cn.nukkit.network.protocol.SetHealthPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PacketViolationWarningPacket$PacketViolationSeverity extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationSeverity[]
        public static valueOf(name: string): cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationSeverity
        constructor(): void
        static $values(): cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationSeverity[]
        public static UNKNOWN: cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationSeverity
        public static WARNING: cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationSeverity
        public static FINAL_WARNING: cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationSeverity
        public static TERMINATING_CONNECTION: cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationSeverity
        static $VALUES: cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationSeverity[]

    }
}

declare module "cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationSeverity" {
    declare const PacketViolationWarningPacket$PacketViolationSeverity = cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationSeverity;
}

declare namespace cn.nukkit.network.protocol {
    declare class GameRulesChangedPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public gameRules: cn.nukkit.level.GameRules

    }
}

declare module "cn.nukkit.network.protocol.GameRulesChangedPacket" {
    declare const GameRulesChangedPacket = cn.nukkit.network.protocol.GameRulesChangedPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class BlockEventPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public x: int
        public y: int
        public z: int
        public case1: int
        public case2: int

    }
}

declare module "cn.nukkit.network.protocol.BlockEventPacket" {
    declare const BlockEventPacket = cn.nukkit.network.protocol.BlockEventPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class LevelChunkPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public chunkX: int
        public chunkZ: int
        public subChunkCount: int
        public cacheEnabled: boolean
        public requestSubChunks: boolean
        public subChunkLimit: int
        public blobIds: long[]
        public data: byte[]

    }
}

declare module "cn.nukkit.network.protocol.LevelChunkPacket" {
    declare const LevelChunkPacket = cn.nukkit.network.protocol.LevelChunkPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetScoreboardIdentityPacket$Action extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.SetScoreboardIdentityPacket$Action[]
        public static valueOf(name: string): cn.nukkit.network.protocol.SetScoreboardIdentityPacket$Action
        constructor(): void
        static $values(): cn.nukkit.network.protocol.SetScoreboardIdentityPacket$Action[]
        public static ADD: cn.nukkit.network.protocol.SetScoreboardIdentityPacket$Action
        public static REMOVE: cn.nukkit.network.protocol.SetScoreboardIdentityPacket$Action
        static $VALUES: cn.nukkit.network.protocol.SetScoreboardIdentityPacket$Action[]

    }
}

declare module "cn.nukkit.network.protocol.SetScoreboardIdentityPacket$Action" {
    declare const SetScoreboardIdentityPacket$Action = cn.nukkit.network.protocol.SetScoreboardIdentityPacket$Action;
}

declare namespace cn.nukkit.network.protocol {
    declare class ContainerSetDataPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public static PROPERTY_FURNACE_TICK_COUNT: int
        public static PROPERTY_FURNACE_LIT_TIME: int
        public static PROPERTY_FURNACE_LIT_DURATION: int
        public static PROPERTY_FURNACE_FUEL_AUX: int
        public static PROPERTY_BREWING_STAND_BREW_TIME: int
        public static PROPERTY_BREWING_STAND_FUEL_AMOUNT: int
        public static PROPERTY_BREWING_STAND_FUEL_TOTAL: int
        public windowId: int
        public property: int
        public value: int

    }
}

declare module "cn.nukkit.network.protocol.ContainerSetDataPacket" {
    declare const ContainerSetDataPacket = cn.nukkit.network.protocol.ContainerSetDataPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ClientboundMapItemDataPacket$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$network$protocol$ClientboundMapItemDataPacket$MapTrackedObject$Type: int[]

    }
}

declare module "cn.nukkit.network.protocol.ClientboundMapItemDataPacket$1" {
    declare const ClientboundMapItemDataPacket$1 = cn.nukkit.network.protocol.ClientboundMapItemDataPacket$1;
}

declare namespace cn.nukkit.network.protocol {
    declare class AvailableEntityIdentifiersPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        static TAG: byte[]
        public tag: byte[]

    }
}

declare module "cn.nukkit.network.protocol.AvailableEntityIdentifiersPacket" {
    declare const AvailableEntityIdentifiersPacket = cn.nukkit.network.protocol.AvailableEntityIdentifiersPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class InteractPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public static ACTION_VEHICLE_EXIT: int
        public static ACTION_MOUSEOVER: int
        public static ACTION_OPEN_INVENTORY: int
        public action: int
        public target: long

    }
}

declare module "cn.nukkit.network.protocol.InteractPacket" {
    declare const InteractPacket = cn.nukkit.network.protocol.InteractPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class MapCreateLockedCopyPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public originalMapId: long
        public newMapId: long

    }
}

declare module "cn.nukkit.network.protocol.MapCreateLockedCopyPacket" {
    declare const MapCreateLockedCopyPacket = cn.nukkit.network.protocol.MapCreateLockedCopyPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class AnvilDamagePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public damage: int
        public x: int
        public y: int
        public z: int

    }
}

declare module "cn.nukkit.network.protocol.AnvilDamagePacket" {
    declare const AnvilDamagePacket = cn.nukkit.network.protocol.AnvilDamagePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class RemoveObjectivePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public objectiveName: string

    }
}

declare module "cn.nukkit.network.protocol.RemoveObjectivePacket" {
    declare const RemoveObjectivePacket = cn.nukkit.network.protocol.RemoveObjectivePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class UpdatePlayerGameTypePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public gameType: cn.nukkit.network.protocol.types.GameType
        public entityId: long

    }
}

declare module "cn.nukkit.network.protocol.UpdatePlayerGameTypePacket" {
    declare const UpdatePlayerGameTypePacket = cn.nukkit.network.protocol.UpdatePlayerGameTypePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class EventPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public eid: long
        public unknown1: int
        public unknown2: byte

    }
}

declare module "cn.nukkit.network.protocol.EventPacket" {
    declare const EventPacket = cn.nukkit.network.protocol.EventPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ContainerOpenPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public windowId: int
        public type: int
        public x: int
        public y: int
        public z: int
        public entityId: long

    }
}

declare module "cn.nukkit.network.protocol.ContainerOpenPacket" {
    declare const ContainerOpenPacket = cn.nukkit.network.protocol.ContainerOpenPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class EntityFallPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public eid: long
        public fallDistance: float
        public unknown: boolean

    }
}

declare module "cn.nukkit.network.protocol.EntityFallPacket" {
    declare const EntityFallPacket = cn.nukkit.network.protocol.EntityFallPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class NPCRequestPacket$RequestType extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.NPCRequestPacket$RequestType[]
        public static valueOf(name: string): cn.nukkit.network.protocol.NPCRequestPacket$RequestType
        constructor(): void
        static $values(): cn.nukkit.network.protocol.NPCRequestPacket$RequestType[]
        public static SET_ACTIONS: cn.nukkit.network.protocol.NPCRequestPacket$RequestType
        public static EXECUTE_ACTION: cn.nukkit.network.protocol.NPCRequestPacket$RequestType
        public static EXECUTE_CLOSING_COMMANDS: cn.nukkit.network.protocol.NPCRequestPacket$RequestType
        public static SET_NAME: cn.nukkit.network.protocol.NPCRequestPacket$RequestType
        public static SET_SKIN: cn.nukkit.network.protocol.NPCRequestPacket$RequestType
        public static SET_INTERACTION_TEXT: cn.nukkit.network.protocol.NPCRequestPacket$RequestType
        public static EXECUTE_OPENING_COMMANDS: cn.nukkit.network.protocol.NPCRequestPacket$RequestType
        static $VALUES: cn.nukkit.network.protocol.NPCRequestPacket$RequestType[]

    }
}

declare module "cn.nukkit.network.protocol.NPCRequestPacket$RequestType" {
    declare const NPCRequestPacket$RequestType = cn.nukkit.network.protocol.NPCRequestPacket$RequestType;
}

declare namespace cn.nukkit.network.protocol {
    declare class PlayerEnchantOptionsPacket$EnchantOptionData extends java.lang.Object {
        public constructor(this$0: int, minLevel: int, primarySlot: java.util.List<cn.nukkit.network.protocol.PlayerEnchantOptionsPacket$EnchantData>, enchants0: java.util.List<cn.nukkit.network.protocol.PlayerEnchantOptionsPacket$EnchantData>, enchants1: java.util.List<cn.nukkit.network.protocol.PlayerEnchantOptionsPacket$EnchantData>, enchants2: string, enchantName: int): void
        public getMinLevel(): int
        public getPrimarySlot(): int
        public getEnchants0(): java.util.List<cn.nukkit.network.protocol.PlayerEnchantOptionsPacket$EnchantData>
        public getEnchants1(): java.util.List<cn.nukkit.network.protocol.PlayerEnchantOptionsPacket$EnchantData>
        public getEnchants2(): java.util.List<cn.nukkit.network.protocol.PlayerEnchantOptionsPacket$EnchantData>
        public getEnchantName(): string
        public getEnchantNetId(): int
        public equals(o: java.lang.Object): boolean
        public hashCode(): int
        public toString(): string
        minLevel: int
        primarySlot: int
        enchants0: java.util.List<cn.nukkit.network.protocol.PlayerEnchantOptionsPacket$EnchantData>
        enchants1: java.util.List<cn.nukkit.network.protocol.PlayerEnchantOptionsPacket$EnchantData>
        enchants2: java.util.List<cn.nukkit.network.protocol.PlayerEnchantOptionsPacket$EnchantData>
        enchantName: string
        enchantNetId: int
        this$0: cn.nukkit.network.protocol.PlayerEnchantOptionsPacket

    }
}

declare module "cn.nukkit.network.protocol.PlayerEnchantOptionsPacket$EnchantOptionData" {
    declare const PlayerEnchantOptionsPacket$EnchantOptionData = cn.nukkit.network.protocol.PlayerEnchantOptionsPacket$EnchantOptionData;
}

declare namespace cn.nukkit.network.protocol {
    declare class CodeBuilderSourcePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public getOperation(): cn.nukkit.network.protocol.types.CodeBuilderOperationType
        public setOperation(operation: cn.nukkit.network.protocol.types.CodeBuilderOperationType): void
        public getCategory(): cn.nukkit.network.protocol.types.CodeBuilderCategoryType
        public setCategory(category: cn.nukkit.network.protocol.types.CodeBuilderCategoryType): void
        public getValue(): string
        public setValue(value: string): void
        operation: cn.nukkit.network.protocol.types.CodeBuilderOperationType
        category: cn.nukkit.network.protocol.types.CodeBuilderCategoryType
        value: string

    }
}

declare module "cn.nukkit.network.protocol.CodeBuilderSourcePacket" {
    declare const CodeBuilderSourcePacket = cn.nukkit.network.protocol.CodeBuilderSourcePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PlayerActionPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public static ACTION_START_BREAK: int
        public static ACTION_ABORT_BREAK: int
        public static ACTION_STOP_BREAK: int
        public static ACTION_GET_UPDATED_BLOCK: int
        public static ACTION_DROP_ITEM: int
        public static ACTION_START_SLEEPING: int
        public static ACTION_STOP_SLEEPING: int
        public static ACTION_RESPAWN: int
        public static ACTION_JUMP: int
        public static ACTION_START_SPRINT: int
        public static ACTION_STOP_SPRINT: int
        public static ACTION_START_SNEAK: int
        public static ACTION_STOP_SNEAK: int
        public static ACTION_CREATIVE_PLAYER_DESTROY_BLOCK: int
        public static ACTION_DIMENSION_CHANGE_ACK: int
        public static ACTION_START_GLIDE: int
        public static ACTION_STOP_GLIDE: int
        public static ACTION_BUILD_DENIED: int
        public static ACTION_CONTINUE_BREAK: int
        public static ACTION_SET_ENCHANTMENT_SEED: int
        public static ACTION_START_SWIMMING: int
        public static ACTION_STOP_SWIMMING: int
        public static ACTION_START_SPIN_ATTACK: int
        public static ACTION_STOP_SPIN_ATTACK: int
        public static ACTION_INTERACT_BLOCK: int
        public static ACTION_PREDICT_DESTROY_BLOCK: int
        public static ACTION_CONTINUE_DESTROY_BLOCK: int
        public static ACTION_START_ITEM_USE_ON: int
        public static ACTION_STOP_ITEM_USE_ON: int
        public entityId: long
        public action: int
        public x: int
        public y: int
        public z: int
        public resultPosition: cn.nukkit.math.BlockVector3
        public face: int

    }
}

declare module "cn.nukkit.network.protocol.PlayerActionPacket" {
    declare const PlayerActionPacket = cn.nukkit.network.protocol.PlayerActionPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class UpdateBlockPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public static FLAG_NONE: int
        public static FLAG_NEIGHBORS: int
        public static FLAG_NETWORK: int
        public static FLAG_NOGRAPHIC: int
        public static FLAG_PRIORITY: int
        public static FLAG_ALL: int
        public static FLAG_ALL_PRIORITY: int
        public x: int
        public z: int
        public y: int
        public blockRuntimeId: int
        public flags: int
        public dataLayer: int

    }
}

declare module "cn.nukkit.network.protocol.UpdateBlockPacket" {
    declare const UpdateBlockPacket = cn.nukkit.network.protocol.UpdateBlockPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ClientboundMapItemDataPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public eids: int[]
        public mapId: long
        public update: int
        public scale: byte
        public isLocked: boolean
        public width: int
        public height: int
        public offsetX: int
        public offsetZ: int
        public dimensionId: byte
        public trackedObjects: java.util.List<cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapTrackedObject>
        public decorators: cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapDecorator[]
        public colors: int[]
        public image: java.awt.image.BufferedImage
        public static TEXTURE_UPDATE: int
        public static DECORATIONS_UPDATE: int
        public static ENTITIES_UPDATE: int

    }
}

declare module "cn.nukkit.network.protocol.ClientboundMapItemDataPacket" {
    declare const ClientboundMapItemDataPacket = cn.nukkit.network.protocol.ClientboundMapItemDataPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class BossEventPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public static TYPE_SHOW: int
        public static TYPE_REGISTER_PLAYER: int
        public static TYPE_UPDATE: int
        public static TYPE_HIDE: int
        public static TYPE_UNREGISTER_PLAYER: int
        public static TYPE_HEALTH_PERCENT: int
        public static TYPE_TITLE: int
        public static TYPE_UPDATE_PROPERTIES: int
        public static TYPE_UNKNOWN_6: int
        public static TYPE_TEXTURE: int
        public static TYPE_QUERY: int
        public bossEid: long
        public type: int
        public playerEid: long
        public healthPercent: float
        public title: string
        public unknown: short
        public color: int
        public overlay: int

    }
}

declare module "cn.nukkit.network.protocol.BossEventPacket" {
    declare const BossEventPacket = cn.nukkit.network.protocol.BossEventPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ResourcePackClientResponsePacket$Entry extends java.lang.Object {
        public constructor(uuid: java.util.UUID, version: string): void
        public toString(): string
        public uuid: java.util.UUID
        public version: string

    }
}

declare module "cn.nukkit.network.protocol.ResourcePackClientResponsePacket$Entry" {
    declare const ResourcePackClientResponsePacket$Entry = cn.nukkit.network.protocol.ResourcePackClientResponsePacket$Entry;
}

declare namespace cn.nukkit.network.protocol {
    declare class ModalFormRequestPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public formId: int
        public data: string

    }
}

declare module "cn.nukkit.network.protocol.ModalFormRequestPacket" {
    declare const ModalFormRequestPacket = cn.nukkit.network.protocol.ModalFormRequestPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PositionTrackingDBServerBroadcastPacket$Action extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.PositionTrackingDBServerBroadcastPacket$Action[]
        public static valueOf(name: string): cn.nukkit.network.protocol.PositionTrackingDBServerBroadcastPacket$Action
        constructor(): void
        static $values(): cn.nukkit.network.protocol.PositionTrackingDBServerBroadcastPacket$Action[]
        public static UPDATE: cn.nukkit.network.protocol.PositionTrackingDBServerBroadcastPacket$Action
        public static DESTROY: cn.nukkit.network.protocol.PositionTrackingDBServerBroadcastPacket$Action
        public static NOT_FOUND: cn.nukkit.network.protocol.PositionTrackingDBServerBroadcastPacket$Action
        static $VALUES: cn.nukkit.network.protocol.PositionTrackingDBServerBroadcastPacket$Action[]

    }
}

declare module "cn.nukkit.network.protocol.PositionTrackingDBServerBroadcastPacket$Action" {
    declare const PositionTrackingDBServerBroadcastPacket$Action = cn.nukkit.network.protocol.PositionTrackingDBServerBroadcastPacket$Action;
}

declare namespace cn.nukkit.network.protocol {
    declare class ModalFormResponsePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public formId: int
        public data: string

    }
}

declare module "cn.nukkit.network.protocol.ModalFormResponsePacket" {
    declare const ModalFormResponsePacket = cn.nukkit.network.protocol.ModalFormResponsePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SimulationTypePacket$SimulationType extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.SimulationTypePacket$SimulationType[]
        public static valueOf(name: string): cn.nukkit.network.protocol.SimulationTypePacket$SimulationType
        constructor(): void
        static $values(): cn.nukkit.network.protocol.SimulationTypePacket$SimulationType[]
        public static GAME: cn.nukkit.network.protocol.SimulationTypePacket$SimulationType
        public static EDITOR: cn.nukkit.network.protocol.SimulationTypePacket$SimulationType
        public static TEST: cn.nukkit.network.protocol.SimulationTypePacket$SimulationType
        static $VALUES: cn.nukkit.network.protocol.SimulationTypePacket$SimulationType[]

    }
}

declare module "cn.nukkit.network.protocol.SimulationTypePacket$SimulationType" {
    declare const SimulationTypePacket$SimulationType = cn.nukkit.network.protocol.SimulationTypePacket$SimulationType;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetTitlePacket$TitleAction extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.SetTitlePacket$TitleAction[]
        public static valueOf(name: string): cn.nukkit.network.protocol.SetTitlePacket$TitleAction
        constructor(): void
        static $values(): cn.nukkit.network.protocol.SetTitlePacket$TitleAction[]
        public static CLEAR: cn.nukkit.network.protocol.SetTitlePacket$TitleAction
        public static RESET: cn.nukkit.network.protocol.SetTitlePacket$TitleAction
        public static SET_TITLE_MESSAGE: cn.nukkit.network.protocol.SetTitlePacket$TitleAction
        public static SET_SUBTITLE_MESSAGE: cn.nukkit.network.protocol.SetTitlePacket$TitleAction
        public static SET_ACTION_BAR_MESSAGE: cn.nukkit.network.protocol.SetTitlePacket$TitleAction
        public static SET_ANIMATION_TIMES: cn.nukkit.network.protocol.SetTitlePacket$TitleAction
        public static SET_TITLE_JSON: cn.nukkit.network.protocol.SetTitlePacket$TitleAction
        public static SET_SUBTITLE_JSON: cn.nukkit.network.protocol.SetTitlePacket$TitleAction
        public static SET_ACTIONBAR_JSON: cn.nukkit.network.protocol.SetTitlePacket$TitleAction
        static $VALUES: cn.nukkit.network.protocol.SetTitlePacket$TitleAction[]

    }
}

declare module "cn.nukkit.network.protocol.SetTitlePacket$TitleAction" {
    declare const SetTitlePacket$TitleAction = cn.nukkit.network.protocol.SetTitlePacket$TitleAction;
}

declare namespace cn.nukkit.network.protocol {
    declare class ChangeDimensionPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public dimension: int
        public x: float
        public y: float
        public z: float
        public respawn: boolean

    }
}

declare module "cn.nukkit.network.protocol.ChangeDimensionPacket" {
    declare const ChangeDimensionPacket = cn.nukkit.network.protocol.ChangeDimensionPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class LoginPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public getProtocol(): int
        decodeChainData(): void
        decodeSkinData(): void
        decodeToken(token: string): com.google.gson.JsonObject
        static getAnimation(element: com.google.gson.JsonObject): cn.nukkit.utils.SkinAnimation
        static getImage(token: com.google.gson.JsonObject, name: string): cn.nukkit.utils.SerializedImage
        static getPersonaPiece(object: com.google.gson.JsonObject): cn.nukkit.utils.PersonaPiece
        public static getTint(object: com.google.gson.JsonObject): cn.nukkit.utils.PersonaPieceTint
        public toString(): string
        public static NETWORK_ID: byte
        static GSON: com.google.gson.Gson
        public username: string
        public protocol: int
        public clientUUID: java.util.UUID
        public clientId: long
        public skin: cn.nukkit.entity.data.Skin
        public issueUnixTime: long

    }
}

declare module "cn.nukkit.network.protocol.LoginPacket" {
    declare const LoginPacket = cn.nukkit.network.protocol.LoginPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ItemComponentPacket$Entry extends java.lang.Object {
        public constructor(name: string, data: cn.nukkit.nbt.tag.CompoundTag): void
        public getName(): string
        public getData(): cn.nukkit.nbt.tag.CompoundTag
        public toString(): string
        public static EMPTY_ARRAY: cn.nukkit.network.protocol.ItemComponentPacket$Entry[]
        name: string
        data: cn.nukkit.nbt.tag.CompoundTag

    }
}

declare module "cn.nukkit.network.protocol.ItemComponentPacket$Entry" {
    declare const ItemComponentPacket$Entry = cn.nukkit.network.protocol.ItemComponentPacket$Entry;
}

declare namespace cn.nukkit.network.protocol {
    declare class ItemStackRequestPacket$Request extends java.lang.Object {
        public constructor(requestId: int, actions: java.util.List<cn.nukkit.network.protocol.ItemStackRequestPacket$ItemStackAction>): void
        public getRequestId(): int
        public getActions(): java.util.List<cn.nukkit.network.protocol.ItemStackRequestPacket$ItemStackAction>
        public equals(o: java.lang.Object): boolean
        public hashCode(): int
        public toString(): string
        requestId: int
        actions: java.util.List<cn.nukkit.network.protocol.ItemStackRequestPacket$ItemStackAction>

    }
}

declare module "cn.nukkit.network.protocol.ItemStackRequestPacket$Request" {
    declare const ItemStackRequestPacket$Request = cn.nukkit.network.protocol.ItemStackRequestPacket$Request;
}

declare namespace cn.nukkit.network.protocol {
    declare class SimulationTypePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public getSimulationType(): cn.nukkit.network.protocol.SimulationTypePacket$SimulationType
        public setSimulationType(type: cn.nukkit.network.protocol.SimulationTypePacket$SimulationType): void
        public static NETWORK_ID: byte
        static TYPES: cn.nukkit.network.protocol.SimulationTypePacket$SimulationType[]
        type: cn.nukkit.network.protocol.SimulationTypePacket$SimulationType

    }
}

declare module "cn.nukkit.network.protocol.SimulationTypePacket" {
    declare const SimulationTypePacket = cn.nukkit.network.protocol.SimulationTypePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class DimensionDataPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        definitions: java.util.List<cn.nukkit.level.DimensionData>

    }
}

declare module "cn.nukkit.network.protocol.DimensionDataPacket" {
    declare const DimensionDataPacket = cn.nukkit.network.protocol.DimensionDataPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class StopSoundPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public name: string
        public stopAll: boolean

    }
}

declare module "cn.nukkit.network.protocol.StopSoundPacket" {
    declare const StopSoundPacket = cn.nukkit.network.protocol.StopSoundPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PacketViolationWarningPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public type: cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationType
        public severity: cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationSeverity
        public packetId: int
        public context: string

    }
}

declare module "cn.nukkit.network.protocol.PacketViolationWarningPacket" {
    declare const PacketViolationWarningPacket = cn.nukkit.network.protocol.PacketViolationWarningPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class LevelSoundEventPacketV2 extends cn.nukkit.network.protocol.LevelSoundEventPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public sound: int
        public x: float
        public y: float
        public z: float
        public extraData: int
        public entityIdentifier: string
        public isBabyMob: boolean
        public isGlobal: boolean

    }
}

declare module "cn.nukkit.network.protocol.LevelSoundEventPacketV2" {
    declare const LevelSoundEventPacketV2 = cn.nukkit.network.protocol.LevelSoundEventPacketV2;
}

declare namespace cn.nukkit.network.protocol {
    declare class HurtArmorPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public cause: int
        public damage: int
        public armorSlots: long

    }
}

declare module "cn.nukkit.network.protocol.HurtArmorPacket" {
    declare const HurtArmorPacket = cn.nukkit.network.protocol.HurtArmorPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class AddEntityPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public static LEGACY_IDS: com.google.common.collect.ImmutableMap<int, string>
        public entityUniqueId: long
        public entityRuntimeId: long
        public type: int
        public id: string
        public x: float
        public y: float
        public z: float
        public speedX: float
        public speedY: float
        public speedZ: float
        public yaw: float
        public pitch: float
        public headYaw: float
        public metadata: cn.nukkit.entity.data.EntityMetadata
        public attributes: cn.nukkit.entity.Attribute[]
        public links: cn.nukkit.network.protocol.types.EntityLink[]

    }
}

declare module "cn.nukkit.network.protocol.AddEntityPacket" {
    declare const AddEntityPacket = cn.nukkit.network.protocol.AddEntityPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetSpawnPositionPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public static TYPE_PLAYER_SPAWN: int
        public static TYPE_WORLD_SPAWN: int
        public spawnType: int
        public y: int
        public z: int
        public x: int
        public dimension: int

    }
}

declare module "cn.nukkit.network.protocol.SetSpawnPositionPacket" {
    declare const SetSpawnPositionPacket = cn.nukkit.network.protocol.SetSpawnPositionPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class EmoteListPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public runtimeId: long
        public pieceIds: java.util.List<java.util.UUID>

    }
}

declare module "cn.nukkit.network.protocol.EmoteListPacket" {
    declare const EmoteListPacket = cn.nukkit.network.protocol.EmoteListPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ItemComponentPacket extends cn.nukkit.network.protocol.DataPacket {
        public setEntries(entries: cn.nukkit.network.protocol.ItemComponentPacket$Entry[]): void
        public getEntries(): cn.nukkit.network.protocol.ItemComponentPacket$Entry[]
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public constructor(): void
        public static NETWORK_ID: byte
        entries: cn.nukkit.network.protocol.ItemComponentPacket$Entry[]

    }
}

declare module "cn.nukkit.network.protocol.ItemComponentPacket" {
    declare const ItemComponentPacket = cn.nukkit.network.protocol.ItemComponentPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class CraftingDataPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public addShapelessRecipe(recipe: cn.nukkit.inventory.ShapelessRecipe[]): void
        public addStonecutterRecipe(recipes: cn.nukkit.inventory.StonecutterRecipe[]): void
        public addShapedRecipe(recipe: cn.nukkit.inventory.ShapedRecipe[]): void
        public addCartographyRecipe(recipe: cn.nukkit.inventory.CartographyRecipe[]): void
        public addFurnaceRecipe(recipe: cn.nukkit.inventory.FurnaceRecipe[]): void
        public addSmokerRecipe(recipe: cn.nukkit.inventory.SmokerRecipe[]): void
        public addBlastFurnaceRecipe(recipe: cn.nukkit.inventory.BlastFurnaceRecipe[]): void
        public addCampfireRecipeRecipe(recipe: cn.nukkit.inventory.CampfireRecipe[]): void
        public addMultiRecipe(recipe: cn.nukkit.inventory.MultiRecipe[]): void
        public addBrewingRecipe(recipe: cn.nukkit.inventory.BrewingRecipe[]): void
        public addContainerRecipe(recipe: cn.nukkit.inventory.ContainerRecipe[]): void
        public clean(): cn.nukkit.network.protocol.DataPacket
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        lambda$addCartographyRecipe$1(r: cn.nukkit.inventory.CartographyRecipe): void
        static lambda$addCartographyRecipe$0(r: cn.nukkit.inventory.CartographyRecipe): boolean
        public static NETWORK_ID: byte
        public static CRAFTING_TAG_CRAFTING_TABLE: string
        public static CRAFTING_TAG_CARTOGRAPHY_TABLE: string
        public static CRAFTING_TAG_STONECUTTER: string
        public static CRAFTING_TAG_FURNACE: string
        public static CRAFTING_TAG_CAMPFIRE: string
        public static CRAFTING_TAG_BLAST_FURNACE: string
        public static CRAFTING_TAG_SMOKER: string
        public static CRAFTING_TAG_SMITHING_TABLE: string
        entries: java.util.List<cn.nukkit.inventory.Recipe>
        brewingEntries: java.util.List<cn.nukkit.inventory.BrewingRecipe>
        containerEntries: java.util.List<cn.nukkit.inventory.ContainerRecipe>
        public cleanRecipes: boolean

    }
}

declare module "cn.nukkit.network.protocol.CraftingDataPacket" {
    declare const CraftingDataPacket = cn.nukkit.network.protocol.CraftingDataPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ScriptCustomEventPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public eventName: string
        public eventData: byte[]

    }
}

declare module "cn.nukkit.network.protocol.ScriptCustomEventPacket" {
    declare const ScriptCustomEventPacket = cn.nukkit.network.protocol.ScriptCustomEventPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class RemoveVolumeEntityPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public getId(): long
        public setId(id: long): void
        public static NETWORK_ID: byte
        id: long
        dimension: int

    }
}

declare module "cn.nukkit.network.protocol.RemoveVolumeEntityPacket" {
    declare const RemoveVolumeEntityPacket = cn.nukkit.network.protocol.RemoveVolumeEntityPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class NPCDialoguePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public getRuntimeEntityId(): long
        public setRuntimeEntityId(runtimeEntityId: long): void
        public getAction(): cn.nukkit.network.protocol.NPCDialoguePacket$NPCDialogAction
        public setAction(action: cn.nukkit.network.protocol.NPCDialoguePacket$NPCDialogAction): void
        public getDialogue(): string
        public setDialogue(dialogue: string): void
        public getSceneName(): string
        public setSceneName(sceneName: string): void
        public getNpcName(): string
        public setNpcName(npcName: string): void
        public getActionJson(): string
        public setActionJson(actionJson: string): void
        public static NETWORK_ID: byte
        static ACTIONS: cn.nukkit.network.protocol.NPCDialoguePacket$NPCDialogAction[]
        runtimeEntityId: long
        action: cn.nukkit.network.protocol.NPCDialoguePacket$NPCDialogAction
        dialogue: string
        sceneName: string
        npcName: string
        actionJson: string

    }
}

declare module "cn.nukkit.network.protocol.NPCDialoguePacket" {
    declare const NPCDialoguePacket = cn.nukkit.network.protocol.NPCDialoguePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PlayerHotbarPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public selectedHotbarSlot: int
        public windowId: int
        public selectHotbarSlot: boolean

    }
}

declare module "cn.nukkit.network.protocol.PlayerHotbarPacket" {
    declare const PlayerHotbarPacket = cn.nukkit.network.protocol.PlayerHotbarPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class AddVolumeEntityPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public getId(): long
        public setId(id: long): void
        public getData(): cn.nukkit.nbt.tag.CompoundTag
        public setData(data: cn.nukkit.nbt.tag.CompoundTag): void
        public getEngineVersion(): string
        public setEngineVersion(engineVersion: string): void
        public getIdentifier(): string
        public setIdentifier(identifier: string): void
        public getInstanceName(): string
        public setInstanceName(instanceName: string): void
        public static NETWORK_ID: byte
        id: long
        data: cn.nukkit.nbt.tag.CompoundTag
        engineVersion: string
        identifier: string
        instanceName: string

    }
}

declare module "cn.nukkit.network.protocol.AddVolumeEntityPacket" {
    declare const AddVolumeEntityPacket = cn.nukkit.network.protocol.AddVolumeEntityPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class VideoStreamConnectPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public static ACTION_OPEN: byte
        public static ACTION_CLOSE: byte
        public address: string
        public screenshotFrequency: float
        public action: byte

    }
}

declare module "cn.nukkit.network.protocol.VideoStreamConnectPacket" {
    declare const VideoStreamConnectPacket = cn.nukkit.network.protocol.VideoStreamConnectPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetScorePacket$ScoreInfo extends java.lang.Object {
        public constructor(scoreboardId: long, var1: string, objectiveId: int): void
        public constructor(scoreboardId: long, var1: string, objectiveId: int, score: string): void
        public constructor(scoreboardId: long, var1: string, objectiveId: int, score: cn.nukkit.scoreboard.data.ScorerType, type: long): void
        public scoreboardId: long
        public objectiveId: string
        public score: int
        public type: cn.nukkit.scoreboard.data.ScorerType
        public name: string
        public entityId: long

    }
}

declare module "cn.nukkit.network.protocol.SetScorePacket$ScoreInfo" {
    declare const SetScorePacket$ScoreInfo = cn.nukkit.network.protocol.SetScorePacket$ScoreInfo;
}

declare namespace cn.nukkit.network.protocol {
    declare class UpdateTradePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public windowId: byte
        public windowType: byte
        public unknownVarInt1: int
        public tradeTier: int
        public trader: long
        public player: long
        public displayName: string
        public screen2: boolean
        public isWilling: boolean
        public offers: byte[]

    }
}

declare module "cn.nukkit.network.protocol.UpdateTradePacket" {
    declare const UpdateTradePacket = cn.nukkit.network.protocol.UpdateTradePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class MobEffectPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public static EVENT_ADD: byte
        public static EVENT_MODIFY: byte
        public static EVENT_REMOVE: byte
        public eid: long
        public eventId: int
        public effectId: int
        public amplifier: int
        public particles: boolean
        public duration: int

    }
}

declare module "cn.nukkit.network.protocol.MobEffectPacket" {
    declare const MobEffectPacket = cn.nukkit.network.protocol.MobEffectPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class NPCDialoguePacket$NPCDialogAction extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.NPCDialoguePacket$NPCDialogAction[]
        public static valueOf(name: string): cn.nukkit.network.protocol.NPCDialoguePacket$NPCDialogAction
        constructor(): void
        static $values(): cn.nukkit.network.protocol.NPCDialoguePacket$NPCDialogAction[]
        public static OPEN: cn.nukkit.network.protocol.NPCDialoguePacket$NPCDialogAction
        public static CLOSE: cn.nukkit.network.protocol.NPCDialoguePacket$NPCDialogAction
        static $VALUES: cn.nukkit.network.protocol.NPCDialoguePacket$NPCDialogAction[]

    }
}

declare module "cn.nukkit.network.protocol.NPCDialoguePacket$NPCDialogAction" {
    declare const NPCDialoguePacket$NPCDialogAction = cn.nukkit.network.protocol.NPCDialoguePacket$NPCDialogAction;
}

declare namespace cn.nukkit.network.protocol {
    declare class ItemStackResponsePacket extends cn.nukkit.network.protocol.DataPacket {
        public encode(): void
        public decode(): void
        public pid(): byte
        public toString(): string
        public constructor(): void
        public static NETWORK_ID: byte

    }
}

declare module "cn.nukkit.network.protocol.ItemStackResponsePacket" {
    declare const ItemStackResponsePacket = cn.nukkit.network.protocol.ItemStackResponsePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class AddPaintingPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public entityUniqueId: long
        public entityRuntimeId: long
        public x: float
        public y: float
        public z: float
        public direction: int
        public title: string

    }
}

declare module "cn.nukkit.network.protocol.AddPaintingPacket" {
    declare const AddPaintingPacket = cn.nukkit.network.protocol.AddPaintingPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetScorePacket$Action extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.SetScorePacket$Action[]
        public static valueOf(name: string): cn.nukkit.network.protocol.SetScorePacket$Action
        constructor(): void
        static $values(): cn.nukkit.network.protocol.SetScorePacket$Action[]
        public static SET: cn.nukkit.network.protocol.SetScorePacket$Action
        public static REMOVE: cn.nukkit.network.protocol.SetScorePacket$Action
        static $VALUES: cn.nukkit.network.protocol.SetScorePacket$Action[]

    }
}

declare module "cn.nukkit.network.protocol.SetScorePacket$Action" {
    declare const SetScorePacket$Action = cn.nukkit.network.protocol.SetScorePacket$Action;
}

declare namespace cn.nukkit.network.protocol {
    declare class PositionTrackingDBClientRequestPacket$Action extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.PositionTrackingDBClientRequestPacket$Action[]
        public static valueOf(name: string): cn.nukkit.network.protocol.PositionTrackingDBClientRequestPacket$Action
        constructor(): void
        static $values(): cn.nukkit.network.protocol.PositionTrackingDBClientRequestPacket$Action[]
        public static QUERY: cn.nukkit.network.protocol.PositionTrackingDBClientRequestPacket$Action
        static $VALUES: cn.nukkit.network.protocol.PositionTrackingDBClientRequestPacket$Action[]

    }
}

declare module "cn.nukkit.network.protocol.PositionTrackingDBClientRequestPacket$Action" {
    declare const PositionTrackingDBClientRequestPacket$Action = cn.nukkit.network.protocol.PositionTrackingDBClientRequestPacket$Action;
}

declare namespace cn.nukkit.network.protocol {
    declare class UpdateSoftEnumPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public values: string[]
        public name: string
        public type: cn.nukkit.network.protocol.UpdateSoftEnumPacket$Type

    }
}

declare module "cn.nukkit.network.protocol.UpdateSoftEnumPacket" {
    declare const UpdateSoftEnumPacket = cn.nukkit.network.protocol.UpdateSoftEnumPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PlayerEnchantOptionsPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public options: java.util.List<cn.nukkit.network.protocol.PlayerEnchantOptionsPacket$EnchantOptionData>

    }
}

declare module "cn.nukkit.network.protocol.PlayerEnchantOptionsPacket" {
    declare const PlayerEnchantOptionsPacket = cn.nukkit.network.protocol.PlayerEnchantOptionsPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ClientboundMapItemDataPacket$MapTrackedObject extends java.lang.Object {
        public constructor(entityId: long): void
        public constructor(position: cn.nukkit.math.Vector3): void
        public getType(): cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapTrackedObject$Type
        public getEntityId(): long
        public getPosition(): cn.nukkit.math.Vector3
        type: cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapTrackedObject$Type
        entityId: long
        position: cn.nukkit.math.Vector3

    }
}

declare module "cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapTrackedObject" {
    declare const ClientboundMapItemDataPacket$MapTrackedObject = cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapTrackedObject;
}

declare namespace cn.nukkit.network.protocol {
    declare class MoveEntityAbsolutePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public eid: long
        public x: double
        public y: double
        public z: double
        public yaw: double
        public headYaw: double
        public pitch: double
        public onGround: boolean
        public teleport: boolean
        public forceMoveLocalEntity: boolean

    }
}

declare module "cn.nukkit.network.protocol.MoveEntityAbsolutePacket" {
    declare const MoveEntityAbsolutePacket = cn.nukkit.network.protocol.MoveEntityAbsolutePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class MoveEntityDeltaPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        getCoordinate(): float
        putCoordinate(value: float): void
        getRotation(): float
        putRotation(value: float): void
        public hasFlag(flag: int): boolean
        public toString(): string
        public static NETWORK_ID: byte
        public static FLAG_HAS_X: int
        public static FLAG_HAS_Y: int
        public static FLAG_HAS_Z: int
        public static FLAG_HAS_PITCH: int
        public static FLAG_HAS_YAW: int
        public static FLAG_HAS_HEAD_YAW: int
        public static FLAG_ON_GROUND: int
        public static FLAG_TELEPORTING: int
        public static FLAG_FORCE_MOVE_LOCAL_ENTITY: int
        public runtimeEntityId: long
        public flags: int
        public x: float
        public y: float
        public z: float
        public pitch: float
        public yaw: float
        public headYaw: float

    }
}

declare module "cn.nukkit.network.protocol.MoveEntityDeltaPacket" {
    declare const MoveEntityDeltaPacket = cn.nukkit.network.protocol.MoveEntityDeltaPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class AddItemEntityPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public entityUniqueId: long
        public entityRuntimeId: long
        public item: cn.nukkit.item.Item
        public x: float
        public y: float
        public z: float
        public speedX: float
        public speedY: float
        public speedZ: float
        public metadata: cn.nukkit.entity.data.EntityMetadata
        public isFromFishing: boolean

    }
}

declare module "cn.nukkit.network.protocol.AddItemEntityPacket" {
    declare const AddItemEntityPacket = cn.nukkit.network.protocol.AddItemEntityPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PacketViolationWarningPacket$PacketViolationType extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationType[]
        public static valueOf(name: string): cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationType
        constructor(): void
        static $values(): cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationType[]
        public static UNKNOWN: cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationType
        public static MALFORMED_PACKET: cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationType
        static $VALUES: cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationType[]

    }
}

declare module "cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationType" {
    declare const PacketViolationWarningPacket$PacketViolationType = cn.nukkit.network.protocol.PacketViolationWarningPacket$PacketViolationType;
}

declare namespace cn.nukkit.network.protocol {
    declare class CameraPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public cameraUniqueId: long
        public playerUniqueId: long

    }
}

declare module "cn.nukkit.network.protocol.CameraPacket" {
    declare const CameraPacket = cn.nukkit.network.protocol.CameraPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class BookEditPacket$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$network$protocol$BookEditPacket$Action: int[]

    }
}

declare module "cn.nukkit.network.protocol.BookEditPacket$1" {
    declare const BookEditPacket$1 = cn.nukkit.network.protocol.BookEditPacket$1;
}

declare namespace cn.nukkit.network.protocol {
    declare class MobArmorEquipmentPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public eid: long
        public slots: cn.nukkit.item.Item[]

    }
}

declare module "cn.nukkit.network.protocol.MobArmorEquipmentPacket" {
    declare const MobArmorEquipmentPacket = cn.nukkit.network.protocol.MobArmorEquipmentPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ResourcePackStackPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public mustAccept: boolean
        public behaviourPackStack: cn.nukkit.resourcepacks.ResourcePack[]
        public resourcePackStack: cn.nukkit.resourcepacks.ResourcePack[]
        public experiments: java.util.List<cn.nukkit.network.protocol.ResourcePackStackPacket$ExperimentData>
        public gameVersion: string

    }
}

declare module "cn.nukkit.network.protocol.ResourcePackStackPacket" {
    declare const ResourcePackStackPacket = cn.nukkit.network.protocol.ResourcePackStackPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class CraftingEventPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        public static NETWORK_ID: byte
        public static TYPE_SHAPELESS: int
        public static TYPE_SHAPED: int
        public static TYPE_FURNACE: int
        public static TYPE_FURNACE_DATA: int
        public static TYPE_MULTI: int
        public static TYPE_SHULKER_BOX: int
        public static TYPE_INVENTORY: int
        public static TYPE_CRAFTING: int
        public static TYPE_WORKBENCH: int
        public windowId: int
        public type: int
        public id: java.util.UUID
        public input: cn.nukkit.item.Item[]
        public output: cn.nukkit.item.Item[]

    }
}

declare module "cn.nukkit.network.protocol.CraftingEventPacket" {
    declare const CraftingEventPacket = cn.nukkit.network.protocol.CraftingEventPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetDifficultyPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public difficulty: int

    }
}

declare module "cn.nukkit.network.protocol.SetDifficultyPacket" {
    declare const SetDifficultyPacket = cn.nukkit.network.protocol.SetDifficultyPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class RemoveEntityPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public eid: long

    }
}

declare module "cn.nukkit.network.protocol.RemoveEntityPacket" {
    declare const RemoveEntityPacket = cn.nukkit.network.protocol.RemoveEntityPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PlayerListPacket$Entry extends java.lang.Object {
        public constructor(uuid: java.util.UUID): void
        public constructor(uuid: java.util.UUID, entityId: long, var2: string, name: cn.nukkit.entity.data.Skin): void
        public constructor(uuid: java.util.UUID, entityId: long, var2: string, name: cn.nukkit.entity.data.Skin, skin: string): void
        public toString(): string
        public static EMPTY_ARRAY: cn.nukkit.network.protocol.PlayerListPacket$Entry[]
        public uuid: java.util.UUID
        public entityId: long
        public name: string
        public xboxUserId: string
        public platformChatId: string
        public buildPlatform: int
        public skin: cn.nukkit.entity.data.Skin
        public isTeacher: boolean
        public isHost: boolean

    }
}

declare module "cn.nukkit.network.protocol.PlayerListPacket$Entry" {
    declare const PlayerListPacket$Entry = cn.nukkit.network.protocol.PlayerListPacket$Entry;
}

declare namespace cn.nukkit.network.protocol {
    declare class StartGamePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        static log: org.apache.logging.log4j.Logger
        public static NETWORK_ID: byte
        public static GAME_PUBLISH_SETTING_NO_MULTI_PLAY: int
        public static GAME_PUBLISH_SETTING_INVITE_ONLY: int
        public static GAME_PUBLISH_SETTING_FRIENDS_ONLY: int
        public static GAME_PUBLISH_SETTING_FRIENDS_OF_FRIENDS: int
        public static GAME_PUBLISH_SETTING_PUBLIC: int
        public entityUniqueId: long
        public entityRuntimeId: long
        public playerGamemode: int
        public x: float
        public y: float
        public z: float
        public yaw: float
        public pitch: float
        public seed: long
        public dimension: byte
        public generator: int
        public worldGamemode: int
        public difficulty: int
        public spawnX: int
        public spawnY: int
        public spawnZ: int
        public hasAchievementsDisabled: boolean
        public dayCycleStopTime: int
        public eduEditionOffer: int
        public hasEduFeaturesEnabled: boolean
        public rainLevel: float
        public lightningLevel: float
        public hasConfirmedPlatformLockedContent: boolean
        public multiplayerGame: boolean
        public broadcastToLAN: boolean
        public xblBroadcastIntent: int
        public platformBroadcastIntent: int
        public commandsEnabled: boolean
        public isTexturePacksRequired: boolean
        public gameRules: cn.nukkit.level.GameRules
        public bonusChest: boolean
        public hasStartWithMapEnabled: boolean
        public permissionLevel: int
        public serverChunkTickRange: int
        public hasLockedBehaviorPack: boolean
        public hasLockedResourcePack: boolean
        public isFromLockedWorldTemplate: boolean
        public isUsingMsaGamertagsOnly: boolean
        public isFromWorldTemplate: boolean
        public isWorldTemplateOptionLocked: boolean
        public isOnlySpawningV1Villagers: boolean
        public vanillaVersion: string
        public levelId: string
        public worldName: string
        public premiumWorldTemplateId: string
        public isTrial: boolean
        public isMovementServerAuthoritative: boolean
        public isInventoryServerAuthoritative: boolean
        public currentTick: long
        public enchantmentSeed: int
        public multiplayerCorrelationId: string

    }
}

declare module "cn.nukkit.network.protocol.StartGamePacket" {
    declare const StartGamePacket = cn.nukkit.network.protocol.StartGamePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class MovePlayerPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public static MODE_NORMAL: int
        public static MODE_RESET: int
        public static MODE_TELEPORT: int
        public static MODE_PITCH: int
        public eid: long
        public x: float
        public y: float
        public z: float
        public yaw: float
        public headYaw: float
        public pitch: float
        public mode: int
        public onGround: boolean
        public ridingEid: long
        public int1: int
        public int2: int
        public frame: long

    }
}

declare module "cn.nukkit.network.protocol.MovePlayerPacket" {
    declare const MovePlayerPacket = cn.nukkit.network.protocol.MovePlayerPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetTimePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public time: int

    }
}

declare module "cn.nukkit.network.protocol.SetTimePacket" {
    declare const SetTimePacket = cn.nukkit.network.protocol.SetTimePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class BlockPickRequestPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public x: int
        public y: int
        public z: int
        public addUserData: boolean
        public selectedSlot: int

    }
}

declare module "cn.nukkit.network.protocol.BlockPickRequestPacket" {
    declare const BlockPickRequestPacket = cn.nukkit.network.protocol.BlockPickRequestPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class GUIDataPickItemPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public encode(): void
        public decode(): void
        public toString(): string
        public hotbarSlot: int

    }
}

declare module "cn.nukkit.network.protocol.GUIDataPickItemPacket" {
    declare const GUIDataPickItemPacket = cn.nukkit.network.protocol.GUIDataPickItemPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare interface ProtocolInfo {
        public static CURRENT_PROTOCOL: int
        public static SUPPORTED_PROTOCOLS: java.util.List<int>
        public static MINECRAFT_VERSION_NETWORK: string
        public static MINECRAFT_VERSION: string
        public static LOGIN_PACKET: byte
        public static PLAY_STATUS_PACKET: byte
        public static SERVER_TO_CLIENT_HANDSHAKE_PACKET: byte
        public static CLIENT_TO_SERVER_HANDSHAKE_PACKET: byte
        public static DISCONNECT_PACKET: byte
        public static RESOURCE_PACKS_INFO_PACKET: byte
        public static RESOURCE_PACK_STACK_PACKET: byte
        public static RESOURCE_PACK_CLIENT_RESPONSE_PACKET: byte
        public static TEXT_PACKET: byte
        public static SET_TIME_PACKET: byte
        public static START_GAME_PACKET: byte
        public static ADD_PLAYER_PACKET: byte
        public static ADD_ENTITY_PACKET: byte
        public static REMOVE_ENTITY_PACKET: byte
        public static ADD_ITEM_ENTITY_PACKET: byte
        public static TAKE_ITEM_ENTITY_PACKET: byte
        public static MOVE_ENTITY_ABSOLUTE_PACKET: byte
        public static MOVE_PLAYER_PACKET: byte
        public static RIDER_JUMP_PACKET: byte
        public static UPDATE_BLOCK_PACKET: byte
        public static ADD_PAINTING_PACKET: byte
        public static TICK_SYNC_PACKET: byte
        public static LEVEL_SOUND_EVENT_PACKET_V1: byte
        public static LEVEL_EVENT_PACKET: byte
        public static BLOCK_EVENT_PACKET: byte
        public static ENTITY_EVENT_PACKET: byte
        public static MOB_EFFECT_PACKET: byte
        public static UPDATE_ATTRIBUTES_PACKET: byte
        public static INVENTORY_TRANSACTION_PACKET: byte
        public static MOB_EQUIPMENT_PACKET: byte
        public static MOB_ARMOR_EQUIPMENT_PACKET: byte
        public static INTERACT_PACKET: byte
        public static BLOCK_PICK_REQUEST_PACKET: byte
        public static ENTITY_PICK_REQUEST_PACKET: byte
        public static PLAYER_ACTION_PACKET: byte
        public static ENTITY_FALL_PACKET: byte
        public static HURT_ARMOR_PACKET: byte
        public static SET_ENTITY_DATA_PACKET: byte
        public static SET_ENTITY_MOTION_PACKET: byte
        public static SET_ENTITY_LINK_PACKET: byte
        public static SET_HEALTH_PACKET: byte
        public static SET_SPAWN_POSITION_PACKET: byte
        public static ANIMATE_PACKET: byte
        public static RESPAWN_PACKET: byte
        public static CONTAINER_OPEN_PACKET: byte
        public static CONTAINER_CLOSE_PACKET: byte
        public static PLAYER_HOTBAR_PACKET: byte
        public static INVENTORY_CONTENT_PACKET: byte
        public static INVENTORY_SLOT_PACKET: byte
        public static CONTAINER_SET_DATA_PACKET: byte
        public static CRAFTING_DATA_PACKET: byte
        public static CRAFTING_EVENT_PACKET: byte
        public static GUI_DATA_PICK_ITEM_PACKET: byte
        public static ADVENTURE_SETTINGS_PACKET: byte
        public static BLOCK_ENTITY_DATA_PACKET: byte
        public static PLAYER_INPUT_PACKET: byte
        public static FULL_CHUNK_DATA_PACKET: byte
        public static SET_COMMANDS_ENABLED_PACKET: byte
        public static SET_DIFFICULTY_PACKET: byte
        public static CHANGE_DIMENSION_PACKET: byte
        public static SET_PLAYER_GAME_TYPE_PACKET: byte
        public static PLAYER_LIST_PACKET: byte
        public static SIMPLE_EVENT_PACKET: byte
        public static EVENT_PACKET: byte
        public static SPAWN_EXPERIENCE_ORB_PACKET: byte
        public static CLIENTBOUND_MAP_ITEM_DATA_PACKET: byte
        public static MAP_INFO_REQUEST_PACKET: byte
        public static REQUEST_CHUNK_RADIUS_PACKET: byte
        public static CHUNK_RADIUS_UPDATED_PACKET: byte
        public static ITEM_FRAME_DROP_ITEM_PACKET: byte
        public static GAME_RULES_CHANGED_PACKET: byte
        public static CAMERA_PACKET: byte
        public static BOSS_EVENT_PACKET: byte
        public static SHOW_CREDITS_PACKET: byte
        public static AVAILABLE_COMMANDS_PACKET: byte
        public static COMMAND_REQUEST_PACKET: byte
        public static COMMAND_BLOCK_UPDATE_PACKET: byte
        public static COMMAND_OUTPUT_PACKET: byte
        public static UPDATE_TRADE_PACKET: byte
        public static UPDATE_EQUIPMENT_PACKET: byte
        public static RESOURCE_PACK_DATA_INFO_PACKET: byte
        public static RESOURCE_PACK_CHUNK_DATA_PACKET: byte
        public static RESOURCE_PACK_CHUNK_REQUEST_PACKET: byte
        public static TRANSFER_PACKET: byte
        public static PLAY_SOUND_PACKET: byte
        public static STOP_SOUND_PACKET: byte
        public static SET_TITLE_PACKET: byte
        public static ADD_BEHAVIOR_TREE_PACKET: byte
        public static STRUCTURE_BLOCK_UPDATE_PACKET: byte
        public static SHOW_STORE_OFFER_PACKET: byte
        public static PURCHASE_RECEIPT_PACKET: byte
        public static PLAYER_SKIN_PACKET: byte
        public static SUB_CLIENT_LOGIN_PACKET: byte
        public static INITIATE_WEB_SOCKET_CONNECTION_PACKET: byte
        public static SET_LAST_HURT_BY_PACKET: byte
        public static BOOK_EDIT_PACKET: byte
        public static NPC_REQUEST_PACKET: byte
        public static PHOTO_TRANSFER_PACKET: byte
        public static MODAL_FORM_REQUEST_PACKET: byte
        public static MODAL_FORM_RESPONSE_PACKET: byte
        public static SERVER_SETTINGS_REQUEST_PACKET: byte
        public static SERVER_SETTINGS_RESPONSE_PACKET: byte
        public static SHOW_PROFILE_PACKET: byte
        public static SET_DEFAULT_GAME_TYPE_PACKET: byte
        public static REMOVE_OBJECTIVE_PACKET: byte
        public static SET_DISPLAY_OBJECTIVE_PACKET: byte
        public static SET_SCORE_PACKET: byte
        public static MOVE_ENTITY_DELTA_PACKET: byte
        public static SET_SCOREBOARD_IDENTITY_PACKET: byte
        public static SET_LOCAL_PLAYER_AS_INITIALIZED_PACKET: byte
        public static UPDATE_SOFT_ENUM_PACKET: byte
        public static NETWORK_STACK_LATENCY_PACKET: byte
        public static SCRIPT_CUSTOM_EVENT_PACKET: byte
        public static SPAWN_PARTICLE_EFFECT_PACKET: byte
        public static AVAILABLE_ENTITY_IDENTIFIERS_PACKET: byte
        public static LEVEL_SOUND_EVENT_PACKET_V2: byte
        public static NETWORK_CHUNK_PUBLISHER_UPDATE_PACKET: byte
        public static BIOME_DEFINITION_LIST_PACKET: byte
        public static LEVEL_SOUND_EVENT_PACKET: byte
        public static LEVEL_EVENT_GENERIC_PACKET: byte
        public static LECTERN_UPDATE_PACKET: byte
        public static VIDEO_STREAM_CONNECT_PACKET: byte
        public static CLIENT_CACHE_STATUS_PACKET: byte
        public static ON_SCREEN_TEXTURE_ANIMATION_PACKET: byte
        public static MAP_CREATE_LOCKED_COPY_PACKET: byte
        public static STRUCTURE_TEMPLATE_DATA_EXPORT_REQUEST: byte
        public static STRUCTURE_TEMPLATE_DATA_EXPORT_RESPONSE: byte
        public static UPDATE_BLOCK_PROPERTIES: byte
        public static CLIENT_CACHE_BLOB_STATUS_PACKET: byte
        public static CLIENT_CACHE_MISS_RESPONSE_PACKET: byte
        public static EDUCATION_SETTINGS_PACKET: byte
        public static EMOTE_PACKET: byte
        public static MULTIPLAYER_SETTINGS_PACKET: byte
        public static SETTINGS_COMMAND_PACKET: byte
        public static ANVIL_DAMAGE_PACKET: byte
        public static COMPLETED_USING_ITEM_PACKET: byte
        public static NETWORK_SETTINGS_PACKET: byte
        public static PLAYER_AUTH_INPUT_PACKET: byte
        public static CREATIVE_CONTENT_PACKET: byte
        public static PLAYER_ENCHANT_OPTIONS_PACKET: byte
        public static ITEM_STACK_REQUEST_PACKET: byte
        public static ITEM_STACK_RESPONSE_PACKET: byte
        public static PLAYER_ARMOR_DAMAGE_PACKET: byte
        public static CODE_BUILDER_PACKET: byte
        public static UPDATE_PLAYER_GAME_TYPE_PACKET: byte
        public static EMOTE_LIST_PACKET: byte
        public static POS_TRACKING_SERVER_BROADCAST_PACKET: byte
        public static POS_TRACKING_CLIENT_REQUEST_PACKET: byte
        public static DEBUG_INFO_PACKET: byte
        public static PACKET_VIOLATION_WARNING_PACKET: byte
        public static MOTION_PREDICTION_HINTS_PACKET: byte
        public static ANIMATE_ENTITY_PACKET: byte
        public static CAMERA_SHAKE_PACKET: byte
        public static PLAYER_FOG_PACKET: byte
        public static CORRECT_PLAYER_MOVE_PREDICTION_PACKET: byte
        public static ITEM_COMPONENT_PACKET: byte
        public static FILTER_TEXT_PACKET: byte
        public static CLIENTBOUND_DEBUG_RENDERER_PACKET: byte
        public static TOAST_REQUEST_PACKET: byte
        public static SYNC_ENTITY_PROPERTY_PACKET: byte
        public static ADD_VOLUME_ENTITY_PACKET: byte
        public static REMOVE_VOLUME_ENTITY_PACKET: byte
        public static SYNC_ENTITY_PROPERTY: byte
        public static ADD_VOLUME_ENTITY: byte
        public static REMOVE_VOLUME_ENTITY: byte
        public static SIMULATION_TYPE_PACKET: byte
        public static NPC_DIALOGUE_PACKET: byte
        public static UPDATE_SUB_CHUNK_BLOCKS_PACKET: byte
        public static PLAYER_START_ITEM_COOL_DOWN_PACKET: byte
        public static SCRIPT_MESSAGE_PACKET: byte
        public static CODE_BUILDER_SOURCE_PACKET: byte
        public static AGENT_ACTION_EVENT_PACKET: byte
        public static CHANGE_MOB_PROPERTY_PACKET: byte
        public static DIMENSION_DATA_PACKET: byte
        public static TICKING_AREAS_LOAD_STATUS_PACKET: byte
        public static BATCH_PACKET: byte

    }
}

declare module "cn.nukkit.network.protocol.ProtocolInfo" {
    declare type ProtocolInfo = cn.nukkit.network.protocol.ProtocolInfo;
}

declare namespace cn.nukkit.network.protocol {
    declare class UpdateEquipmentPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public windowId: int
        public windowType: int
        public unknown: int
        public eid: long
        public namedtag: byte[]

    }
}

declare module "cn.nukkit.network.protocol.UpdateEquipmentPacket" {
    declare const UpdateEquipmentPacket = cn.nukkit.network.protocol.UpdateEquipmentPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ShowCreditsPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public static STATUS_START_CREDITS: int
        public static STATUS_END_CREDITS: int
        public eid: long
        public status: int

    }
}

declare module "cn.nukkit.network.protocol.ShowCreditsPacket" {
    declare const ShowCreditsPacket = cn.nukkit.network.protocol.ShowCreditsPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class UpdateSoftEnumPacket$Type extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.UpdateSoftEnumPacket$Type[]
        public static valueOf(name: string): cn.nukkit.network.protocol.UpdateSoftEnumPacket$Type
        constructor(): void
        static $values(): cn.nukkit.network.protocol.UpdateSoftEnumPacket$Type[]
        public static ADD: cn.nukkit.network.protocol.UpdateSoftEnumPacket$Type
        public static REMOVE: cn.nukkit.network.protocol.UpdateSoftEnumPacket$Type
        public static SET: cn.nukkit.network.protocol.UpdateSoftEnumPacket$Type
        static $VALUES: cn.nukkit.network.protocol.UpdateSoftEnumPacket$Type[]

    }
}

declare module "cn.nukkit.network.protocol.UpdateSoftEnumPacket$Type" {
    declare const UpdateSoftEnumPacket$Type = cn.nukkit.network.protocol.UpdateSoftEnumPacket$Type;
}

declare namespace cn.nukkit.network.protocol {
    declare class DataPacket extends cn.nukkit.utils.BinaryStream implements java.lang.Cloneable {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public tryEncode(): void
        public reset(): cn.nukkit.network.protocol.DataPacket
        public setChannel(channel: int): void
        public getChannel(): int
        public clean(): cn.nukkit.network.protocol.DataPacket
        public clone(): cn.nukkit.network.protocol.DataPacket
        public compress(): cn.nukkit.network.protocol.BatchPacket
        public compress(level: int): cn.nukkit.network.protocol.BatchPacket
        public reset(): cn.nukkit.utils.BinaryStream
        public clone(): java.lang.Object
        public static EMPTY_ARRAY: cn.nukkit.network.protocol.DataPacket[]
        public isEncoded: boolean
        channel: int
        public reliability: com.nukkitx.network.raknet.RakNetReliability

    }
}

declare module "cn.nukkit.network.protocol.DataPacket" {
    declare const DataPacket = cn.nukkit.network.protocol.DataPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SpawnExperienceOrbPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public x: float
        public y: float
        public z: float
        public amount: int

    }
}

declare module "cn.nukkit.network.protocol.SpawnExperienceOrbPacket" {
    declare const SpawnExperienceOrbPacket = cn.nukkit.network.protocol.SpawnExperienceOrbPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetScorePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public action: cn.nukkit.network.protocol.SetScorePacket$Action
        public infos: java.util.List<cn.nukkit.network.protocol.SetScorePacket$ScoreInfo>

    }
}

declare module "cn.nukkit.network.protocol.SetScorePacket" {
    declare const SetScorePacket = cn.nukkit.network.protocol.SetScorePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class NetworkChunkPublisherUpdatePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public position: cn.nukkit.math.BlockVector3
        public radius: int

    }
}

declare module "cn.nukkit.network.protocol.NetworkChunkPublisherUpdatePacket" {
    declare const NetworkChunkPublisherUpdatePacket = cn.nukkit.network.protocol.NetworkChunkPublisherUpdatePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class UpdateBlockPacket$Entry extends java.lang.Object {
        public constructor(x: int, z: int, y: int, blockId: int, blockData: int, flags: int): void
        public x: int
        public z: int
        public y: int
        public blockId: int
        public blockData: int
        public flags: int

    }
}

declare module "cn.nukkit.network.protocol.UpdateBlockPacket$Entry" {
    declare const UpdateBlockPacket$Entry = cn.nukkit.network.protocol.UpdateBlockPacket$Entry;
}

declare namespace cn.nukkit.network.protocol {
    declare class ItemStackRequestPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public requests: java.util.List<cn.nukkit.network.protocol.ItemStackRequestPacket$Request>

    }
}

declare module "cn.nukkit.network.protocol.ItemStackRequestPacket" {
    declare const ItemStackRequestPacket = cn.nukkit.network.protocol.ItemStackRequestPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class CameraShakePacket$CameraShakeAction extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.CameraShakePacket$CameraShakeAction[]
        public static valueOf(name: string): cn.nukkit.network.protocol.CameraShakePacket$CameraShakeAction
        constructor(): void
        static $values(): cn.nukkit.network.protocol.CameraShakePacket$CameraShakeAction[]
        public static ADD: cn.nukkit.network.protocol.CameraShakePacket$CameraShakeAction
        public static STOP: cn.nukkit.network.protocol.CameraShakePacket$CameraShakeAction
        static $VALUES: cn.nukkit.network.protocol.CameraShakePacket$CameraShakeAction[]

    }
}

declare module "cn.nukkit.network.protocol.CameraShakePacket$CameraShakeAction" {
    declare const CameraShakePacket$CameraShakeAction = cn.nukkit.network.protocol.CameraShakePacket$CameraShakeAction;
}

declare namespace cn.nukkit.network.protocol {
    declare class RiderJumpPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public unknown: int

    }
}

declare module "cn.nukkit.network.protocol.RiderJumpPacket" {
    declare const RiderJumpPacket = cn.nukkit.network.protocol.RiderJumpPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ResourcePackChunkDataPacket extends cn.nukkit.network.protocol.AbstractResourcePackDataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public getPackVersion(): org.powernukkit.version.Version
        public setPackVersion(packVersion: org.powernukkit.version.Version): void
        public getPackId(): java.util.UUID
        public setPackId(packId: java.util.UUID): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public packId: java.util.UUID
        packVersion: org.powernukkit.version.Version
        public chunkIndex: int
        public progress: long
        public data: byte[]

    }
}

declare module "cn.nukkit.network.protocol.ResourcePackChunkDataPacket" {
    declare const ResourcePackChunkDataPacket = cn.nukkit.network.protocol.ResourcePackChunkDataPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class InitiateWebSocketConnectionPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string

    }
}

declare module "cn.nukkit.network.protocol.InitiateWebSocketConnectionPacket" {
    declare const InitiateWebSocketConnectionPacket = cn.nukkit.network.protocol.InitiateWebSocketConnectionPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class CameraShakePacket$CameraShakeType extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.CameraShakePacket$CameraShakeType[]
        public static valueOf(name: string): cn.nukkit.network.protocol.CameraShakePacket$CameraShakeType
        constructor(): void
        static $values(): cn.nukkit.network.protocol.CameraShakePacket$CameraShakeType[]
        public static POSITIONAL: cn.nukkit.network.protocol.CameraShakePacket$CameraShakeType
        public static ROTATIONAL: cn.nukkit.network.protocol.CameraShakePacket$CameraShakeType
        static $VALUES: cn.nukkit.network.protocol.CameraShakePacket$CameraShakeType[]

    }
}

declare module "cn.nukkit.network.protocol.CameraShakePacket$CameraShakeType" {
    declare const CameraShakePacket$CameraShakeType = cn.nukkit.network.protocol.CameraShakePacket$CameraShakeType;
}

declare namespace cn.nukkit.network.protocol {
    declare class FilterTextPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public constructor(text: string, fromServer: boolean): void
        public pid(): byte
        public encode(): void
        public decode(): void
        public getText(): string
        public setText(text: string): void
        public isFromServer(): boolean
        public setFromServer(fromServer: boolean): void
        public toString(): string
        public static NETWORK_ID: byte
        public text: string
        public fromServer: boolean

    }
}

declare module "cn.nukkit.network.protocol.FilterTextPacket" {
    declare const FilterTextPacket = cn.nukkit.network.protocol.FilterTextPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PlayerInputPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public motionX: float
        public motionY: float
        public jumping: boolean
        public sneaking: boolean

    }
}

declare module "cn.nukkit.network.protocol.PlayerInputPacket" {
    declare const PlayerInputPacket = cn.nukkit.network.protocol.PlayerInputPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ResourcePackDataInfoPacket extends cn.nukkit.network.protocol.AbstractResourcePackDataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public getPackVersion(): org.powernukkit.version.Version
        public setPackVersion(packVersion: org.powernukkit.version.Version): void
        public getPackId(): java.util.UUID
        public setPackId(packId: java.util.UUID): void
        public toString(): string
        public static NETWORK_ID: byte
        public static TYPE_INVALID: int
        public static TYPE_ADDON: int
        public static TYPE_CACHED: int
        public static TYPE_COPY_PROTECTED: int
        public static TYPE_BEHAVIOR: int
        public static TYPE_PERSONA_PIECE: int
        public static TYPE_RESOURCE: int
        public static TYPE_SKINS: int
        public static TYPE_WORLD_TEMPLATE: int
        public static TYPE_COUNT: int
        public packId: java.util.UUID
        packVersion: org.powernukkit.version.Version
        public maxChunkSize: int
        public chunkCount: int
        public compressedPackSize: long
        public sha256: byte[]
        public premium: boolean
        public type: int

    }
}

declare module "cn.nukkit.network.protocol.ResourcePackDataInfoPacket" {
    declare const ResourcePackDataInfoPacket = cn.nukkit.network.protocol.ResourcePackDataInfoPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetScoreboardIdentityPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        entries: java.util.List<cn.nukkit.network.protocol.SetScoreboardIdentityPacket$Entry>
        action: cn.nukkit.network.protocol.SetScoreboardIdentityPacket$Action

    }
}

declare module "cn.nukkit.network.protocol.SetScoreboardIdentityPacket" {
    declare const SetScoreboardIdentityPacket = cn.nukkit.network.protocol.SetScoreboardIdentityPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class MobEquipmentPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public eid: long
        public item: cn.nukkit.item.Item
        public inventorySlot: int
        public hotbarSlot: int
        public windowId: int

    }
}

declare module "cn.nukkit.network.protocol.MobEquipmentPacket" {
    declare const MobEquipmentPacket = cn.nukkit.network.protocol.MobEquipmentPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class LoginPacket$1 extends com.google.gson.reflect.TypeToken {
        constructor(this$0: cn.nukkit.network.protocol.LoginPacket): void
        this$0: cn.nukkit.network.protocol.LoginPacket

    }
}

declare module "cn.nukkit.network.protocol.LoginPacket$1" {
    declare const LoginPacket$1 = cn.nukkit.network.protocol.LoginPacket$1;
}

declare namespace cn.nukkit.network.protocol {
    declare class RequestChunkRadiusPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public radius: int

    }
}

declare module "cn.nukkit.network.protocol.RequestChunkRadiusPacket" {
    declare const RequestChunkRadiusPacket = cn.nukkit.network.protocol.RequestChunkRadiusPacket;
}

declare namespace cn.nukkit.potion {
    declare class Effect extends java.lang.Object implements java.lang.Cloneable {
        public static init(): void
        public static getEffect(id: int): cn.nukkit.potion.Effect
        public static getEffectByName(name: string): cn.nukkit.potion.Effect
        public constructor(id: int, name: string, r: int, g: int, b: int): void
        public constructor(id: int, name: string, r: int, g: int, b: int, isBad: boolean): void
        public getName(): string
        public getId(): int
        public setDuration(ticks: int): cn.nukkit.potion.Effect
        public getDuration(): int
        public isVisible(): boolean
        public setVisible(visible: boolean): cn.nukkit.potion.Effect
        public getAmplifier(): int
        public setAmplifier(amplifier: int): cn.nukkit.potion.Effect
        public isAmbient(): boolean
        public setAmbient(ambient: boolean): cn.nukkit.potion.Effect
        public isBad(): boolean
        public canTick(): boolean
        public applyEffect(entity: cn.nukkit.entity.Entity): void
        public getColor(): int[]
        public setColor(r: int, g: int, b: int): void
        public add(entity: cn.nukkit.entity.Entity): void
        public remove(entity: cn.nukkit.entity.Entity): void
        public clone(): cn.nukkit.potion.Effect
        public clone(): java.lang.Object
        public static SPEED: int
        public static SLOWNESS: int
        public static HASTE: int
        public static SWIFTNESS: int
        public static FATIGUE: int
        public static MINING_FATIGUE: int
        public static STRENGTH: int
        public static INSTANT_HEALTH: int
        public static HEALING: int
        public static INSTANT_DAMAGE: int
        public static HARMING: int
        public static JUMP_BOOST: int
        public static JUMP: int
        public static NAUSEA: int
        public static CONFUSION: int
        public static REGENERATION: int
        public static RESISTANCE: int
        public static DAMAGE_RESISTANCE: int
        public static FIRE_RESISTANCE: int
        public static WATER_BREATHING: int
        public static INVISIBILITY: int
        public static BLINDNESS: int
        public static NIGHT_VISION: int
        public static HUNGER: int
        public static WEAKNESS: int
        public static POISON: int
        public static WITHER: int
        public static HEALTH_BOOST: int
        public static ABSORPTION: int
        public static SATURATION: int
        public static LEVITATION: int
        public static FATAL_POISON: int
        public static CONDUIT_POWER: int
        public static COUNDIT_POWER: int
        public static SLOW_FALLING: int
        public static BAD_OMEN: int
        public static VILLAGE_HERO: int
        public static DARKNESS: int
        static effects: cn.nukkit.potion.Effect[]
        id: int
        name: string
        duration: int
        amplifier: int
        color: int
        show: boolean
        ambient: boolean
        bad: boolean

    }
}

declare module "cn.nukkit.potion.Effect" {
    declare const Effect = cn.nukkit.potion.Effect;
}

declare namespace cn.nukkit.resourcepacks {
    declare interface ResourcePack {
        public getPackName(): string
        public getPackId(): java.util.UUID
        public getPackVersion(): string
        public getPackSize(): int
        public getSha256(): byte[]
        public getPackChunk(var0: int, var1: int): byte[]
        public static EMPTY_ARRAY: cn.nukkit.resourcepacks.ResourcePack[]

    }
}

declare module "cn.nukkit.resourcepacks.ResourcePack" {
    declare type ResourcePack = cn.nukkit.resourcepacks.ResourcePack;
}

declare namespace cn.nukkit.resourcepacks {
    declare class ResourcePackManager extends java.lang.Object {
        public constructor(path: java.io.File): void
        public getResourceStack(): cn.nukkit.resourcepacks.ResourcePack[]
        public getPackById(id: java.util.UUID): cn.nukkit.resourcepacks.ResourcePack
        public getMaxChunkSize(): int
        public setMaxChunkSize(size: int): void
        static log: org.apache.logging.log4j.Logger
        maxChunkSize: int
        resourcePacksById: java.util.Map<java.util.UUID, cn.nukkit.resourcepacks.ResourcePack>
        resourcePacks: cn.nukkit.resourcepacks.ResourcePack[]

    }
}

declare module "cn.nukkit.resourcepacks.ResourcePackManager" {
    declare const ResourcePackManager = cn.nukkit.resourcepacks.ResourcePackManager;
}

declare namespace cn.nukkit.resourcepacks {
    declare class AbstractResourcePack extends java.lang.Object implements cn.nukkit.resourcepacks.ResourcePack {
        public constructor(): void
        verifyManifest(): boolean
        public getPackName(): string
        public getPackId(): java.util.UUID
        public getPackVersion(): string
        manifest: com.google.gson.JsonObject
        id: java.util.UUID

    }
}

declare module "cn.nukkit.resourcepacks.AbstractResourcePack" {
    declare const AbstractResourcePack = cn.nukkit.resourcepacks.AbstractResourcePack;
}

declare namespace cn.nukkit.metadata {
    declare class EntityMetadataStore extends cn.nukkit.metadata.MetadataStore {
        public constructor(): void
        disambiguate(entity: cn.nukkit.metadata.Metadatable, metadataKey: string): string

    }
}

declare module "cn.nukkit.metadata.EntityMetadataStore" {
    declare const EntityMetadataStore = cn.nukkit.metadata.EntityMetadataStore;
}

declare namespace cn.nukkit.metadata {
    declare class PlayerMetadataStore extends cn.nukkit.metadata.MetadataStore {
        public constructor(): void
        disambiguate(player: cn.nukkit.metadata.Metadatable, metadataKey: string): string

    }
}

declare module "cn.nukkit.metadata.PlayerMetadataStore" {
    declare const PlayerMetadataStore = cn.nukkit.metadata.PlayerMetadataStore;
}

declare namespace cn.nukkit.metadata {
    declare class MetadataValue extends java.lang.Object {
        constructor(owningPlugin: cn.nukkit.plugin.Plugin): void
        public getOwningPlugin(): cn.nukkit.plugin.Plugin
        public value(): java.lang.Object
        public invalidate(): void
        owningPlugin: java.lang.ref.WeakReference<cn.nukkit.plugin.Plugin>

    }
}

declare module "cn.nukkit.metadata.MetadataValue" {
    declare const MetadataValue = cn.nukkit.metadata.MetadataValue;
}

declare namespace cn.nukkit.metadata {
    declare interface Metadatable {
        public setMetadata(var0: string, var1: cn.nukkit.metadata.MetadataValue): void
        public getMetadata(var0: string): java.util.List<cn.nukkit.metadata.MetadataValue>
        public hasMetadata(var0: string): boolean
        public removeMetadata(var0: string, var1: cn.nukkit.plugin.Plugin): void

    }
}

declare module "cn.nukkit.metadata.Metadatable" {
    declare type Metadatable = cn.nukkit.metadata.Metadatable;
}

declare namespace cn.nukkit.metadata {
    declare class BlockMetadataStore extends cn.nukkit.metadata.MetadataStore {
        public constructor(owningLevel: cn.nukkit.level.Level): void
        disambiguate(block: cn.nukkit.metadata.Metadatable, metadataKey: string): string
        public getMetadata(block: java.lang.Object, metadataKey: string): java.util.List<cn.nukkit.metadata.MetadataValue>
        public hasMetadata(block: java.lang.Object, metadataKey: string): boolean
        public removeMetadata(block: java.lang.Object, metadataKey: string, owningPlugin: cn.nukkit.plugin.Plugin): void
        public setMetadata(block: java.lang.Object, metadataKey: string, newMetadataValue: cn.nukkit.metadata.MetadataValue): void
        owningLevel: cn.nukkit.level.Level

    }
}

declare module "cn.nukkit.metadata.BlockMetadataStore" {
    declare const BlockMetadataStore = cn.nukkit.metadata.BlockMetadataStore;
}

declare namespace cn.nukkit.dialog.element {
    declare class ElementDialogButton$Mode extends java.lang.Enum {
        public static values(): cn.nukkit.dialog.element.ElementDialogButton$Mode[]
        public static valueOf(name: string): cn.nukkit.dialog.element.ElementDialogButton$Mode
        constructor(): void
        static $values(): cn.nukkit.dialog.element.ElementDialogButton$Mode[]
        public static BUTTON_MODE: cn.nukkit.dialog.element.ElementDialogButton$Mode
        public static ON_EXIT: cn.nukkit.dialog.element.ElementDialogButton$Mode
        public static ON_ENTER: cn.nukkit.dialog.element.ElementDialogButton$Mode
        static $VALUES: cn.nukkit.dialog.element.ElementDialogButton$Mode[]

    }
}

declare module "cn.nukkit.dialog.element.ElementDialogButton$Mode" {
    declare const ElementDialogButton$Mode = cn.nukkit.dialog.element.ElementDialogButton$Mode;
}

declare namespace cn.nukkit.dialog.element {
    declare class ElementDialogButton$CmdLine extends java.lang.Object {
        public constructor(cmd_line: string, cmd_ver: int): void
        public cmd_line: string
        public cmd_ver: int
        public static CMD_VER: int

    }
}

declare module "cn.nukkit.dialog.element.ElementDialogButton$CmdLine" {
    declare const ElementDialogButton$CmdLine = cn.nukkit.dialog.element.ElementDialogButton$CmdLine;
}

declare namespace cn.nukkit.dialog.element {
    declare class ElementDialogButton extends java.lang.Object {
        public constructor(name: string, text: string): void
        public constructor(name: string, text: string, nextDialog: cn.nukkit.dialog.window.Dialog): void
        public constructor(name: string, text: string, nextDialog: cn.nukkit.dialog.window.Dialog, mode: cn.nukkit.dialog.element.ElementDialogButton$Mode): void
        public constructor(name: string, text: string, nextDialog: cn.nukkit.dialog.window.Dialog, mode: cn.nukkit.dialog.element.ElementDialogButton$Mode, type: int): void
        public updateButtonData(): java.util.List<cn.nukkit.dialog.element.ElementDialogButton$CmdLine>
        public getName(): string
        public setName(name: string): void
        public getText(): string
        public setText(text: string): void
        public getData(): java.util.List<cn.nukkit.dialog.element.ElementDialogButton$CmdLine>
        public getMode(): cn.nukkit.dialog.element.ElementDialogButton$Mode
        public setMode(mode: cn.nukkit.dialog.element.ElementDialogButton$Mode): void
        public getType(): int
        public setType(type: int): void
        public getNextDialog(): cn.nukkit.dialog.window.Dialog
        public setNextDialog(nextDialog: cn.nukkit.dialog.window.Dialog): void
        button_name: string
        text: string
        data: java.util.List<cn.nukkit.dialog.element.ElementDialogButton$CmdLine>
        nextDialog: cn.nukkit.dialog.window.Dialog
        mode: int
        type: int

    }
}

declare module "cn.nukkit.dialog.element.ElementDialogButton" {
    declare const ElementDialogButton = cn.nukkit.dialog.element.ElementDialogButton;
}

declare namespace cn.nukkit.dialog.handler {
    declare interface FormDialogHandler {
        public static withoutPlayer(responseConsumer: java.util.function.Consumer<cn.nukkit.dialog.response.FormResponseDialog>): cn.nukkit.dialog.handler.FormDialogHandler
        public handle(var0: cn.nukkit.Player, var1: cn.nukkit.dialog.response.FormResponseDialog): void
        static lambda$withoutPlayer$0(responseConsumer: java.util.function.Consumer, player: cn.nukkit.Player, response: cn.nukkit.dialog.response.FormResponseDialog): void

    }
}

declare module "cn.nukkit.dialog.handler.FormDialogHandler" {
    declare type FormDialogHandler = cn.nukkit.dialog.handler.FormDialogHandler;
}

declare namespace cn.nukkit.dialog.response {
    declare class FormResponseDialog extends java.lang.Object {
        public constructor(packet: cn.nukkit.network.protocol.NPCRequestPacket, dialog: cn.nukkit.dialog.window.FormWindowDialog): void
        public getEntityRuntimeId(): long
        public getData(): string
        public getClickedButton(): cn.nukkit.dialog.element.ElementDialogButton
        public getSceneName(): string
        public getRequestType(): cn.nukkit.network.protocol.NPCRequestPacket$RequestType
        public getSkinType(): int
        entityRuntimeId: long
        data: string
        clickedButton: cn.nukkit.dialog.element.ElementDialogButton
        sceneName: string
        requestType: cn.nukkit.network.protocol.NPCRequestPacket$RequestType
        skinType: int

    }
}

declare module "cn.nukkit.dialog.response.FormResponseDialog" {
    declare const FormResponseDialog = cn.nukkit.dialog.response.FormResponseDialog;
}

declare namespace cn.nukkit.dialog.window {
    declare class ScrollingTextDialog extends java.lang.Object implements cn.nukkit.dialog.window.Dialog {
        public constructor(player: cn.nukkit.Player, dialog: cn.nukkit.dialog.window.FormWindowDialog): void
        public constructor(player: cn.nukkit.Player, dialog: cn.nukkit.dialog.window.FormWindowDialog, scrollingSpeed: int): void
        public getPlayer(): cn.nukkit.Player
        public setPlayer(player: cn.nukkit.Player): void
        public getDialog(): cn.nukkit.dialog.window.FormWindowDialog
        public setDialog(dialog: cn.nukkit.dialog.window.FormWindowDialog): void
        public getScrollingSpeed(): int
        public setScrollingSpeed(scrollingSpeed: int): void
        public isScrolling(): boolean
        public stopScrolling(): void
        public setScrolling(scrolling: boolean): void
        public getCursor(): int
        public setCursor(cursor: int): void
        public startScrolling(): void
        public send(p: cn.nukkit.Player): void
        player: cn.nukkit.Player
        dialog: cn.nukkit.dialog.window.FormWindowDialog
        scrollingSpeed: int
        scrolling: boolean
        cursor: int
        scrollingTask: cn.nukkit.scheduler.Task

    }
}

declare module "cn.nukkit.dialog.window.ScrollingTextDialog" {
    declare const ScrollingTextDialog = cn.nukkit.dialog.window.ScrollingTextDialog;
}

declare namespace cn.nukkit.dialog.window {
    declare interface Dialog {
        public send(var0: cn.nukkit.Player): void

    }
}

declare module "cn.nukkit.dialog.window.Dialog" {
    declare type Dialog = cn.nukkit.dialog.window.Dialog;
}

declare namespace cn.nukkit.dialog.window {
    declare class FormWindowDialog$1 extends com.google.common.reflect.TypeToken {
        constructor(this$0: cn.nukkit.dialog.window.FormWindowDialog): void
        this$0: cn.nukkit.dialog.window.FormWindowDialog

    }
}

declare module "cn.nukkit.dialog.window.FormWindowDialog$1" {
    declare const FormWindowDialog$1 = cn.nukkit.dialog.window.FormWindowDialog$1;
}

declare namespace cn.nukkit.dialog.window {
    declare class FormWindowDialog extends java.lang.Object implements cn.nukkit.dialog.window.Dialog {
        public constructor(title: string, content: string, bindEntity: cn.nukkit.entity.Entity): void
        public constructor(title: string, content: string, bindEntity: cn.nukkit.entity.Entity, buttons: java.util.List<cn.nukkit.dialog.element.ElementDialogButton>): void
        public getTitle(): string
        public setTitle(title: string): void
        public getContent(): string
        public setContent(content: string): void
        public getButtons(): java.util.List<cn.nukkit.dialog.element.ElementDialogButton>
        public setButtons(buttons: java.util.List<cn.nukkit.dialog.element.ElementDialogButton>): void
        public addButton(text: string): void
        public addButton(button: cn.nukkit.dialog.element.ElementDialogButton): void
        public getEntityId(): long
        public getBindEntity(): cn.nukkit.entity.Entity
        public setBindEntity(bindEntity: cn.nukkit.entity.Entity): void
        public getSkinData(): string
        public setSkinData(data: string): void
        public addHandler(handler: cn.nukkit.dialog.handler.FormDialogHandler): void
        public getHandlers(): java.util.List<cn.nukkit.dialog.handler.FormDialogHandler>
        public getButtonJSONData(): string
        public setButtonJSONData(json: string): void
        public getSceneName(): string
        setSceneName(sceneName: string): void
        public updateSceneName(): void
        public send(player: cn.nukkit.Player): void
        static GSON: com.google.gson.Gson
        static dialogId: long
        title: string
        content: string
        skinData: string
        sceneName: string
        buttons: java.util.List<cn.nukkit.dialog.element.ElementDialogButton>
        bindEntity: cn.nukkit.entity.Entity
        handlers: java.util.List<cn.nukkit.dialog.handler.FormDialogHandler>

    }
}

declare module "cn.nukkit.dialog.window.FormWindowDialog" {
    declare const FormWindowDialog = cn.nukkit.dialog.window.FormWindowDialog;
}

declare namespace cn.nukkit.dialog.window {
    declare class ScrollingTextDialog$ScrollingRunner extends cn.nukkit.scheduler.Task {
        constructor(var0: cn.nukkit.dialog.window.ScrollingTextDialog): void
        public onRun(currentTick: int): void
        clone: cn.nukkit.dialog.window.FormWindowDialog
        this$0: cn.nukkit.dialog.window.ScrollingTextDialog

    }
}

declare module "cn.nukkit.dialog.window.ScrollingTextDialog$ScrollingRunner" {
    declare const ScrollingTextDialog$ScrollingRunner = cn.nukkit.dialog.window.ScrollingTextDialog$ScrollingRunner;
}

declare namespace cn.nukkit {
    declare interface IPlayer extends cn.nukkit.permission.ServerOperator, cn.nukkit.metadata.Metadatable {
        public isOnline(): boolean
        public getName(): string
        public getUniqueId(): java.util.UUID
        public isBanned(): boolean
        public setBanned(var0: boolean): void
        public isWhitelisted(): boolean
        public setWhitelisted(var0: boolean): void
        public getPlayer(): cn.nukkit.Player
        public getServer(): cn.nukkit.Server
        public getFirstPlayed(): long
        public getLastPlayed(): long
        public hasPlayedBefore(): boolean

    }
}

declare module "cn.nukkit.IPlayer" {
    declare type IPlayer = cn.nukkit.IPlayer;
}

declare namespace cn.nukkit.event {
    declare class Event extends java.lang.Object {
        public constructor(): void
        public getEventName(): string
        public isCancelled(): boolean
        public setCancelled(): void
        public setCancelled(value: boolean): void
        eventName: string
        isCancelled: boolean

    }
}

declare module "cn.nukkit.event.Event" {
    declare const Event = cn.nukkit.event.Event;
}

declare namespace cn.nukkit.event.command {
    declare class ScoreboardEvent extends cn.nukkit.event.Event implements cn.nukkit.event.Cancellable {
        public constructor(scoreboard: cn.nukkit.scoreboard.Scoreboard): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        public getScoreboard(): cn.nukkit.scoreboard.Scoreboard
        static handlers: cn.nukkit.event.HandlerList
        scoreboard: cn.nukkit.scoreboard.Scoreboard

    }
}

declare module "cn.nukkit.event.command.ScoreboardEvent" {
    declare const ScoreboardEvent = cn.nukkit.event.command.ScoreboardEvent;
}

declare namespace cn.nukkit.event.command {
    declare class ScoreboardObjectiveChangeEvent$ActionType extends java.lang.Enum {
        public static values(): cn.nukkit.event.command.ScoreboardObjectiveChangeEvent$ActionType[]
        public static valueOf(name: string): cn.nukkit.event.command.ScoreboardObjectiveChangeEvent$ActionType
        constructor(): void
        static $values(): cn.nukkit.event.command.ScoreboardObjectiveChangeEvent$ActionType[]
        public static ADD: cn.nukkit.event.command.ScoreboardObjectiveChangeEvent$ActionType
        public static REMOVE: cn.nukkit.event.command.ScoreboardObjectiveChangeEvent$ActionType
        static $VALUES: cn.nukkit.event.command.ScoreboardObjectiveChangeEvent$ActionType[]

    }
}

declare module "cn.nukkit.event.command.ScoreboardObjectiveChangeEvent$ActionType" {
    declare const ScoreboardObjectiveChangeEvent$ActionType = cn.nukkit.event.command.ScoreboardObjectiveChangeEvent$ActionType;
}

declare namespace cn.nukkit.event.command {
    declare class ScoreboardScoreChangeEvent extends cn.nukkit.event.command.ScoreboardEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(scoreboard: cn.nukkit.scoreboard.Scoreboard, scorer: cn.nukkit.scoreboard.interfaces.Scorer, newValue: int, oldValue: int): void
        public constructor(scoreboard: cn.nukkit.scoreboard.Scoreboard, scorer: cn.nukkit.scoreboard.interfaces.Scorer, newValue: int, oldValue: int, actionType: cn.nukkit.event.command.ScoreboardScoreChangeEvent$ActionType): void
        public getScorer(): cn.nukkit.scoreboard.interfaces.Scorer
        public getNewValue(): int
        public setNewValue(newValue: int): void
        public getOldValue(): int
        public setOldValue(oldValue: int): void
        public getActionType(): cn.nukkit.event.command.ScoreboardScoreChangeEvent$ActionType
        static handlers: cn.nukkit.event.HandlerList
        scorer: cn.nukkit.scoreboard.interfaces.Scorer
        newValue: int
        oldValue: int
        actionType: cn.nukkit.event.command.ScoreboardScoreChangeEvent$ActionType

    }
}

declare module "cn.nukkit.event.command.ScoreboardScoreChangeEvent" {
    declare const ScoreboardScoreChangeEvent = cn.nukkit.event.command.ScoreboardScoreChangeEvent;
}

declare namespace cn.nukkit.event.command {
    declare class ScoreboardObjectiveChangeEvent extends cn.nukkit.event.command.ScoreboardEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(scoreboard: cn.nukkit.scoreboard.Scoreboard, actionType: cn.nukkit.event.command.ScoreboardObjectiveChangeEvent$ActionType): void
        public getActionType(): cn.nukkit.event.command.ScoreboardObjectiveChangeEvent$ActionType
        static handlers: cn.nukkit.event.HandlerList
        actionType: cn.nukkit.event.command.ScoreboardObjectiveChangeEvent$ActionType

    }
}

declare module "cn.nukkit.event.command.ScoreboardObjectiveChangeEvent" {
    declare const ScoreboardObjectiveChangeEvent = cn.nukkit.event.command.ScoreboardObjectiveChangeEvent;
}

declare namespace cn.nukkit.event.command {
    declare class CommandBlockExecuteEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public constructor(block: cn.nukkit.block.Block, command: string): void
        public getCommand(): string
        public setCommand(command: string): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        static handlers: cn.nukkit.event.HandlerList
        command: string

    }
}

declare module "cn.nukkit.event.command.CommandBlockExecuteEvent" {
    declare const CommandBlockExecuteEvent = cn.nukkit.event.command.CommandBlockExecuteEvent;
}

declare namespace cn.nukkit.event.command {
    declare class ScoreboardScoreChangeEvent$ActionType extends java.lang.Enum {
        public static values(): cn.nukkit.event.command.ScoreboardScoreChangeEvent$ActionType[]
        public static valueOf(name: string): cn.nukkit.event.command.ScoreboardScoreChangeEvent$ActionType
        constructor(): void
        static $values(): cn.nukkit.event.command.ScoreboardScoreChangeEvent$ActionType[]
        public static CHANGE: cn.nukkit.event.command.ScoreboardScoreChangeEvent$ActionType
        public static REMOVE: cn.nukkit.event.command.ScoreboardScoreChangeEvent$ActionType
        public static ADD: cn.nukkit.event.command.ScoreboardScoreChangeEvent$ActionType
        static $VALUES: cn.nukkit.event.command.ScoreboardScoreChangeEvent$ActionType[]

    }
}

declare module "cn.nukkit.event.command.ScoreboardScoreChangeEvent$ActionType" {
    declare const ScoreboardScoreChangeEvent$ActionType = cn.nukkit.event.command.ScoreboardScoreChangeEvent$ActionType;
}

declare namespace cn.nukkit.event {
    declare interface Cancellable {
        public isCancelled(): boolean
        public setCancelled(): void
        public setCancelled(var0: boolean): void

    }
}

declare module "cn.nukkit.event.Cancellable" {
    declare type Cancellable = cn.nukkit.event.Cancellable;
}

declare namespace cn.nukkit.event.blockstate {
    declare class BlockStateRepairEvent extends cn.nukkit.event.Event {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(repair: cn.nukkit.blockstate.BlockStateRepair): void
        public getRepair(): cn.nukkit.blockstate.BlockStateRepair
        static handlers: cn.nukkit.event.HandlerList
        repair: cn.nukkit.blockstate.BlockStateRepair

    }
}

declare module "cn.nukkit.event.blockstate.BlockStateRepairEvent" {
    declare const BlockStateRepairEvent = cn.nukkit.event.blockstate.BlockStateRepairEvent;
}

declare namespace cn.nukkit.event.vehicle {
    declare class VehicleEvent extends cn.nukkit.event.Event {
        public constructor(vehicle: cn.nukkit.entity.Entity): void
        public getVehicle(): cn.nukkit.entity.Entity
        vehicle: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.event.vehicle.VehicleEvent" {
    declare const VehicleEvent = cn.nukkit.event.vehicle.VehicleEvent;
}

declare namespace cn.nukkit.event.vehicle {
    declare class EntityEnterVehicleEvent extends cn.nukkit.event.vehicle.VehicleEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(riding: cn.nukkit.entity.Entity, vehicle: cn.nukkit.entity.Entity): void
        public getEntity(): cn.nukkit.entity.Entity
        public isPlayer(): boolean
        static handlers: cn.nukkit.event.HandlerList
        riding: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.event.vehicle.EntityEnterVehicleEvent" {
    declare const EntityEnterVehicleEvent = cn.nukkit.event.vehicle.EntityEnterVehicleEvent;
}

declare namespace cn.nukkit.event.vehicle {
    declare class VehicleDamageByEntityEvent extends cn.nukkit.event.vehicle.VehicleDamageEvent implements cn.nukkit.event.Cancellable {
        public constructor(vehicle: cn.nukkit.entity.item.EntityVehicle, attacker: cn.nukkit.entity.Entity, damage: double): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        public getAttacker(): cn.nukkit.entity.Entity
        static handlers: cn.nukkit.event.HandlerList
        attacker: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.event.vehicle.VehicleDamageByEntityEvent" {
    declare const VehicleDamageByEntityEvent = cn.nukkit.event.vehicle.VehicleDamageByEntityEvent;
}

declare namespace cn.nukkit.event.vehicle {
    declare class VehicleCreateEvent extends cn.nukkit.event.vehicle.VehicleEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(vehicle: cn.nukkit.entity.Entity): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.vehicle.VehicleCreateEvent" {
    declare const VehicleCreateEvent = cn.nukkit.event.vehicle.VehicleCreateEvent;
}

declare namespace cn.nukkit.event.vehicle {
    declare class VehicleDestroyEvent extends cn.nukkit.event.vehicle.VehicleEvent implements cn.nukkit.event.Cancellable {
        public constructor(vehicle: cn.nukkit.entity.Entity): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.vehicle.VehicleDestroyEvent" {
    declare const VehicleDestroyEvent = cn.nukkit.event.vehicle.VehicleDestroyEvent;
}

declare namespace cn.nukkit.event.weather {
    declare class LightningStrikeEvent extends cn.nukkit.event.level.WeatherEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(level: cn.nukkit.level.Level, bolt: cn.nukkit.entity.weather.EntityLightningStrike): void
        public getLightning(): cn.nukkit.entity.weather.EntityLightningStrike
        static handlers: cn.nukkit.event.HandlerList
        bolt: cn.nukkit.entity.weather.EntityLightningStrike

    }
}

declare module "cn.nukkit.event.weather.LightningStrikeEvent" {
    declare const LightningStrikeEvent = cn.nukkit.event.weather.LightningStrikeEvent;
}

declare namespace cn.nukkit.event.block {
    declare class LeavesDecayEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.block.LeavesDecayEvent" {
    declare const LeavesDecayEvent = cn.nukkit.event.block.LeavesDecayEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BellRingEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(bell: cn.nukkit.block.BlockBell, cause: cn.nukkit.event.block.BellRingEvent$RingCause, entity: cn.nukkit.entity.Entity): void
        public getBlock(): cn.nukkit.block.BlockBell
        public getEntity(): cn.nukkit.entity.Entity
        public getCause(): cn.nukkit.event.block.BellRingEvent$RingCause
        public getBlock(): cn.nukkit.block.Block
        static handlers: cn.nukkit.event.HandlerList
        cause: cn.nukkit.event.block.BellRingEvent$RingCause
        entity: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.event.block.BellRingEvent" {
    declare const BellRingEvent = cn.nukkit.event.block.BellRingEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockFallEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.block.BlockFallEvent" {
    declare const BlockFallEvent = cn.nukkit.event.block.BlockFallEvent;
}

declare namespace cn.nukkit.event.block {
    declare class ItemFrameDropItemEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public constructor(player: cn.nukkit.Player, block: cn.nukkit.block.Block, itemFrame: cn.nukkit.blockentity.BlockEntityItemFrame, item: cn.nukkit.item.Item): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        public getPlayer(): cn.nukkit.Player
        public getItemFrame(): cn.nukkit.blockentity.BlockEntityItemFrame
        public getItem(): cn.nukkit.item.Item
        static handlers: cn.nukkit.event.HandlerList
        player: cn.nukkit.Player
        item: cn.nukkit.item.Item
        itemFrame: cn.nukkit.blockentity.BlockEntityItemFrame

    }
}

declare module "cn.nukkit.event.block.ItemFrameDropItemEvent" {
    declare const ItemFrameDropItemEvent = cn.nukkit.event.block.ItemFrameDropItemEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockPlaceEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, blockPlace: cn.nukkit.block.Block, blockReplace: cn.nukkit.block.Block, blockAgainst: cn.nukkit.block.Block, item: cn.nukkit.item.Item): void
        public getPlayer(): cn.nukkit.Player
        public getItem(): cn.nukkit.item.Item
        public getBlockReplace(): cn.nukkit.block.Block
        public getBlockAgainst(): cn.nukkit.block.Block
        static handlers: cn.nukkit.event.HandlerList
        player: cn.nukkit.Player
        item: cn.nukkit.item.Item
        blockReplace: cn.nukkit.block.Block
        blockAgainst: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.event.block.BlockPlaceEvent" {
    declare const BlockPlaceEvent = cn.nukkit.event.block.BlockPlaceEvent;
}

declare namespace cn.nukkit.event.block {
    declare class LiquidFlowEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(to: cn.nukkit.block.Block, source: cn.nukkit.block.BlockLiquid, newFlowDecay: int): void
        public getNewFlowDecay(): int
        public getSource(): cn.nukkit.block.BlockLiquid
        public getTo(): cn.nukkit.block.Block
        static handlers: cn.nukkit.event.HandlerList
        to: cn.nukkit.block.Block
        source: cn.nukkit.block.BlockLiquid
        newFlowDecay: int

    }
}

declare module "cn.nukkit.event.block.LiquidFlowEvent" {
    declare const LiquidFlowEvent = cn.nukkit.event.block.LiquidFlowEvent;
}

declare namespace cn.nukkit.event.block {
    declare class ConduitActivateEvent extends cn.nukkit.event.block.BlockEvent {
        public constructor(block: cn.nukkit.block.Block): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.block.ConduitActivateEvent" {
    declare const ConduitActivateEvent = cn.nukkit.event.block.ConduitActivateEvent;
}

declare namespace cn.nukkit.event.block {
    declare class LecternPlaceBookEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public constructor(player: cn.nukkit.Player, lectern: cn.nukkit.blockentity.BlockEntityLectern, book: cn.nukkit.item.Item): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        public getLectern(): cn.nukkit.blockentity.BlockEntityLectern
        public getPlayer(): cn.nukkit.Player
        public getBook(): cn.nukkit.item.Item
        public setBook(book: cn.nukkit.item.Item): void
        static handlers: cn.nukkit.event.HandlerList
        player: cn.nukkit.Player
        lectern: cn.nukkit.blockentity.BlockEntityLectern
        book: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.event.block.LecternPlaceBookEvent" {
    declare const LecternPlaceBookEvent = cn.nukkit.event.block.LecternPlaceBookEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockRedstoneEvent extends cn.nukkit.event.block.BlockEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, oldPower: int, newPower: int): void
        public getOldPower(): int
        public getNewPower(): int
        static handlers: cn.nukkit.event.HandlerList
        oldPower: int
        newPower: int

    }
}

declare module "cn.nukkit.event.block.BlockRedstoneEvent" {
    declare const BlockRedstoneEvent = cn.nukkit.event.block.BlockRedstoneEvent;
}

declare namespace cn.nukkit.event.block {
    declare class LecternDropBookEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public constructor(player: cn.nukkit.Player, lectern: cn.nukkit.blockentity.BlockEntityLectern, book: cn.nukkit.item.Item): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        public getLectern(): cn.nukkit.blockentity.BlockEntityLectern
        public getPlayer(): cn.nukkit.Player
        public getBook(): cn.nukkit.item.Item
        public setBook(book: cn.nukkit.item.Item): void
        static handlers: cn.nukkit.event.HandlerList
        player: cn.nukkit.Player
        lectern: cn.nukkit.blockentity.BlockEntityLectern
        book: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.event.block.LecternDropBookEvent" {
    declare const LecternDropBookEvent = cn.nukkit.event.block.LecternDropBookEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockFromToEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, to: cn.nukkit.block.Block): void
        public getFrom(): cn.nukkit.block.Block
        public getTo(): cn.nukkit.block.Block
        public setTo(newTo: cn.nukkit.block.Block): void
        static handlers: cn.nukkit.event.HandlerList
        to: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.event.block.BlockFromToEvent" {
    declare const BlockFromToEvent = cn.nukkit.event.block.BlockFromToEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockExplodeEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, position: cn.nukkit.level.Position, blocks: java.util.Set<cn.nukkit.block.Block>, ignitions: java.util.Set<cn.nukkit.block.Block>, yield: double, var5: double): void
        public getPosition(): cn.nukkit.level.Position
        public getAffectedBlocks(): java.util.Set<cn.nukkit.block.Block>
        public setAffectedBlocks(blocks: java.util.Set<cn.nukkit.block.Block>): void
        public getYield(): double
        public setYield(yield: double): void
        public getIgnitions(): java.util.Set<cn.nukkit.block.Block>
        public setIgnitions(ignitions: java.util.Set<cn.nukkit.block.Block>): void
        public getFireChance(): double
        static handlers: cn.nukkit.event.HandlerList
        position: cn.nukkit.level.Position
        blocks: java.util.Set<cn.nukkit.block.Block>
        ignitions: java.util.Set<cn.nukkit.block.Block>
        yield: double
        fireChance: double

    }
}

declare module "cn.nukkit.event.block.BlockExplodeEvent" {
    declare const BlockExplodeEvent = cn.nukkit.event.block.BlockExplodeEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockIgniteEvent$BlockIgniteCause extends java.lang.Enum {
        public static values(): cn.nukkit.event.block.BlockIgniteEvent$BlockIgniteCause[]
        public static valueOf(name: string): cn.nukkit.event.block.BlockIgniteEvent$BlockIgniteCause
        constructor(): void
        static $values(): cn.nukkit.event.block.BlockIgniteEvent$BlockIgniteCause[]
        public static EXPLOSION: cn.nukkit.event.block.BlockIgniteEvent$BlockIgniteCause
        public static FIREBALL: cn.nukkit.event.block.BlockIgniteEvent$BlockIgniteCause
        public static FLINT_AND_STEEL: cn.nukkit.event.block.BlockIgniteEvent$BlockIgniteCause
        public static LAVA: cn.nukkit.event.block.BlockIgniteEvent$BlockIgniteCause
        public static LIGHTNING: cn.nukkit.event.block.BlockIgniteEvent$BlockIgniteCause
        public static SPREAD: cn.nukkit.event.block.BlockIgniteEvent$BlockIgniteCause
        static $VALUES: cn.nukkit.event.block.BlockIgniteEvent$BlockIgniteCause[]

    }
}

declare module "cn.nukkit.event.block.BlockIgniteEvent$BlockIgniteCause" {
    declare const BlockIgniteEvent$BlockIgniteCause = cn.nukkit.event.block.BlockIgniteEvent$BlockIgniteCause;
}

declare namespace cn.nukkit.event.block {
    declare class ComposterFillEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public constructor(block: cn.nukkit.block.Block, player: cn.nukkit.Player, item: cn.nukkit.item.Item, chance: int, success: boolean): void
        public getPlayer(): cn.nukkit.Player
        public getItem(): cn.nukkit.item.Item
        public getChance(): int
        public isSuccess(): boolean
        public setSuccess(success: boolean): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        static handlers: cn.nukkit.event.HandlerList
        player: cn.nukkit.Player
        item: cn.nukkit.item.Item
        chance: int
        success: boolean

    }
}

declare module "cn.nukkit.event.block.ComposterFillEvent" {
    declare const ComposterFillEvent = cn.nukkit.event.block.ComposterFillEvent;
}

declare namespace cn.nukkit.event.block {
    declare class WaterFrostEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, entity: cn.nukkit.entity.Entity): void
        public getEntity(): cn.nukkit.entity.Entity
        static handlers: cn.nukkit.event.HandlerList
        entity: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.event.block.WaterFrostEvent" {
    declare const WaterFrostEvent = cn.nukkit.event.block.WaterFrostEvent;
}

declare namespace cn.nukkit.event.block {
    declare class AnvilDamageEvent$DamageCause extends java.lang.Enum {
        public static values(): cn.nukkit.event.block.AnvilDamageEvent$DamageCause[]
        public static valueOf(name: string): cn.nukkit.event.block.AnvilDamageEvent$DamageCause
        constructor(): void
        static $values(): cn.nukkit.event.block.AnvilDamageEvent$DamageCause[]
        public static USE: cn.nukkit.event.block.AnvilDamageEvent$DamageCause
        public static FALL: cn.nukkit.event.block.AnvilDamageEvent$DamageCause
        static $VALUES: cn.nukkit.event.block.AnvilDamageEvent$DamageCause[]

    }
}

declare module "cn.nukkit.event.block.AnvilDamageEvent$DamageCause" {
    declare const AnvilDamageEvent$DamageCause = cn.nukkit.event.block.AnvilDamageEvent$DamageCause;
}

declare namespace cn.nukkit.event.block {
    declare class BigDripleafTiltChangeEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, oldTilt: cn.nukkit.block.BlockBigDripleaf$Tilt, newTilt: cn.nukkit.block.BlockBigDripleaf$Tilt): void
        public getOldTilt(): cn.nukkit.block.BlockBigDripleaf$Tilt
        public getNewTilt(): cn.nukkit.block.BlockBigDripleaf$Tilt
        public setNewTilt(newTilt: cn.nukkit.block.BlockBigDripleaf$Tilt): void
        static handlers: cn.nukkit.event.HandlerList
        oldTilt: cn.nukkit.block.BlockBigDripleaf$Tilt
        newTilt: cn.nukkit.block.BlockBigDripleaf$Tilt

    }
}

declare module "cn.nukkit.event.block.BigDripleafTiltChangeEvent" {
    declare const BigDripleafTiltChangeEvent = cn.nukkit.event.block.BigDripleafTiltChangeEvent;
}

declare namespace cn.nukkit.event.block {
    declare class SignChangeEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, player: cn.nukkit.Player, lines: string[]): void
        public getPlayer(): cn.nukkit.Player
        public getLines(): string[]
        public getLine(index: int): string
        public setLine(index: int, line: string): void
        static handlers: cn.nukkit.event.HandlerList
        player: cn.nukkit.Player
        lines: string[]

    }
}

declare module "cn.nukkit.event.block.SignChangeEvent" {
    declare const SignChangeEvent = cn.nukkit.event.block.SignChangeEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockBreakEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, block: cn.nukkit.block.Block, item: cn.nukkit.item.Item, drops: cn.nukkit.item.Item[]): void
        public constructor(player: cn.nukkit.Player, block: cn.nukkit.block.Block, item: cn.nukkit.item.Item, drops: cn.nukkit.item.Item[], instaBreak: boolean): void
        public constructor(player: cn.nukkit.Player, block: cn.nukkit.block.Block, item: cn.nukkit.item.Item, drops: cn.nukkit.item.Item[], instaBreak: boolean, fastBreak: boolean): void
        public constructor(player: cn.nukkit.Player, block: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item, drops: cn.nukkit.item.Item[], instaBreak: boolean, fastBreak: boolean): void
        public getPlayer(): cn.nukkit.Player
        public getFace(): cn.nukkit.math.BlockFace
        public getItem(): cn.nukkit.item.Item
        public getInstaBreak(): boolean
        public getDrops(): cn.nukkit.item.Item[]
        public setDrops(drops: cn.nukkit.item.Item[]): void
        public getDropExp(): int
        public setDropExp(xp: int): void
        public setInstaBreak(instaBreak: boolean): void
        public isFastBreak(): boolean
        static handlers: cn.nukkit.event.HandlerList
        player: cn.nukkit.Player
        item: cn.nukkit.item.Item
        face: cn.nukkit.math.BlockFace
        instaBreak: boolean
        blockDrops: cn.nukkit.item.Item[]
        blockXP: int
        fastBreak: boolean

    }
}

declare module "cn.nukkit.event.block.BlockBreakEvent" {
    declare const BlockBreakEvent = cn.nukkit.event.block.BlockBreakEvent;
}

declare namespace cn.nukkit.event.block {
    declare class SignGlowEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, player: cn.nukkit.Player, glowing: boolean): void
        public getPlayer(): cn.nukkit.Player
        public isGlowing(): boolean
        static handlers: cn.nukkit.event.HandlerList
        player: cn.nukkit.Player
        glowing: boolean

    }
}

declare module "cn.nukkit.event.block.SignGlowEvent" {
    declare const SignGlowEvent = cn.nukkit.event.block.SignGlowEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockSpreadEvent extends cn.nukkit.event.block.BlockFormEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, source: cn.nukkit.block.Block, newState: cn.nukkit.block.Block): void
        public getSource(): cn.nukkit.block.Block
        static handlers: cn.nukkit.event.HandlerList
        source: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.event.block.BlockSpreadEvent" {
    declare const BlockSpreadEvent = cn.nukkit.event.block.BlockSpreadEvent;
}

declare namespace cn.nukkit.event.block {
    declare class SignColorChangeEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, player: cn.nukkit.Player, color: cn.nukkit.utils.BlockColor): void
        public getPlayer(): cn.nukkit.Player
        public getColor(): cn.nukkit.utils.BlockColor
        static handlers: cn.nukkit.event.HandlerList
        player: cn.nukkit.Player
        color: cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.event.block.SignColorChangeEvent" {
    declare const SignColorChangeEvent = cn.nukkit.event.block.SignColorChangeEvent;
}

declare namespace cn.nukkit.event.block {
    declare class AnvilDamageEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, oldDamage: int, newDamage: int, cause: cn.nukkit.event.block.AnvilDamageEvent$DamageCause, player: cn.nukkit.Player): void
        public constructor(block: cn.nukkit.block.Block, newState: cn.nukkit.block.Block, player: cn.nukkit.Player, transaction: cn.nukkit.inventory.transaction.CraftingTransaction, cause: cn.nukkit.event.block.AnvilDamageEvent$DamageCause): void
        public constructor(block: cn.nukkit.block.Block, newState: cn.nukkit.blockstate.BlockState, player: cn.nukkit.Player, transaction: cn.nukkit.inventory.transaction.CraftingTransaction, cause: cn.nukkit.event.block.AnvilDamageEvent$DamageCause): void
        public getTransaction(): cn.nukkit.inventory.transaction.CraftingTransaction
        public getDamageCause(): cn.nukkit.event.block.AnvilDamageEvent$DamageCause
        public getOldDamage(): int
        public getOldAnvilDamage(): cn.nukkit.blockproperty.value.AnvilDamage
        public getOldBlockState(): cn.nukkit.blockstate.BlockState
        public getNewBlockState(): cn.nukkit.blockstate.BlockState
        public getNewState(): cn.nukkit.block.Block
        public getNewDamage(): int
        public setNewBlockState(state: cn.nukkit.blockstate.BlockState): void
        public setNewDamage(newDamage: int): void
        public setNewState(block: cn.nukkit.block.Block): void
        public getCause(): cn.nukkit.event.block.AnvilDamageEvent$DamageCause
        public getPlayer(): cn.nukkit.Player
        static adjustBlock(block: cn.nukkit.block.Block, damage: int): cn.nukkit.block.Block
        static handlers: cn.nukkit.event.HandlerList
        player: cn.nukkit.Player
        transaction: cn.nukkit.inventory.transaction.CraftingTransaction
        cause: cn.nukkit.event.block.AnvilDamageEvent$DamageCause
        oldState: cn.nukkit.blockstate.BlockState
        newState: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.event.block.AnvilDamageEvent" {
    declare const AnvilDamageEvent = cn.nukkit.event.block.AnvilDamageEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class StartBrewEvent extends cn.nukkit.event.inventory.InventoryEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(blockEntity: cn.nukkit.blockentity.BlockEntityBrewingStand): void
        public getBrewingStand(): cn.nukkit.blockentity.BlockEntityBrewingStand
        public getIngredient(): cn.nukkit.item.Item
        public getPotions(): cn.nukkit.item.Item[]
        public getPotion(index: int): cn.nukkit.item.Item
        static handlers: cn.nukkit.event.HandlerList
        brewingStand: cn.nukkit.blockentity.BlockEntityBrewingStand
        ingredient: cn.nukkit.item.Item
        potions: cn.nukkit.item.Item[]

    }
}

declare module "cn.nukkit.event.inventory.StartBrewEvent" {
    declare const StartBrewEvent = cn.nukkit.event.inventory.StartBrewEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class SmithingTableEvent extends cn.nukkit.event.inventory.InventoryEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(inventory: cn.nukkit.inventory.SmithingInventory, equipmentItem: cn.nukkit.item.Item, resultItem: cn.nukkit.item.Item, ingredientItem: cn.nukkit.item.Item, player: cn.nukkit.Player): void
        public getEquipmentItem(): cn.nukkit.item.Item
        public getResultItem(): cn.nukkit.item.Item
        public getIngredientItem(): cn.nukkit.item.Item
        public getPlayer(): cn.nukkit.Player
        static handlers: cn.nukkit.event.HandlerList
        equipmentItem: cn.nukkit.item.Item
        resultItem: cn.nukkit.item.Item
        ingredientItem: cn.nukkit.item.Item
        player: cn.nukkit.Player

    }
}

declare module "cn.nukkit.event.inventory.SmithingTableEvent" {
    declare const SmithingTableEvent = cn.nukkit.event.inventory.SmithingTableEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class InventoryPickupArrowEvent extends cn.nukkit.event.inventory.InventoryEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(inventory: cn.nukkit.inventory.Inventory, arrow: cn.nukkit.entity.projectile.EntityArrow): void
        public getArrow(): cn.nukkit.entity.projectile.EntityArrow
        static handlers: cn.nukkit.event.HandlerList
        arrow: cn.nukkit.entity.projectile.EntityArrow

    }
}

declare module "cn.nukkit.event.inventory.InventoryPickupArrowEvent" {
    declare const InventoryPickupArrowEvent = cn.nukkit.event.inventory.InventoryPickupArrowEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class EnchantItemEvent extends cn.nukkit.event.inventory.InventoryEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(inventory: cn.nukkit.inventory.EnchantInventory, oldItem: cn.nukkit.item.Item, newItem: cn.nukkit.item.Item, cost: int, p: cn.nukkit.Player): void
        public getOldItem(): cn.nukkit.item.Item
        public setOldItem(oldItem: cn.nukkit.item.Item): void
        public getNewItem(): cn.nukkit.item.Item
        public setNewItem(newItem: cn.nukkit.item.Item): void
        public getXpCost(): int
        public setXpCost(xpCost: int): void
        public getEnchanter(): cn.nukkit.Player
        public setEnchanter(enchanter: cn.nukkit.Player): void
        static handlers: cn.nukkit.event.HandlerList
        oldItem: cn.nukkit.item.Item
        newItem: cn.nukkit.item.Item
        xpCost: int
        enchanter: cn.nukkit.Player

    }
}

declare module "cn.nukkit.event.inventory.EnchantItemEvent" {
    declare const EnchantItemEvent = cn.nukkit.event.inventory.EnchantItemEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerCommandPreprocessEvent extends cn.nukkit.event.player.PlayerMessageEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, message: string): void
        public setPlayer(player: cn.nukkit.Player): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.player.PlayerCommandPreprocessEvent" {
    declare const PlayerCommandPreprocessEvent = cn.nukkit.event.player.PlayerCommandPreprocessEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerExperienceChangeEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, oldExp: int, oldLevel: int, newExp: int, newLevel: int): void
        public getOldExperience(): int
        public getOldExperienceLevel(): int
        public getNewExperience(): int
        public setNewExperience(exp: int): void
        public getNewExperienceLevel(): int
        public setNewExperienceLevel(level: int): void
        static handlers: cn.nukkit.event.HandlerList
        oldExp: int
        oldExpLevel: int
        newExp: int
        newExpLevel: int

    }
}

declare module "cn.nukkit.event.player.PlayerExperienceChangeEvent" {
    declare const PlayerExperienceChangeEvent = cn.nukkit.event.player.PlayerExperienceChangeEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerJoinEvent extends cn.nukkit.event.player.PlayerEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, joinMessage: cn.nukkit.lang.TextContainer): void
        public constructor(player: cn.nukkit.Player, joinMessage: string): void
        public getJoinMessage(): cn.nukkit.lang.TextContainer
        public setJoinMessage(joinMessage: cn.nukkit.lang.TextContainer): void
        public setJoinMessage(joinMessage: string): void
        static handlers: cn.nukkit.event.HandlerList
        joinMessage: cn.nukkit.lang.TextContainer

    }
}

declare module "cn.nukkit.event.player.PlayerJoinEvent" {
    declare const PlayerJoinEvent = cn.nukkit.event.player.PlayerJoinEvent;
}

declare namespace cn.nukkit.event.server {
    declare class ServerStopEvent extends cn.nukkit.event.server.ServerEvent {
        public constructor(): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.server.ServerStopEvent" {
    declare const ServerStopEvent = cn.nukkit.event.server.ServerStopEvent;
}

declare namespace cn.nukkit.event.server {
    declare class ServerCommandEvent extends cn.nukkit.event.server.ServerEvent implements cn.nukkit.event.Cancellable {
        public constructor(sender: cn.nukkit.command.CommandSender, command: string): void
        public getSender(): cn.nukkit.command.CommandSender
        public getCommand(): string
        public setCommand(command: string): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        static handlers: cn.nukkit.event.HandlerList
        command: string
        sender: cn.nukkit.command.CommandSender

    }
}

declare module "cn.nukkit.event.server.ServerCommandEvent" {
    declare const ServerCommandEvent = cn.nukkit.event.server.ServerCommandEvent;
}

declare namespace cn.nukkit.event.server {
    declare class DataPacketReceiveEvent extends cn.nukkit.event.server.ServerEvent implements cn.nukkit.event.Cancellable {
        public constructor(player: cn.nukkit.Player, packet: cn.nukkit.network.protocol.DataPacket): void
        public getPacket(): cn.nukkit.network.protocol.DataPacket
        public getPlayer(): cn.nukkit.Player
        public static getHandlers(): cn.nukkit.event.HandlerList
        static handlers: cn.nukkit.event.HandlerList
        packet: cn.nukkit.network.protocol.DataPacket
        player: cn.nukkit.Player

    }
}

declare module "cn.nukkit.event.server.DataPacketReceiveEvent" {
    declare const DataPacketReceiveEvent = cn.nukkit.event.server.DataPacketReceiveEvent;
}

declare namespace cn.nukkit.event.server {
    declare class DataPacketSendEvent extends cn.nukkit.event.server.ServerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, packet: cn.nukkit.network.protocol.DataPacket): void
        public getPlayer(): cn.nukkit.Player
        public getPacket(): cn.nukkit.network.protocol.DataPacket
        static handlers: cn.nukkit.event.HandlerList
        packet: cn.nukkit.network.protocol.DataPacket
        player: cn.nukkit.Player

    }
}

declare module "cn.nukkit.event.server.DataPacketSendEvent" {
    declare const DataPacketSendEvent = cn.nukkit.event.server.DataPacketSendEvent;
}

declare namespace cn.nukkit.event.server {
    declare class RemoteServerCommandEvent extends cn.nukkit.event.server.ServerCommandEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(sender: cn.nukkit.command.CommandSender, command: string): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.server.RemoteServerCommandEvent" {
    declare const RemoteServerCommandEvent = cn.nukkit.event.server.RemoteServerCommandEvent;
}

declare namespace cn.nukkit.event.server {
    declare class PlayerDataSerializeEvent extends cn.nukkit.event.server.ServerEvent {
        public constructor(name: string, serializer: cn.nukkit.utils.PlayerDataSerializer): void
        public getName(): java.util.Optional<string>
        public getUuid(): java.util.Optional<java.util.UUID>
        public getSerializer(): cn.nukkit.utils.PlayerDataSerializer
        public setSerializer(serializer: cn.nukkit.utils.PlayerDataSerializer): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        static handlers: cn.nukkit.event.HandlerList
        name: java.util.Optional<string>
        uuid: java.util.Optional<java.util.UUID>
        serializer: cn.nukkit.utils.PlayerDataSerializer

    }
}

declare module "cn.nukkit.event.server.PlayerDataSerializeEvent" {
    declare const PlayerDataSerializeEvent = cn.nukkit.event.server.PlayerDataSerializeEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityExplodeEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity, position: cn.nukkit.level.Position, blocks: java.util.List<cn.nukkit.block.Block>, yield: double): void
        public getPosition(): cn.nukkit.level.Position
        public getBlockList(): java.util.List<cn.nukkit.block.Block>
        public setBlockList(blocks: java.util.List<cn.nukkit.block.Block>): void
        public getYield(): double
        public setYield(yield: double): void
        public getIgnitions(): java.util.Set<cn.nukkit.block.Block>
        public setIgnitions(ignitions: java.util.Set<cn.nukkit.block.Block>): void
        static handlers: cn.nukkit.event.HandlerList
        position: cn.nukkit.level.Position
        blocks: java.util.List<cn.nukkit.block.Block>
        ignitions: java.util.Set<cn.nukkit.block.Block>
        yield: double

    }
}

declare module "cn.nukkit.event.entity.EntityExplodeEvent" {
    declare const EntityExplodeEvent = cn.nukkit.event.entity.EntityExplodeEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityDamageByChildEntityEvent extends cn.nukkit.event.entity.EntityDamageByEntityEvent {
        public constructor(damager: cn.nukkit.entity.Entity, childEntity: cn.nukkit.entity.Entity, entity: cn.nukkit.entity.Entity, cause: cn.nukkit.event.entity.EntityDamageEvent$DamageCause, damage: float): void
        public getChild(): cn.nukkit.entity.Entity
        childEntity: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.event.entity.EntityDamageByChildEntityEvent" {
    declare const EntityDamageByChildEntityEvent = cn.nukkit.event.entity.EntityDamageByChildEntityEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityVehicleEnterEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity, vehicle: cn.nukkit.entity.Entity): void
        public getVehicle(): cn.nukkit.entity.Entity
        static handlers: cn.nukkit.event.HandlerList
        vehicle: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.event.entity.EntityVehicleEnterEvent" {
    declare const EntityVehicleEnterEvent = cn.nukkit.event.entity.EntityVehicleEnterEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class ItemDespawnEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(item: cn.nukkit.entity.item.EntityItem): void
        public getEntity(): cn.nukkit.entity.item.EntityItem
        public getEntity(): cn.nukkit.entity.Entity
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.entity.ItemDespawnEvent" {
    declare const ItemDespawnEvent = cn.nukkit.event.entity.ItemDespawnEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityDespawnEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity): void
        public getPosition(): cn.nukkit.level.Position
        public getType(): int
        public isCreature(): boolean
        public isHuman(): boolean
        public isProjectile(): boolean
        public isVehicle(): boolean
        public isItem(): boolean
        static handlers: cn.nukkit.event.HandlerList
        entityType: int

    }
}

declare module "cn.nukkit.event.entity.EntityDespawnEvent" {
    declare const EntityDespawnEvent = cn.nukkit.event.entity.EntityDespawnEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityDamageByEntityEvent extends cn.nukkit.event.entity.EntityDamageEvent {
        public constructor(damager: cn.nukkit.entity.Entity, entity: cn.nukkit.entity.Entity, cause: cn.nukkit.event.entity.EntityDamageEvent$DamageCause, damage: float): void
        public constructor(damager: cn.nukkit.entity.Entity, entity: cn.nukkit.entity.Entity, cause: cn.nukkit.event.entity.EntityDamageEvent$DamageCause, modifiers: java.util.Map<cn.nukkit.event.entity.EntityDamageEvent$DamageModifier, float>): void
        public constructor(damager: cn.nukkit.entity.Entity, entity: cn.nukkit.entity.Entity, cause: cn.nukkit.event.entity.EntityDamageEvent$DamageCause, damage: float, knockBack: float): void
        public constructor(damager: cn.nukkit.entity.Entity, entity: cn.nukkit.entity.Entity, cause: cn.nukkit.event.entity.EntityDamageEvent$DamageCause, modifiers: java.util.Map<cn.nukkit.event.entity.EntityDamageEvent$DamageModifier, float>, knockBack: float): void
        public constructor(damager: cn.nukkit.entity.Entity, entity: cn.nukkit.entity.Entity, cause: cn.nukkit.event.entity.EntityDamageEvent$DamageCause, modifiers: java.util.Map<cn.nukkit.event.entity.EntityDamageEvent$DamageModifier, float>, knockBack: float, enchantments: cn.nukkit.item.enchantment.Enchantment[]): void
        addAttackerModifiers(damager: cn.nukkit.entity.Entity): void
        public getDamager(): cn.nukkit.entity.Entity
        public getKnockBack(): float
        public setKnockBack(knockBack: float): void
        public getWeaponEnchantments(): cn.nukkit.item.enchantment.Enchantment[]
        damager: cn.nukkit.entity.Entity
        knockBack: float
        enchantments: cn.nukkit.item.enchantment.Enchantment[]

    }
}

declare module "cn.nukkit.event.entity.EntityDamageByEntityEvent" {
    declare const EntityDamageByEntityEvent = cn.nukkit.event.entity.EntityDamageByEntityEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityDeathEvent extends cn.nukkit.event.entity.EntityEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.EntityLiving): void
        public constructor(entity: cn.nukkit.entity.EntityLiving, drops: cn.nukkit.item.Item[]): void
        public getDrops(): cn.nukkit.item.Item[]
        public setDrops(drops: cn.nukkit.item.Item[]): void
        static handlers: cn.nukkit.event.HandlerList
        drops: cn.nukkit.item.Item[]

    }
}

declare module "cn.nukkit.event.entity.EntityDeathEvent" {
    declare const EntityDeathEvent = cn.nukkit.event.entity.EntityDeathEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class CreatureSpawnEvent$SpawnReason extends java.lang.Enum {
        public static values(): cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason[]
        public static valueOf(name: string): cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        constructor(): void
        static $values(): cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason[]
        public static NATURAL: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static JOCKEY: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static SPAWNER: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static EGG: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static SPAWN_EGG: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static LIGHTNING: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static BUILD_SNOWMAN: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static BUILD_IRONGOLEM: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static BUILD_WITHER: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static VILLAGE_DEFENSE: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static VILLAGE_INVASION: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static BREEDING: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static SLIME_SPLIT: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static REINFORCEMENTS: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static NETHER_PORTAL: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static DISPENSE_EGG: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static INFECTION: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static CURED: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static OCELOT_BABY: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static SILVERFISH_BLOCK: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static MOUNT: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static TRAP: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static ENDER_PEARL: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static SHOULDER_ENTITY: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static DROWNED: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static SHEARED: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static CUSTOM: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static DEFAULT: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public static TURTLE_EGG: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        static $VALUES: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason[]

    }
}

declare module "cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason" {
    declare const CreatureSpawnEvent$SpawnReason = cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityShootBowEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(shooter: cn.nukkit.entity.EntityLiving, bow: cn.nukkit.item.Item, projectile: cn.nukkit.entity.projectile.EntityProjectile, force: double): void
        public getEntity(): cn.nukkit.entity.EntityLiving
        public getBow(): cn.nukkit.item.Item
        public getProjectile(): cn.nukkit.entity.projectile.EntityProjectile
        public setProjectile(projectile: cn.nukkit.entity.Entity): void
        public getForce(): double
        public setForce(force: double): void
        public getEntity(): cn.nukkit.entity.Entity
        static handlers: cn.nukkit.event.HandlerList
        bow: cn.nukkit.item.Item
        projectile: cn.nukkit.entity.projectile.EntityProjectile
        force: double

    }
}

declare module "cn.nukkit.event.entity.EntityShootBowEvent" {
    declare const EntityShootBowEvent = cn.nukkit.event.entity.EntityShootBowEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityCombustByBlockEvent extends cn.nukkit.event.entity.EntityCombustEvent {
        public constructor(combuster: cn.nukkit.block.Block, combustee: cn.nukkit.entity.Entity, duration: int): void
        public getCombuster(): cn.nukkit.block.Block
        combuster: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.event.entity.EntityCombustByBlockEvent" {
    declare const EntityCombustByBlockEvent = cn.nukkit.event.entity.EntityCombustByBlockEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityTeleportEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity, from: cn.nukkit.level.Location, to: cn.nukkit.level.Location): void
        public getFrom(): cn.nukkit.level.Location
        public setFrom(from: cn.nukkit.level.Location): void
        public getTo(): cn.nukkit.level.Location
        public setTo(to: cn.nukkit.level.Location): void
        static handlers: cn.nukkit.event.HandlerList
        from: cn.nukkit.level.Location
        to: cn.nukkit.level.Location

    }
}

declare module "cn.nukkit.event.entity.EntityTeleportEvent" {
    declare const EntityTeleportEvent = cn.nukkit.event.entity.EntityTeleportEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityShootCrossbowEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(shooter: cn.nukkit.entity.EntityLiving, crossbow: cn.nukkit.item.Item, projectiles: cn.nukkit.entity.projectile.EntityProjectile[]): void
        public getEntity(): cn.nukkit.entity.EntityLiving
        public getCrossbow(): cn.nukkit.item.Item
        public getProjectile(array: int): cn.nukkit.entity.projectile.EntityProjectile
        public getProjectiles(): cn.nukkit.entity.projectile.EntityProjectile[]
        public getProjectilesCount(): int
        public setProjectile(projectile: cn.nukkit.entity.projectile.EntityProjectile, array: int): void
        public setProjectiles(projectiles: cn.nukkit.entity.projectile.EntityProjectile[]): void
        public killProjectiles(): void
        public getEntity(): cn.nukkit.entity.Entity
        static handlers: cn.nukkit.event.HandlerList
        crossbow: cn.nukkit.item.Item
        projectiles: cn.nukkit.entity.projectile.EntityProjectile[]

    }
}

declare module "cn.nukkit.event.entity.EntityShootCrossbowEvent" {
    declare const EntityShootCrossbowEvent = cn.nukkit.event.entity.EntityShootCrossbowEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityEvent extends cn.nukkit.event.Event {
        public constructor(): void
        public getEntity(): cn.nukkit.entity.Entity
        entity: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.event.entity.EntityEvent" {
    declare const EntityEvent = cn.nukkit.event.entity.EntityEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityRegainHealthEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity, amount: float, regainReason: int): void
        public getAmount(): float
        public setAmount(amount: float): void
        public getRegainReason(): int
        static handlers: cn.nukkit.event.HandlerList
        public static CAUSE_REGEN: int
        public static CAUSE_EATING: int
        public static CAUSE_MAGIC: int
        public static CAUSE_CUSTOM: int
        amount: float
        reason: int

    }
}

declare module "cn.nukkit.event.entity.EntityRegainHealthEvent" {
    declare const EntityRegainHealthEvent = cn.nukkit.event.entity.EntityRegainHealthEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class ItemSpawnEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(item: cn.nukkit.entity.item.EntityItem): void
        public getEntity(): cn.nukkit.entity.item.EntityItem
        public getEntity(): cn.nukkit.entity.Entity
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.entity.ItemSpawnEvent" {
    declare const ItemSpawnEvent = cn.nukkit.event.entity.ItemSpawnEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityDamageEvent$DamageCause extends java.lang.Enum {
        public static values(): cn.nukkit.event.entity.EntityDamageEvent$DamageCause[]
        public static valueOf(name: string): cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        constructor(): void
        static $values(): cn.nukkit.event.entity.EntityDamageEvent$DamageCause[]
        public static CONTACT: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static ENTITY_ATTACK: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static PROJECTILE: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static SUFFOCATION: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static FALL: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static FIRE: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static FIRE_TICK: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static LAVA: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static DROWNING: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static BLOCK_EXPLOSION: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static ENTITY_EXPLOSION: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static VOID: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static SUICIDE: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static MAGIC: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static CUSTOM: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static LIGHTNING: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static HUNGER: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static WITHER: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static THORNS: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static FALLING_BLOCK: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static FLYING_INTO_WALL: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static HOT_FLOOR: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static FIREWORKS: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static FREEZING: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static NONE: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public static COLLIDE: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        static $VALUES: cn.nukkit.event.entity.EntityDamageEvent$DamageCause[]

    }
}

declare module "cn.nukkit.event.entity.EntityDamageEvent$DamageCause" {
    declare const EntityDamageEvent$DamageCause = cn.nukkit.event.entity.EntityDamageEvent$DamageCause;
}

declare namespace cn.nukkit.console {
    declare class NukkitConsole extends net.minecrell.terminalconsole.SimpleTerminalConsole {
        isRunning(): boolean
        runCommand(command: string): void
        public readLine(): string
        shutdown(): void
        buildReader(builder: org.jline.reader.LineReaderBuilder): org.jline.reader.LineReader
        public isExecutingCommands(): boolean
        public setExecutingCommands(executingCommands: boolean): void
        public constructor(server: cn.nukkit.Server): void
        lambda$runCommand$0(event: cn.nukkit.event.server.ServerCommandEvent): void
        server: cn.nukkit.Server
        consoleQueue: java.util.concurrent.BlockingQueue<string>
        executingCommands: java.util.concurrent.atomic.AtomicBoolean

    }
}

declare module "cn.nukkit.console.NukkitConsole" {
    declare const NukkitConsole = cn.nukkit.console.NukkitConsole;
}

declare namespace cn.nukkit {
    declare class Player$2 extends cn.nukkit.scheduler.AsyncTask {
        constructor(this$0: cn.nukkit.Player, var1: cn.nukkit.Player): void
        public onRun(): void
        public onCompletion(server: cn.nukkit.Server): void
        event: cn.nukkit.event.player.PlayerAsyncPreLoginEvent
        val$playerInstance: cn.nukkit.Player
        this$0: cn.nukkit.Player

    }
}

declare module "cn.nukkit.Player$2" {
    declare const Player$2 = cn.nukkit.Player$2;
}

declare namespace cn.nukkit.positiontracking {
    declare class PositionTrackingService$1 extends java.lang.Object implements java.util.Iterator {
        constructor(): void
        public hasNext(): boolean
        public next(): cn.nukkit.inventory.Inventory
        public next(): java.lang.Object
        next: int
        val$player: cn.nukkit.Player
        this$0: cn.nukkit.positiontracking.PositionTrackingService

    }
}

declare module "cn.nukkit.positiontracking.PositionTrackingService$1" {
    declare const PositionTrackingService$1 = cn.nukkit.positiontracking.PositionTrackingService$1;
}

declare namespace cn.nukkit.positiontracking {
    declare class PositionTracking extends cn.nukkit.positiontracking.NamedPosition {
        public constructor(levelName: string, x: double, var2: double, y: double): void
        public constructor(level: cn.nukkit.level.Level, x: double, var2: double, y: double): void
        public constructor(level: cn.nukkit.level.Level, v: cn.nukkit.math.Vector3): void
        public constructor(levelName: string, v: cn.nukkit.math.Vector3): void
        public constructor(pos: cn.nukkit.level.Position): void
        public constructor(pos: cn.nukkit.positiontracking.NamedPosition): void
        public getLevelName(): string
        public setLevelName(levelName: string): void
        public add(x: double): cn.nukkit.positiontracking.PositionTracking
        public add(x: double, var1: double): cn.nukkit.positiontracking.PositionTracking
        public add(x: double, var1: double, y: double): cn.nukkit.positiontracking.PositionTracking
        public add(v: cn.nukkit.math.Vector3): cn.nukkit.positiontracking.PositionTracking
        public subtract(): cn.nukkit.positiontracking.PositionTracking
        public subtract(x: double): cn.nukkit.positiontracking.PositionTracking
        public subtract(x: double, var1: double): cn.nukkit.positiontracking.PositionTracking
        public subtract(x: double, var1: double, y: double): cn.nukkit.positiontracking.PositionTracking
        public subtract(v: cn.nukkit.math.Vector3): cn.nukkit.positiontracking.PositionTracking
        public multiply(number: double): cn.nukkit.positiontracking.PositionTracking
        public divide(number: double): cn.nukkit.positiontracking.PositionTracking
        public ceil(): cn.nukkit.positiontracking.PositionTracking
        public floor(): cn.nukkit.positiontracking.PositionTracking
        public round(): cn.nukkit.positiontracking.PositionTracking
        public abs(): cn.nukkit.positiontracking.PositionTracking
        public getSide(face: cn.nukkit.math.BlockFace): cn.nukkit.positiontracking.PositionTracking
        public getSide(face: cn.nukkit.math.BlockFace, step: int): cn.nukkit.positiontracking.PositionTracking
        public up(): cn.nukkit.positiontracking.PositionTracking
        public up(step: int): cn.nukkit.positiontracking.PositionTracking
        public down(): cn.nukkit.positiontracking.PositionTracking
        public down(step: int): cn.nukkit.positiontracking.PositionTracking
        public north(): cn.nukkit.positiontracking.PositionTracking
        public north(step: int): cn.nukkit.positiontracking.PositionTracking
        public south(): cn.nukkit.positiontracking.PositionTracking
        public south(step: int): cn.nukkit.positiontracking.PositionTracking
        public east(): cn.nukkit.positiontracking.PositionTracking
        public east(step: int): cn.nukkit.positiontracking.PositionTracking
        public west(): cn.nukkit.positiontracking.PositionTracking
        public west(step: int): cn.nukkit.positiontracking.PositionTracking
        public getIntermediateWithXValue(v: cn.nukkit.math.Vector3, x: double): cn.nukkit.positiontracking.PositionTracking
        public getIntermediateWithYValue(v: cn.nukkit.math.Vector3, y: double): cn.nukkit.math.Vector3
        public getIntermediateWithZValue(v: cn.nukkit.math.Vector3, z: double): cn.nukkit.math.Vector3
        public setComponents(x: double, var1: double, y: double): cn.nukkit.positiontracking.PositionTracking
        public setComponents(pos: cn.nukkit.math.Vector3): cn.nukkit.positiontracking.PositionTracking
        public clone(): cn.nukkit.positiontracking.PositionTracking
        public clone(): cn.nukkit.positiontracking.NamedPosition
        public clone(): cn.nukkit.math.Vector3
        public setComponents(var0: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public setComponents(var0: double, var1: double, var2: double): cn.nukkit.math.Vector3
        public getIntermediateWithXValue(var0: cn.nukkit.math.Vector3, var1: double): cn.nukkit.math.Vector3
        public west(var0: int): cn.nukkit.math.Vector3
        public west(): cn.nukkit.math.Vector3
        public east(var0: int): cn.nukkit.math.Vector3
        public east(): cn.nukkit.math.Vector3
        public south(var0: int): cn.nukkit.math.Vector3
        public south(): cn.nukkit.math.Vector3
        public north(var0: int): cn.nukkit.math.Vector3
        public north(): cn.nukkit.math.Vector3
        public down(var0: int): cn.nukkit.math.Vector3
        public down(): cn.nukkit.math.Vector3
        public up(var0: int): cn.nukkit.math.Vector3
        public up(): cn.nukkit.math.Vector3
        public getSide(var0: cn.nukkit.math.BlockFace, var1: int): cn.nukkit.math.Vector3
        public getSide(var0: cn.nukkit.math.BlockFace): cn.nukkit.math.Vector3
        public abs(): cn.nukkit.math.Vector3
        public round(): cn.nukkit.math.Vector3
        public floor(): cn.nukkit.math.Vector3
        public ceil(): cn.nukkit.math.Vector3
        public divide(var0: double): cn.nukkit.math.Vector3
        public multiply(var0: double): cn.nukkit.math.Vector3
        public subtract(var0: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public subtract(var0: double, var1: double, var2: double): cn.nukkit.math.Vector3
        public subtract(var0: double, var1: double): cn.nukkit.math.Vector3
        public subtract(var0: double): cn.nukkit.math.Vector3
        public subtract(): cn.nukkit.math.Vector3
        public add(var0: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public add(var0: double, var1: double, var2: double): cn.nukkit.math.Vector3
        public add(var0: double, var1: double): cn.nukkit.math.Vector3
        public add(var0: double): cn.nukkit.math.Vector3
        public clone(): java.lang.Object
        levelName: string

    }
}

declare module "cn.nukkit.positiontracking.PositionTracking" {
    declare const PositionTracking = cn.nukkit.positiontracking.PositionTracking;
}

declare namespace cn.nukkit.positiontracking {
    declare class PositionTrackingStorage extends java.lang.Object implements java.io.Closeable {
        public constructor(startIndex: int, persistenceFile: java.io.File): void
        public constructor(startIndex: int, persistenceFile: java.io.File, maxStorage: int): void
        getAxisPos(trackingHandler: int): long
        validateHandler(trackingHandler: int): void
        public getPosition(trackingHandler: int): cn.nukkit.positiontracking.PositionTracking
        public getPosition(trackingHandler: int, onlyEnabled: boolean): cn.nukkit.positiontracking.PositionTracking
        public addOrReusePosition(position: cn.nukkit.positiontracking.NamedPosition): java.util.OptionalInt
        public addNewPosition(position: cn.nukkit.positiontracking.NamedPosition): java.util.OptionalInt
        public addNewPosition(position: cn.nukkit.positiontracking.NamedPosition, enabled: boolean): java.util.OptionalInt
        public findTrackingHandler(position: cn.nukkit.positiontracking.NamedPosition): java.util.OptionalInt
        handleExecutionException(e: java.util.concurrent.ExecutionException): java.io.IOException
        public invalidateHandler(trackingHandler: int): void
        public isEnabled(trackingHandler: int): boolean
        public setEnabled(trackingHandler: int, enabled: boolean): boolean
        public hasPosition(trackingHandler: int): boolean
        public hasPosition(trackingHandler: int, onlyEnabled: boolean): boolean
        invalidatePos(trackingHandler: int): void
        addGarbage(pos: long, var1: int): void
        findSpaceInStringHeap(len: int): long
        addNewPos(pos: cn.nukkit.positiontracking.NamedPosition, enabled: boolean): java.util.OptionalInt
        writePos(trackingHandler: int, pos: cn.nukkit.positiontracking.NamedPosition, enabled: boolean): void
        addLevelName(name: byte[]): long
        public findTrackingHandlers(pos: cn.nukkit.positiontracking.NamedPosition): it.unimi.dsi.fastutil.ints.IntList
        public findTrackingHandlers(pos: cn.nukkit.positiontracking.NamedPosition, onlyEnabled: boolean): it.unimi.dsi.fastutil.ints.IntList
        public findTrackingHandlers(pos: cn.nukkit.positiontracking.NamedPosition, onlyEnabled: boolean, limit: int): it.unimi.dsi.fastutil.ints.IntList
        loadPosition(trackingHandler: int, onlyEnabled: boolean): java.util.Optional<cn.nukkit.positiontracking.PositionTracking>
        public getStartingHandler(): int
        public getMaxHandler(): int
        public close(): void
        finalize(): void
        static lambda$findTrackingHandler$1(position: cn.nukkit.positiontracking.NamedPosition, e: java.util.Map$Entry): boolean
        lambda$getPosition$0(trackingHandler: int): java.util.Optional
        public static DEFAULT_MAX_STORAGE: int
        static HEADER: byte[]
        startIndex: int
        maxStorage: int
        garbagePos: long
        stringHeapPos: long
        persistence: java.io.RandomAccessFile
        cache: com.google.common.cache.Cache<int, java.util.Optional<cn.nukkit.positiontracking.PositionTracking>>
        nextIndex: int

    }
}

declare module "cn.nukkit.positiontracking.PositionTrackingStorage" {
    declare const PositionTrackingStorage = cn.nukkit.positiontracking.PositionTrackingStorage;
}

declare namespace cn.nukkit.plugin {
    declare class PluginClassLoader extends java.net.URLClassLoader {
        public constructor(loader: cn.nukkit.plugin.JavaPluginLoader, parent: java.lang.ClassLoader, file: java.io.File): void
        findClass(name: string): char
        findClass(name: string, checkGlobal: boolean): char
        getClasses(): java.util.Set<string>
        loader: cn.nukkit.plugin.JavaPluginLoader
        classes: java.util.Map<string, java.lang.Class>

    }
}

declare module "cn.nukkit.plugin.PluginClassLoader" {
    declare const PluginClassLoader = cn.nukkit.plugin.PluginClassLoader;
}

declare namespace cn.nukkit.plugin.service {
    declare class NKServiceManager extends java.lang.Object implements cn.nukkit.plugin.service.ServiceManager {
        public constructor(): void
        public register(service: java.lang.Object, provider: java.lang.Class<any>, plugin: cn.nukkit.plugin.Plugin, priority: cn.nukkit.plugin.service.ServicePriority): boolean
        provide(service: java.lang.Object, instance: java.lang.Class<any>, plugin: cn.nukkit.plugin.Plugin, priority: cn.nukkit.plugin.service.ServicePriority): boolean
        public cancel(plugin: cn.nukkit.plugin.Plugin): java.util.List<short>
        public cancel(service: java.lang.Object, provider: java.lang.Class<any>): cn.nukkit.plugin.service.RegisteredServiceProvider<any>
        public getProvider(service: java.lang.Object, var1: java.lang.Class<any>): cn.nukkit.plugin.service.RegisteredServiceProvider<any>
        public getKnownService(): java.util.List<char>
        public getRegistrations(plugin: cn.nukkit.plugin.Plugin): java.util.List<short>
        public getRegistrations(service: java.lang.Object, builder: java.lang.Class<any>): java.util.List<cn.nukkit.plugin.service.RegisteredServiceProvider<any>>
        public isProvidedFor(service: java.lang.Object, var1: java.lang.Class<any>): boolean
        static lambda$provide$0(k: java.lang.Class): java.util.List
        handle: java.util.Map<java.lang.Class<short>>

    }
}

declare module "cn.nukkit.plugin.service.NKServiceManager" {
    declare const NKServiceManager = cn.nukkit.plugin.service.NKServiceManager;
}

declare namespace cn.nukkit.plugin {
    declare interface Plugin extends cn.nukkit.command.CommandExecutor {
        public onLoad(): void
        public onEnable(): void
        public isEnabled(): boolean
        public onDisable(): void
        public isDisabled(): boolean
        public getDataFolder(): java.io.File
        public getDescription(): cn.nukkit.plugin.PluginDescription
        public getResource(var0: string): java.io.InputStream
        public saveResource(var0: string): boolean
        public saveResource(var0: string, var1: boolean): boolean
        public saveResource(var0: string, var1: string, var2: boolean): boolean
        public getConfig(): cn.nukkit.utils.Config
        public saveConfig(): void
        public saveDefaultConfig(): void
        public reloadConfig(): void
        public getServer(): cn.nukkit.Server
        public getName(): string
        public getLogger(): cn.nukkit.plugin.PluginLogger
        public getPluginLoader(): cn.nukkit.plugin.PluginLoader
        public static EMPTY_ARRAY: cn.nukkit.plugin.Plugin[]

    }
}

declare module "cn.nukkit.plugin.Plugin" {
    declare type Plugin = cn.nukkit.plugin.Plugin;
}

declare namespace cn.nukkit.plugin {
    declare class LibraryLoader extends java.lang.Object {
        public constructor(): void
        public static load(library: string): void
        public static load(library: cn.nukkit.plugin.Library): void
        public static getBaseFolder(): java.io.File
        static BASE_FOLDER: java.io.File
        static LOGGER: java.util.logging.Logger
        static SUFFIX: string

    }
}

declare module "cn.nukkit.plugin.LibraryLoader" {
    declare const LibraryLoader = cn.nukkit.plugin.LibraryLoader;
}

declare namespace cn.nukkit.plugin.js {
    declare interface JSFeature {
        public getName(): string
        public availableModuleNames(): java.util.Collection<string>
        public generateModule(var0: string, var1: org.graalvm.polyglot.Context): string
        public needsInject(): boolean
        public injectIntoContext(context: org.graalvm.polyglot.Context): void

    }
}

declare module "cn.nukkit.plugin.js.JSFeature" {
    declare type JSFeature = cn.nukkit.plugin.js.JSFeature;
}

declare namespace cn.nukkit.plugin.js {
    declare class JSTimerTask extends java.util.TimerTask {
        public constructor(id: long, var1: org.graalvm.polyglot.Context, jsContext: org.graalvm.polyglot.Value, callback: java.lang.Object[]): void
        public run(): void
        public getId(): long
        id: long
        jsContext: org.graalvm.polyglot.Context
        callback: org.graalvm.polyglot.Value
        args: java.lang.Object[]

    }
}

declare module "cn.nukkit.plugin.js.JSTimerTask" {
    declare const JSTimerTask = cn.nukkit.plugin.js.JSTimerTask;
}

declare namespace cn.nukkit.plugin.js {
    declare class JSFeatures extends java.lang.Object {
        constructor(): void
        public static registerFeature(feature: cn.nukkit.plugin.js.JSFeature): void
        public static getFeature(name: string): cn.nukkit.plugin.js.JSFeature
        public static getFeatureByModule(moduleName: string): cn.nukkit.plugin.js.JSFeature
        public static hasFeature(name: string): boolean
        public static hasFeatureByModule(moduleName: string): boolean
        public static unregisterFeature(name: string): void
        public static clearFeatures(): void
        public static initInternalFeatures(): void
        public static JS_FEATURE_MAP: java.util.Map<string, cn.nukkit.plugin.js.JSFeature>
        public static FEATURE_MODULE_MAP: java.util.Map<string, cn.nukkit.plugin.js.JSFeature>
        public static FEATURE_GENERATED_TMP_MAP: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap<java.lang.Object>
        public static FEATURE_GENERATED_TMP_ID: java.util.concurrent.atomic.AtomicInteger

    }
}

declare module "cn.nukkit.plugin.js.JSFeatures" {
    declare const JSFeatures = cn.nukkit.plugin.js.JSFeatures;
}

declare namespace cn.nukkit.plugin.js {
    declare class JSEventManager$CommandBuilder$1 extends cn.nukkit.command.Command {
        constructor(this$0: cn.nukkit.plugin.js.JSEventManager$CommandBuilder, name: string, description: string, usageMessage: string, aliases: string[]): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        this$0: cn.nukkit.plugin.js.JSEventManager$CommandBuilder

    }
}

declare module "cn.nukkit.plugin.js.JSEventManager$CommandBuilder$1" {
    declare const JSEventManager$CommandBuilder$1 = cn.nukkit.plugin.js.JSEventManager$CommandBuilder$1;
}

declare namespace cn.nukkit.plugin.js {
    declare class JSConcurrentManager extends java.lang.Object {
        public constructor(jsPlugin: cn.nukkit.plugin.CommonJSPlugin): void
        public warpSafe(object: java.lang.Object): cn.nukkit.plugin.js.JSSafeObject
        public createWorker(sourcePath: string): cn.nukkit.plugin.js.JSWorker
        public createJob(sourcePath: string): cn.nukkit.plugin.js.JSJob
        public getLockTimeout(): long
        public setLockTimeout(lockTimeout: long): cn.nukkit.plugin.js.JSConcurrentManager
        public static wrapPromise(context: org.graalvm.polyglot.Context, javaFuture: char, var2: float): cn.nukkit.plugin.js.JSConcurrentManager$JPromise
        public static PROMISE_FAILED: java.lang.Object
        lockTimeout: long
        jsPlugin: cn.nukkit.plugin.CommonJSPlugin

    }
}

declare module "cn.nukkit.plugin.js.JSConcurrentManager" {
    declare const JSConcurrentManager = cn.nukkit.plugin.js.JSConcurrentManager;
}

declare namespace cn.nukkit.plugin.js {
    declare interface JSConcurrentManager$Thenable {
        public then(var0: org.graalvm.polyglot.Value, var1: org.graalvm.polyglot.Value): void

    }
}

declare module "cn.nukkit.plugin.js.JSConcurrentManager$Thenable" {
    declare type JSConcurrentManager$Thenable = cn.nukkit.plugin.js.JSConcurrentManager$Thenable;
}

declare namespace cn.nukkit.plugin.js.external {
    declare class ExternalFunction extends cn.nukkit.plugin.js.JSExternal implements org.graalvm.polyglot.proxy.ProxyExecutable {
        public constructor(sourceContext: org.graalvm.polyglot.Context, value: org.graalvm.polyglot.Value): void
        public execute(arguments: org.graalvm.polyglot.Value[]): java.lang.Object

    }
}

declare module "cn.nukkit.plugin.js.external.ExternalFunction" {
    declare const ExternalFunction = cn.nukkit.plugin.js.external.ExternalFunction;
}

declare namespace cn.nukkit.plugin.js.external {
    declare class ExternalArray extends cn.nukkit.plugin.js.JSExternal implements org.graalvm.polyglot.proxy.ProxyArray {
        public constructor(sourceContext: org.graalvm.polyglot.Context, value: org.graalvm.polyglot.Value): void
        public get(index: long): java.lang.Object
        public set(index: long, var1: org.graalvm.polyglot.Value): void
        public remove(index: long): boolean
        public getSize(): long
        public getIterator(): java.lang.Object

    }
}

declare module "cn.nukkit.plugin.js.external.ExternalArray" {
    declare const ExternalArray = cn.nukkit.plugin.js.external.ExternalArray;
}

declare namespace cn.nukkit.plugin.js {
    declare class JSIInitiator extends java.lang.Object {
        public constructor(): void
        public static reset(): void
        public static init(context: org.graalvm.polyglot.Context): void
        public static closeContext(context: org.graalvm.polyglot.Context): void
        public static initTimer(context: org.graalvm.polyglot.Context): void
        static addContextTimerId(context: org.graalvm.polyglot.Context, timerId: long): void
        static removeContextTimerId(context: org.graalvm.polyglot.Context, timerId: long): void
        static lambda$initTimer$7(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        static lambda$initTimer$6(context: org.graalvm.polyglot.Context, arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        static lambda$initTimer$5(context: org.graalvm.polyglot.Context, arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        static lambda$initTimer$4(context: org.graalvm.polyglot.Context, arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        static lambda$initTimer$3(context: org.graalvm.polyglot.Context, arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        static lambda$initTimer$2(context: org.graalvm.polyglot.Context, arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        static lambda$initTimer$1(context: org.graalvm.polyglot.Context, arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        static lambda$initTimer$0(context: org.graalvm.polyglot.Context, arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        static NULL: org.graalvm.polyglot.Value
        public static jsTimer: java.util.Timer
        public static jsTimeTaskMap: it.unimi.dsi.fastutil.longs.Long2ObjectMap<cn.nukkit.plugin.js.JSTimerTask>
        public static contextTimerIdMap: java.util.Map<org.graalvm.polyglot.Context, it.unimi.dsi.fastutil.longs.LongList>
        public static externalMap: com.google.common.collect.Multimap<org.graalvm.polyglot.Context, string>
        static globalTimerId: java.util.concurrent.atomic.AtomicLong

    }
}

declare module "cn.nukkit.plugin.js.JSIInitiator" {
    declare const JSIInitiator = cn.nukkit.plugin.js.JSIInitiator;
}

declare namespace cn.nukkit.plugin.js {
    declare class JSProxyLogger$1 extends java.lang.Object implements org.graalvm.polyglot.proxy.ProxyArray {
        constructor(this$0: cn.nukkit.plugin.js.JSProxyLogger): void
        public get(index: long): java.lang.Object
        public set(index: long, var1: org.graalvm.polyglot.Value): void
        public getSize(): long
        this$0: cn.nukkit.plugin.js.JSProxyLogger

    }
}

declare module "cn.nukkit.plugin.js.JSProxyLogger$1" {
    declare const JSProxyLogger$1 = cn.nukkit.plugin.js.JSProxyLogger$1;
}

declare namespace cn.nukkit.plugin.js {
    declare class JSWorker extends java.lang.Object implements java.lang.AutoCloseable {
        public constructor(sourceContext: org.graalvm.polyglot.Context, fileSystem: cn.nukkit.plugin.js.ESMFileSystem, workerSourcePath: string): void
        public init(): void
        public start(): void
        public setSourceReceiveCallback(value: org.graalvm.polyglot.Value): void
        public setWorkerReceiveCallback(value: org.graalvm.polyglot.Value): void
        public getSourceReceiveCallback(): org.graalvm.polyglot.Value
        public getWorkerReceiveCallback(): org.graalvm.polyglot.Value
        public postMessage(arguments: org.graalvm.polyglot.Value[]): org.graalvm.polyglot.Value
        public postMessageAsync(arguments: org.graalvm.polyglot.Value[]): cn.nukkit.plugin.js.JSConcurrentManager$JPromise
        public close(): void
        lambda$postMessageAsync$5(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$start$4(): void
        lambda$init$3(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$init$2(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$init$1(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        static lambda$init$0(className: string): boolean
        static NULL: org.graalvm.polyglot.Value
        sourceContext: org.graalvm.polyglot.Context
        fileSystem: cn.nukkit.plugin.js.ESMFileSystem
        workerSourcePath: string
        workerContext: org.graalvm.polyglot.Context
        sourceReader: java.io.Reader
        sourcePath: java.nio.file.Path
        workerThread: java.lang.Thread
        sourceReceiveCallback: org.graalvm.polyglot.Value
        workerReceiveCallback: org.graalvm.polyglot.Value

    }
}

declare module "cn.nukkit.plugin.js.JSWorker" {
    declare const JSWorker = cn.nukkit.plugin.js.JSWorker;
}

declare namespace cn.nukkit.plugin.js {
    declare class JSEventManager extends java.lang.Object {
        public constructor(jsPlugin: cn.nukkit.plugin.CommonJSPlugin): void
        public register(fullEventName: string, priority: cn.nukkit.event.EventPriority, callback: org.graalvm.polyglot.Value): boolean
        public commandBuilder(): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        lambda$register$0(callback: org.graalvm.polyglot.Value, listener: cn.nukkit.event.Listener, event: cn.nukkit.event.Event): void
        jsPlugin: cn.nukkit.plugin.CommonJSPlugin

    }
}

declare module "cn.nukkit.plugin.js.JSEventManager" {
    declare const JSEventManager = cn.nukkit.plugin.js.JSEventManager;
}

declare namespace cn.nukkit.plugin.js {
    declare class JSExternal extends java.lang.Object {
        checkAlive(): void
        public constructor(sourceContext: org.graalvm.polyglot.Context, value: org.graalvm.polyglot.Value): void
        public getSourceContext(): org.graalvm.polyglot.Context
        public getValue(): org.graalvm.polyglot.Value
        public isAlive(): boolean
        public setAlive(alive: boolean): void
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        public toString(): string
        sourceContext: org.graalvm.polyglot.Context
        value: org.graalvm.polyglot.Value
        alive: boolean

    }
}

declare module "cn.nukkit.plugin.js.JSExternal" {
    declare const JSExternal = cn.nukkit.plugin.js.JSExternal;
}

declare namespace cn.nukkit.plugin.js {
    declare class ESMFileSystem extends java.lang.Object implements org.graalvm.polyglot.io.FileSystem {
        public constructor(baseDir: java.io.File, plugin: cn.nukkit.plugin.CommonJSPlugin): void
        public parsePath(uri: java.net.URI): java.nio.file.Path
        public parsePath(path: string): java.nio.file.Path
        static getDots(originStr: string): int
        public checkAccess(path: java.nio.file.Path, modes: java.util.Set<java.nio.file.AccessMode>, linkOptions: java.nio.file.LinkOption[]): void
        public createDirectory(dir: java.nio.file.Path, attrs: float): void
        public delete(path: java.nio.file.Path): void
        public newByteChannel(path: java.nio.file.Path, options: java.util.Set<java.nio.file.OpenOption>, attrs: float): java.nio.channels.SeekableByteChannel
        public newReader(path: java.nio.file.Path): java.io.Reader
        public newDirectoryStream(dir: java.nio.file.Path, filter: java.nio.file.DirectoryStream$Filter<java.nio.file.Path>): java.nio.file.DirectoryStream<java.nio.file.Path>
        public toAbsolutePath(path: java.nio.file.Path): java.nio.file.Path
        public toRealPath(path: java.nio.file.Path, linkOptions: java.nio.file.LinkOption[]): java.nio.file.Path
        public readAttributes(path: java.nio.file.Path, attributes: string, options: java.nio.file.LinkOption[]): java.util.Map<string, java.lang.Object>
        baseDir: java.io.File
        plugin: cn.nukkit.plugin.CommonJSPlugin
        mainClassLoader: java.lang.ClassLoader
        static innerModuleCache: string
        static javaClassCache: java.util.Map<string, char>

    }
}

declare module "cn.nukkit.plugin.js.ESMFileSystem" {
    declare const ESMFileSystem = cn.nukkit.plugin.js.ESMFileSystem;
}

declare namespace cn.nukkit.nbt.tag {
    declare class ByteArrayTag extends cn.nukkit.nbt.tag.Tag {
        public constructor(name: string): void
        public constructor(name: string, data: byte[]): void
        write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void
        load(dis: cn.nukkit.nbt.stream.NBTInputStream): void
        public getData(): byte[]
        public getId(): byte
        public toString(): string
        public toSnbt(): string
        public equals(obj: java.lang.Object): boolean
        public hashCode(): int
        public copy(): cn.nukkit.nbt.tag.Tag
        public parseValue(): byte[]
        public parseValue(): java.lang.Object
        public data: byte[]

    }
}

declare module "cn.nukkit.nbt.tag.ByteArrayTag" {
    declare const ByteArrayTag = cn.nukkit.nbt.tag.ByteArrayTag;
}

declare namespace cn.nukkit.nbt.tag {
    declare class LongTag extends cn.nukkit.nbt.tag.NumberTag {
        public getData(): long
        public setData(data: long): void
        public constructor(name: string): void
        public constructor(name: string, data: long): void
        write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void
        load(dis: cn.nukkit.nbt.stream.NBTInputStream): void
        public parseValue(): long
        public getId(): byte
        public toString(): string
        public toSnbt(): string
        public copy(): cn.nukkit.nbt.tag.Tag
        public equals(obj: java.lang.Object): boolean
        public setData(var0: java.lang.Number): void
        public getData(): java.lang.Number
        public parseValue(): java.lang.Object
        public data: long

    }
}

declare module "cn.nukkit.nbt.tag.LongTag" {
    declare const LongTag = cn.nukkit.nbt.tag.LongTag;
}

declare namespace cn.nukkit.nbt.tag {
    declare class EndTag extends cn.nukkit.nbt.tag.Tag {
        public constructor(): void
        load(dis: cn.nukkit.nbt.stream.NBTInputStream): void
        write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void
        public getId(): byte
        public toString(): string
        public toSnbt(): string
        public copy(): cn.nukkit.nbt.tag.Tag
        public parseValue(): java.lang.Object

    }
}

declare module "cn.nukkit.nbt.tag.EndTag" {
    declare const EndTag = cn.nukkit.nbt.tag.EndTag;
}

declare namespace cn.nukkit.nbt.tag {
    declare class IntArrayTag extends cn.nukkit.nbt.tag.Tag {
        public constructor(name: string): void
        public constructor(name: string, data: int[]): void
        write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void
        load(dis: cn.nukkit.nbt.stream.NBTInputStream): void
        public getData(): int[]
        public parseValue(): int[]
        public getId(): byte
        public toString(): string
        public toSnbt(): string
        public equals(obj: java.lang.Object): boolean
        public hashCode(): int
        public copy(): cn.nukkit.nbt.tag.Tag
        public parseValue(): java.lang.Object
        public data: int[]

    }
}

declare module "cn.nukkit.nbt.tag.IntArrayTag" {
    declare const IntArrayTag = cn.nukkit.nbt.tag.IntArrayTag;
}

declare namespace cn.nukkit.nbt.tag {
    declare class NumberTag extends cn.nukkit.nbt.tag.Tag {
        constructor(name: string): void
        public getData(): any
        public setData(): void
        public hashCode(): int

    }
}

declare module "cn.nukkit.nbt.tag.NumberTag" {
    declare const NumberTag = cn.nukkit.nbt.tag.NumberTag;
}

declare namespace cn.nukkit.nbt.tag {
    declare class ListTag extends cn.nukkit.nbt.tag.Tag {
        public constructor(): void
        public constructor(name: string): void
        write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void
        load(dis: cn.nukkit.nbt.stream.NBTInputStream): void
        public getId(): byte
        public toString(): string
        public toSnbt(): string
        public print(prefix: string, out: java.io.PrintStream): void
        public add(): cn.nukkit.nbt.tag.ListTag<any>
        public add(index: int): cn.nukkit.nbt.tag.ListTag<any>
        public parseValue(): java.util.List<java.lang.Object>
        public get(): int
        public getAll(): java.util.List<any>
        public setAll(tags: java.util.List<any>): void
        public remove(): void
        public remove(index: int): void
        public removeAll(tags: java.util.Collection<any>): void
        public size(): int
        public copy(): cn.nukkit.nbt.tag.Tag
        public equals(obj: java.lang.Object): boolean
        public hashCode(): int
        public parseValue(): java.lang.Object
        static lambda$toSnbt$1(tag: cn.nukkit.nbt.tag.Tag): string
        static lambda$toString$0(joiner: java.util.StringJoiner, tag: cn.nukkit.nbt.tag.Tag): void
        list: java.util.List<any>
        public type: byte

    }
}

declare module "cn.nukkit.nbt.tag.ListTag" {
    declare const ListTag = cn.nukkit.nbt.tag.ListTag;
}

declare namespace cn.nukkit.nbt {
    declare class NBTIO extends java.lang.Object {
        public constructor(): void
        public static putItemHelper(item: cn.nukkit.item.Item): cn.nukkit.nbt.tag.CompoundTag
        public static putItemHelper(item: cn.nukkit.item.Item, slot: int): cn.nukkit.nbt.tag.CompoundTag
        public static getItemHelper(tag: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.item.Item
        static fixAlphaItem(id: int, damage: int, count: int): cn.nukkit.item.Item
        public static read(file: java.io.File): cn.nukkit.nbt.tag.CompoundTag
        public static read(file: java.io.File, endianness: java.nio.ByteOrder): cn.nukkit.nbt.tag.CompoundTag
        public static read(inputStream: java.io.InputStream): cn.nukkit.nbt.tag.CompoundTag
        public static read(inputStream: java.io.InputStream, endianness: java.nio.ByteOrder): cn.nukkit.nbt.tag.CompoundTag
        public static read(inputStream: java.io.InputStream, endianness: java.nio.ByteOrder, network: boolean): cn.nukkit.nbt.tag.CompoundTag
        public static readTag(inputStream: java.io.InputStream, endianness: java.nio.ByteOrder, network: boolean): cn.nukkit.nbt.tag.Tag
        public static read(data: byte[]): cn.nukkit.nbt.tag.CompoundTag
        public static read(data: byte[], endianness: java.nio.ByteOrder): cn.nukkit.nbt.tag.CompoundTag
        public static read(data: byte[], endianness: java.nio.ByteOrder, network: boolean): cn.nukkit.nbt.tag.CompoundTag
        public static readCompressed(inputStream: java.io.InputStream): cn.nukkit.nbt.tag.CompoundTag
        public static readCompressed(inputStream: java.io.InputStream, endianness: java.nio.ByteOrder): cn.nukkit.nbt.tag.CompoundTag
        public static readCompressed(data: byte[]): cn.nukkit.nbt.tag.CompoundTag
        public static readCompressed(data: byte[], endianness: java.nio.ByteOrder): cn.nukkit.nbt.tag.CompoundTag
        public static readNetworkCompressed(inputStream: java.io.InputStream): cn.nukkit.nbt.tag.CompoundTag
        public static readNetworkCompressed(inputStream: java.io.InputStream, endianness: java.nio.ByteOrder): cn.nukkit.nbt.tag.CompoundTag
        public static readNetworkCompressed(data: byte[]): cn.nukkit.nbt.tag.CompoundTag
        public static readNetworkCompressed(data: byte[], endianness: java.nio.ByteOrder): cn.nukkit.nbt.tag.CompoundTag
        public static write(tag: cn.nukkit.nbt.tag.CompoundTag): byte[]
        public static write(tag: cn.nukkit.nbt.tag.CompoundTag, endianness: java.nio.ByteOrder): byte[]
        public static write(tag: cn.nukkit.nbt.tag.CompoundTag, endianness: java.nio.ByteOrder, network: boolean): byte[]
        public static write(tag: cn.nukkit.nbt.tag.Tag, endianness: java.nio.ByteOrder, network: boolean): byte[]
        public static write(tags: java.util.Collection<cn.nukkit.nbt.tag.CompoundTag>): byte[]
        public static write(tags: java.util.Collection<cn.nukkit.nbt.tag.CompoundTag>, endianness: java.nio.ByteOrder): byte[]
        public static write(tags: java.util.Collection<cn.nukkit.nbt.tag.CompoundTag>, endianness: java.nio.ByteOrder, network: boolean): byte[]
        public static write(tag: cn.nukkit.nbt.tag.CompoundTag, file: java.io.File): void
        public static write(tag: cn.nukkit.nbt.tag.CompoundTag, file: java.io.File, endianness: java.nio.ByteOrder): void
        public static write(tag: cn.nukkit.nbt.tag.CompoundTag, outputStream: java.io.OutputStream): void
        public static write(tag: cn.nukkit.nbt.tag.CompoundTag, outputStream: java.io.OutputStream, endianness: java.nio.ByteOrder): void
        public static write(tag: cn.nukkit.nbt.tag.CompoundTag, outputStream: java.io.OutputStream, endianness: java.nio.ByteOrder, network: boolean): void
        public static writeNetwork(tag: cn.nukkit.nbt.tag.Tag): byte[]
        public static writeGZIPCompressed(tag: cn.nukkit.nbt.tag.CompoundTag): byte[]
        public static writeGZIPCompressed(tag: cn.nukkit.nbt.tag.CompoundTag, endianness: java.nio.ByteOrder): byte[]
        public static writeGZIPCompressed(tag: cn.nukkit.nbt.tag.CompoundTag, outputStream: java.io.OutputStream): void
        public static writeGZIPCompressed(tag: cn.nukkit.nbt.tag.CompoundTag, outputStream: java.io.OutputStream, endianness: java.nio.ByteOrder): void
        public static writeNetworkGZIPCompressed(tag: cn.nukkit.nbt.tag.CompoundTag): byte[]
        public static writeNetworkGZIPCompressed(tag: cn.nukkit.nbt.tag.CompoundTag, endianness: java.nio.ByteOrder): byte[]
        public static writeNetworkGZIPCompressed(tag: cn.nukkit.nbt.tag.CompoundTag, outputStream: java.io.OutputStream): void
        public static writeNetworkGZIPCompressed(tag: cn.nukkit.nbt.tag.CompoundTag, outputStream: java.io.OutputStream, endianness: java.nio.ByteOrder): void
        public static writeZLIBCompressed(tag: cn.nukkit.nbt.tag.CompoundTag, outputStream: java.io.OutputStream): void
        public static writeZLIBCompressed(tag: cn.nukkit.nbt.tag.CompoundTag, outputStream: java.io.OutputStream, endianness: java.nio.ByteOrder): void
        public static writeZLIBCompressed(tag: cn.nukkit.nbt.tag.CompoundTag, outputStream: java.io.OutputStream, level: int): void
        public static writeZLIBCompressed(tag: cn.nukkit.nbt.tag.CompoundTag, outputStream: java.io.OutputStream, level: int, endianness: java.nio.ByteOrder): void
        public static safeWrite(tag: cn.nukkit.nbt.tag.CompoundTag, file: java.io.File): void

    }
}

declare module "cn.nukkit.nbt.NBTIO" {
    declare const NBTIO = cn.nukkit.nbt.NBTIO;
}

declare namespace cn.nukkit.nbt.stream {
    declare class FastByteArrayOutputStream extends java.io.OutputStream {
        public constructor(): void
        public constructor(initialCapacity: int): void
        public constructor(a: byte[]): void
        public reset(): cn.nukkit.nbt.stream.FastByteArrayOutputStream
        public write(b: int): void
        public static ensureOffsetLength(arrayLength: int, offset: int, length: int): void
        public static grow(array: byte[], length: int): byte[]
        public static grow(array: byte[], length: int, preserve: int): byte[]
        public write(b: byte[], off: int, len: int): void
        public position(newPosition: long): void
        public position(): long
        public length(): long
        public toByteArray(): byte[]
        public static ONEOVERPHI: long
        public static DEFAULT_INITIAL_CAPACITY: int
        public array: byte[]
        public length: int
        position: int

    }
}

declare module "cn.nukkit.nbt.stream.FastByteArrayOutputStream" {
    declare const FastByteArrayOutputStream = cn.nukkit.nbt.stream.FastByteArrayOutputStream;
}

declare namespace cn.nukkit.scoreboard.interfaces {
    declare interface Scorer {
        public getScorerType(): cn.nukkit.scoreboard.data.ScorerType
        public getName(): string

    }
}

declare module "cn.nukkit.scoreboard.interfaces.Scorer" {
    declare type Scorer = cn.nukkit.scoreboard.interfaces.Scorer;
}

declare namespace cn.nukkit.scoreboard {
    declare class Scoreboard$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$scoreboard$data$ScorerType: int[]

    }
}

declare module "cn.nukkit.scoreboard.Scoreboard$1" {
    declare const Scoreboard$1 = cn.nukkit.scoreboard.Scoreboard$1;
}

declare namespace cn.nukkit {
    declare class Achievement$1 extends java.util.HashMap {
        constructor(): void

    }
}

declare module "cn.nukkit.Achievement$1" {
    declare const Achievement$1 = cn.nukkit.Achievement$1;
}

declare namespace cn.nukkit.entity.data {
    declare class EntityMetadata extends java.lang.Object {
        public constructor(): void
        public get(id: int): cn.nukkit.entity.data.EntityData
        public getOrDefault(id: int, defaultValue: cn.nukkit.entity.data.EntityData): cn.nukkit.entity.data.EntityData
        public exists(id: int): boolean
        public put(data: cn.nukkit.entity.data.EntityData): cn.nukkit.entity.data.EntityMetadata
        public getByte(id: int): int
        public getShort(id: int): int
        public getInt(id: int): int
        public getLong(id: int): long
        public getFloat(id: int): float
        public getBoolean(id: int): boolean
        public getNBT(id: int): cn.nukkit.nbt.tag.CompoundTag
        public getString(id: int): string
        public getPosition(id: int): cn.nukkit.math.Vector3
        public getFloatPosition(id: int): cn.nukkit.math.Vector3f
        public putByte(id: int, value: int): cn.nukkit.entity.data.EntityMetadata
        public putShort(id: int, value: int): cn.nukkit.entity.data.EntityMetadata
        public putInt(id: int, value: int): cn.nukkit.entity.data.EntityMetadata
        public putLong(id: int, value: long): cn.nukkit.entity.data.EntityMetadata
        public putFloat(id: int, value: float): cn.nukkit.entity.data.EntityMetadata
        public putBoolean(id: int, value: boolean): cn.nukkit.entity.data.EntityMetadata
        public putNBT(id: int, tag: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.entity.data.EntityMetadata
        public putSlot(id: int, value: cn.nukkit.item.Item): cn.nukkit.entity.data.EntityMetadata
        public putString(id: int, value: string): cn.nukkit.entity.data.EntityMetadata
        public getMap(): java.util.Map<int, cn.nukkit.entity.data.EntityData>
        public toString(): string
        static log: org.apache.logging.log4j.Logger
        map: java.util.Map<int, cn.nukkit.entity.data.EntityData>

    }
}

declare module "cn.nukkit.entity.data.EntityMetadata" {
    declare const EntityMetadata = cn.nukkit.entity.data.EntityMetadata;
}

declare namespace cn.nukkit.entity.data {
    declare class Skin extends java.lang.Object {
        public constructor(): void
        public isValid(): boolean
        isValidSkin(): boolean
        isValidResourcePatch(): boolean
        public getSkinData(): cn.nukkit.utils.SerializedImage
        public getSkinId(): string
        public setSkinId(skinId: string): void
        public generateSkinId(name: string): void
        public setSkinData(skinData: byte[]): void
        public setSkinData(image: java.awt.image.BufferedImage): void
        public setSkinData(skinData: cn.nukkit.utils.SerializedImage): void
        public setSkinResourcePatch(skinResourcePatch: string): void
        public setGeometryName(geometryName: string): void
        public getSkinResourcePatch(): string
        public getCapeData(): cn.nukkit.utils.SerializedImage
        public getCapeId(): string
        public setCapeId(capeId: string): void
        public setCapeData(capeData: byte[]): void
        public setCapeData(image: java.awt.image.BufferedImage): void
        public setCapeData(capeData: cn.nukkit.utils.SerializedImage): void
        public getGeometryData(): string
        public setGeometryData(geometryData: string): void
        public getAnimationData(): string
        public setAnimationData(animationData: string): void
        public getAnimations(): java.util.List<cn.nukkit.utils.SkinAnimation>
        public getPersonaPieces(): java.util.List<cn.nukkit.utils.PersonaPiece>
        public getTintColors(): java.util.List<cn.nukkit.utils.PersonaPieceTint>
        public isPremium(): boolean
        public setPremium(premium: boolean): void
        public isPersona(): boolean
        public setPersona(persona: boolean): void
        public isCapeOnClassic(): boolean
        public setCapeOnClassic(capeOnClassic: boolean): void
        public setPrimaryUser(primaryUser: boolean): void
        public isPrimaryUser(): boolean
        public setGeometryDataEngineVersion(geometryDataEngineVersion: string): void
        public getGeometryDataEngineVersion(): string
        public isTrusted(): boolean
        public setTrusted(trusted: boolean): void
        public getSkinColor(): string
        public setSkinColor(skinColor: string): void
        public getArmSize(): string
        public setArmSize(armSize: string): void
        public getFullSkinId(): string
        public setPlayFabId(playFabId: string): void
        public getPlayFabId(): string
        static parseBufferedImage(image: java.awt.image.BufferedImage): cn.nukkit.utils.SerializedImage
        static convertLegacyGeometryName(geometryName: string): string
        public toString(): string
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        static PIXEL_SIZE: int
        public static SINGLE_SKIN_SIZE: int
        public static DOUBLE_SKIN_SIZE: int
        public static SKIN_128_64_SIZE: int
        public static SKIN_128_128_SIZE: int
        public static GEOMETRY_CUSTOM: string
        public static GEOMETRY_CUSTOM_SLIM: string
        fullSkinId: string
        skinId: string
        playFabId: string
        skinResourcePatch: string
        skinData: cn.nukkit.utils.SerializedImage
        animations: java.util.List<cn.nukkit.utils.SkinAnimation>
        personaPieces: java.util.List<cn.nukkit.utils.PersonaPiece>
        tintColors: java.util.List<cn.nukkit.utils.PersonaPieceTint>
        capeData: cn.nukkit.utils.SerializedImage
        geometryData: string
        animationData: string
        premium: boolean
        persona: boolean
        capeOnClassic: boolean
        primaryUser: boolean
        capeId: string
        skinColor: string
        armSize: string
        trusted: boolean
        geometryDataEngineVersion: string

    }
}

declare module "cn.nukkit.entity.data.Skin" {
    declare const Skin = cn.nukkit.entity.data.Skin;
}

declare namespace cn.nukkit.entity.data {
    declare class ShortEntityData extends cn.nukkit.entity.data.EntityData {
        public constructor(id: int, data: int): void
        public getData(): int
        public setData(data: int): void
        public getType(): int
        public toString(): string
        public setData(var0: java.lang.Object): void
        public getData(): java.lang.Object
        public data: int

    }
}

declare module "cn.nukkit.entity.data.ShortEntityData" {
    declare const ShortEntityData = cn.nukkit.entity.data.ShortEntityData;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityEnderDragon extends cn.nukkit.entity.mob.EntityMob {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        applyNameTag(player: cn.nukkit.Player, item: cn.nukkit.item.Item): boolean
        public applyNameTag(item: cn.nukkit.item.Item): boolean
        public getOriginalName(): string
        public isBoss(): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityEnderDragon" {
    declare const EntityEnderDragon = cn.nukkit.entity.mob.EntityEnderDragon;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityGhast extends cn.nukkit.entity.mob.EntityMob {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityGhast" {
    declare const EntityGhast = cn.nukkit.entity.mob.EntityGhast;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityDrowned extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntitySmite {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public getDrops(): cn.nukkit.item.Item[]
        public isUndead(): boolean
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityDrowned" {
    declare const EntityDrowned = cn.nukkit.entity.mob.EntityDrowned;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntitySilverfish extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntityArthropod {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getOriginalName(): string
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntitySilverfish" {
    declare const EntitySilverfish = cn.nukkit.entity.mob.EntitySilverfish;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntitySkeleton extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntitySmite {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public getDrops(): cn.nukkit.item.Item[]
        public isUndead(): boolean
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public onUpdate(currentTick: int): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntitySkeleton" {
    declare const EntitySkeleton = cn.nukkit.entity.mob.EntitySkeleton;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityZombie extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntitySmite {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isUndead(): boolean
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public onUpdate(currentTick: int): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityZombie" {
    declare const EntityZombie = cn.nukkit.entity.mob.EntityZombie;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityPiglin extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntityAgeable {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isBaby(): boolean
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityPiglin" {
    declare const EntityPiglin = cn.nukkit.entity.mob.EntityPiglin;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityHoglin extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntityAgeable {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isBaby(): boolean
        public setBaby(baby: boolean): void
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityHoglin" {
    declare const EntityHoglin = cn.nukkit.entity.mob.EntityHoglin;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntitySlime extends cn.nukkit.entity.mob.EntityMob {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public getDrops(): cn.nukkit.item.Item[]
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntitySlime" {
    declare const EntitySlime = cn.nukkit.entity.mob.EntitySlime;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntitySpider extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntityArthropod {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public getDrops(): cn.nukkit.item.Item[]
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntitySpider" {
    declare const EntitySpider = cn.nukkit.entity.mob.EntitySpider;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityPillager extends cn.nukkit.entity.mob.EntityMob {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityPillager" {
    declare const EntityPillager = cn.nukkit.entity.mob.EntityPillager;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityIronGolem extends cn.nukkit.entity.mob.EntityMob {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getOriginalName(): string
        public getWidth(): float
        public getHeight(): float
        initEntity(): void
        public getDrops(): cn.nukkit.item.Item[]
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityIronGolem" {
    declare const EntityIronGolem = cn.nukkit.entity.mob.EntityIronGolem;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityZombieVillager extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntitySmite {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isUndead(): boolean
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public onUpdate(currentTick: int): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityZombieVillager" {
    declare const EntityZombieVillager = cn.nukkit.entity.mob.EntityZombieVillager;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityWitch extends cn.nukkit.entity.mob.EntityMob {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityWitch" {
    declare const EntityWitch = cn.nukkit.entity.mob.EntityWitch;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityEndermite extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntityArthropod {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityEndermite" {
    declare const EntityEndermite = cn.nukkit.entity.mob.EntityEndermite;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityZombiePigman extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntitySmite {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isUndead(): boolean
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityZombiePigman" {
    declare const EntityZombiePigman = cn.nukkit.entity.mob.EntityZombiePigman;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityEnderman extends cn.nukkit.entity.mob.EntityMob {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityEnderman" {
    declare const EntityEnderman = cn.nukkit.entity.mob.EntityEnderman;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityPhantom extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntitySmite {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public getDrops(): cn.nukkit.item.Item[]
        public isUndead(): boolean
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityPhantom" {
    declare const EntityPhantom = cn.nukkit.entity.mob.EntityPhantom;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityMagmaCube extends cn.nukkit.entity.mob.EntityMob {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityMagmaCube" {
    declare const EntityMagmaCube = cn.nukkit.entity.mob.EntityMagmaCube;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityCaveSpider extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntityArthropod {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityCaveSpider" {
    declare const EntityCaveSpider = cn.nukkit.entity.mob.EntityCaveSpider;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityElderGuardian extends cn.nukkit.entity.mob.EntityMob {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityElderGuardian" {
    declare const EntityElderGuardian = cn.nukkit.entity.mob.EntityElderGuardian;
}

declare namespace cn.nukkit.entity {
    declare interface EntitySmite {

    }
}

declare module "cn.nukkit.entity.EntitySmite" {
    declare type EntitySmite = cn.nukkit.entity.EntitySmite;
}

declare namespace cn.nukkit.entity {
    declare interface EntityOwnable {
        public getOwnerName(): string
        public setOwnerName(var0: string): void
        public getOwner(): cn.nukkit.Player

    }
}

declare module "cn.nukkit.entity.EntityOwnable" {
    declare type EntityOwnable = cn.nukkit.entity.EntityOwnable;
}

declare namespace cn.nukkit.entity.weather {
    declare interface EntityLightningStrike extends cn.nukkit.entity.weather.EntityWeather {
        public isEffect(): boolean
        public setEffect(var0: boolean): void

    }
}

declare module "cn.nukkit.entity.weather.EntityLightningStrike" {
    declare type EntityLightningStrike = cn.nukkit.entity.weather.EntityLightningStrike;
}

declare namespace cn.nukkit.entity.weather {
    declare class EntityLightning extends cn.nukkit.entity.Entity implements cn.nukkit.entity.weather.EntityLightningStrike {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public isEffect(): boolean
        public setEffect(e: boolean): void
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        static isVulnerableOxidizable(block: cn.nukkit.block.Block): boolean
        public onUpdate(currentTick: int): boolean
        public getOriginalName(): string
        static lambda$onUpdate$2(directionPos: cn.nukkit.level.Position, down: cn.nukkit.block.Block, cleanOxidizationAround: java.util.function.Supplier, count: int): void
        lambda$onUpdate$1(randomPos: cn.nukkit.level.Position, directionPos: cn.nukkit.level.Position, random: java.util.concurrent.ThreadLocalRandom, changes: java.util.Map): cn.nukkit.math.Vector3
        static lambda$onUpdate$0(possibility: cn.nukkit.block.Block, k: cn.nukkit.level.Position, v: cn.nukkit.blockproperty.value.OxidizationLevel): cn.nukkit.blockproperty.value.OxidizationLevel
        public static NETWORK_ID: int
        isEffect: boolean
        public state: int
        public liveTime: int

    }
}

declare module "cn.nukkit.entity.weather.EntityLightning" {
    declare const EntityLightning = cn.nukkit.entity.weather.EntityLightning;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityMinecartHopper extends cn.nukkit.entity.item.EntityMinecartAbstract implements cn.nukkit.inventory.InventoryHolder {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getOriginalName(): string
        public getType(): cn.nukkit.utils.MinecartType
        public isRideable(): boolean
        public getNetworkId(): int
        public dropItem(): void
        public mountEntity(entity: cn.nukkit.entity.Entity, mode: byte): boolean
        public onInteract(player: cn.nukkit.Player, item: cn.nukkit.item.Item, clickedPos: cn.nukkit.math.Vector3): boolean
        public getInventory(): cn.nukkit.inventory.MinecartHopperInventory
        public initEntity(): void
        public saveNBT(): void
        public getInventory(): cn.nukkit.inventory.Inventory
        public static NETWORK_ID: int
        inventory: cn.nukkit.inventory.MinecartHopperInventory

    }
}

declare module "cn.nukkit.entity.item.EntityMinecartHopper" {
    declare const EntityMinecartHopper = cn.nukkit.entity.item.EntityMinecartHopper;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityPrimedTNT extends cn.nukkit.entity.Entity implements cn.nukkit.entity.EntityExplosive {
        public getWidth(): float
        public getLength(): float
        public getHeight(): float
        getGravity(): float
        getDrag(): float
        getBaseOffset(): float
        public canCollide(): boolean
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, source: cn.nukkit.entity.Entity): void
        public getNetworkId(): int
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        initEntity(): void
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean
        public saveNBT(): void
        public onUpdate(currentTick: int): boolean
        public explode(): void
        public getSource(): cn.nukkit.entity.Entity
        public getOriginalName(): string
        public static NETWORK_ID: int
        fuse: int
        source: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.entity.item.EntityPrimedTNT" {
    declare const EntityPrimedTNT = cn.nukkit.entity.item.EntityPrimedTNT;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityBoat extends cn.nukkit.entity.item.EntityVehicle {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getHeight(): float
        public getWidth(): float
        getDrag(): float
        getGravity(): float
        public getBaseOffset(): float
        public getNetworkId(): int
        public getInteractButtonText(player: cn.nukkit.Player): string
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        public close(): void
        createAddEntityPacket(): cn.nukkit.network.protocol.DataPacket
        public onUpdate(currentTick: int): boolean
        updateBoat(tickDiff: int): boolean
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean
        public canDoInteraction(): boolean
        moveBoat(waterDiff: double): void
        collectCollidingEntities(): boolean
        computeBuoyancy(waterDiff: double): boolean
        public updatePassengers(): void
        public updatePassengers(sendLinks: boolean): void
        public getWaterLevel(): double
        public mountEntity(entity: cn.nukkit.entity.Entity): boolean
        public mountEntity(entity: cn.nukkit.entity.Entity, mode: byte): boolean
        updatePassengerPosition(passenger: cn.nukkit.entity.Entity): void
        public dismountEntity(entity: cn.nukkit.entity.Entity, sendLinks: boolean): boolean
        public isControlling(entity: cn.nukkit.entity.Entity): boolean
        public onInteract(player: cn.nukkit.Player, item: cn.nukkit.item.Item, clickedPos: cn.nukkit.math.Vector3): boolean
        public getMountedOffset(entity: cn.nukkit.entity.Entity): cn.nukkit.math.Vector3f
        public onPaddle(animation: cn.nukkit.network.protocol.AnimatePacket$Action, value: float): void
        public applyEntityCollision(entity: cn.nukkit.entity.Entity): void
        public canPassThrough(): boolean
        public kill(): void
        public saveNBT(): void
        public getVariant(): int
        public setVariant(variant: int): void
        public getOriginalName(): string
        public onInput(x: double, var1: double, y: double, var3: double): void
        public static NETWORK_ID: int
        public static RIDER_PLAYER_OFFSET: cn.nukkit.math.Vector3f
        public static RIDER_OFFSET: cn.nukkit.math.Vector3f
        public static PASSENGER_OFFSET: cn.nukkit.math.Vector3f
        public static RIDER_PASSENGER_OFFSET: cn.nukkit.math.Vector3f
        public static RIDER_INDEX: int
        public static PASSENGER_INDEX: int
        public static SINKING_DEPTH: double
        public static SINKING_SPEED: double
        public static SINKING_MAX_SPEED: double
        sinking: boolean
        ticksInWater: int
        ignoreCollision: java.util.Set<cn.nukkit.entity.Entity>
        public woodID: int

    }
}

declare module "cn.nukkit.entity.item.EntityBoat" {
    declare const EntityBoat = cn.nukkit.entity.item.EntityBoat;
}

declare namespace cn.nukkit.entity {
    declare class EntityHumanType extends cn.nukkit.entity.EntityCreature implements cn.nukkit.inventory.InventoryHolder {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getInventory(): cn.nukkit.inventory.PlayerInventory
        public getEnderChestInventory(): cn.nukkit.inventory.PlayerEnderChestInventory
        public getOffhandInventory(): cn.nukkit.inventory.PlayerOffhandInventory
        initEntity(): void
        public saveNBT(): void
        public getDrops(): cn.nukkit.item.Item[]
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        calculateEnchantmentProtectionFactor(item: cn.nukkit.item.Item, source: cn.nukkit.event.entity.EntityDamageEvent): double
        public setOnFire(seconds: int): void
        applyNameTag(player: cn.nukkit.Player, item: cn.nukkit.item.Item): boolean
        public applyNameTag(item: cn.nukkit.item.Item): boolean
        damageArmor(armor: cn.nukkit.item.Item, damager: cn.nukkit.entity.Entity): cn.nukkit.item.Item
        public getInventory(): cn.nukkit.inventory.Inventory
        static lambda$getDrops$0(item: cn.nukkit.item.Item): boolean
        inventory: cn.nukkit.inventory.PlayerInventory
        enderChestInventory: cn.nukkit.inventory.PlayerEnderChestInventory
        offhandInventory: cn.nukkit.inventory.PlayerOffhandInventory

    }
}

declare module "cn.nukkit.entity.EntityHumanType" {
    declare const EntityHumanType = cn.nukkit.entity.EntityHumanType;
}

declare namespace cn.nukkit.entity {
    declare class EntityLiving extends cn.nukkit.entity.Entity implements cn.nukkit.entity.EntityDamageable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        getGravity(): float
        getDrag(): float
        initEntity(): void
        public setHealth(health: float): void
        public saveNBT(): void
        public hasLineOfSight(entity: cn.nukkit.entity.Entity): boolean
        public collidingWith(ent: cn.nukkit.entity.Entity): void
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        public knockBack(attacker: cn.nukkit.entity.Entity, damage: double, var2: double, x: double): void
        public knockBack(attacker: cn.nukkit.entity.Entity, damage: double, var2: double, x: double, var4: double): void
        public kill(): void
        public entityBaseTick(): boolean
        public entityBaseTick(tickDiff: int): boolean
        public getDrops(): cn.nukkit.item.Item[]
        public getLineOfSight(maxDistance: int): cn.nukkit.block.Block[]
        public getLineOfSight(maxDistance: int, maxLength: int): cn.nukkit.block.Block[]
        public getLineOfSight(maxDistance: int, maxLength: int, transparent: java.util.Map<int, java.lang.Object>): cn.nukkit.block.Block[]
        public getLineOfSight(maxDistance: int, maxLength: int, transparent: int[]): cn.nukkit.block.Block[]
        public getTargetBlock(maxDistance: int): cn.nukkit.block.Block
        public getTargetBlock(maxDistance: int, transparent: java.util.Map<int, java.lang.Object>): cn.nukkit.block.Block
        public getTargetBlock(maxDistance: int, transparent: int[]): cn.nukkit.block.Block
        public setMovementSpeed(speed: float): void
        public getMovementSpeed(): float
        public getAirTicks(): int
        public setAirTicks(ticks: int): void
        blockedByShield(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        onBlock(entity: cn.nukkit.entity.Entity, animate: boolean): void
        public isBlocking(): boolean
        public setBlocking(value: boolean): void
        public isPersistent(): boolean
        public setPersistent(persistent: boolean): void
        public preAttack(player: cn.nukkit.Player): void
        public postAttack(player: cn.nukkit.Player): void
        attackTime: int
        attackTimeByShieldKb: boolean
        attackTimeBefore: int
        invisible: boolean
        movementSpeed: float
        turtleTicks: int

    }
}

declare module "cn.nukkit.entity.EntityLiving" {
    declare const EntityLiving = cn.nukkit.entity.EntityLiving;
}

declare namespace cn.nukkit.entity {
    declare class Entity$2 extends cn.nukkit.scheduler.Task {
        constructor(this$0: cn.nukkit.entity.Entity, var1: cn.nukkit.level.Position): void
        public onRun(currentTick: int): void
        val$newPos: cn.nukkit.level.Position
        this$0: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.entity.Entity$2" {
    declare const Entity$2 = cn.nukkit.entity.Entity$2;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityTameable extends cn.nukkit.entity.passive.EntityAnimal implements cn.nukkit.entity.EntityOwnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public saveNBT(): void
        public getOwnerName(): string
        public setOwnerName(playerName: string): void
        public getOwner(): cn.nukkit.Player
        public isTamed(): boolean
        public setTamed(flag: boolean): void
        public isSitting(): boolean
        public setSitting(flag: boolean): void
        public static DATA_TAMED_FLAG: int
        public static DATA_OWNER_NAME: int

    }
}

declare module "cn.nukkit.entity.passive.EntityTameable" {
    declare const EntityTameable = cn.nukkit.entity.passive.EntityTameable;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityWanderingTrader extends cn.nukkit.entity.EntityCreature implements cn.nukkit.entity.passive.EntityNPC {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public getNetworkId(): int
        public initEntity(): void
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityWanderingTrader" {
    declare const EntityWanderingTrader = cn.nukkit.entity.passive.EntityWanderingTrader;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityVillagerV1 extends cn.nukkit.entity.EntityCreature implements cn.nukkit.entity.passive.EntityNPC, cn.nukkit.entity.EntityAgeable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public getNetworkId(): int
        public initEntity(): void
        public getProfession(): int
        public setProfession(profession: int): void
        public isBaby(): boolean
        public static PROFESSION_FARMER: int
        public static PROFESSION_LIBRARIAN: int
        public static PROFESSION_PRIEST: int
        public static PROFESSION_BLACKSMITH: int
        public static PROFESSION_BUTCHER: int
        public static PROFESSION_GENERIC: int
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityVillagerV1" {
    declare const EntityVillagerV1 = cn.nukkit.entity.passive.EntityVillagerV1;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityWaterAnimal extends cn.nukkit.entity.EntityCreature implements cn.nukkit.entity.EntityAgeable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public isBaby(): boolean

    }
}

declare module "cn.nukkit.entity.passive.EntityWaterAnimal" {
    declare const EntityWaterAnimal = cn.nukkit.entity.passive.EntityWaterAnimal;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityVillager extends cn.nukkit.entity.EntityCreature implements cn.nukkit.entity.passive.EntityNPC, cn.nukkit.entity.EntityAgeable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public initEntity(): void
        public isBaby(): boolean
        public setBaby(baby: boolean): void
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityVillager" {
    declare const EntityVillager = cn.nukkit.entity.passive.EntityVillager;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityHorse extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public getDrops(): cn.nukkit.item.Item[]
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityHorse" {
    declare const EntityHorse = cn.nukkit.entity.passive.EntityHorse;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityAnimal extends cn.nukkit.entity.EntityPhysical implements cn.nukkit.entity.EntityAgeable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public isBaby(): boolean
        public isBreedingItem(item: cn.nukkit.item.Item): boolean
        getStepHeight(): double

    }
}

declare module "cn.nukkit.entity.passive.EntityAnimal" {
    declare const EntityAnimal = cn.nukkit.entity.passive.EntityAnimal;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityPig extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public getOriginalName(): string
        public getDrops(): cn.nukkit.item.Item[]
        public getNetworkId(): int
        public isBreedingItem(item: cn.nukkit.item.Item): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityPig" {
    declare const EntityPig = cn.nukkit.entity.passive.EntityPig;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityPolarBear extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public getDrops(): cn.nukkit.item.Item[]
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityPolarBear" {
    declare const EntityPolarBear = cn.nukkit.entity.passive.EntityPolarBear;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityWolf extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public getNetworkId(): int
        public initEntity(): void
        public isBreedingItem(item: cn.nukkit.item.Item): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityWolf" {
    declare const EntityWolf = cn.nukkit.entity.passive.EntityWolf;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntitySkeletonHorse extends cn.nukkit.entity.passive.EntityAnimal implements cn.nukkit.entity.EntitySmite {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public getDrops(): cn.nukkit.item.Item[]
        public isUndead(): boolean
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntitySkeletonHorse" {
    declare const EntitySkeletonHorse = cn.nukkit.entity.passive.EntitySkeletonHorse;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityCod extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getOriginalName(): string
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityCod" {
    declare const EntityCod = cn.nukkit.entity.passive.EntityCod;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityMule extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getDrops(): cn.nukkit.item.Item[]
        public getNetworkId(): int
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityMule" {
    declare const EntityMule = cn.nukkit.entity.passive.EntityMule;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityPanda extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityPanda" {
    declare const EntityPanda = cn.nukkit.entity.passive.EntityPanda;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityZombieHorse extends cn.nukkit.entity.passive.EntityAnimal implements cn.nukkit.entity.EntitySmite {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public getDrops(): cn.nukkit.item.Item[]
        public isUndead(): boolean
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityZombieHorse" {
    declare const EntityZombieHorse = cn.nukkit.entity.passive.EntityZombieHorse;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityBee extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getWidth(): float
        public getHeight(): float
        public getHasNectar(): boolean
        public setHasNectar(hasNectar: boolean): void
        public isAngry(): boolean
        public setAngry(angry: boolean): void
        public onUpdate(currentTick: int): boolean
        initEntity(): void
        public nectarDelivered(blockEntityBeehive: cn.nukkit.blockentity.BlockEntityBeehive): void
        public leftBeehive(blockEntityBeehive: cn.nukkit.blockentity.BlockEntityBeehive): void
        public setAngry(player: cn.nukkit.Player): void
        public getOriginalName(): string
        static lambda$onUpdate$0(block: cn.nukkit.block.Block): boolean
        public static NETWORK_ID: int
        beehiveTimer: int

    }
}

declare module "cn.nukkit.entity.passive.EntityBee" {
    declare const EntityBee = cn.nukkit.entity.passive.EntityBee;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityChicken extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public getDrops(): cn.nukkit.item.Item[]
        public getNetworkId(): int
        initEntity(): void
        public isBreedingItem(item: cn.nukkit.item.Item): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityChicken" {
    declare const EntityChicken = cn.nukkit.entity.passive.EntityChicken;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityFox extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getWidth(): float
        public getHeight(): float
        initEntity(): void
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityFox" {
    declare const EntityFox = cn.nukkit.entity.passive.EntityFox;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntitySquid extends cn.nukkit.entity.passive.EntityWaterAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public getDrops(): cn.nukkit.item.Item[]
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntitySquid" {
    declare const EntitySquid = cn.nukkit.entity.passive.EntitySquid;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityMooshroom extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public getDrops(): cn.nukkit.item.Item[]
        public getNetworkId(): int
        initEntity(): void
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityMooshroom" {
    declare const EntityMooshroom = cn.nukkit.entity.passive.EntityMooshroom;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityDonkey extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public getDrops(): cn.nukkit.item.Item[]
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityDonkey" {
    declare const EntityDonkey = cn.nukkit.entity.passive.EntityDonkey;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntitySalmon extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getOriginalName(): string
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntitySalmon" {
    declare const EntitySalmon = cn.nukkit.entity.passive.EntitySalmon;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityLlama extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getWidth(): float
        public getHeight(): float
        public getEyeHeight(): float
        public initEntity(): void
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityLlama" {
    declare const EntityLlama = cn.nukkit.entity.passive.EntityLlama;
}

declare namespace cn.nukkit.entity {
    declare class EntityCreature extends cn.nukkit.entity.EntityLiving implements cn.nukkit.entity.EntityNameable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public onInteract(player: cn.nukkit.Player, item: cn.nukkit.item.Item, clickedPos: cn.nukkit.math.Vector3): boolean
        public playerApplyNameTag(player: cn.nukkit.Player, item: cn.nukkit.item.Item): boolean
        applyNameTag(player: cn.nukkit.Player, item: cn.nukkit.item.Item): boolean

    }
}

declare module "cn.nukkit.entity.EntityCreature" {
    declare const EntityCreature = cn.nukkit.entity.EntityCreature;
}

declare namespace cn.nukkit.entity {
    declare class EntityHanging extends cn.nukkit.entity.Entity {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public saveNBT(): void
        public getDirection(): cn.nukkit.math.BlockFace
        public onUpdate(currentTick: int): boolean
        isSurfaceValid(): boolean
        direction: int

    }
}

declare module "cn.nukkit.entity.EntityHanging" {
    declare const EntityHanging = cn.nukkit.entity.EntityHanging;
}

declare namespace cn.nukkit.entity {
    declare interface EntityAgeable {
        public isBaby(): boolean

    }
}

declare module "cn.nukkit.entity.EntityAgeable" {
    declare type EntityAgeable = cn.nukkit.entity.EntityAgeable;
}

declare namespace cn.nukkit.entity {
    declare interface EntityArthropod {

    }
}

declare module "cn.nukkit.entity.EntityArthropod" {
    declare type EntityArthropod = cn.nukkit.entity.EntityArthropod;
}

declare namespace cn.nukkit.entity.projectile {
    declare class EntityArrow extends cn.nukkit.entity.projectile.EntityProjectile {
        public getNetworkId(): int
        public getWidth(): float
        public getLength(): float
        public getHeight(): float
        public getGravity(): float
        public getDrag(): float
        updateMotion(): void
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, shootingEntity: cn.nukkit.entity.Entity): void
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, shootingEntity: cn.nukkit.entity.Entity, critical: boolean): void
        initEntity(): void
        public setCritical(): void
        public setCritical(value: boolean): void
        public isCritical(): boolean
        public getResultDamage(): int
        getBaseDamage(): double
        public onUpdate(currentTick: int): boolean
        public canBeMovedByCurrents(): boolean
        afterCollisionWithEntity(entity: cn.nukkit.entity.Entity): void
        addHitEffect(): void
        public saveNBT(): void
        public getPickupMode(): int
        public setPickupMode(pickupMode: int): void
        public getOriginalName(): string
        public static NETWORK_ID: int
        pickupMode: int

    }
}

declare module "cn.nukkit.entity.projectile.EntityArrow" {
    declare const EntityArrow = cn.nukkit.entity.projectile.EntityArrow;
}

declare namespace cn.nukkit.entity.projectile {
    declare class EntityEgg extends cn.nukkit.entity.projectile.EntityProjectile {
        public getNetworkId(): int
        public getWidth(): float
        public getLength(): float
        public getHeight(): float
        getGravity(): float
        getDrag(): float
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, shootingEntity: cn.nukkit.entity.Entity): void
        public onUpdate(currentTick: int): boolean
        addHitEffect(): void
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.projectile.EntityEgg" {
    declare const EntityEgg = cn.nukkit.entity.projectile.EntityEgg;
}

declare namespace cn.nukkit.entity.projectile {
    declare class EntitySnowball extends cn.nukkit.entity.projectile.EntityProjectile {
        static nextParticleCount(): int
        public getNetworkId(): int
        public getWidth(): float
        public getLength(): float
        public getHeight(): float
        getGravity(): float
        getDrag(): float
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, shootingEntity: cn.nukkit.entity.Entity): void
        public onUpdate(currentTick: int): boolean
        public getResultDamage(entity: cn.nukkit.entity.Entity): int
        addHitEffect(): void
        public getOriginalName(): string
        public static NETWORK_ID: int
        static particleCounts: byte[]
        static particleIndex: int

    }
}

declare module "cn.nukkit.entity.projectile.EntitySnowball" {
    declare const EntitySnowball = cn.nukkit.entity.projectile.EntitySnowball;
}

declare namespace cn.nukkit.entity.projectile {
    declare class EntityEnderPearl extends cn.nukkit.entity.projectile.EntityProjectile {
        public getNetworkId(): int
        public getWidth(): float
        public getLength(): float
        public getHeight(): float
        getGravity(): float
        getDrag(): float
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, shootingEntity: cn.nukkit.entity.Entity): void
        public onUpdate(currentTick: int): boolean
        public onCollideWithEntity(entity: cn.nukkit.entity.Entity): void
        teleport(): void
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.projectile.EntityEnderPearl" {
    declare const EntityEnderPearl = cn.nukkit.entity.projectile.EntityEnderPearl;
}

declare namespace co.aikar.timings {
    declare class TimingsExport extends java.lang.Thread {
        constructor(sender: cn.nukkit.command.CommandSender, out: com.google.gson.JsonObject, history: co.aikar.timings.TimingsHistory[]): void
        public static reportTimings(sender: cn.nukkit.command.CommandSender): void
        static getCost(): long
        public start(): void
        public run(): void
        getResponse(con: java.net.HttpURLConnection): string
        static lambda$reportTimings$5(plugin: cn.nukkit.plugin.Plugin): cn.nukkit.timings.JsonUtil$JSONPair
        static lambda$reportTimings$4(entry: java.util.Map$Entry): cn.nukkit.timings.JsonUtil$JSONPair
        static lambda$reportTimings$3(entry: java.util.Map$Entry): cn.nukkit.timings.JsonUtil$JSONPair
        static lambda$reportTimings$2(entry: java.util.Map$Entry): cn.nukkit.timings.JsonUtil$JSONPair
        static lambda$reportTimings$1(group: co.aikar.timings.TimingIdentifier$TimingGroup): cn.nukkit.timings.JsonUtil$JSONPair
        static lambda$reportTimings$0(input: java.lang.management.GarbageCollectorMXBean): cn.nukkit.timings.JsonUtil$JSONPair
        static log: org.apache.logging.log4j.Logger
        sender: cn.nukkit.command.CommandSender
        out: com.google.gson.JsonObject
        history: co.aikar.timings.TimingsHistory[]

    }
}

declare module "co.aikar.timings.TimingsExport" {
    declare const TimingsExport = co.aikar.timings.TimingsExport;
}

declare namespace co.aikar.timings {
    declare class TimingsHistory$TicksRecord extends java.lang.Object {
        constructor(): void
        timed: long
        player: long
        entity: long
        activatedEntity: long
        tileEntity: long

    }
}

declare module "co.aikar.timings.TimingsHistory$TicksRecord" {
    declare const TimingsHistory$TicksRecord = co.aikar.timings.TimingsHistory$TicksRecord;
}

declare namespace co.aikar.timings {
    declare class Timing extends java.lang.Object implements java.lang.AutoCloseable {
        constructor(id: co.aikar.timings.TimingIdentifier): void
        checkEnabled(): void
        tick(violated: boolean): void
        public startTiming(): co.aikar.timings.Timing
        public stopTiming(): void
        public abort(): void
        addDiff(diff: long): void
        reset(full: boolean): void
        public equals(o: java.lang.Object): boolean
        public hashCode(): int
        public close(): void
        isSpecial(): boolean
        static idPool: int
        id: int
        name: string
        verbose: boolean
        children: java.util.Map<int, co.aikar.timings.TimingData>
        parent: co.aikar.timings.Timing
        groupTiming: co.aikar.timings.Timing
        record: co.aikar.timings.TimingData
        start: long
        timingDepth: int
        added: boolean
        timed: boolean
        enabled: boolean

    }
}

declare module "co.aikar.timings.Timing" {
    declare const Timing = co.aikar.timings.Timing;
}

declare namespace co.aikar.timings {
    declare class TimingIdentifier extends java.lang.Object {
        constructor(group: string, name: string, groupTiming: co.aikar.timings.Timing): void
        static getGroup(name: string): co.aikar.timings.TimingIdentifier$TimingGroup
        public equals(o: java.lang.Object): boolean
        public hashCode(): int
        static lambda$getGroup$0(name: string, k: string): co.aikar.timings.TimingIdentifier$TimingGroup
        static GROUP_MAP: java.util.Map<string, co.aikar.timings.TimingIdentifier$TimingGroup>
        static DEFAULT_GROUP: co.aikar.timings.TimingIdentifier$TimingGroup
        group: string
        name: string
        groupTiming: co.aikar.timings.Timing
        hashCode: int

    }
}

declare module "co.aikar.timings.TimingIdentifier" {
    declare const TimingIdentifier = co.aikar.timings.TimingIdentifier;
}

declare namespace co.aikar.timings {
    declare class TimingsManager$BoundedQueue extends java.util.LinkedList {
        constructor(maxSize: int): void
        public add(): boolean
        maxSize: int

    }
}

declare module "co.aikar.timings.TimingsManager$BoundedQueue" {
    declare const TimingsManager$BoundedQueue = co.aikar.timings.TimingsManager$BoundedQueue;
}

declare namespace co.aikar.timings {
    declare class TimingsHistoryEntry extends java.lang.Object {
        constructor(timing: co.aikar.timings.Timing): void
        export(): com.google.gson.JsonArray
        data: co.aikar.timings.TimingData
        children: co.aikar.timings.TimingData[]

    }
}

declare module "co.aikar.timings.TimingsHistoryEntry" {
    declare const TimingsHistoryEntry = co.aikar.timings.TimingsHistoryEntry;
}

declare namespace co.aikar.timings {
    declare class TimingsManager extends java.lang.Object {
        public constructor(): void
        static reset(): void
        static tick(): void
        static recheckEnabled(): void
        static resetTimings(): void
        public static getTiming(name: string): co.aikar.timings.Timing
        static getTiming(group: string, name: string, groupTiming: co.aikar.timings.Timing): co.aikar.timings.Timing
        static lambda$getTiming$0(id: co.aikar.timings.TimingIdentifier, k: co.aikar.timings.TimingIdentifier): co.aikar.timings.Timing
        static TIMING_MAP: java.util.Map<co.aikar.timings.TimingIdentifier, co.aikar.timings.Timing>
        static TIMINGS: java.util.Queue<co.aikar.timings.Timing>
        static MINUTE_REPORTS: java.util.ArrayDeque<co.aikar.timings.TimingsHistory$MinuteReport>
        static HISTORY: java.util.Queue<co.aikar.timings.TimingsHistory>
        static CURRENT: co.aikar.timings.Timing
        static timingStart: long
        static historyStart: long
        static needsFullReset: boolean
        static needsRecheckEnabled: boolean

    }
}

declare module "co.aikar.timings.TimingsManager" {
    declare const TimingsManager = co.aikar.timings.TimingsManager;
}

declare namespace co.aikar.timings {
    declare class TimingData extends java.lang.Object {
        constructor(id: int): void
        constructor(data: co.aikar.timings.TimingData): void
        add(diff: long): void
        tick(violated: boolean): void
        reset(): void
        clone(): co.aikar.timings.TimingData
        export(): com.google.gson.JsonArray
        clone(): java.lang.Object
        id: int
        count: int
        lagCount: int
        totalTime: long
        lagTotalTime: long
        curTickCount: int
        curTickTotal: int

    }
}

declare module "co.aikar.timings.TimingData" {
    declare const TimingData = co.aikar.timings.TimingData;
}

declare namespace co.aikar.timings {
    declare class TimingIdentifier$TimingGroup extends java.lang.Object {
        constructor(name: string): void
        static idPool: int
        id: int
        name: string
        timings: java.util.ArrayDeque<co.aikar.timings.Timing>

    }
}

declare module "co.aikar.timings.TimingIdentifier$TimingGroup" {
    declare const TimingIdentifier$TimingGroup = co.aikar.timings.TimingIdentifier$TimingGroup;
}

declare namespace co.aikar.timings {
    declare class TimingsHistory$PingRecord extends java.lang.Object {
        constructor(): void
        avg: double

    }
}

declare module "co.aikar.timings.TimingsHistory$PingRecord" {
    declare const TimingsHistory$PingRecord = co.aikar.timings.TimingsHistory$PingRecord;
}

declare namespace co.aikar.timings {
    declare class TimingsHistory$MinuteReport extends java.lang.Object {
        constructor(): void
        export(): com.google.gson.JsonArray
        public static EMPTY_ARRAY: co.aikar.timings.TimingsHistory$MinuteReport[]
        time: long
        ticksRecord: co.aikar.timings.TimingsHistory$TicksRecord
        pingRecord: co.aikar.timings.TimingsHistory$PingRecord
        fst: co.aikar.timings.TimingData
        tps: double
        usedMemory: double
        freeMemory: double
        loadAvg: double

    }
}

declare module "co.aikar.timings.TimingsHistory$MinuteReport" {
    declare const TimingsHistory$MinuteReport = co.aikar.timings.TimingsHistory$MinuteReport;
}

declare namespace co.aikar.timings {
    declare class TimingsHistory extends java.lang.Object {
        constructor(): void
        static resetTicks(fullReset: boolean): void
        export(): com.google.gson.JsonObject
        static lambda$export$2(entry: co.aikar.timings.TimingsHistoryEntry): java.lang.Object
        static lambda$new$1(entry: java.util.Map$Entry): cn.nukkit.timings.JsonUtil$JSONPair
        static lambda$new$0(entry: java.util.Map$Entry): cn.nukkit.timings.JsonUtil$JSONPair
        public static lastMinuteTime: long
        public static timedTicks: long
        public static playerTicks: long
        public static entityTicks: long
        public static tileEntityTicks: long
        public static activatedEntityTicks: long
        static levelIdPool: int
        static levelMap: java.util.Map<string, int>
        static entityMap: java.util.Map<int, string>
        static blockEntityMap: java.util.Map<int, string>
        endTime: long
        startTime: long
        totalTicks: long
        totalTime: long
        minuteReports: co.aikar.timings.TimingsHistory$MinuteReport[]
        entries: co.aikar.timings.TimingsHistoryEntry[]
        levels: com.google.gson.JsonObject

    }
}

declare module "co.aikar.timings.TimingsHistory" {
    declare const TimingsHistory = co.aikar.timings.TimingsHistory;
}

declare namespace co.aikar.timings {
    declare class Timings extends java.lang.Object {
        public constructor(): void
        public static init(): void
        public static isTimingsEnabled(): boolean
        public static setTimingsEnabled(enabled: boolean): void
        public static isVerboseEnabled(): boolean
        public static setVerboseEnabled(enabled: boolean): void
        public static isPrivacy(): boolean
        public static getIgnoredConfigSections(): java.util.Set<string>
        public static getHistoryInterval(): int
        public static setHistoryInterval(interval: int): void
        public static getHistoryLength(): int
        public static setHistoryLength(length: int): void
        public static reset(): void
        public static getCommandTiming(command: cn.nukkit.command.Command): co.aikar.timings.Timing
        public static getTaskTiming(handler: cn.nukkit.scheduler.TaskHandler, period: long): co.aikar.timings.Timing
        public static getPluginEventTiming(event: java.lang.Class<cn.nukkit.event.Event>, listener: cn.nukkit.event.Listener, executor: cn.nukkit.plugin.EventExecutor, plugin: cn.nukkit.plugin.Plugin): co.aikar.timings.Timing
        public static getEntityTiming(entity: cn.nukkit.entity.Entity): co.aikar.timings.Timing
        public static getBlockEntityTiming(blockEntity: cn.nukkit.blockentity.BlockEntity): co.aikar.timings.Timing
        public static getReceiveDataPacketTiming(pk: cn.nukkit.network.protocol.DataPacket): co.aikar.timings.Timing
        public static getSendDataPacketTiming(pk: cn.nukkit.network.protocol.DataPacket): co.aikar.timings.Timing
        public static stopServer(): void
        static log: org.apache.logging.log4j.Logger
        static timingsEnabled: boolean
        static verboseEnabled: boolean
        static privacy: boolean
        static ignoredConfigSections: java.util.Set<string>
        static MAX_HISTORY_FRAMES: int
        static historyInterval: int
        static historyLength: int
        public static fullServerTickTimer: co.aikar.timings.FullServerTickTiming
        public static timingsTickTimer: co.aikar.timings.Timing
        public static pluginEventTimer: co.aikar.timings.Timing
        public static connectionTimer: co.aikar.timings.Timing
        public static schedulerTimer: co.aikar.timings.Timing
        public static schedulerAsyncTimer: co.aikar.timings.Timing
        public static schedulerSyncTimer: co.aikar.timings.Timing
        public static commandTimer: co.aikar.timings.Timing
        public static serverCommandTimer: co.aikar.timings.Timing
        public static levelSaveTimer: co.aikar.timings.Timing
        public static playerNetworkSendTimer: co.aikar.timings.Timing
        public static playerNetworkReceiveTimer: co.aikar.timings.Timing
        public static playerChunkOrderTimer: co.aikar.timings.Timing
        public static playerChunkSendTimer: co.aikar.timings.Timing
        public static playerCommandTimer: co.aikar.timings.Timing
        public static tickEntityTimer: co.aikar.timings.Timing
        public static tickBlockEntityTimer: co.aikar.timings.Timing
        public static entityMoveTimer: co.aikar.timings.Timing
        public static entityBaseTickTimer: co.aikar.timings.Timing
        public static livingEntityBaseTickTimer: co.aikar.timings.Timing
        public static generationTimer: co.aikar.timings.Timing
        public static populationTimer: co.aikar.timings.Timing
        public static generationCallbackTimer: co.aikar.timings.Timing
        public static permissibleCalculationTimer: co.aikar.timings.Timing
        public static permissionDefaultTimer: co.aikar.timings.Timing

    }
}

declare module "co.aikar.timings.Timings" {
    declare const Timings = co.aikar.timings.Timings;
}

declare namespace cn.nukkit.command.data.args {
    declare class CommandArg extends java.lang.Object {
        public constructor(): void
        public getRules(): cn.nukkit.command.data.args.CommandArgRules[]
        public getSelector(): string
        rules: cn.nukkit.command.data.args.CommandArgRules[]
        selector: string

    }
}

declare module "cn.nukkit.command.data.args.CommandArg" {
    declare const CommandArg = cn.nukkit.command.data.args.CommandArg;
}

declare namespace cn.nukkit.command.data.args {
    declare class CommandArgBlockVector extends java.lang.Object {
        public constructor(): void
        public getX(): int
        public getY(): int
        public getZ(): int
        public isXrelative(): boolean
        public isYrelative(): boolean
        public isZrelative(): boolean
        x: int
        y: int
        z: int
        xrelative: boolean
        yrelative: boolean
        zrelative: boolean

    }
}

declare module "cn.nukkit.command.data.args.CommandArgBlockVector" {
    declare const CommandArgBlockVector = cn.nukkit.command.data.args.CommandArgBlockVector;
}

declare namespace cn.nukkit.command.data.args {
    declare class CommandArgRules extends java.lang.Object {
        public constructor(): void
        public isInverted(): boolean
        public getName(): string
        public getValue(): string
        inverted: boolean
        name: string
        value: string

    }
}

declare module "cn.nukkit.command.data.args.CommandArgRules" {
    declare const CommandArgRules = cn.nukkit.command.data.args.CommandArgRules;
}

declare namespace cn.nukkit.command.data {
    declare class CommandData extends java.lang.Object implements java.lang.Cloneable {
        public constructor(): void
        public clone(): cn.nukkit.command.data.CommandData
        public clone(): java.lang.Object
        public aliases: cn.nukkit.command.data.CommandEnum
        public description: string
        public overloads: java.util.Map<string, cn.nukkit.command.data.CommandOverload>
        public flags: int
        public permission: int

    }
}

declare module "cn.nukkit.command.data.CommandData" {
    declare const CommandData = cn.nukkit.command.data.CommandData;
}

declare namespace cn.nukkit.command.data {
    declare class CommandInput extends java.lang.Object {
        public constructor(): void
        public parameters: cn.nukkit.command.data.CommandParameter[]

    }
}

declare module "cn.nukkit.command.data.CommandInput" {
    declare const CommandInput = cn.nukkit.command.data.CommandInput;
}

declare namespace cn.nukkit.command.data {
    declare class CommandOverload extends java.lang.Object {
        public constructor(): void
        public input: cn.nukkit.command.data.CommandInput
        public output: cn.nukkit.command.data.CommandOutput

    }
}

declare module "cn.nukkit.command.data.CommandOverload" {
    declare const CommandOverload = cn.nukkit.command.data.CommandOverload;
}

declare namespace cn.nukkit.command.data {
    declare class CommandEnum extends java.lang.Object {
        public constructor(name: string, values: string[]): void
        public constructor(name: string, values: java.util.List<string>): void
        public constructor(name: string, values: java.util.List<string>, limited: boolean): void
        public getName(): string
        public getValues(): java.util.List<string>
        public isLimited(): boolean
        public hashCode(): int
        public static ENUM_BOOLEAN: cn.nukkit.command.data.CommandEnum
        public static ENUM_GAMEMODE: cn.nukkit.command.data.CommandEnum
        public static ENUM_BLOCK: cn.nukkit.command.data.CommandEnum
        public static ENUM_ITEM: cn.nukkit.command.data.CommandEnum
        name: string
        values: java.util.List<string>
        limited: boolean

    }
}

declare module "cn.nukkit.command.data.CommandEnum" {
    declare const CommandEnum = cn.nukkit.command.data.CommandEnum;
}

declare namespace cn.nukkit.command.data {
    declare class CommandOutput extends java.lang.Object {
        public constructor(): void
        public format_strings: string[]

    }
}

declare module "cn.nukkit.command.data.CommandOutput" {
    declare const CommandOutput = cn.nukkit.command.data.CommandOutput;
}

declare namespace cn.nukkit.command.data {
    declare class CommandArgs extends java.util.HashMap {
        public constructor(): void

    }
}

declare module "cn.nukkit.command.data.CommandArgs" {
    declare const CommandArgs = cn.nukkit.command.data.CommandArgs;
}

declare namespace cn.nukkit.command.data {
    declare class CommandParameter extends java.lang.Object {
        public constructor(name: string, type: string, optional: boolean): void
        public constructor(name: string, type: cn.nukkit.command.data.CommandParamType, optional: boolean): void
        public constructor(name: string, optional: boolean): void
        public constructor(name: string): void
        public constructor(name: string, optional: boolean, enumType: string): void
        public constructor(name: string, optional: boolean, enumValues: string[]): void
        public constructor(name: string, enumType: string): void
        public constructor(name: string, enumValues: string[]): void
        constructor(name: string, optional: boolean, type: cn.nukkit.command.data.CommandParamType, enumData: cn.nukkit.command.data.CommandEnum, postFix: string): void
        public static newType(name: string, type: cn.nukkit.command.data.CommandParamType): cn.nukkit.command.data.CommandParameter
        public static newType(name: string, optional: boolean, type: cn.nukkit.command.data.CommandParamType): cn.nukkit.command.data.CommandParameter
        public static newEnum(name: string, values: string[]): cn.nukkit.command.data.CommandParameter
        public static newEnum(name: string, optional: boolean, values: string[]): cn.nukkit.command.data.CommandParameter
        public static newEnum(name: string, type: string): cn.nukkit.command.data.CommandParameter
        public static newEnum(name: string, optional: boolean, type: string): cn.nukkit.command.data.CommandParameter
        public static newEnum(name: string, optional: boolean, type: string, limited: boolean): cn.nukkit.command.data.CommandParameter
        public static newEnum(name: string, data: cn.nukkit.command.data.CommandEnum): cn.nukkit.command.data.CommandParameter
        public static newEnum(name: string, optional: boolean, data: cn.nukkit.command.data.CommandEnum): cn.nukkit.command.data.CommandParameter
        public static newPostfix(name: string, postfix: string): cn.nukkit.command.data.CommandParameter
        public static newPostfix(name: string, optional: boolean, postfix: string): cn.nukkit.command.data.CommandParameter
        static fromString(param: string): cn.nukkit.command.data.CommandParamType
        public static EMPTY_ARRAY: cn.nukkit.command.data.CommandParameter[]
        public name: string
        public type: cn.nukkit.command.data.CommandParamType
        public optional: boolean
        public options: byte
        public enumData: cn.nukkit.command.data.CommandEnum
        public postFix: string
        public static ARG_TYPE_STRING: string
        public static ARG_TYPE_STRING_ENUM: string
        public static ARG_TYPE_BOOL: string
        public static ARG_TYPE_TARGET: string
        public static ARG_TYPE_PLAYER: string
        public static ARG_TYPE_BLOCK_POS: string
        public static ARG_TYPE_RAW_TEXT: string
        public static ARG_TYPE_INT: string
        public static ENUM_TYPE_ITEM_LIST: string
        public static ENUM_TYPE_BLOCK_LIST: string
        public static ENUM_TYPE_COMMAND_LIST: string
        public static ENUM_TYPE_ENCHANTMENT_LIST: string
        public static ENUM_TYPE_ENTITY_LIST: string
        public static ENUM_TYPE_EFFECT_LIST: string
        public static ENUM_TYPE_PARTICLE_LIST: string

    }
}

declare module "cn.nukkit.command.data.CommandParameter" {
    declare const CommandParameter = cn.nukkit.command.data.CommandParameter;
}

declare namespace cn.nukkit.command.data {
    declare class CommandDataVersions extends java.lang.Object {
        public constructor(): void
        public versions: java.util.List<cn.nukkit.command.data.CommandData>

    }
}

declare module "cn.nukkit.command.data.CommandDataVersions" {
    declare const CommandDataVersions = cn.nukkit.command.data.CommandDataVersions;
}

declare namespace cn.nukkit.command.data {
    declare class CommandParamType extends java.lang.Enum {
        public static values(): cn.nukkit.command.data.CommandParamType[]
        public static valueOf(name: string): cn.nukkit.command.data.CommandParamType
        constructor(var0: int): void
        public getId(): int
        static $values(): cn.nukkit.command.data.CommandParamType[]
        public static INT: cn.nukkit.command.data.CommandParamType
        public static FLOAT: cn.nukkit.command.data.CommandParamType
        public static VALUE: cn.nukkit.command.data.CommandParamType
        public static WILDCARD_INT: cn.nukkit.command.data.CommandParamType
        public static TARGET: cn.nukkit.command.data.CommandParamType
        public static WILDCARD_TARGET: cn.nukkit.command.data.CommandParamType
        public static EQUIPMENT_SLOT: cn.nukkit.command.data.CommandParamType
        public static STRING: cn.nukkit.command.data.CommandParamType
        public static BLOCK_POSITION: cn.nukkit.command.data.CommandParamType
        public static POSITION: cn.nukkit.command.data.CommandParamType
        public static MESSAGE: cn.nukkit.command.data.CommandParamType
        public static RAWTEXT: cn.nukkit.command.data.CommandParamType
        public static JSON: cn.nukkit.command.data.CommandParamType
        public static TEXT: cn.nukkit.command.data.CommandParamType
        public static COMMAND: cn.nukkit.command.data.CommandParamType
        public static FILE_PATH: cn.nukkit.command.data.CommandParamType
        public static OPERATOR: cn.nukkit.command.data.CommandParamType
        public static COMPARE_OPERATOR: cn.nukkit.command.data.CommandParamType
        public static FULL_INTEGER_RANGE: cn.nukkit.command.data.CommandParamType
        public static BLOCK_STATES: cn.nukkit.command.data.CommandParamType
        id: int
        static $VALUES: cn.nukkit.command.data.CommandParamType[]

    }
}

declare module "cn.nukkit.command.data.CommandParamType" {
    declare const CommandParamType = cn.nukkit.command.data.CommandParamType;
}

declare namespace cn.nukkit.command {
    declare class ExecutorCommandSender extends java.lang.Object implements cn.nukkit.command.CommandSender {
        public constructor(executor: cn.nukkit.command.CommandSender, entity: cn.nukkit.entity.Entity, executeLocation: cn.nukkit.level.Location): void
        public sendMessage(message: string): void
        public sendMessage(message: cn.nukkit.lang.TextContainer): void
        public getServer(): cn.nukkit.Server
        public getName(): string
        public isPlayer(): boolean
        public isEntity(): boolean
        public asEntity(): cn.nukkit.entity.Entity
        public asPlayer(): cn.nukkit.Player
        public getPosition(): cn.nukkit.level.Position
        public getLocation(): cn.nukkit.level.Location
        public isOp(): boolean
        public setOp(value: boolean): void
        public isPermissionSet(name: string): boolean
        public isPermissionSet(permission: cn.nukkit.permission.Permission): boolean
        public hasPermission(name: string): boolean
        public hasPermission(permission: cn.nukkit.permission.Permission): boolean
        public addAttachment(plugin: cn.nukkit.plugin.Plugin): cn.nukkit.permission.PermissionAttachment
        public addAttachment(plugin: cn.nukkit.plugin.Plugin, name: string): cn.nukkit.permission.PermissionAttachment
        public addAttachment(plugin: cn.nukkit.plugin.Plugin, name: string, value: boolean): cn.nukkit.permission.PermissionAttachment
        public removeAttachment(attachment: cn.nukkit.permission.PermissionAttachment): void
        public recalculatePermissions(): void
        public getEffectivePermissions(): java.util.Map<string, cn.nukkit.permission.PermissionAttachmentInfo>
        public getExecutor(): cn.nukkit.command.CommandSender
        executor: cn.nukkit.command.CommandSender
        entity: cn.nukkit.entity.Entity
        executeLocation: cn.nukkit.level.Location

    }
}

declare module "cn.nukkit.command.ExecutorCommandSender" {
    declare const ExecutorCommandSender = cn.nukkit.command.ExecutorCommandSender;
}

declare namespace cn.nukkit.command {
    declare class CapturingCommandSender extends java.lang.Object implements cn.nukkit.command.CommandSender {
        public constructor(): void
        public constructor(name: string): void
        public constructor(name: string, isOp: boolean): void
        public constructor(name: string, isOp: boolean, permissibleFactory: java.util.function.Function<cn.nukkit.permission.ServerOperator, cn.nukkit.permission.Permissible>): void
        public getName(): string
        public setName(name: string): void
        public isOp(): boolean
        public setOp(op: boolean): void
        public resetCapture(): void
        public getRawCapture(): string
        public getCleanCapture(): string
        public toString(): string
        public sendMessage(message: string): void
        public sendMessage(message: cn.nukkit.lang.TextContainer): void
        public getServer(): cn.nukkit.Server
        public isPlayer(): boolean
        public isPermissionSet(name: string): boolean
        public isPermissionSet(permission: cn.nukkit.permission.Permission): boolean
        public hasPermission(name: string): boolean
        public hasPermission(permission: cn.nukkit.permission.Permission): boolean
        public addAttachment(plugin: cn.nukkit.plugin.Plugin): cn.nukkit.permission.PermissionAttachment
        public addAttachment(plugin: cn.nukkit.plugin.Plugin, name: string): cn.nukkit.permission.PermissionAttachment
        public addAttachment(plugin: cn.nukkit.plugin.Plugin, name: string, value: boolean): cn.nukkit.permission.PermissionAttachment
        public removeAttachment(attachment: cn.nukkit.permission.PermissionAttachment): void
        public recalculatePermissions(): void
        public getEffectivePermissions(): java.util.Map<string, cn.nukkit.permission.PermissionAttachmentInfo>
        public constructor(name: string, isOp: boolean, perms: cn.nukkit.permission.Permissible): void
        captured: java.lang.StringBuilder
        name: string
        isOp: boolean
        perms: cn.nukkit.permission.Permissible

    }
}

declare module "cn.nukkit.command.CapturingCommandSender" {
    declare const CapturingCommandSender = cn.nukkit.command.CapturingCommandSender;
}

declare namespace cn.nukkit.command {
    declare class PluginCommand extends cn.nukkit.command.Command implements cn.nukkit.command.PluginIdentifiableCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        public getExecutor(): cn.nukkit.command.CommandExecutor
        public setExecutor(executor: cn.nukkit.command.CommandExecutor): void
        public getPlugin(): any
        owningPlugin: any
        executor: cn.nukkit.command.CommandExecutor

    }
}

declare module "cn.nukkit.command.PluginCommand" {
    declare const PluginCommand = cn.nukkit.command.PluginCommand;
}

declare namespace cn.nukkit.command {
    declare interface CommandSender extends cn.nukkit.permission.Permissible {
        public sendMessage(var0: string): void
        public sendMessage(var0: cn.nukkit.lang.TextContainer): void
        public getServer(): cn.nukkit.Server
        public getName(): string
        public isPlayer(): boolean
        public isEntity(): boolean
        public asEntity(): cn.nukkit.entity.Entity
        public asPlayer(): cn.nukkit.Player
        public getPosition(): cn.nukkit.level.Position
        public getLocation(): cn.nukkit.level.Location

    }
}

declare module "cn.nukkit.command.CommandSender" {
    declare type CommandSender = cn.nukkit.command.CommandSender;
}

declare namespace cn.nukkit.command.function {
    declare class Function extends java.lang.Object {
        constructor(manager: cn.nukkit.command.function.FunctionManager, fullPath: java.nio.file.Path): void
        public static fromPath(manager: cn.nukkit.command.function.FunctionManager, path: java.nio.file.Path): cn.nukkit.command.function.Function
        public dispatch(sender: cn.nukkit.command.CommandSender): boolean
        public getFullPath(): java.nio.file.Path
        public getCommands(): java.util.List<string>
        static lambda$new$0(s: string): string
        fullPath: java.nio.file.Path
        commands: java.util.List<string>

    }
}

declare module "cn.nukkit.command.function.Function" {
    declare const Function = cn.nukkit.command.function.Function;
}

declare namespace cn.nukkit.command.function {
    declare class FunctionManager$1 extends java.nio.file.SimpleFileVisitor {
        constructor(this$0: cn.nukkit.command.function.FunctionManager): void
        public visitFile(path: java.nio.file.Path, attrs: java.nio.file.attribute.BasicFileAttributes): java.nio.file.FileVisitResult
        public visitFile(var0: java.lang.Object, var1: java.nio.file.attribute.BasicFileAttributes): java.nio.file.FileVisitResult
        this$0: cn.nukkit.command.function.FunctionManager

    }
}

declare module "cn.nukkit.command.function.FunctionManager$1" {
    declare const FunctionManager$1 = cn.nukkit.command.function.FunctionManager$1;
}

declare namespace cn.nukkit.command.function {
    declare class FunctionManager extends java.lang.Object {
        public constructor(rootPath: java.nio.file.Path): void
        public constructor(rootPath: string): void
        public loadFunctions(): void
        public reload(): void
        public containFunction(name: string): boolean
        public getFunction(name: string): cn.nukkit.command.function.Function
        public getRootPath(): java.nio.file.Path
        public getFunctions(): java.util.Map<string, cn.nukkit.command.function.Function>
        rootPath: java.nio.file.Path
        functions: java.util.Map<string, cn.nukkit.command.function.Function>

    }
}

declare module "cn.nukkit.command.function.FunctionManager" {
    declare const FunctionManager = cn.nukkit.command.function.FunctionManager;
}

declare namespace cn.nukkit.command.utils {
    declare class RawText$Component$ScoreComponent extends java.lang.Object {
        constructor(): void
        name: string
        objective: string
        value: int

    }
}

declare module "cn.nukkit.command.utils.RawText$Component$ScoreComponent" {
    declare const RawText$Component$ScoreComponent = cn.nukkit.command.utils.RawText$Component$ScoreComponent;
}

declare namespace cn.nukkit.command.utils {
    declare class CommandParser$CoordinateType extends java.lang.Enum {
        public static values(): cn.nukkit.command.utils.CommandParser$CoordinateType[]
        public static valueOf(name: string): cn.nukkit.command.utils.CommandParser$CoordinateType
        constructor(): void
        static $values(): cn.nukkit.command.utils.CommandParser$CoordinateType[]
        public static X: cn.nukkit.command.utils.CommandParser$CoordinateType
        public static Y: cn.nukkit.command.utils.CommandParser$CoordinateType
        public static Z: cn.nukkit.command.utils.CommandParser$CoordinateType
        static $VALUES: cn.nukkit.command.utils.CommandParser$CoordinateType[]

    }
}

declare module "cn.nukkit.command.utils.CommandParser$CoordinateType" {
    declare const CommandParser$CoordinateType = cn.nukkit.command.utils.CommandParser$CoordinateType;
}

declare namespace cn.nukkit.command.utils {
    declare class CommandParser$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$command$data$CommandParamType: int[]
        static $SwitchMap$cn$nukkit$command$utils$CommandParser$CoordinateType: int[]

    }
}

declare module "cn.nukkit.command.utils.CommandParser$1" {
    declare const CommandParser$1 = cn.nukkit.command.utils.CommandParser$1;
}

declare namespace cn.nukkit.command.utils {
    declare class EntitySelector extends java.lang.Object {
        static registerArgument(arg: string): string
        public static matchEntities(sender: cn.nukkit.command.CommandSender, token: string): java.util.List<cn.nukkit.entity.Entity>
        static getLevels(sender: cn.nukkit.command.CommandSender, argumentMap: java.util.Map<string, java.util.List<string>>): java.util.List<cn.nukkit.level.Level>
        static isEntityTypeValid(params: java.util.Map<string, java.util.List<string>>): boolean
        static getTypePredicates(params: java.util.Map<string, java.util.List<string>>, selectorType: string): java.util.List<com.google.common.base.Predicate<cn.nukkit.entity.Entity>>
        static getXpLevelPredicates(params: java.util.Map<string, java.util.List<string>>): java.util.List<com.google.common.base.Predicate<cn.nukkit.entity.Entity>>
        static getGamemodePredicates(params: java.util.Map<string, java.util.List<string>>): java.util.List<com.google.common.base.Predicate<cn.nukkit.entity.Entity>>
        static getNamePredicates(params: java.util.Map<string, java.util.List<string>>): java.util.List<com.google.common.base.Predicate<cn.nukkit.entity.Entity>>
        static getRadiusPredicates(params: java.util.Map<string, java.util.List<string>>, vec: cn.nukkit.math.Vector3): java.util.List<com.google.common.base.Predicate<cn.nukkit.entity.Entity>>
        static getRotationsPredicates(params: java.util.Map<string, java.util.List<string>>): java.util.List<com.google.common.base.Predicate<cn.nukkit.entity.Entity>>
        static getTagsPredicates(params: java.util.Map<string, java.util.List<string>>): java.util.List<com.google.common.base.Predicate<cn.nukkit.entity.Entity>>
        static getScoresPredicate(params: java.util.Map<string, java.util.List<string>>): java.util.List<com.google.common.base.Predicate<cn.nukkit.entity.Entity>>
        static clampAngle(angle: int): int
        static filterResults(params: java.util.Map<string, java.util.List<string>>, predicates: java.util.List<com.google.common.base.Predicate<cn.nukkit.entity.Entity>>, selectorType: string, level: cn.nukkit.level.Level, vec: cn.nukkit.math.BlockVector3): java.util.List<cn.nukkit.entity.Entity>
        static getEntitiesFromPredicates(matchingEntities: java.util.List<cn.nukkit.entity.Entity>, params: java.util.Map<string, java.util.List<string>>, sender: cn.nukkit.command.CommandSender, selectorType: string, vec: cn.nukkit.math.Vector3): java.util.List<cn.nukkit.entity.Entity>
        static getAABB(vec: cn.nukkit.math.BlockVector3, dx: int, dy: int, dz: int): cn.nukkit.math.AxisAlignedBB
        static getBlockVectorFromArguments(params: java.util.Map<string, java.util.List<string>>, sender: cn.nukkit.command.CommandSender): cn.nukkit.math.BlockVector3
        static getVector3FromArguments(params: java.util.Map<string, java.util.List<string>>, sender: cn.nukkit.command.CommandSender): cn.nukkit.math.Vector3
        static getCoordinate(params: java.util.Map<string, java.util.List<string>>, key: string, defaultCoordinate: double, var3: boolean): double
        static hasLevelArgument(params: java.util.Map<string, java.util.List<string>>): boolean
        static getInt(params: java.util.Map<string, java.util.List<string>>, key: string, defaultValue: int): int
        static getInt(value: string, defaultValue: int): int
        static getArgument(params: java.util.Map<string, java.util.List<string>>, key: string): java.util.List<string>
        public static canMatchesMultiplePlayers(inputSelector: string): boolean
        public static hasArguments(inputSelector: string): boolean
        static getArgumentMap(inputArguments: string): java.util.Map<string, java.util.List<string>>
        static separateArguments(inputArguments: string): java.util.List<string>
        static getEntities(level: cn.nukkit.level.Level, filter: com.google.common.base.Predicate<cn.nukkit.entity.Entity>): java.util.List<cn.nukkit.entity.Entity>
        static getPlayers(level: cn.nukkit.level.Level, filter: com.google.common.base.Predicate<cn.nukkit.entity.Entity>): java.util.List<cn.nukkit.Player>
        static getNearbyEntities(level: cn.nukkit.level.Level, aabb: cn.nukkit.math.AxisAlignedBB, filter: com.google.common.base.Predicate<cn.nukkit.entity.Entity>): java.util.List<cn.nukkit.entity.Entity>
        static parseGameMode(name: string, fallback: int): int
        constructor(): void
        static lambda$separateArguments$28(s: string): boolean
        static lambda$getEntitiesFromPredicates$27(vec: cn.nukkit.math.Vector3, entity1: cn.nukkit.entity.Entity, entity2: cn.nukkit.entity.Entity): int
        static lambda$filterResults$26(aabb: cn.nukkit.math.AxisAlignedBB, entity: cn.nukkit.entity.Entity): boolean
        static lambda$filterResults$25(type: string): string
        static lambda$getScoresPredicate$24(predicates: java.util.List, e: cn.nukkit.entity.Entity): boolean
        static lambda$getScoresPredicate$23(e: cn.nukkit.entity.Entity, predicate: com.google.common.base.Predicate): boolean
        static lambda$getScoresPredicate$22(scoreboard: cn.nukkit.scoreboard.Scoreboard, finalScore: int, inverted: boolean, entity: cn.nukkit.entity.Entity): boolean
        static lambda$getScoresPredicate$21(scoreboard: cn.nukkit.scoreboard.Scoreboard, finalMin: int, finalMax: int, inverted: boolean, entity: cn.nukkit.entity.Entity): boolean
        static lambda$getScoresPredicate$20(predicates: java.util.List, e: cn.nukkit.entity.Entity): boolean
        static lambda$getScoresPredicate$19(e: cn.nukkit.entity.Entity, predicate: com.google.common.base.Predicate): boolean
        static lambda$getScoresPredicate$18(entity: cn.nukkit.entity.Entity): boolean
        static lambda$getTagsPredicates$17(predicates: java.util.List, e: cn.nukkit.entity.Entity): boolean
        static lambda$getTagsPredicates$16(e: cn.nukkit.entity.Entity, predicate: com.google.common.base.Predicate): boolean
        static lambda$getTagsPredicates$15(entity: cn.nukkit.entity.Entity): boolean
        static lambda$getTagsPredicates$14(finalTag: string, inverted: boolean, entity: cn.nukkit.entity.Entity): boolean
        static lambda$getRotationsPredicates$13(rxm: int, rx: int, entity: cn.nukkit.entity.Entity): boolean
        static lambda$getRotationsPredicates$12(rym: int, ry: int, entity: cn.nukkit.entity.Entity): boolean
        static lambda$getRadiusPredicates$11(vec: cn.nukkit.math.Vector3, rmInverted: boolean, rmSquare: double, var3: boolean, rInverted: double, rSquare: cn.nukkit.entity.Entity): boolean
        static lambda$getNamePredicates$10(predicates: java.util.List, e: cn.nukkit.entity.Entity): boolean
        static lambda$getNamePredicates$9(e: cn.nukkit.entity.Entity, predicate: com.google.common.base.Predicate): boolean
        static lambda$getNamePredicates$8(finalName: string, inverted: boolean, entity: cn.nukkit.entity.Entity): boolean
        static lambda$getGamemodePredicates$7(inverted: boolean, f: int, entity: cn.nukkit.entity.Entity): boolean
        static lambda$getXpLevelPredicates$6(lm: int, l: int, entity: cn.nukkit.entity.Entity): boolean
        static lambda$getTypePredicates$5(predicates: java.util.List, e: cn.nukkit.entity.Entity): boolean
        static lambda$getTypePredicates$4(e: cn.nukkit.entity.Entity, predicate: com.google.common.base.Predicate): boolean
        static lambda$getTypePredicates$3(entity: cn.nukkit.entity.Entity): boolean
        static lambda$getTypePredicates$2(identifier: string, inverted: boolean, entity: cn.nukkit.entity.Entity): boolean
        static lambda$static$1(arg: string): boolean
        static lambda$static$0(builder: com.google.common.collect.ImmutableMap$Builder, id: int, name: string): void
        public static ENTITY_ID2NAME: java.util.Map<int, string>
        public static ENTITY_NAME2ID: java.util.Map<string, int>
        static ENTITY_SELECTOR: java.util.regex.Pattern
        static ARGUMENT_JOINER: com.google.common.base.Splitter
        static ARGS: java.util.Set<string>
        static ARG_X: string
        static ARG_Y: string
        static ARG_Z: string
        static ARG_DX: string
        static ARG_DY: string
        static ARG_DZ: string
        static ARG_R: string
        static ARG_RM: string
        static ARG_C: string
        static ARG_L: string
        static ARG_LM: string
        static ARG_M: string
        static ARG_NAME: string
        static ARG_RX: string
        static ARG_RXM: string
        static ARG_RY: string
        static ARG_RYM: string
        static ARG_TYPE: string
        static ARG_TAG: string
        static ARG_SCORE: string
        static LEVEL_ARGS: java.util.Set<string>
        static VALID_ARGUMENT: com.google.common.base.Predicate<string>
        static args_cache: com.google.common.cache.Cache<string, java.util.Map<string, java.util.List<string>>>
        static SCORE_SEPARATOR: com.google.common.base.Splitter
        static SCORE_JOINER: com.google.common.base.Splitter
        static SCORE_SCOPE_SEPARATOR: com.google.common.base.Splitter

    }
}

declare module "cn.nukkit.command.utils.EntitySelector" {
    declare const EntitySelector = cn.nukkit.command.utils.EntitySelector;
}

declare namespace cn.nukkit.command.utils {
    declare class RawText$Component extends java.lang.Object {
        public constructor(): void
        public getType(): cn.nukkit.command.utils.RawText$Component$ComponentType
        public getComponent_text(): string
        public getComponent_selector(): string
        public getComponent_translate(): string
        public getComponent_translate_with(): java.lang.Object
        public getComponent_score(): cn.nukkit.command.utils.RawText$Component$ScoreComponent
        public getComponent_rawtext(): java.util.List<cn.nukkit.command.utils.RawText$Component>
        public setComponent_text(component_text: string): void
        public setComponent_selector(component_selector: string): void
        public setComponent_translate(component_translate: string): void
        public setComponent_translate_with(component_translate_with: java.lang.Object): void
        public setComponent_score(component_score: cn.nukkit.command.utils.RawText$Component$ScoreComponent): void
        public setComponent_rawtext(component_rawtext: java.util.List<cn.nukkit.command.utils.RawText$Component>): void
        component_text: string
        component_selector: string
        component_translate: string
        component_translate_with: java.lang.Object
        component_score: cn.nukkit.command.utils.RawText$Component$ScoreComponent
        component_rawtext: java.util.List<cn.nukkit.command.utils.RawText$Component>

    }
}

declare module "cn.nukkit.command.utils.RawText$Component" {
    declare const RawText$Component = cn.nukkit.command.utils.RawText$Component;
}

declare namespace cn.nukkit.command.utils {
    declare class EntitySelector$GameMode extends java.lang.Enum {
        public static values(): cn.nukkit.command.utils.EntitySelector$GameMode[]
        public static valueOf(name: string): cn.nukkit.command.utils.EntitySelector$GameMode
        constructor(var0: int, var1: string, id: string): void
        static $values(): cn.nukkit.command.utils.EntitySelector$GameMode[]
        public static SURVIVAL: cn.nukkit.command.utils.EntitySelector$GameMode
        public static CREATIVE: cn.nukkit.command.utils.EntitySelector$GameMode
        public static ADVENTURE: cn.nukkit.command.utils.EntitySelector$GameMode
        public static SPECTATOR: cn.nukkit.command.utils.EntitySelector$GameMode
        id: int
        name: string
        shortName: string
        static $VALUES: cn.nukkit.command.utils.EntitySelector$GameMode[]

    }
}

declare module "cn.nukkit.command.utils.EntitySelector$GameMode" {
    declare const EntitySelector$GameMode = cn.nukkit.command.utils.EntitySelector$GameMode;
}

declare namespace cn.nukkit.command.utils {
    declare class RawText extends java.lang.Object {
        constructor(base: cn.nukkit.command.utils.RawText$Component): void
        public static fromRawText(rawText: string): cn.nukkit.command.utils.RawText
        public preParse(sender: cn.nukkit.command.CommandSender): void
        static preParse(sender: cn.nukkit.command.CommandSender, cps: cn.nukkit.command.utils.RawText$Component): void
        static preParseScore(component: cn.nukkit.command.utils.RawText$Component, sender: cn.nukkit.command.CommandSender): cn.nukkit.command.utils.RawText$Component
        static preParseSelector(component: cn.nukkit.command.utils.RawText$Component, sender: cn.nukkit.command.CommandSender): cn.nukkit.command.utils.RawText$Component
        public toRawText(): string
        public toString(): string
        public getBase(): cn.nukkit.command.utils.RawText$Component
        static lambda$preParseScore$0(t: cn.nukkit.entity.Entity): cn.nukkit.scoreboard.interfaces.Scorer
        static gson: com.google.gson.Gson
        base: cn.nukkit.command.utils.RawText$Component

    }
}

declare module "cn.nukkit.command.utils.RawText" {
    declare const RawText = cn.nukkit.command.utils.RawText;
}

declare namespace cn.nukkit.command.utils {
    declare class CommandParser extends java.lang.Object {
        public constructor(command: cn.nukkit.command.Command, sender: cn.nukkit.command.CommandSender, args: string[]): void
        public constructor(parser: cn.nukkit.command.utils.CommandParser): void
        next(): string
        next(moveCursor: boolean): string
        public matchCommandForm(): string
        public getTargetLevel(): cn.nukkit.level.Level
        public hasNext(): boolean
        public parseInt(): int
        public parseInt(moveCursor: boolean): int
        public parseWildcardInt(defaultValue: int): int
        public parseWildcardInt(defaultValue: int, moveCursor: boolean): int
        public parseDouble(): double
        public parseDouble(moveCursor: boolean): double
        public parseOffsetDouble(base: double): double
        public parseOffsetDouble(base: double, var1: boolean): double
        public parseBoolean(): boolean
        public parseBoolean(moveCursor: boolean): boolean
        public parseString(): string
        public parseString(moveCursor: boolean): string
        public parseEnum(enumType: java.lang.Enum<any>): java.lang.Class<any>
        public parseEnum(enumType: java.lang.Enum<any>, moveCursor: java.lang.Class<any>): boolean
        public parseTargets(): java.util.List<cn.nukkit.entity.Entity>
        public parseTargets(moveCursor: boolean): java.util.List<cn.nukkit.entity.Entity>
        public parseTargetPlayers(): java.util.List<cn.nukkit.Player>
        public parseTargetPlayers(moveCursor: boolean): java.util.List<cn.nukkit.Player>
        public parsePosition(): cn.nukkit.level.Position
        public parsePosition(baseVector: cn.nukkit.math.Vector3): cn.nukkit.level.Position
        public parsePosition(baseVector: cn.nukkit.math.Vector3, moveCursor: boolean): cn.nukkit.level.Position
        public parseVector3(): cn.nukkit.math.Vector3
        public parseVector3(bv: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public parseVector3(bv: cn.nukkit.math.Vector3, moveCursor: boolean): cn.nukkit.math.Vector3
        public parseVector2(): cn.nukkit.math.Vector2
        public parseVector2(moveCursor: boolean): cn.nukkit.math.Vector2
        public parseAllRemain(): string
        public parseAllRemain(moveCursor: boolean): string
        parseCoordinate(baseVector3: cn.nukkit.math.Vector3, type: cn.nukkit.command.utils.CommandParser$CoordinateType): cn.nukkit.math.Vector3
        parseCoordinate(baseVector3: cn.nukkit.math.Vector3, type: cn.nukkit.command.utils.CommandParser$CoordinateType, moveCursor: boolean): cn.nukkit.math.Vector3
        static lambda$parseTargetPlayers$1(entity: cn.nukkit.entity.Entity): cn.nukkit.Player
        static lambda$parseTargetPlayers$0(entity: cn.nukkit.entity.Entity): boolean
        static STRING_PATTERN: string
        static TARGET_PATTERN: string
        static WILDCARD_TARGET_PATTERN: string
        static MULTIPLE_STRING_PATTERN: string
        static INT_PATTERN: string
        static WILDCARD_INT_PATTERN: string
        static FLOAT_PATTERN: string
        static COORDINATE_PATTERN: string
        static BLOCK_COORDINATE_PATTERN: string
        static result_cache: com.google.common.cache.Cache<string, cn.nukkit.command.utils.CommandParser>
        static pattern_cache: com.google.common.cache.Cache<string, cn.nukkit.command.utils.CommandParser$PatternCache>
        command: cn.nukkit.command.Command
        sender: cn.nukkit.command.CommandSender
        args: string[]
        parsedArgs: string[]
        matchedCommandForm: string
        cursor: int

    }
}

declare module "cn.nukkit.command.utils.CommandParser" {
    declare const CommandParser = cn.nukkit.command.utils.CommandParser;
}

declare namespace cn.nukkit.command.utils {
    declare class CommandParser$PatternCache extends java.lang.Record {
        constructor(pattern: java.util.regex.Pattern, length: int): void
        public toString(): string
        public hashCode(): int
        public equals(o: java.lang.Object): boolean
        public pattern(): java.util.regex.Pattern
        public length(): int
        pattern: java.util.regex.Pattern
        length: int

    }
}

declare module "cn.nukkit.command.utils.CommandParser$PatternCache" {
    declare const CommandParser$PatternCache = cn.nukkit.command.utils.CommandParser$PatternCache;
}

declare namespace cn.nukkit.command.utils {
    declare class RawText$Component$ComponentType extends java.lang.Enum {
        public static values(): cn.nukkit.command.utils.RawText$Component$ComponentType[]
        public static valueOf(name: string): cn.nukkit.command.utils.RawText$Component$ComponentType
        constructor(): void
        static $values(): cn.nukkit.command.utils.RawText$Component$ComponentType[]
        public static TEXT: cn.nukkit.command.utils.RawText$Component$ComponentType
        public static SELECTOR: cn.nukkit.command.utils.RawText$Component$ComponentType
        public static TRANSLATE: cn.nukkit.command.utils.RawText$Component$ComponentType
        public static TRANSLATE_WITH: cn.nukkit.command.utils.RawText$Component$ComponentType
        public static SCORE: cn.nukkit.command.utils.RawText$Component$ComponentType
        public static RAWTEXT: cn.nukkit.command.utils.RawText$Component$ComponentType
        static $VALUES: cn.nukkit.command.utils.RawText$Component$ComponentType[]

    }
}

declare module "cn.nukkit.command.utils.RawText$Component$ComponentType" {
    declare const RawText$Component$ComponentType = cn.nukkit.command.utils.RawText$Component$ComponentType;
}

declare namespace cn.nukkit.command {
    declare class ListenDefiner extends java.lang.Object {
        public constructor(): void
        public static getDefinedEvents(token: string): java.util.Map<string, string>
        public static clearDefinition(token: string): string
        public static existDefinition(token: string): boolean
        static getArguments(token: string): string
        public static LISTEN_DEFINER: java.util.regex.Pattern
        public static ARGUMENT_SEPARATOR: com.google.common.base.Splitter
        public static ARGUMENT_JOINER: com.google.common.base.Splitter

    }
}

declare module "cn.nukkit.command.ListenDefiner" {
    declare const ListenDefiner = cn.nukkit.command.ListenDefiner;
}

declare namespace cn.nukkit.command {
    declare class NPCCommandSender extends java.lang.Object implements cn.nukkit.command.CommandSender {
        public constructor(npc: cn.nukkit.entity.passive.EntityNPCEntity, initiator: cn.nukkit.Player): void
        public getInitiator(): cn.nukkit.Player
        public getNpc(): cn.nukkit.entity.passive.EntityNPCEntity
        public sendMessage(message: string): void
        public sendMessage(message: cn.nukkit.lang.TextContainer): void
        public getServer(): cn.nukkit.Server
        public getName(): string
        public isPlayer(): boolean
        public isEntity(): boolean
        public asEntity(): cn.nukkit.entity.Entity
        public asPlayer(): cn.nukkit.Player
        public getPosition(): cn.nukkit.level.Position
        public getLocation(): cn.nukkit.level.Location
        public isPermissionSet(name: string): boolean
        public isPermissionSet(permission: cn.nukkit.permission.Permission): boolean
        public hasPermission(name: string): boolean
        public hasPermission(permission: cn.nukkit.permission.Permission): boolean
        public addAttachment(plugin: cn.nukkit.plugin.Plugin): cn.nukkit.permission.PermissionAttachment
        public addAttachment(plugin: cn.nukkit.plugin.Plugin, name: string): cn.nukkit.permission.PermissionAttachment
        public addAttachment(plugin: cn.nukkit.plugin.Plugin, name: string, value: boolean): cn.nukkit.permission.PermissionAttachment
        public removeAttachment(attachment: cn.nukkit.permission.PermissionAttachment): void
        public recalculatePermissions(): void
        public getEffectivePermissions(): java.util.Map<string, cn.nukkit.permission.PermissionAttachmentInfo>
        public isOp(): boolean
        public setOp(value: boolean): void
        perm: cn.nukkit.permission.PermissibleBase
        initiator: cn.nukkit.Player
        npc: cn.nukkit.entity.passive.EntityNPCEntity

    }
}

declare module "cn.nukkit.command.NPCCommandSender" {
    declare const NPCCommandSender = cn.nukkit.command.NPCCommandSender;
}

declare namespace cn.nukkit.command {
    declare class FormattedCommandAlias extends cn.nukkit.command.Command {
        public constructor(alias: string, formatStrings: string[]): void
        public constructor(alias: string, formatStrings: java.util.List<string>): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        buildCommand(formatString: string, args: string[]): string
        static inRange(i: int, j: int, k: int): boolean
        static log: org.apache.logging.log4j.Logger
        formatStrings: string[]

    }
}

declare module "cn.nukkit.command.FormattedCommandAlias" {
    declare const FormattedCommandAlias = cn.nukkit.command.FormattedCommandAlias;
}

declare namespace cn.nukkit.command {
    declare interface PluginIdentifiableCommand {
        public getPlugin(): cn.nukkit.plugin.Plugin

    }
}

declare module "cn.nukkit.command.PluginIdentifiableCommand" {
    declare type PluginIdentifiableCommand = cn.nukkit.command.PluginIdentifiableCommand;
}

declare namespace cn.nukkit.command {
    declare interface CommandExecutor {
        public onCommand(var0: cn.nukkit.command.CommandSender, var1: cn.nukkit.command.Command, var2: string, var3: string[]): boolean

    }
}

declare module "cn.nukkit.command.CommandExecutor" {
    declare type CommandExecutor = cn.nukkit.command.CommandExecutor;
}

declare namespace cn.nukkit.command.exceptions {
    declare class SelectorSyntaxException extends java.lang.Exception {
        public constructor(): void

    }
}

declare module "cn.nukkit.command.exceptions.SelectorSyntaxException" {
    declare const SelectorSyntaxException = cn.nukkit.command.exceptions.SelectorSyntaxException;
}

declare namespace cn.nukkit.command.exceptions {
    declare class CommandSyntaxException extends java.lang.Exception {
        public constructor(): void

    }
}

declare module "cn.nukkit.command.exceptions.CommandSyntaxException" {
    declare const CommandSyntaxException = cn.nukkit.command.exceptions.CommandSyntaxException;
}

declare namespace cn.nukkit.command {
    declare class ConsoleCommandSender extends java.lang.Object implements cn.nukkit.command.CommandSender {
        public constructor(): void
        public isPermissionSet(name: string): boolean
        public isPermissionSet(permission: cn.nukkit.permission.Permission): boolean
        public hasPermission(name: string): boolean
        public hasPermission(permission: cn.nukkit.permission.Permission): boolean
        public addAttachment(plugin: cn.nukkit.plugin.Plugin): cn.nukkit.permission.PermissionAttachment
        public addAttachment(plugin: cn.nukkit.plugin.Plugin, name: string): cn.nukkit.permission.PermissionAttachment
        public addAttachment(plugin: cn.nukkit.plugin.Plugin, name: string, value: boolean): cn.nukkit.permission.PermissionAttachment
        public removeAttachment(attachment: cn.nukkit.permission.PermissionAttachment): void
        public recalculatePermissions(): void
        public getEffectivePermissions(): java.util.Map<string, cn.nukkit.permission.PermissionAttachmentInfo>
        public isPlayer(): boolean
        public getServer(): cn.nukkit.Server
        public sendMessage(message: string): void
        public sendMessage(message: cn.nukkit.lang.TextContainer): void
        public getName(): string
        public isOp(): boolean
        public setOp(value: boolean): void
        static log: org.apache.logging.log4j.Logger
        perm: cn.nukkit.permission.PermissibleBase

    }
}

declare module "cn.nukkit.command.ConsoleCommandSender" {
    declare const ConsoleCommandSender = cn.nukkit.command.ConsoleCommandSender;
}

declare namespace cn.nukkit.command {
    declare interface CommandMap {
        public registerAll(var0: string, var1: java.util.List<cn.nukkit.command.Command>): void
        public register(var0: string, var1: cn.nukkit.command.Command): boolean
        public register(var0: string, var1: cn.nukkit.command.Command, var2: string): boolean
        public registerSimpleCommands(var0: java.lang.Object): void
        public dispatch(var0: cn.nukkit.command.CommandSender, var1: string): boolean
        public clearCommands(): void
        public getCommand(var0: string): cn.nukkit.command.Command

    }
}

declare module "cn.nukkit.command.CommandMap" {
    declare type CommandMap = cn.nukkit.command.CommandMap;
}

declare namespace cn.nukkit.command.simple {
    declare interface CommandPermission extends java.lang.annotation.Annotation {
        public value(): string

    }
}

declare module "cn.nukkit.command.simple.CommandPermission" {
    declare type CommandPermission = cn.nukkit.command.simple.CommandPermission;
}

declare namespace cn.nukkit.command.simple {
    declare interface Parameters extends java.lang.annotation.Annotation {
        public name(): string
        public parameters(): cn.nukkit.command.simple.Parameter[]

    }
}

declare module "cn.nukkit.command.simple.Parameters" {
    declare type Parameters = cn.nukkit.command.simple.Parameters;
}

declare namespace cn.nukkit.command.simple {
    declare class SimpleCommand extends cn.nukkit.command.Command {
        public constructor(object: java.lang.Object, method: java.lang.reflect.Method, name: string, description: string, usageMessage: string, aliases: string[]): void
        public setForbidConsole(forbidConsole: boolean): void
        public setMaxArgs(maxArgs: int): void
        public setMinArgs(minArgs: int): void
        public sendUsageMessage(sender: cn.nukkit.command.CommandSender): void
        public sendInGameMessage(sender: cn.nukkit.command.CommandSender): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static log: org.apache.logging.log4j.Logger
        object: java.lang.Object
        method: java.lang.reflect.Method
        forbidConsole: boolean
        maxArgs: int
        minArgs: int

    }
}

declare module "cn.nukkit.command.simple.SimpleCommand" {
    declare const SimpleCommand = cn.nukkit.command.simple.SimpleCommand;
}

declare namespace cn.nukkit.command.simple {
    declare interface ForbidConsole extends java.lang.annotation.Annotation {

    }
}

declare module "cn.nukkit.command.simple.ForbidConsole" {
    declare type ForbidConsole = cn.nukkit.command.simple.ForbidConsole;
}

declare namespace cn.nukkit.command.simple {
    declare interface Arguments extends java.lang.annotation.Annotation {
        public min(): int
        public max(): int

    }
}

declare module "cn.nukkit.command.simple.Arguments" {
    declare type Arguments = cn.nukkit.command.simple.Arguments;
}

declare namespace cn.nukkit.command.simple {
    declare interface Command extends java.lang.annotation.Annotation {
        public name(): string
        public description(): string
        public usageMessage(): string
        public aliases(): string[]

    }
}

declare module "cn.nukkit.command.simple.Command" {
    declare type Command = cn.nukkit.command.simple.Command;
}

declare namespace cn.nukkit.command.simple {
    declare interface Parameter extends java.lang.annotation.Annotation {
        public name(): string
        public type(): cn.nukkit.command.data.CommandParamType
        public optional(): boolean

    }
}

declare module "cn.nukkit.command.simple.Parameter" {
    declare type Parameter = cn.nukkit.command.simple.Parameter;
}

declare namespace cn.nukkit.command.simple {
    declare interface CommandParameters extends java.lang.annotation.Annotation {
        public parameters(): cn.nukkit.command.simple.Parameters[]

    }
}

declare module "cn.nukkit.command.simple.CommandParameters" {
    declare type CommandParameters = cn.nukkit.command.simple.CommandParameters;
}

declare namespace cn.nukkit.command {
    declare class Command extends java.lang.Object {
        public constructor(name: string): void
        public constructor(name: string, description: string): void
        public constructor(name: string, description: string, usageMessage: string): void
        public constructor(name: string, description: string, usageMessage: string, aliases: string[]): void
        public getDefaultCommandData(): cn.nukkit.command.data.CommandData
        public getCommandParameters(key: string): cn.nukkit.command.data.CommandParameter[]
        public getCommandParameters(): java.util.Map<string, cn.nukkit.command.data.CommandParameter[]>
        public setCommandParameters(commandParameters: java.util.Map<string, cn.nukkit.command.data.CommandParameter[]>): void
        public addCommandParameters(key: string, parameters: cn.nukkit.command.data.CommandParameter[]): void
        public generateCustomCommandData(player: cn.nukkit.Player): cn.nukkit.command.data.CommandDataVersions
        public getOverloads(): java.util.Map<string, cn.nukkit.command.data.CommandOverload>
        parseTilde(arg: string, pos: double): double
        public execute(var0: cn.nukkit.command.CommandSender, var1: string, var2: string[]): boolean
        public getName(): string
        public getPermission(): string
        public setPermission(permission: string): void
        public testPermission(target: cn.nukkit.command.CommandSender): boolean
        public testPermissionSilent(target: cn.nukkit.command.CommandSender): boolean
        public getLabel(): string
        public setLabel(name: string): boolean
        public register(commandMap: cn.nukkit.command.CommandMap): boolean
        public unregister(commandMap: cn.nukkit.command.CommandMap): boolean
        public allowChangesFrom(commandMap: cn.nukkit.command.CommandMap): boolean
        public isRegistered(): boolean
        public getAliases(): string[]
        public getPermissionMessage(): string
        public getDescription(): string
        public getUsage(): string
        public getCommandFormatTips(): string
        public setAliases(aliases: string[]): void
        public setDescription(description: string): void
        public setPermissionMessage(permissionMessage: string): void
        public setUsage(usageMessage: string): void
        public static generateDefaultData(): cn.nukkit.command.data.CommandData
        public static broadcastCommandMessage(source: cn.nukkit.command.CommandSender, message: string): void
        public static broadcastCommandMessage(source: cn.nukkit.command.CommandSender, message: string, sendToSource: boolean): void
        public static broadcastCommandMessage(source: cn.nukkit.command.CommandSender, message: cn.nukkit.lang.TextContainer): void
        public static broadcastCommandMessage(source: cn.nukkit.command.CommandSender, message: cn.nukkit.lang.TextContainer, sendToSource: boolean): void
        public toString(): string
        static lambda$generateCustomCommandData$0(customData: cn.nukkit.command.data.CommandData, key: string, par: cn.nukkit.command.data.CommandParameter[]): void
        commandData: cn.nukkit.command.data.CommandData
        name: string
        nextLabel: string
        label: string
        aliases: string[]
        activeAliases: string[]
        commandMap: cn.nukkit.command.CommandMap
        description: string
        usageMessage: string
        permission: string
        permissionMessage: string
        commandParameters: java.util.Map<string, cn.nukkit.command.data.CommandParameter[]>
        public timing: co.aikar.timings.Timing

    }
}

declare module "cn.nukkit.command.Command" {
    declare const Command = cn.nukkit.command.Command;
}

declare namespace cn.nukkit.command {
    declare class RemoteConsoleCommandSender extends cn.nukkit.command.ConsoleCommandSender {
        public constructor(): void
        public sendMessage(message: string): void
        public sendMessage(message: cn.nukkit.lang.TextContainer): void
        public getMessages(): string
        public getName(): string
        messages: java.lang.StringBuilder

    }
}

declare module "cn.nukkit.command.RemoteConsoleCommandSender" {
    declare const RemoteConsoleCommandSender = cn.nukkit.command.RemoteConsoleCommandSender;
}

declare namespace cn.nukkit.command.defaults {
    declare class StopSoundCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.StopSoundCommand" {
    declare const StopSoundCommand = cn.nukkit.command.defaults.StopSoundCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class CloneCommand$MaskMode extends java.lang.Enum {
        public static values(): cn.nukkit.command.defaults.CloneCommand$MaskMode[]
        public static valueOf(name: string): cn.nukkit.command.defaults.CloneCommand$MaskMode
        constructor(): void
        static $values(): cn.nukkit.command.defaults.CloneCommand$MaskMode[]
        public static REPLACE: cn.nukkit.command.defaults.CloneCommand$MaskMode
        public static MASKED: cn.nukkit.command.defaults.CloneCommand$MaskMode
        public static FILTERED: cn.nukkit.command.defaults.CloneCommand$MaskMode
        static $VALUES: cn.nukkit.command.defaults.CloneCommand$MaskMode[]

    }
}

declare module "cn.nukkit.command.defaults.CloneCommand$MaskMode" {
    declare const CloneCommand$MaskMode = cn.nukkit.command.defaults.CloneCommand$MaskMode;
}

declare namespace cn.nukkit.command.defaults {
    declare class TeleportCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.TeleportCommand" {
    declare const TeleportCommand = cn.nukkit.command.defaults.TeleportCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class HelpCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.HelpCommand" {
    declare const HelpCommand = cn.nukkit.command.defaults.HelpCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class TagCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$execute$0(t: cn.nukkit.nbt.tag.StringTag): string

    }
}

declare module "cn.nukkit.command.defaults.TagCommand" {
    declare const TagCommand = cn.nukkit.command.defaults.TagCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class FillCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.FillCommand" {
    declare const FillCommand = cn.nukkit.command.defaults.FillCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class VersionCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        listVersion(): java.util.concurrent.CompletableFuture<com.google.gson.JsonArray>
        static lambda$listVersion$3(): com.google.gson.JsonArray
        static lambda$execute$2(authorsString: string[], s: string): void
        static lambda$execute$1(finalPluginName: string, exactPlugin: cn.nukkit.plugin.Plugin[], found: boolean[], s: string, p: cn.nukkit.plugin.Plugin): void
        lambda$new$0(): void
        queryQueue: java.util.List<cn.nukkit.command.defaults.VersionCommand$Query>

    }
}

declare module "cn.nukkit.command.defaults.VersionCommand" {
    declare const VersionCommand = cn.nukkit.command.defaults.VersionCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class BanIpCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        processIPBan(ip: string, sender: cn.nukkit.command.CommandSender, reason: string): void

    }
}

declare module "cn.nukkit.command.defaults.BanIpCommand" {
    declare const BanIpCommand = cn.nukkit.command.defaults.BanIpCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class TestForBlocksCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.TestForBlocksCommand" {
    declare const TestForBlocksCommand = cn.nukkit.command.defaults.TestForBlocksCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class OpCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$execute$0(p: cn.nukkit.Player): cn.nukkit.IPlayer

    }
}

declare module "cn.nukkit.command.defaults.OpCommand" {
    declare const OpCommand = cn.nukkit.command.defaults.OpCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class FunctionCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.FunctionCommand" {
    declare const FunctionCommand = cn.nukkit.command.defaults.FunctionCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class TimingsCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.TimingsCommand" {
    declare const TimingsCommand = cn.nukkit.command.defaults.TimingsCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class ClearCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.ClearCommand" {
    declare const ClearCommand = cn.nukkit.command.defaults.ClearCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class SaveOnCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.SaveOnCommand" {
    declare const SaveOnCommand = cn.nukkit.command.defaults.SaveOnCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class GameruleCommand$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$level$GameRules$Type: int[]

    }
}

declare module "cn.nukkit.command.defaults.GameruleCommand$1" {
    declare const GameruleCommand$1 = cn.nukkit.command.defaults.GameruleCommand$1;
}

declare namespace cn.nukkit.command.defaults {
    declare class PardonCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.PardonCommand" {
    declare const PardonCommand = cn.nukkit.command.defaults.PardonCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class GameruleCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$new$0(boolGameRules: java.util.List, intGameRules: java.util.List, floatGameRules: java.util.List, unknownGameRules: java.util.List, rule: cn.nukkit.level.GameRule, value: cn.nukkit.level.GameRules$Value): void

    }
}

declare module "cn.nukkit.command.defaults.GameruleCommand" {
    declare const GameruleCommand = cn.nukkit.command.defaults.GameruleCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class VanillaCommand extends cn.nukkit.command.Command {
        public constructor(name: string): void
        public constructor(name: string, description: string): void
        public constructor(name: string, description: string, usageMessage: string): void
        public constructor(name: string, description: string, usageMessage: string, aliases: string[]): void

    }
}

declare module "cn.nukkit.command.defaults.VanillaCommand" {
    declare const VanillaCommand = cn.nukkit.command.defaults.VanillaCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class DifficultyCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.DifficultyCommand" {
    declare const DifficultyCommand = cn.nukkit.command.defaults.DifficultyCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class SummonCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.SummonCommand" {
    declare const SummonCommand = cn.nukkit.command.defaults.SummonCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class TitlerawCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$execute$1(e: cn.nukkit.entity.Entity): cn.nukkit.Player
        static lambda$execute$0(e: cn.nukkit.entity.Entity): boolean

    }
}

declare module "cn.nukkit.command.defaults.TitlerawCommand" {
    declare const TitlerawCommand = cn.nukkit.command.defaults.TitlerawCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class AbilityCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.AbilityCommand" {
    declare const AbilityCommand = cn.nukkit.command.defaults.AbilityCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class TimeCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.TimeCommand" {
    declare const TimeCommand = cn.nukkit.command.defaults.TimeCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class TitleCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$execute$1(e: cn.nukkit.entity.Entity): cn.nukkit.Player
        static lambda$execute$0(e: cn.nukkit.entity.Entity): boolean

    }
}

declare module "cn.nukkit.command.defaults.TitleCommand" {
    declare const TitleCommand = cn.nukkit.command.defaults.TitleCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class KillCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$execute$1(entity: cn.nukkit.entity.Entity): string
        static lambda$execute$0(entity: cn.nukkit.entity.Entity): boolean

    }
}

declare module "cn.nukkit.command.defaults.KillCommand" {
    declare const KillCommand = cn.nukkit.command.defaults.KillCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class SetBlockCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.SetBlockCommand" {
    declare const SetBlockCommand = cn.nukkit.command.defaults.SetBlockCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class ClearSpawnPointCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$execute$0(p: cn.nukkit.Player): string

    }
}

declare module "cn.nukkit.command.defaults.ClearSpawnPointCommand" {
    declare const ClearSpawnPointCommand = cn.nukkit.command.defaults.ClearSpawnPointCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class BanListCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.BanListCommand" {
    declare const BanListCommand = cn.nukkit.command.defaults.BanListCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class DayLockCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.DayLockCommand" {
    declare const DayLockCommand = cn.nukkit.command.defaults.DayLockCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class GiveCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$execute$2(p: cn.nukkit.Player): string
        static lambda$execute$1(p: cn.nukkit.entity.Entity): cn.nukkit.Player
        static lambda$execute$0(entity: cn.nukkit.entity.Entity): boolean

    }
}

declare module "cn.nukkit.command.defaults.GiveCommand" {
    declare const GiveCommand = cn.nukkit.command.defaults.GiveCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class EnchantCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$new$0(x$0: int): string[]

    }
}

declare module "cn.nukkit.command.defaults.EnchantCommand" {
    declare const EnchantCommand = cn.nukkit.command.defaults.EnchantCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class BanCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.BanCommand" {
    declare const BanCommand = cn.nukkit.command.defaults.BanCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class MeCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.MeCommand" {
    declare const MeCommand = cn.nukkit.command.defaults.MeCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class PardonIpCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.PardonIpCommand" {
    declare const PardonIpCommand = cn.nukkit.command.defaults.PardonIpCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class WhitelistCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        badPerm(sender: cn.nukkit.command.CommandSender, perm: string): boolean

    }
}

declare module "cn.nukkit.command.defaults.WhitelistCommand" {
    declare const WhitelistCommand = cn.nukkit.command.defaults.WhitelistCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class VersionCommand$Query extends java.lang.Record {
        constructor(sender: cn.nukkit.command.CommandSender, jsonArrayFuture: java.util.concurrent.CompletableFuture<com.google.gson.JsonArray>): void
        public toString(): string
        public hashCode(): int
        public equals(o: java.lang.Object): boolean
        public sender(): cn.nukkit.command.CommandSender
        public jsonArrayFuture(): java.util.concurrent.CompletableFuture<com.google.gson.JsonArray>
        sender: cn.nukkit.command.CommandSender
        jsonArrayFuture: java.util.concurrent.CompletableFuture<com.google.gson.JsonArray>

    }
}

declare module "cn.nukkit.command.defaults.VersionCommand$Query" {
    declare const VersionCommand$Query = cn.nukkit.command.defaults.VersionCommand$Query;
}

declare namespace cn.nukkit.command.defaults {
    declare class SaveCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.SaveCommand" {
    declare const SaveCommand = cn.nukkit.command.defaults.SaveCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class TestForCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.TestForCommand" {
    declare const TestForCommand = cn.nukkit.command.defaults.TestForCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class GarbageCollectorCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.GarbageCollectorCommand" {
    declare const GarbageCollectorCommand = cn.nukkit.command.defaults.GarbageCollectorCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class TellCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$execute$1(p: cn.nukkit.entity.Entity): cn.nukkit.Player
        static lambda$execute$0(p: cn.nukkit.entity.Entity): boolean

    }
}

declare module "cn.nukkit.command.defaults.TellCommand" {
    declare const TellCommand = cn.nukkit.command.defaults.TellCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class StopCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.StopCommand" {
    declare const StopCommand = cn.nukkit.command.defaults.StopCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class GamemodeCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$execute$1(p: cn.nukkit.entity.Entity): cn.nukkit.Player
        static lambda$execute$0(p: cn.nukkit.entity.Entity): boolean

    }
}

declare module "cn.nukkit.command.defaults.GamemodeCommand" {
    declare const GamemodeCommand = cn.nukkit.command.defaults.GamemodeCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class ListCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.ListCommand" {
    declare const ListCommand = cn.nukkit.command.defaults.ListCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class SetMaxPlayersCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.SetMaxPlayersCommand" {
    declare const SetMaxPlayersCommand = cn.nukkit.command.defaults.SetMaxPlayersCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class TestForBlockCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.TestForBlockCommand" {
    declare const TestForBlockCommand = cn.nukkit.command.defaults.TestForBlockCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class PlaySoundCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static lambda$new$0(s: cn.nukkit.level.Sound): string

    }
}

declare module "cn.nukkit.command.defaults.PlaySoundCommand" {
    declare const PlaySoundCommand = cn.nukkit.command.defaults.PlaySoundCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class ReplaceItemCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.ReplaceItemCommand" {
    declare const ReplaceItemCommand = cn.nukkit.command.defaults.ReplaceItemCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class ExecuteCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.ExecuteCommand" {
    declare const ExecuteCommand = cn.nukkit.command.defaults.ExecuteCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class TellrawCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.TellrawCommand" {
    declare const TellrawCommand = cn.nukkit.command.defaults.TellrawCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class SayCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean

    }
}

declare module "cn.nukkit.command.defaults.SayCommand" {
    declare const SayCommand = cn.nukkit.command.defaults.SayCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class StatusCommand extends cn.nukkit.command.defaults.VanillaCommand {
        public constructor(name: string): void
        public execute(sender: cn.nukkit.command.CommandSender, commandLabel: string, args: string[]): boolean
        static formatUptime(uptime: long): string
        static UPTIME_FORMAT: string

    }
}

declare module "cn.nukkit.command.defaults.StatusCommand" {
    declare const StatusCommand = cn.nukkit.command.defaults.StatusCommand;
}

declare namespace cn.nukkit.command.defaults {
    declare class TestForBlocksCommand$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$command$defaults$TestForBlocksCommand$TestForBlocksMode: int[]

    }
}

declare module "cn.nukkit.command.defaults.TestForBlocksCommand$1" {
    declare const TestForBlocksCommand$1 = cn.nukkit.command.defaults.TestForBlocksCommand$1;
}

declare namespace cn.nukkit.command.defaults {
    declare class TestForBlocksCommand$TestForBlocksMode extends java.lang.Enum {
        public static values(): cn.nukkit.command.defaults.TestForBlocksCommand$TestForBlocksMode[]
        public static valueOf(name: string): cn.nukkit.command.defaults.TestForBlocksCommand$TestForBlocksMode
        constructor(): void
        static $values(): cn.nukkit.command.defaults.TestForBlocksCommand$TestForBlocksMode[]
        public static ALL: cn.nukkit.command.defaults.TestForBlocksCommand$TestForBlocksMode
        public static MASKED: cn.nukkit.command.defaults.TestForBlocksCommand$TestForBlocksMode
        static $VALUES: cn.nukkit.command.defaults.TestForBlocksCommand$TestForBlocksMode[]

    }
}

declare module "cn.nukkit.command.defaults.TestForBlocksCommand$TestForBlocksMode" {
    declare const TestForBlocksCommand$TestForBlocksMode = cn.nukkit.command.defaults.TestForBlocksCommand$TestForBlocksMode;
}

declare namespace cn.nukkit.utils.collection {
    declare class ConvertingMapWrapper$EntryWrapper extends java.lang.Object implements java.util.Map$Entry {
        public constructor(var0: java.util.Map$Entry<any>, entryProxied: java.util.function.Function<any>, entryConverter: java.util.function.Function<any>): void
        public getKey(): any
        public getValue(): any
        public setValue(): any
        public toString(): string
        public equals(o: java.lang.Object): boolean
        public hashCode(): int
        entryConverter: java.util.function.Function<any>
        entryReverseConverter: java.util.function.Function<any>
        entryProxied: java.util.Map$Entry<any>
        this$0: cn.nukkit.utils.collection.ConvertingMapWrapper

    }
}

declare module "cn.nukkit.utils.collection.ConvertingMapWrapper$EntryWrapper" {
    declare const ConvertingMapWrapper$EntryWrapper = cn.nukkit.utils.collection.ConvertingMapWrapper$EntryWrapper;
}

declare namespace cn.nukkit.utils.collection {
    declare class ConvertingSetWrapper$ConvertingIterator extends java.lang.Object implements java.util.Iterator {
        constructor(var0: cn.nukkit.utils.collection.ConvertingSetWrapper): void
        public remove(): void
        public hasNext(): boolean
        public next(): void
        proxiedIterator: java.util.Iterator<void>
        this$0: cn.nukkit.utils.collection.ConvertingSetWrapper

    }
}

declare module "cn.nukkit.utils.collection.ConvertingSetWrapper$ConvertingIterator" {
    declare const ConvertingSetWrapper$ConvertingIterator = cn.nukkit.utils.collection.ConvertingSetWrapper$ConvertingIterator;
}

declare namespace cn.nukkit.utils {
    declare class Utils extends java.lang.Object {
        public constructor(): void
        public static safeWrite(currentFile: java.io.File, operation: java.util.function.Consumer<java.io.File>): void
        public static writeFile(fileName: string, content: string): void
        public static writeFile(fileName: string, content: java.io.InputStream): void
        public static writeFile(file: java.io.File, content: string): void
        public static writeFile(file: java.io.File, content: java.io.InputStream): void
        public static readFile(file: java.io.File): string
        public static readFile(filename: string): string
        public static readFile(inputStream: java.io.InputStream): string
        static readFile(reader: java.io.Reader): string
        public static copyFile(from: java.io.File, to: java.io.File): void
        public static getAllThreadDumps(): string
        public static getExceptionMessage(e: java.lang.Throwable): string
        public static dataToUUID(params: string[]): java.util.UUID
        public static dataToUUID(params: byte[][]): java.util.UUID
        public static rtrim(s: string, character: char): string
        public static isByteArrayEmpty(array: byte[]): boolean
        public static toRGB(r: byte, g: byte, b: byte, a: byte): long
        public static toABGR(argb: int): long
        public static splitArray(arrayToSplit: java.lang.Object[], chunkSize: int): java.lang.Object[][]
        public static reverseArray(data: java.lang.Object): void
        public static reverseArray(array: java.lang.Object): boolean
        public static clone2dArray(): java.lang.Object
        public static getOrCreate(map: java.lang.Object, key: java.lang.Object, existing: void, toPut: java.lang.Object, var4: java.util.Map<java.util.Map<void>>): java.util.Map<void>
        public static getOrCreate(map: java.lang.Object, clazz: java.lang.Object, key: void, existing: java.util.Map<any>): java.lang.Class<void>
        public static toInt(number: java.lang.Object): int
        public static parseHexBinary(s: string): byte[]
        static hexToBin(ch: char): int
        public static rand(min: int, max: int): int
        public static rand(min: double, var1: double): double
        public static rand(): boolean
        public static dynamic(value: int): int
        public static dynamic(): java.lang.Object
        public static zipFolder(sourceFolderPath: java.nio.file.Path, zipPath: java.nio.file.Path): void
        public static isInteger(str: string): boolean
        public static getLevelBlocks(level: cn.nukkit.level.Level, bb: cn.nukkit.math.AxisAlignedBB): cn.nukkit.block.Block[]
        static log: org.apache.logging.log4j.Logger
        public static EMPTY_INTEGERS: int[]
        public static random: java.util.SplittableRandom

    }
}

declare module "cn.nukkit.utils.Utils" {
    declare const Utils = cn.nukkit.utils.Utils;
}

declare namespace cn.nukkit.utils {
    declare class TextFormat extends java.lang.Enum {
        public static values(): cn.nukkit.utils.TextFormat[]
        public static valueOf(name: string): cn.nukkit.utils.TextFormat
        constructor(var0: char, var1: int): void
        constructor(var0: char, var1: int, code: boolean): void
        public static getByChar(code: char): cn.nukkit.utils.TextFormat
        public static getByChar(code: string): cn.nukkit.utils.TextFormat
        public static clean(input: string): string
        public static clean(input: string, recursive: boolean): string
        public static colorize(altFormatChar: char, textToTranslate: string): string
        public static colorize(textToTranslate: string): string
        public static getLastColors(input: string): string
        public getChar(): char
        public toString(): string
        public isFormat(): boolean
        public isColor(): boolean
        static $values(): cn.nukkit.utils.TextFormat[]
        public static BLACK: cn.nukkit.utils.TextFormat
        public static DARK_BLUE: cn.nukkit.utils.TextFormat
        public static DARK_GREEN: cn.nukkit.utils.TextFormat
        public static DARK_AQUA: cn.nukkit.utils.TextFormat
        public static DARK_RED: cn.nukkit.utils.TextFormat
        public static DARK_PURPLE: cn.nukkit.utils.TextFormat
        public static GOLD: cn.nukkit.utils.TextFormat
        public static GRAY: cn.nukkit.utils.TextFormat
        public static DARK_GRAY: cn.nukkit.utils.TextFormat
        public static BLUE: cn.nukkit.utils.TextFormat
        public static GREEN: cn.nukkit.utils.TextFormat
        public static AQUA: cn.nukkit.utils.TextFormat
        public static RED: cn.nukkit.utils.TextFormat
        public static LIGHT_PURPLE: cn.nukkit.utils.TextFormat
        public static YELLOW: cn.nukkit.utils.TextFormat
        public static WHITE: cn.nukkit.utils.TextFormat
        public static MINECOIN_GOLD: cn.nukkit.utils.TextFormat
        public static OBFUSCATED: cn.nukkit.utils.TextFormat
        public static BOLD: cn.nukkit.utils.TextFormat
        public static STRIKETHROUGH: cn.nukkit.utils.TextFormat
        public static UNDERLINE: cn.nukkit.utils.TextFormat
        public static ITALIC: cn.nukkit.utils.TextFormat
        public static RESET: cn.nukkit.utils.TextFormat
        public static ESCAPE: char
        static CLEAN_PATTERN: java.util.regex.Pattern
        static BY_ID: java.util.Map<int, cn.nukkit.utils.TextFormat>
        static BY_CHAR: java.util.Map<char, cn.nukkit.utils.TextFormat>
        intCode: int
        code: char
        isFormat: boolean
        toString: string
        static $VALUES: cn.nukkit.utils.TextFormat[]

    }
}

declare module "cn.nukkit.utils.TextFormat" {
    declare const TextFormat = cn.nukkit.utils.TextFormat;
}

declare namespace cn.nukkit.utils {
    declare class HumanStringComparator extends java.lang.Object implements java.util.Comparator {
        public compare(o1: string, o2: string): int
        splitSymbols(list: java.util.List<string>): java.util.List<string>
        compare(l1: java.util.List<string>, l2: java.util.List<string>): int
        detectOmittedNumber(l1: java.util.List<string>, len1: int, i: int, str2: string, strLen2: int, minStrLen: int, commonPart1: string): boolean
        combineNegativeSign(list: java.util.List<string>): java.util.List<string>
        split(str: string): java.util.List<string>
        public static getInstance(): cn.nukkit.utils.HumanStringComparator
        public constructor(): void
        public compare(var0: java.lang.Object, var1: java.lang.Object): int
        static INSTANCE: cn.nukkit.utils.HumanStringComparator
        static LEFT: int
        static RIGHT: int
        static EQUALS: int
        static SYMBOLS: string
        static $assertionsDisabled: boolean

    }
}

declare module "cn.nukkit.utils.HumanStringComparator" {
    declare const HumanStringComparator = cn.nukkit.utils.HumanStringComparator;
}

declare namespace cn.nukkit.utils {
    declare class Config$2 extends com.google.gson.reflect.TypeToken {
        constructor(this$0: cn.nukkit.utils.Config): void
        this$0: cn.nukkit.utils.Config

    }
}

declare module "cn.nukkit.utils.Config$2" {
    declare const Config$2 = cn.nukkit.utils.Config$2;
}

declare namespace cn.nukkit.utils {
    declare class Watchdog extends java.lang.Thread {
        public constructor(server: cn.nukkit.Server, time: long): void
        public kill(): void
        checkFinalizer(): void
        public run(): void
        static dumpThread(thread: java.lang.management.ThreadInfo, builder: java.lang.StringBuilder): void
        static lambda$checkFinalizer$0(): void
        static log: org.apache.logging.log4j.Logger
        server: cn.nukkit.Server
        time: long
        public running: boolean
        responding: boolean
        forcedFinalizer: java.lang.Thread
        warnedAboutFinalizer: boolean

    }
}

declare module "cn.nukkit.utils.Watchdog" {
    declare const Watchdog = cn.nukkit.utils.Watchdog;
}

declare namespace cn.nukkit.utils {
    declare interface PlayerDataSerializer {
        public read(var0: string, var1: java.util.UUID): java.util.Optional<java.io.InputStream>
        public write(var0: string, var1: java.util.UUID): java.io.OutputStream

    }
}

declare module "cn.nukkit.utils.PlayerDataSerializer" {
    declare type PlayerDataSerializer = cn.nukkit.utils.PlayerDataSerializer;
}

declare namespace cn.nukkit.utils {
    declare class ZlibThreadLocal extends java.lang.Object implements cn.nukkit.utils.ZlibProvider {
        public constructor(): void
        public deflate(datas: byte[][], level: int): byte[]
        public deflate(data: byte[], level: int): byte[]
        public inflate(data: byte[], maxSize: int): byte[]
        static lambda$static$0(): byte[]
        static INFLATER: java.lang.ThreadLocal<java.util.zip.Inflater>
        static DEFLATER: java.lang.ThreadLocal<java.util.zip.Deflater>
        static BUFFER: byte[]

    }
}

declare module "cn.nukkit.utils.ZlibThreadLocal" {
    declare const ZlibThreadLocal = cn.nukkit.utils.ZlibThreadLocal;
}

declare namespace cn.nukkit.utils {
    declare interface SimpleConfig$Skip extends java.lang.annotation.Annotation {
        public skipSave(): boolean
        public skipLoad(): boolean

    }
}

declare module "cn.nukkit.utils.SimpleConfig$Skip" {
    declare type SimpleConfig$Skip = cn.nukkit.utils.SimpleConfig$Skip;
}

declare namespace cn.nukkit.utils {
    declare class BVector3 extends java.lang.Object {
        public static fromLocation(location: cn.nukkit.level.Location): cn.nukkit.utils.BVector3
        public static fromLocation(location: cn.nukkit.level.Location, length: double): cn.nukkit.utils.BVector3
        public static fromAngle(xzAxisAngle: double, var1: double, yAxisAngle: double): cn.nukkit.utils.BVector3
        public static fromPos(pos: cn.nukkit.math.Vector3): cn.nukkit.utils.BVector3
        constructor(xzAxisAngle: double, var1: double, yAxisAngle: double): void
        constructor(pos: cn.nukkit.math.Vector3): void
        public extend(length: double): cn.nukkit.utils.BVector3
        public setLength(length: double): cn.nukkit.utils.BVector3
        public setAngle(xzAxisAngle: double, var1: double): cn.nukkit.utils.BVector3
        public setYAngle(yAngle: double): cn.nukkit.utils.BVector3
        public setXZAngle(xzAngle: double): cn.nukkit.utils.BVector3
        public addAngle(xzAxisAngle: double, var1: double): cn.nukkit.utils.BVector3
        public setPos(x: double, var1: double, y: double): cn.nukkit.utils.BVector3
        public addPos(x: double, var1: double, y: double): cn.nukkit.utils.BVector3
        public addToPos(pos: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public getYaw(): double
        public getPitch(): double
        updatePos(): void
        updateAngle(): void
        convertAngle(xzAxisAngle: double, var1: double): void
        public static sin(angle: double): double
        public static cos(angle: double): double
        public static tan(angle: double): double
        public static asin(sin: double): double
        public static acos(cos: double): double
        public static atan(tan: double): double
        public static minAbs(a: double, var1: double): double
        public static maxAbs(a: double, var1: double): double
        public getXzAxisAngle(): double
        public getYAxisAngle(): double
        public getPos(): cn.nukkit.math.Vector3
        public getLength(): double
        xzAxisAngle: double
        yAxisAngle: double
        pos: cn.nukkit.math.Vector3
        length: double

    }
}

declare module "cn.nukkit.utils.BVector3" {
    declare const BVector3 = cn.nukkit.utils.BVector3;
}

declare namespace cn.nukkit.utils {
    declare class EventException extends java.lang.RuntimeException {
        public constructor(throwable: java.lang.Throwable): void
        public constructor(): void
        public constructor(cause: java.lang.Throwable, message: string): void
        public constructor(message: string): void
        public getCause(): java.lang.Throwable
        cause: java.lang.Throwable

    }
}

declare module "cn.nukkit.utils.EventException" {
    declare const EventException = cn.nukkit.utils.EventException;
}

declare namespace cn.nukkit.utils {
    declare class Rail extends java.lang.Object {
        public static isRailBlock(block: cn.nukkit.block.Block): boolean
        public static isRailBlock(blockId: int): boolean
        constructor(): void

    }
}

declare module "cn.nukkit.utils.Rail" {
    declare const Rail = cn.nukkit.utils.Rail;
}

declare namespace cn.nukkit.utils {
    declare class Zlib extends java.lang.Object {
        public constructor(): void
        public static setProvider(providerIndex: int): void
        public static deflate(data: byte[]): byte[]
        public static deflate(data: byte[], level: int): byte[]
        public static deflate(data: byte[][], level: int): byte[]
        public static inflate(data: byte[]): byte[]
        public static inflate(data: byte[], maxSize: int): byte[]
        static log: org.apache.logging.log4j.Logger
        static providers: cn.nukkit.utils.ZlibProvider[]
        static provider: cn.nukkit.utils.ZlibProvider

    }
}

declare module "cn.nukkit.utils.Zlib" {
    declare const Zlib = cn.nukkit.utils.Zlib;
}

declare namespace cn.nukkit.utils {
    declare interface SimpleConfig$Path extends java.lang.annotation.Annotation {
        public value(): string

    }
}

declare module "cn.nukkit.utils.SimpleConfig$Path" {
    declare type SimpleConfig$Path = cn.nukkit.utils.SimpleConfig$Path;
}

declare namespace cn.nukkit.utils {
    declare class BlockUpdateEntry extends java.lang.Object implements java.lang.Comparable {
        public constructor(pos: cn.nukkit.math.Vector3, block: cn.nukkit.block.Block): void
        public constructor(pos: cn.nukkit.math.Vector3, block: cn.nukkit.block.Block, delay: long, var3: int): void
        public constructor(pos: cn.nukkit.math.Vector3, block: cn.nukkit.block.Block, delay: long, var3: int, priority: boolean): void
        public compareTo(entry: cn.nukkit.utils.BlockUpdateEntry): int
        public equals(object: java.lang.Object): boolean
        public hashCode(): int
        public compareTo(var0: java.lang.Object): int
        static entryID: long
        public priority: int
        public delay: long
        public checkBlockWhenUpdate: boolean
        public pos: cn.nukkit.math.Vector3
        public block: cn.nukkit.block.Block
        public id: long

    }
}

declare module "cn.nukkit.utils.BlockUpdateEntry" {
    declare const BlockUpdateEntry = cn.nukkit.utils.BlockUpdateEntry;
}

declare namespace cn.nukkit.utils {
    declare interface Faceable {
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void

    }
}

declare module "cn.nukkit.utils.Faceable" {
    declare type Faceable = cn.nukkit.utils.Faceable;
}

declare namespace cn.nukkit.utils {
    declare interface Logger {
        public emergency(var0: string): void
        public alert(var0: string): void
        public critical(var0: string): void
        public error(var0: string): void
        public warning(var0: string): void
        public notice(var0: string): void
        public info(var0: string): void
        public debug(var0: string): void
        public log(var0: cn.nukkit.utils.LogLevel, var1: string): void
        public emergency(var0: string, var1: java.lang.Throwable): void
        public alert(var0: string, var1: java.lang.Throwable): void
        public critical(var0: string, var1: java.lang.Throwable): void
        public error(var0: string, var1: java.lang.Throwable): void
        public warning(var0: string, var1: java.lang.Throwable): void
        public notice(var0: string, var1: java.lang.Throwable): void
        public info(var0: string, var1: java.lang.Throwable): void
        public debug(var0: string, var1: java.lang.Throwable): void
        public log(var0: cn.nukkit.utils.LogLevel, var1: string, var2: java.lang.Throwable): void

    }
}

declare module "cn.nukkit.utils.Logger" {
    declare type Logger = cn.nukkit.utils.Logger;
}

declare namespace cn.nukkit.utils {
    declare class Config extends java.lang.Object {
        public constructor(type: int): void
        public constructor(): void
        public constructor(file: string): void
        public constructor(file: java.io.File): void
        public constructor(file: string, type: int): void
        public constructor(file: java.io.File, type: int): void
        public constructor(file: string, type: int, defaultMap: java.util.LinkedHashMap<string, java.lang.Object>): void
        public constructor(file: string, type: int, defaultMap: cn.nukkit.utils.ConfigSection): void
        public constructor(file: java.io.File, type: int, defaultMap: cn.nukkit.utils.ConfigSection): void
        public constructor(file: java.io.File, type: int, defaultMap: java.util.LinkedHashMap<string, java.lang.Object>): void
        public reload(): void
        public load(file: string): boolean
        public load(file: string, type: int): boolean
        public load(file: string, type: int, defaultMap: cn.nukkit.utils.ConfigSection): boolean
        public load(inputStream: java.io.InputStream): boolean
        public loadAsJson(inputStream: java.io.InputStream, gson: com.google.gson.Gson): boolean
        public check(): boolean
        public isCorrect(): boolean
        public save(file: java.io.File, async: boolean): boolean
        public save(file: java.io.File): boolean
        public saveAsJson(file: java.io.File, async: boolean, gson: com.google.gson.Gson): boolean
        public save(): boolean
        public saveAsJson(async: boolean, gson: com.google.gson.Gson): boolean
        public save(async: boolean): boolean
        save0(async: boolean, content: java.lang.StringBuilder): void
        public set(key: string, value: java.lang.Object): void
        public get(key: string): java.lang.Object
        public get(key: java.lang.Object): string
        public getSection(key: string): cn.nukkit.utils.ConfigSection
        public isSection(key: string): boolean
        public getSections(key: string): cn.nukkit.utils.ConfigSection
        public getSections(): cn.nukkit.utils.ConfigSection
        public getInt(key: string): int
        public getInt(key: string, defaultValue: int): int
        public isInt(key: string): boolean
        public getLong(key: string): long
        public getLong(key: string, defaultValue: long): long
        public isLong(key: string): boolean
        public getDouble(key: string): double
        public getDouble(key: string, defaultValue: double): double
        public isDouble(key: string): boolean
        public getString(key: string): string
        public getString(key: string, defaultValue: string): string
        public isString(key: string): boolean
        public getBoolean(key: string): boolean
        public getBoolean(key: string, defaultValue: boolean): boolean
        public isBoolean(key: string): boolean
        public getList(key: string): java.util.List
        public getList(key: string, defaultList: java.util.List): java.util.List
        public isList(key: string): boolean
        public getStringList(key: string): java.util.List<string>
        public getIntegerList(key: string): java.util.List<int>
        public getBooleanList(key: string): java.util.List<boolean>
        public getDoubleList(key: string): java.util.List<double>
        public getFloatList(key: string): java.util.List<float>
        public getLongList(key: string): java.util.List<long>
        public getByteList(key: string): java.util.List<byte>
        public getCharacterList(key: string): java.util.List<char>
        public getShortList(key: string): java.util.List<java.lang.Short>
        public getMapList(key: string): java.util.List<java.util.Map>
        public setAll(map: java.util.LinkedHashMap<string, java.lang.Object>): void
        public setAll(section: cn.nukkit.utils.ConfigSection): void
        public exists(key: string): boolean
        public exists(key: string, ignoreCase: boolean): boolean
        public remove(key: string): void
        public getAll(): java.util.Map<string, java.lang.Object>
        public getRootSection(): cn.nukkit.utils.ConfigSection
        public setDefault(map: java.util.LinkedHashMap<string, java.lang.Object>): int
        public setDefault(map: cn.nukkit.utils.ConfigSection): int
        fillDefaults(defaultMap: cn.nukkit.utils.ConfigSection, data: cn.nukkit.utils.ConfigSection): cn.nukkit.utils.ConfigSection
        parseList(content: string): void
        writeProperties(): string
        parseProperties(content: string): void
        public getNested(key: string): java.lang.Object
        public getNested(key: java.lang.Object): string
        public getNestedAs(key: java.lang.Object, type: string): java.lang.Class<any>
        public removeNested(key: string): void
        parseContentAsJson(content: string, gson: com.google.gson.Gson): void
        parseContent(content: string): void
        public getKeys(): java.util.Set<string>
        public getKeys(child: boolean): java.util.Set<string>
        static log: org.apache.logging.log4j.Logger
        public static DETECT: int
        public static PROPERTIES: int
        public static CNF: int
        public static JSON: int
        public static YAML: int
        public static ENUM: int
        public static ENUMERATION: int
        config: cn.nukkit.utils.ConfigSection
        file: java.io.File
        correct: boolean
        type: int
        public static format: java.util.Map<string, int>

    }
}

declare module "cn.nukkit.utils.Config" {
    declare const Config = cn.nukkit.utils.Config;
}

declare namespace cn.nukkit.utils {
    declare class StringUtils extends java.lang.Object {
        constructor(): void
        public static beforeLast(str: string, splitter: string): string
        public static afterFirst(str: string, splitter: string): string

    }
}

declare module "cn.nukkit.utils.StringUtils" {
    declare const StringUtils = cn.nukkit.utils.StringUtils;
}

declare namespace cn.nukkit.utils {
    declare class ZlibOriginal extends java.lang.Object implements cn.nukkit.utils.ZlibProvider {
        public constructor(): void
        public deflate(datas: byte[][], level: int): byte[]
        public deflate(data: byte[], level: int): byte[]
        public inflate(data: byte[], maxSize: int): byte[]

    }
}

declare module "cn.nukkit.utils.ZlibOriginal" {
    declare const ZlibOriginal = cn.nukkit.utils.ZlibOriginal;
}

declare namespace cn.nukkit.utils {
    declare class OptionalBoolean extends java.lang.Enum {
        public static values(): cn.nukkit.utils.OptionalBoolean[]
        public static valueOf(name: string): cn.nukkit.utils.OptionalBoolean
        constructor(var0: boolean): void
        public static of(value: boolean): cn.nukkit.utils.OptionalBoolean
        public static of(value: boolean): cn.nukkit.utils.OptionalBoolean
        public static ofNullable(value: boolean): cn.nukkit.utils.OptionalBoolean
        public static empty(): cn.nukkit.utils.OptionalBoolean
        public getAsBoolean(): boolean
        public isPresent(): boolean
        public ifPresent(consumer: cn.nukkit.utils.functional.BooleanConsumer): void
        public orElse(other: boolean): boolean
        public orElseGet(other: java.util.function.BooleanSupplier): boolean
        public orElseThrow(exceptionSupplier: java.lang.Throwable, var1: java.util.function.Supplier<any>): boolean
        public toString(): string
        static $values(): cn.nukkit.utils.OptionalBoolean[]
        public static TRUE: cn.nukkit.utils.OptionalBoolean
        public static FALSE: cn.nukkit.utils.OptionalBoolean
        public static EMPTY: cn.nukkit.utils.OptionalBoolean
        value: boolean
        static $VALUES: cn.nukkit.utils.OptionalBoolean[]

    }
}

declare module "cn.nukkit.utils.OptionalBoolean" {
    declare const OptionalBoolean = cn.nukkit.utils.OptionalBoolean;
}

declare namespace cn.nukkit.utils {
    declare class MinecartType extends java.lang.Enum {
        public static values(): cn.nukkit.utils.MinecartType[]
        public static valueOf(name: string): cn.nukkit.utils.MinecartType
        constructor(var0: int, var1: boolean, number: string): void
        public getId(): int
        public getName(): string
        public hasBlockInside(): boolean
        public static valueOf(types: int): cn.nukkit.utils.MinecartType
        static $values(): cn.nukkit.utils.MinecartType[]
        public static MINECART_EMPTY: cn.nukkit.utils.MinecartType
        public static MINECART_CHEST: cn.nukkit.utils.MinecartType
        public static MINECART_FURNACE: cn.nukkit.utils.MinecartType
        public static MINECART_TNT: cn.nukkit.utils.MinecartType
        public static MINECART_MOB_SPAWNER: cn.nukkit.utils.MinecartType
        public static MINECART_HOPPER: cn.nukkit.utils.MinecartType
        public static MINECART_COMMAND_BLOCK: cn.nukkit.utils.MinecartType
        public static MINECART_UNKNOWN: cn.nukkit.utils.MinecartType
        type: int
        hasBlockInside: boolean
        realName: string
        static TYPES: java.util.Map<int, cn.nukkit.utils.MinecartType>
        static $VALUES: cn.nukkit.utils.MinecartType[]

    }
}

declare module "cn.nukkit.utils.MinecartType" {
    declare const MinecartType = cn.nukkit.utils.MinecartType;
}

declare namespace cn.nukkit.utils {
    declare class Validation extends java.lang.Object {
        public static checkPositive(arg: string, value: byte): void
        public static checkPositive(arg: string, value: short): void
        public static checkPositive(arg: string, value: int): void
        public static checkPositive(arg: string, value: long): void
        public static checkPositive(arg: string, value: float): void
        public static checkPositive(arg: string, value: double): void
        public static checkPositive(arg: string, value: java.math.BigInteger): void
        public static checkPositive(arg: string, value: java.math.BigDecimal): void
        constructor(): void

    }
}

declare module "cn.nukkit.utils.Validation" {
    declare const Validation = cn.nukkit.utils.Validation;
}

declare namespace cn.nukkit.utils {
    declare class NukkitCollectors extends java.lang.Object {
        public static countingInt(var0: java.lang.Object): java.util.stream.Collector<int>
        constructor(): void
        static lambda$countingInt$0(e: java.lang.Object): int

    }
}

declare module "cn.nukkit.utils.NukkitCollectors" {
    declare const NukkitCollectors = cn.nukkit.utils.NukkitCollectors;
}

declare namespace cn.nukkit.utils {
    declare class Hash extends java.lang.Object {
        public constructor(): void
        public static hashBlock(x: int, y: int, z: int): long
        public static hashBlockX(triple: long): int
        public static hashBlockY(triple: long): int
        public static hashBlockZ(triple: long): int
        public static hashBlock(blockPos: cn.nukkit.math.Vector3): long

    }
}

declare module "cn.nukkit.utils.Hash" {
    declare const Hash = cn.nukkit.utils.Hash;
}

declare namespace cn.nukkit.utils {
    declare class ZlibSingleThreadLowMem extends java.lang.Object implements cn.nukkit.utils.ZlibProvider {
        public constructor(): void
        public deflate(datas: byte[][], level: int): byte[]
        public deflate(data: byte[], level: int): byte[]
        public inflate(data: byte[], maxSize: int): byte[]
        static BUFFER_SIZE: int
        static DEFLATER: java.util.zip.Deflater
        static INFLATER: java.util.zip.Inflater
        static BUFFER: byte[]

    }
}

declare module "cn.nukkit.utils.ZlibSingleThreadLowMem" {
    declare const ZlibSingleThreadLowMem = cn.nukkit.utils.ZlibSingleThreadLowMem;
}

declare namespace cn.nukkit.utils {
    declare class ThreadCache$1 extends cn.nukkit.utils.IterableThreadLocal {
        constructor(): void
        public init(): byte[][]
        public init(): java.lang.Object

    }
}

declare module "cn.nukkit.utils.ThreadCache$1" {
    declare const ThreadCache$1 = cn.nukkit.utils.ThreadCache$1;
}

declare namespace cn.nukkit.utils {
    declare class SkinAnimation extends java.lang.Object {
        public constructor(image: cn.nukkit.utils.SerializedImage, type: int, frames: float): void
        public constructor(image: cn.nukkit.utils.SerializedImage, type: int, frames: float, expression: int): void
        public toString(): string
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        public image: cn.nukkit.utils.SerializedImage
        public type: int
        public frames: float
        public expression: int

    }
}

declare module "cn.nukkit.utils.SkinAnimation" {
    declare const SkinAnimation = cn.nukkit.utils.SkinAnimation;
}

declare namespace cn.nukkit.utils {
    declare class Utils$1 extends java.nio.file.SimpleFileVisitor {
        constructor(var0: java.util.zip.ZipOutputStream, var1: java.nio.file.Path): void
        public visitFile(file: java.nio.file.Path, attrs: java.nio.file.attribute.BasicFileAttributes): java.nio.file.FileVisitResult
        public visitFile(var0: java.lang.Object, var1: java.nio.file.attribute.BasicFileAttributes): java.nio.file.FileVisitResult
        val$zos: java.util.zip.ZipOutputStream
        val$sourceFolderPath: java.nio.file.Path

    }
}

declare module "cn.nukkit.utils.Utils$1" {
    declare const Utils$1 = cn.nukkit.utils.Utils$1;
}

declare namespace cn.nukkit.utils {
    declare class Binary extends java.lang.Object {
        public constructor(): void
        public static signByte(value: int): int
        public static unsignByte(value: int): int
        public static signShort(value: int): int
        public unsignShort(value: int): int
        public static signInt(value: int): int
        public static unsignInt(value: int): int
        public static readTriad(bytes: byte[]): int
        public static writeTriad(value: int): byte[]
        public static readLTriad(bytes: byte[]): int
        public static writeLTriad(value: int): byte[]
        public static readUUID(bytes: byte[]): java.util.UUID
        public static writeUUID(uuid: java.util.UUID): byte[]
        public static writeMetadata(metadata: cn.nukkit.entity.data.EntityMetadata): byte[]
        public static readMetadata(payload: byte[]): cn.nukkit.entity.data.EntityMetadata
        public static readBool(b: byte): boolean
        public static writeBool(b: boolean): byte
        public static readSignedByte(b: byte): int
        public static writeByte(b: byte): byte
        public static readShort(bytes: byte[]): int
        public static readSignedShort(bytes: byte[]): short
        public static writeShort(s: int): byte[]
        public static readLShort(bytes: byte[]): int
        public static readSignedLShort(bytes: byte[]): short
        public static writeLShort(s: int): byte[]
        public static readInt(bytes: byte[]): int
        public static writeInt(i: int): byte[]
        public static readLInt(bytes: byte[]): int
        public static writeLInt(i: int): byte[]
        public static readFloat(bytes: byte[]): float
        public static readFloat(bytes: byte[], accuracy: int): float
        public static writeFloat(f: float): byte[]
        public static readLFloat(bytes: byte[]): float
        public static readLFloat(bytes: byte[], accuracy: int): float
        public static writeLFloat(f: float): byte[]
        public static readDouble(bytes: byte[]): double
        public static writeDouble(d: double): byte[]
        public static readLDouble(bytes: byte[]): double
        public static writeLDouble(d: double): byte[]
        public static readLong(bytes: byte[]): long
        public static writeLong(l: long): byte[]
        public static readLLong(bytes: byte[]): long
        public static writeLLong(l: long): byte[]
        public static writeVarInt(v: int): byte[]
        public static writeUnsignedVarInt(v: long): byte[]
        public static reserveBytes(bytes: byte[]): byte[]
        public static bytesToHexString(src: byte[]): string
        public static bytesToHexString(src: byte[], blank: boolean): string
        public static hexStringToBytes(hexString: string): byte[]
        public static subBytes(bytes: byte[], start: int, length: int): byte[]
        public static subBytes(bytes: byte[], start: int): byte[]
        public static splitBytes(bytes: byte[], chunkSize: int): byte[][]
        public static appendBytes(bytes: byte[][]): byte[]
        public static appendBytes(byte1: byte, bytes2: byte[][]): byte[]
        public static appendBytes(bytes1: byte[], bytes2: byte[][]): byte[]

    }
}

declare module "cn.nukkit.utils.Binary" {
    declare const Binary = cn.nukkit.utils.Binary;
}

declare namespace cn.nukkit.utils {
    declare interface ZlibProvider {
        public deflate(var0: byte[][], var1: int): byte[]
        public deflate(var0: byte[], var1: int): byte[]
        public inflate(var0: byte[], var1: int): byte[]

    }
}

declare module "cn.nukkit.utils.ZlibProvider" {
    declare type ZlibProvider = cn.nukkit.utils.ZlibProvider;
}

declare namespace cn.nukkit.utils {
    declare class LogLevel extends java.lang.Enum implements java.lang.Comparable {
        public static values(): cn.nukkit.utils.LogLevel[]
        public static valueOf(name: string): cn.nukkit.utils.LogLevel
        constructor(var0: java.util.function.BiConsumer<cn.nukkit.utils.MainLogger, string>, var1: org.apache.logging.log4j.util.TriConsumer<cn.nukkit.utils.MainLogger, string, java.lang.Throwable>): void
        public log(logger: cn.nukkit.utils.MainLogger, message: string): void
        public log(logger: cn.nukkit.utils.MainLogger, message: string, throwable: java.lang.Throwable): void
        public getLevel(): int
        static lambda$static$1(mainLogger: cn.nukkit.utils.MainLogger, s: string, throwable: java.lang.Throwable): void
        static lambda$static$0(logger: cn.nukkit.utils.MainLogger, message: string): void
        static $values(): cn.nukkit.utils.LogLevel[]
        public static NONE: cn.nukkit.utils.LogLevel
        public static EMERGENCY: cn.nukkit.utils.LogLevel
        public static ALERT: cn.nukkit.utils.LogLevel
        public static CRITICAL: cn.nukkit.utils.LogLevel
        public static ERROR: cn.nukkit.utils.LogLevel
        public static WARNING: cn.nukkit.utils.LogLevel
        public static NOTICE: cn.nukkit.utils.LogLevel
        public static INFO: cn.nukkit.utils.LogLevel
        public static DEBUG: cn.nukkit.utils.LogLevel
        public static DEFAULT_LEVEL: cn.nukkit.utils.LogLevel
        logTo: java.util.function.BiConsumer<cn.nukkit.utils.MainLogger, string>
        logThrowableTo: org.apache.logging.log4j.util.TriConsumer<cn.nukkit.utils.MainLogger, string, java.lang.Throwable>
        static $VALUES: cn.nukkit.utils.LogLevel[]

    }
}

declare module "cn.nukkit.utils.LogLevel" {
    declare const LogLevel = cn.nukkit.utils.LogLevel;
}

declare namespace cn.nukkit.utils {
    declare class Rail$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$math$BlockFace: int[]

    }
}

declare module "cn.nukkit.utils.Rail$1" {
    declare const Rail$1 = cn.nukkit.utils.Rail$1;
}

declare namespace cn.nukkit.utils.functional {
    declare interface BlockPositionConsumer {
        public accept(var0: int, var1: int, var2: int): void
        public static validate(fromX: int, fromY: int, fromZ: int, toX: int, toY: int, toZ: int, xInc: int, yInc: int, zInc: int): void
        public static xzy(fromX: int, fromY: int, fromZ: int, toX: int, toY: int, toZ: int, xInc: int, yInc: int, zInc: int, iterator: cn.nukkit.utils.functional.BlockPositionConsumer): void
        public static xzy(fromX: int, fromY: int, fromZ: int, toX: int, toY: int, toZ: int, iterator: cn.nukkit.utils.functional.BlockPositionConsumer): void
        public static xzy(toX: int, toY: int, toZ: int, iterator: cn.nukkit.utils.functional.BlockPositionConsumer): void
        static lambda$xzy$2(zStream: java.util.stream.IntStream, yStream: java.util.stream.IntStream, iterator: cn.nukkit.utils.functional.BlockPositionConsumer, x: int): void
        static lambda$xzy$1(yStream: java.util.stream.IntStream, iterator: cn.nukkit.utils.functional.BlockPositionConsumer, x: int, z: int): void
        static lambda$xzy$0(iterator: cn.nukkit.utils.functional.BlockPositionConsumer, x: int, z: int, y: int): void

    }
}

declare module "cn.nukkit.utils.functional.BlockPositionConsumer" {
    declare type BlockPositionConsumer = cn.nukkit.utils.functional.BlockPositionConsumer;
}

declare namespace cn.nukkit.utils.functional {
    declare interface ToLongTriFunctionOneLong {
        public apply(var0: float, var1: short, var2: long): long
        public andThen(after: java.util.function.LongUnaryOperator): cn.nukkit.utils.functional.ToLongTriFunctionOneLong<float, short>
        lambda$andThen$0(after: java.util.function.LongUnaryOperator, f: java.lang.Object, s: java.lang.Object, t: long): long

    }
}

declare module "cn.nukkit.utils.functional.ToLongTriFunctionOneLong" {
    declare type ToLongTriFunctionOneLong = cn.nukkit.utils.functional.ToLongTriFunctionOneLong;
}

declare namespace cn.nukkit.utils.functional {
    declare interface BlockPositionDataConsumer {
        public accept(var0: int, var1: int, var2: int, var3: double): void

    }
}

declare module "cn.nukkit.utils.functional.BlockPositionDataConsumer" {
    declare type BlockPositionDataConsumer = cn.nukkit.utils.functional.BlockPositionDataConsumer;
}

declare namespace cn.nukkit.utils.functional {
    declare interface ToLongTriFunctionOneIntOneLong {
        public apply(var0: float, var1: int, var2: long): long
        public andThen(after: java.util.function.LongUnaryOperator): cn.nukkit.utils.functional.ToLongTriFunctionOneIntOneLong<float>
        lambda$andThen$0(after: java.util.function.LongUnaryOperator, f: java.lang.Object, s: int, t: long): long

    }
}

declare module "cn.nukkit.utils.functional.ToLongTriFunctionOneIntOneLong" {
    declare type ToLongTriFunctionOneIntOneLong = cn.nukkit.utils.functional.ToLongTriFunctionOneIntOneLong;
}

declare namespace cn.nukkit.utils {
    declare class ThreadCache$4 extends cn.nukkit.utils.IterableThreadLocal {
        constructor(): void
        public init(): byte[]
        public init(): java.lang.Object

    }
}

declare module "cn.nukkit.utils.ThreadCache$4" {
    declare const ThreadCache$4 = cn.nukkit.utils.ThreadCache$4;
}

declare namespace cn.nukkit.utils {
    declare class Rail$Orientation extends java.lang.Enum {
        public static values(): cn.nukkit.utils.Rail$Orientation[]
        public static valueOf(name: string): cn.nukkit.utils.Rail$Orientation
        constructor(var0: int, var1: cn.nukkit.utils.Rail$Orientation$State, meta: cn.nukkit.math.BlockFace, state: cn.nukkit.math.BlockFace, from: cn.nukkit.math.BlockFace): void
        public static byMetadata(meta: int): cn.nukkit.utils.Rail$Orientation
        public static straight(face: cn.nukkit.math.BlockFace): cn.nukkit.utils.Rail$Orientation
        public static ascending(face: cn.nukkit.math.BlockFace): cn.nukkit.utils.Rail$Orientation
        public static curved(f1: cn.nukkit.math.BlockFace, f2: cn.nukkit.math.BlockFace): cn.nukkit.utils.Rail$Orientation
        public static straightOrCurved(f1: cn.nukkit.math.BlockFace, f2: cn.nukkit.math.BlockFace): cn.nukkit.utils.Rail$Orientation
        public metadata(): int
        public hasConnectingDirections(faces: cn.nukkit.math.BlockFace[]): boolean
        public hasConnectingDirections(faces: java.util.Collection<cn.nukkit.math.BlockFace>): boolean
        public connectingDirections(): java.util.List<cn.nukkit.math.BlockFace>
        public ascendingDirection(): java.util.Optional<cn.nukkit.math.BlockFace>
        public isStraight(): boolean
        public isAscending(): boolean
        public isCurved(): boolean
        static $values(): cn.nukkit.utils.Rail$Orientation[]
        public static STRAIGHT_NORTH_SOUTH: cn.nukkit.utils.Rail$Orientation
        public static STRAIGHT_EAST_WEST: cn.nukkit.utils.Rail$Orientation
        public static ASCENDING_EAST: cn.nukkit.utils.Rail$Orientation
        public static ASCENDING_WEST: cn.nukkit.utils.Rail$Orientation
        public static ASCENDING_NORTH: cn.nukkit.utils.Rail$Orientation
        public static ASCENDING_SOUTH: cn.nukkit.utils.Rail$Orientation
        public static CURVED_SOUTH_EAST: cn.nukkit.utils.Rail$Orientation
        public static CURVED_SOUTH_WEST: cn.nukkit.utils.Rail$Orientation
        public static CURVED_NORTH_WEST: cn.nukkit.utils.Rail$Orientation
        public static CURVED_NORTH_EAST: cn.nukkit.utils.Rail$Orientation
        static META_LOOKUP: cn.nukkit.utils.Rail$Orientation[]
        meta: int
        state: cn.nukkit.utils.Rail$Orientation$State
        connectingDirections: java.util.List<cn.nukkit.math.BlockFace>
        ascendingDirection: cn.nukkit.math.BlockFace
        static $VALUES: cn.nukkit.utils.Rail$Orientation[]

    }
}

declare module "cn.nukkit.utils.Rail$Orientation" {
    declare const Rail$Orientation = cn.nukkit.utils.Rail$Orientation;
}

declare namespace cn.nukkit.utils {
    declare class ServerKiller extends java.lang.Thread {
        public constructor(time: long): void
        public constructor(time: long, var1: java.util.concurrent.TimeUnit): void
        public run(): void
        public sleepTime: long

    }
}

declare module "cn.nukkit.utils.ServerKiller" {
    declare const ServerKiller = cn.nukkit.utils.ServerKiller;
}

declare namespace cn.nukkit.utils {
    declare class ThreadedLogger extends java.lang.Thread implements cn.nukkit.utils.Logger {
        public constructor(): void

    }
}

declare module "cn.nukkit.utils.ThreadedLogger" {
    declare const ThreadedLogger = cn.nukkit.utils.ThreadedLogger;
}

declare namespace cn.nukkit.utils {
    declare class ThreadCache$5 extends cn.nukkit.utils.IterableThreadLocal {
        constructor(): void
        public init(): boolean[]
        public init(): java.lang.Object

    }
}

declare module "cn.nukkit.utils.ThreadCache$5" {
    declare const ThreadCache$5 = cn.nukkit.utils.ThreadCache$5;
}

declare namespace cn.nukkit.utils {
    declare class ThreadCache$9 extends cn.nukkit.utils.IterableThreadLocal {
        constructor(): void
        public init(): cn.nukkit.nbt.stream.FastByteArrayOutputStream
        public init(): java.lang.Object

    }
}

declare module "cn.nukkit.utils.ThreadCache$9" {
    declare const ThreadCache$9 = cn.nukkit.utils.ThreadCache$9;
}

declare namespace cn.nukkit.utils {
    declare class ThreadCache$3 extends cn.nukkit.utils.IterableThreadLocal {
        constructor(): void
        public init(): byte[]
        public init(): java.lang.Object

    }
}

declare module "cn.nukkit.utils.ThreadCache$3" {
    declare const ThreadCache$3 = cn.nukkit.utils.ThreadCache$3;
}

declare namespace cn.nukkit.utils {
    declare interface LoginChainData {
        public getUsername(): string
        public getClientUUID(): java.util.UUID
        public getIdentityPublicKey(): string
        public getClientId(): long
        public getServerAddress(): string
        public getDeviceModel(): string
        public getDeviceOS(): int
        public getDeviceId(): string
        public getGameVersion(): string
        public getGuiScale(): int
        public getLanguageCode(): string
        public getXUID(): string
        public isXboxAuthed(): boolean
        public getCurrentInputMode(): int
        public getDefaultInputMode(): int
        public getCapeData(): string
        public getUIProfile(): int
        public getRawData(): com.google.gson.JsonObject

    }
}

declare module "cn.nukkit.utils.LoginChainData" {
    declare type LoginChainData = cn.nukkit.utils.LoginChainData;
}

declare namespace cn.nukkit.utils {
    declare class HastebinUtility extends java.lang.Object {
        public constructor(): void
        public static upload(string: string): string
        public static upload(file: java.io.File): string
        public static BIN_URL: string
        public static USER_AGENT: string
        public static PATTERN: java.util.regex.Pattern

    }
}

declare module "cn.nukkit.utils.HastebinUtility" {
    declare const HastebinUtility = cn.nukkit.utils.HastebinUtility;
}

declare namespace cn.nukkit.utils {
    declare class BlockIterator extends java.lang.Object implements java.util.Iterator {
        public constructor(level: cn.nukkit.level.Level, start: cn.nukkit.math.Vector3, direction: cn.nukkit.math.Vector3): void
        public constructor(level: cn.nukkit.level.Level, start: cn.nukkit.math.Vector3, direction: cn.nukkit.math.Vector3, yOffset: double): void
        public constructor(level: cn.nukkit.level.Level, start: cn.nukkit.math.Vector3, direction: cn.nukkit.math.Vector3, yOffset: double, var4: int): void
        blockEquals(a: cn.nukkit.block.Block, b: cn.nukkit.block.Block): boolean
        getXFace(direction: cn.nukkit.math.Vector3): cn.nukkit.math.BlockFace
        getYFace(direction: cn.nukkit.math.Vector3): cn.nukkit.math.BlockFace
        getZFace(direction: cn.nukkit.math.Vector3): cn.nukkit.math.BlockFace
        getXLength(direction: cn.nukkit.math.Vector3): double
        getYLength(direction: cn.nukkit.math.Vector3): double
        getZLength(direction: cn.nukkit.math.Vector3): double
        getPosition(direction: double, var1: double, position: double): double
        getXPosition(direction: cn.nukkit.math.Vector3, position: cn.nukkit.math.Vector3, block: cn.nukkit.block.Block): double
        getYPosition(direction: cn.nukkit.math.Vector3, position: cn.nukkit.math.Vector3, block: cn.nukkit.block.Block): double
        getZPosition(direction: cn.nukkit.math.Vector3, position: cn.nukkit.math.Vector3, block: cn.nukkit.block.Block): double
        public next(): cn.nukkit.block.Block
        public hasNext(): boolean
        scan(): void
        public next(): java.lang.Object
        level: cn.nukkit.level.Level
        maxDistance: int
        static gridSize: int
        end: boolean
        blockQueue: cn.nukkit.block.Block[]
        currentBlock: int
        currentBlockObject: cn.nukkit.block.Block
        currentDistance: int
        maxDistanceInt: int
        secondError: int
        thirdError: int
        secondStep: int
        thirdStep: int
        mainFace: cn.nukkit.math.BlockFace
        secondFace: cn.nukkit.math.BlockFace
        thirdFace: cn.nukkit.math.BlockFace

    }
}

declare module "cn.nukkit.utils.BlockIterator" {
    declare const BlockIterator = cn.nukkit.utils.BlockIterator;
}

declare namespace cn.nukkit.utils {
    declare class LevelException extends cn.nukkit.utils.ServerException {
        public constructor(message: string): void
        public constructor(message: string, cause: java.lang.Throwable): void

    }
}

declare module "cn.nukkit.utils.LevelException" {
    declare const LevelException = cn.nukkit.utils.LevelException;
}

declare namespace cn.nukkit.utils {
    declare class PersonaPieceTint extends java.lang.Object {
        public constructor(pieceType: string, colors: java.util.List<string>): void
        public toString(): string
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        public pieceType: string
        public colors: com.google.common.collect.ImmutableList<string>

    }
}

declare module "cn.nukkit.utils.PersonaPieceTint" {
    declare const PersonaPieceTint = cn.nukkit.utils.PersonaPieceTint;
}

declare namespace cn.nukkit.utils {
    declare class DummyBossBar$Builder extends java.lang.Object {
        public constructor(player: cn.nukkit.Player): void
        public text(text: string): cn.nukkit.utils.DummyBossBar$Builder
        public length(length: float): cn.nukkit.utils.DummyBossBar$Builder
        public color(color: cn.nukkit.utils.BossBarColor): cn.nukkit.utils.DummyBossBar$Builder
        public build(): cn.nukkit.utils.DummyBossBar
        player: cn.nukkit.Player
        bossBarId: long
        text: string
        length: float
        color: cn.nukkit.utils.BossBarColor

    }
}

declare module "cn.nukkit.utils.DummyBossBar$Builder" {
    declare const DummyBossBar$Builder = cn.nukkit.utils.DummyBossBar$Builder;
}

declare namespace cn.nukkit.utils {
    declare class Config$1 extends com.google.gson.reflect.TypeToken {
        constructor(this$0: cn.nukkit.utils.Config): void
        this$0: cn.nukkit.utils.Config

    }
}

declare module "cn.nukkit.utils.Config$1" {
    declare const Config$1 = cn.nukkit.utils.Config$1;
}

declare namespace cn.nukkit.utils {
    declare class ClientChainData extends java.lang.Object implements cn.nukkit.utils.LoginChainData {
        public static of(buffer: byte[]): cn.nukkit.utils.ClientChainData
        public static read(pk: cn.nukkit.network.protocol.LoginPacket): cn.nukkit.utils.ClientChainData
        public getUsername(): string
        public getClientUUID(): java.util.UUID
        public getIdentityPublicKey(): string
        public getClientId(): long
        public getServerAddress(): string
        public getDeviceModel(): string
        public getDeviceOS(): int
        public getDeviceId(): string
        public getGameVersion(): string
        public getGuiScale(): int
        public getLanguageCode(): string
        public getXUID(): string
        public getCurrentInputMode(): int
        public getDefaultInputMode(): int
        public getCapeData(): string
        public getUIProfile(): int
        public getRawData(): com.google.gson.JsonObject
        public equals(obj: java.lang.Object): boolean
        public hashCode(): int
        static generateKey(base64: string): java.security.interfaces.ECPublicKey
        constructor(buffer: byte[]): void
        public isXboxAuthed(): boolean
        decodeSkinData(): void
        decodeToken(token: string): com.google.gson.JsonObject
        decodeChainData(): void
        verifyChain(chains: java.util.List<string>): boolean
        verify(key: java.security.interfaces.ECPublicKey, object: com.nimbusds.jose.JWSObject): boolean
        static MOJANG_PUBLIC_KEY_BASE64: string
        static MOJANG_PUBLIC_KEY: java.security.PublicKey
        xboxAuthed: boolean
        public static UI_PROFILE_CLASSIC: int
        public static UI_PROFILE_POCKET: int
        username: string
        clientUUID: java.util.UUID
        xuid: string
        identityPublicKey: string
        clientId: long
        serverAddress: string
        deviceModel: string
        deviceOS: int
        deviceId: string
        gameVersion: string
        guiScale: int
        languageCode: string
        currentInputMode: int
        defaultInputMode: int
        UIProfile: int
        capeData: string
        rawData: com.google.gson.JsonObject
        bs: cn.nukkit.utils.BinaryStream

    }
}

declare module "cn.nukkit.utils.ClientChainData" {
    declare const ClientChainData = cn.nukkit.utils.ClientChainData;
}

declare namespace cn.nukkit.utils {
    declare class ThreadCache$8 extends cn.nukkit.utils.IterableThreadLocal {
        constructor(): void
        public init(): int[]
        public init(): java.lang.Object

    }
}

declare module "cn.nukkit.utils.ThreadCache$8" {
    declare const ThreadCache$8 = cn.nukkit.utils.ThreadCache$8;
}

declare namespace cn.nukkit.utils {
    declare class IterableThreadLocal extends java.lang.ThreadLocal implements java.lang.Iterable {
        public constructor(): void
        initialValue(): any
        public iterator(): java.util.Iterator<any>
        public init(): any
        public clean(): void
        public static clean(instance: java.lang.ThreadLocal): void
        public static cleanAll(): void
        public getAll(): java.util.Collection<any>
        finalize(): void
        flag: java.lang.ThreadLocal<any>
        allValues: java.util.concurrent.ConcurrentLinkedDeque<any>

    }
}

declare module "cn.nukkit.utils.IterableThreadLocal" {
    declare const IterableThreadLocal = cn.nukkit.utils.IterableThreadLocal;
}

declare namespace cn.nukkit.utils {
    declare class MainLogger extends cn.nukkit.utils.ThreadedLogger {
        public static getLogger(): cn.nukkit.utils.MainLogger
        public emergency(message: string): void
        public alert(message: string): void
        public critical(message: string): void
        public error(message: string): void
        public warning(message: string): void
        public notice(message: string): void
        public info(message: string): void
        public debug(message: string): void
        public setLogDebug(logDebug: boolean): void
        public logException(t: java.lang.Throwable): void
        public log(level: cn.nukkit.utils.LogLevel, message: string): void
        public shutdown(): void
        public emergency(message: string, t: java.lang.Throwable): void
        public alert(message: string, t: java.lang.Throwable): void
        public critical(message: string, t: java.lang.Throwable): void
        public error(message: string, t: java.lang.Throwable): void
        public warning(message: string, t: java.lang.Throwable): void
        public notice(message: string, t: java.lang.Throwable): void
        public info(message: string, t: java.lang.Throwable): void
        public debug(message: string, t: java.lang.Throwable): void
        public log(level: cn.nukkit.utils.LogLevel, message: string, t: java.lang.Throwable): void
        constructor(): void
        static log: org.apache.logging.log4j.Logger
        static logger: cn.nukkit.utils.MainLogger

    }
}

declare module "cn.nukkit.utils.MainLogger" {
    declare const MainLogger = cn.nukkit.utils.MainLogger;
}

declare namespace cn.nukkit.utils {
    declare class DefaultPlayerDataSerializer extends java.lang.Object implements cn.nukkit.utils.PlayerDataSerializer {
        public constructor(server: cn.nukkit.Server): void
        public constructor(dataPath: string): void
        public read(name: string, uuid: java.util.UUID): java.util.Optional<java.io.InputStream>
        public write(name: string, uuid: java.util.UUID): java.io.OutputStream
        dataPath: string

    }
}

declare module "cn.nukkit.utils.DefaultPlayerDataSerializer" {
    declare const DefaultPlayerDataSerializer = cn.nukkit.utils.DefaultPlayerDataSerializer;
}

declare namespace cn.nukkit.utils {
    declare class DyeColor extends java.lang.Enum {
        public static values(): cn.nukkit.utils.DyeColor[]
        public static valueOf(name: string): cn.nukkit.utils.DyeColor
        constructor(var0: int, var1: int, dyeColorMeta: string, woolColorMeta: cn.nukkit.utils.BlockColor, colorName: cn.nukkit.utils.BlockColor): void
        constructor(var0: int, var1: int, dyeColorMeta: int, woolColorMeta: string, itemDyeMeta: cn.nukkit.utils.BlockColor): void
        constructor(var0: int, var1: int, dyeColorMeta: int, woolColorMeta: string, itemDyeMeta: cn.nukkit.utils.BlockColor, colorName: cn.nukkit.utils.BlockColor, blockColor: cn.nukkit.utils.BlockColor): void
        constructor(var0: int, var1: int, dyeColorMeta: int, woolColorMeta: string, itemDyeMeta: string, colorName: cn.nukkit.utils.BlockColor): void
        constructor(var0: int, var1: int, dyeColorMeta: int, woolColorMeta: string, itemDyeMeta: string, colorName: cn.nukkit.utils.BlockColor, dyeName: cn.nukkit.utils.BlockColor, blockColor: cn.nukkit.utils.BlockColor): void
        public getColor(): cn.nukkit.utils.BlockColor
        public getSignColor(): cn.nukkit.utils.BlockColor
        public getDyeData(): int
        public getItemDyeMeta(): int
        public getLeatherColor(): cn.nukkit.utils.BlockColor
        public getWoolData(): int
        public getName(): string
        public getDyeName(): string
        public static getByDyeData(dyeColorMeta: int): cn.nukkit.utils.DyeColor
        public static getByWoolData(woolColorMeta: int): cn.nukkit.utils.DyeColor
        static $values(): cn.nukkit.utils.DyeColor[]
        public static BLACK: cn.nukkit.utils.DyeColor
        public static RED: cn.nukkit.utils.DyeColor
        public static GREEN: cn.nukkit.utils.DyeColor
        public static BROWN: cn.nukkit.utils.DyeColor
        public static BLUE: cn.nukkit.utils.DyeColor
        public static PURPLE: cn.nukkit.utils.DyeColor
        public static CYAN: cn.nukkit.utils.DyeColor
        public static LIGHT_GRAY: cn.nukkit.utils.DyeColor
        public static GRAY: cn.nukkit.utils.DyeColor
        public static PINK: cn.nukkit.utils.DyeColor
        public static LIME: cn.nukkit.utils.DyeColor
        public static YELLOW: cn.nukkit.utils.DyeColor
        public static LIGHT_BLUE: cn.nukkit.utils.DyeColor
        public static MAGENTA: cn.nukkit.utils.DyeColor
        public static ORANGE: cn.nukkit.utils.DyeColor
        public static WHITE: cn.nukkit.utils.DyeColor
        public static BONE_MEAL: cn.nukkit.utils.DyeColor
        dyeColorMeta: int
        itemDyeMeta: int
        woolColorMeta: int
        colorName: string
        dyeName: string
        blockColor: cn.nukkit.utils.BlockColor
        leatherColor: cn.nukkit.utils.BlockColor
        signColor: cn.nukkit.utils.BlockColor
        static BY_WOOL_DATA: cn.nukkit.utils.DyeColor[]
        static BY_DYE_DATA: cn.nukkit.utils.DyeColor[]
        static $VALUES: cn.nukkit.utils.DyeColor[]

    }
}

declare module "cn.nukkit.utils.DyeColor" {
    declare const DyeColor = cn.nukkit.utils.DyeColor;
}

declare namespace cn.nukkit.utils {
    declare class BannerPattern$Type extends java.lang.Enum {
        public static values(): cn.nukkit.utils.BannerPattern$Type[]
        public static valueOf(name: string): cn.nukkit.utils.BannerPattern$Type
        constructor(var0: string): void
        public getName(): string
        public static getByName(name: string): cn.nukkit.utils.BannerPattern$Type
        static $values(): cn.nukkit.utils.BannerPattern$Type[]
        public static PATTERN_BOTTOM_STRIPE: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_TOP_STRIPE: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_LEFT_STRIPE: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_RIGHT_STRIPE: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_CENTER_STRIPE: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_MIDDLE_STRIPE: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_DOWN_RIGHT_STRIPE: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_DOWN_LEFT_STRIPE: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_SMALL_STRIPES: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_DIAGONAL_CROSS: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_SQUARE_CROSS: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_LEFT_OF_DIAGONAL: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_RIGHT_OF_UPSIDE_DOWN_DIAGONAL: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_LEFT_OF_UPSIDE_DOWN_DIAGONAL: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_RIGHT_OF_DIAGONAL: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_VERTICAL_HALF_LEFT: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_VERTICAL_HALF_RIGHT: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_HORIZONTAL_HALF_TOP: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_HORIZONTAL_HALF_BOTTOM: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_BOTTOM_LEFT_CORNER: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_BOTTOM_RIGHT_CORNER: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_TOP_LEFT_CORNER: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_TOP_RIGHT_CORNER: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_BOTTOM_TRIANGLE: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_TOP_TRIANGLE: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_BOTTOM_TRIANGLE_SAWTOOTH: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_TOP_TRIANGLE_SAWTOOTH: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_MIDDLE_CIRCLE: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_MIDDLE_RHOMBUS: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_BORDER: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_CURLY_BORDER: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_BRICK: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_GRADIENT: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_GRADIENT_UPSIDE_DOWN: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_CREEPER: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_SKULL: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_FLOWER: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_MOJANG: cn.nukkit.utils.BannerPattern$Type
        public static PATTERN_SNOUT: cn.nukkit.utils.BannerPattern$Type
        static BY_NAME: java.util.Map<string, cn.nukkit.utils.BannerPattern$Type>
        name: string
        static $VALUES: cn.nukkit.utils.BannerPattern$Type[]

    }
}

declare module "cn.nukkit.utils.BannerPattern$Type" {
    declare const BannerPattern$Type = cn.nukkit.utils.BannerPattern$Type;
}

declare namespace cn.nukkit.utils {
    declare class BlockColor extends java.lang.Object {
        public constructor(red: int, green: int, blue: int, alpha: int): void
        public constructor(red: int, green: int, blue: int): void
        public constructor(rgb: int): void
        public constructor(rgb: int, hasAlpha: boolean): void
        public equals(obj: java.lang.Object): boolean
        public toString(): string
        public getRed(): int
        public getGreen(): int
        public getBlue(): int
        public getAlpha(): int
        public getRGB(): int
        public getARGB(): int
        public static getDyeColor(dyeColorMeta: int): cn.nukkit.utils.BlockColor
        public static TRANSPARENT_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static VOID_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static AIR_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static GRASS_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static SAND_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static CLOTH_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static TNT_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static ICE_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static IRON_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static FOLIAGE_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static SNOW_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static CLAY_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static DIRT_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static STONE_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static WATER_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static LAVA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static WOOD_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static QUARTZ_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static ADOBE_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static WHITE_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static ORANGE_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static MAGENTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static LIGHT_BLUE_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static YELLOW_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static LIME_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static PINK_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static GRAY_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static LIGHT_GRAY_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static CYAN_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static PURPLE_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static BLUE_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static BROWN_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static GREEN_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static RED_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static BLACK_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static GOLD_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static DIAMOND_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static LAPIS_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static EMERALD_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static OBSIDIAN_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static SPRUCE_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static NETHERRACK_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static REDSTONE_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static WHITE_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static ORANGE_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static MAGENTA_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static LIGHT_BLUE_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static YELLOW_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static LIME_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static PINK_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static GRAY_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static LIGHT_GRAY_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static CYAN_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static PURPLE_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static BLUE_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static BROWN_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static GREEN_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static RED_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static BLACK_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static CRIMSON_NYLIUM_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static CRIMSON_STEM_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static CRIMSON_HYPHAE_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static WARPED_NYLIUM_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static WARPED_STEM_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static WARPED_HYPHAE_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static WARPED_WART_BLOCK_COLOR: cn.nukkit.utils.BlockColor
        public static DEEPSLATE_GRAY: cn.nukkit.utils.BlockColor
        public static LICHEN_GREEN: cn.nukkit.utils.BlockColor
        public static BROWNISH_RED: cn.nukkit.utils.BlockColor
        red: int
        green: int
        blue: int
        alpha: int

    }
}

declare module "cn.nukkit.utils.BlockColor" {
    declare const BlockColor = cn.nukkit.utils.BlockColor;
}

declare namespace cn.nukkit.utils {
    declare class InvalidBlockDamageException extends cn.nukkit.blockproperty.exception.InvalidBlockPropertyMetaException {
        public constructor(blockId: int, damage: int, before: int): void
        public getBlockId(): int
        public getDamage(): int
        public getBefore(): int
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        blockId: int
        damage: int
        before: int

    }
}

declare module "cn.nukkit.utils.InvalidBlockDamageException" {
    declare const InvalidBlockDamageException = cn.nukkit.utils.InvalidBlockDamageException;
}

declare namespace cn.nukkit.utils {
    declare class BossBarColor extends java.lang.Enum {
        public static values(): cn.nukkit.utils.BossBarColor[]
        public static valueOf(name: string): cn.nukkit.utils.BossBarColor
        constructor(): void
        static $values(): cn.nukkit.utils.BossBarColor[]
        public static PINK: cn.nukkit.utils.BossBarColor
        public static BLUE: cn.nukkit.utils.BossBarColor
        public static RED: cn.nukkit.utils.BossBarColor
        public static GREEN: cn.nukkit.utils.BossBarColor
        public static YELLOW: cn.nukkit.utils.BossBarColor
        public static PURPLE: cn.nukkit.utils.BossBarColor
        public static WHITE: cn.nukkit.utils.BossBarColor
        static $VALUES: cn.nukkit.utils.BossBarColor[]

    }
}

declare module "cn.nukkit.utils.BossBarColor" {
    declare const BossBarColor = cn.nukkit.utils.BossBarColor;
}

declare namespace cn.nukkit.utils {
    declare class ThreadStore extends java.lang.Object {
        public constructor(): void
        public static store: java.util.Map<string, java.lang.Object>

    }
}

declare module "cn.nukkit.utils.ThreadStore" {
    declare const ThreadStore = cn.nukkit.utils.ThreadStore;
}

declare namespace cn.nukkit.utils {
    declare class SeekableInMemoryByteChannel extends java.lang.Object implements java.nio.channels.SeekableByteChannel {
        public constructor(data: byte[]): void
        public constructor(): void
        public constructor(size: int): void
        public position(): long
        public position(newPosition: long): java.nio.channels.SeekableByteChannel
        public size(): long
        public truncate(newSize: long): java.nio.channels.SeekableByteChannel
        public read(buf: java.nio.ByteBuffer): int
        public close(): void
        public isOpen(): boolean
        public write(b: java.nio.ByteBuffer): int
        public array(): byte[]
        resize(newLength: int): void
        ensureOpen(): void
        static NAIVE_RESIZE_LIMIT: int
        data: byte[]
        closed: java.util.concurrent.atomic.AtomicBoolean
        position: int
        size: int

    }
}

declare module "cn.nukkit.utils.SeekableInMemoryByteChannel" {
    declare const SeekableInMemoryByteChannel = cn.nukkit.utils.SeekableInMemoryByteChannel;
}

declare namespace cn.nukkit.utils {
    declare class ThreadCache$10 extends cn.nukkit.utils.IterableThreadLocal {
        constructor(): void
        public init(): cn.nukkit.utils.BinaryStream
        public init(): java.lang.Object

    }
}

declare module "cn.nukkit.utils.ThreadCache$10" {
    declare const ThreadCache$10 = cn.nukkit.utils.ThreadCache$10;
}

declare namespace cn.nukkit.utils {
    declare class ThreadCache$7 extends cn.nukkit.utils.IterableThreadLocal {
        constructor(): void
        public init(): char[]
        public init(): java.lang.Object

    }
}

declare module "cn.nukkit.utils.ThreadCache$7" {
    declare const ThreadCache$7 = cn.nukkit.utils.ThreadCache$7;
}

declare namespace cn.nukkit.utils {
    declare class ClientChainData$1 extends com.google.gson.reflect.TypeToken {
        constructor(this$0: cn.nukkit.utils.ClientChainData): void
        this$0: cn.nukkit.utils.ClientChainData

    }
}

declare module "cn.nukkit.utils.ClientChainData$1" {
    declare const ClientChainData$1 = cn.nukkit.utils.ClientChainData$1;
}

declare namespace cn.nukkit.utils {
    declare class ServerException extends java.lang.RuntimeException {
        public constructor(message: string): void
        public constructor(message: string, cause: java.lang.Throwable): void

    }
}

declare module "cn.nukkit.utils.ServerException" {
    declare const ServerException = cn.nukkit.utils.ServerException;
}

declare namespace cn.nukkit.utils.bugreport {
    declare class ExceptionHandler extends java.lang.Object implements java.lang.Thread$UncaughtExceptionHandler {
        public constructor(): void
        public static registerExceptionHandler(): void
        public uncaughtException(thread: java.lang.Thread, throwable: java.lang.Throwable): void
        public handle(thread: java.lang.Thread, throwable: java.lang.Throwable): void

    }
}

declare module "cn.nukkit.utils.bugreport.ExceptionHandler" {
    declare const ExceptionHandler = cn.nukkit.utils.bugreport.ExceptionHandler;
}

declare namespace cn.nukkit.utils.bugreport {
    declare class BugReportGenerator extends java.lang.Thread {
        constructor(throwable: java.lang.Throwable): void
        public run(): void
        generate(): string
        public static getCount(bytes: long, var1: boolean): string
        static log: org.apache.logging.log4j.Logger
        throwable: java.lang.Throwable

    }
}

declare module "cn.nukkit.utils.bugreport.BugReportGenerator" {
    declare const BugReportGenerator = cn.nukkit.utils.bugreport.BugReportGenerator;
}

declare namespace cn.nukkit.utils {
    declare class VarInt extends java.lang.Object {
        constructor(): void
        public static encodeZigZag32(v: int): long
        public static decodeZigZag32(v: long): int
        public static encodeZigZag64(v: long): long
        public static decodeZigZag64(v: long): long
        static read(stream: cn.nukkit.utils.BinaryStream, maxSize: int): long
        static read(stream: java.io.InputStream, maxSize: int): long
        public static readVarInt(stream: cn.nukkit.utils.BinaryStream): int
        public static readVarInt(stream: java.io.InputStream): int
        public static readUnsignedVarInt(stream: cn.nukkit.utils.BinaryStream): long
        public static readUnsignedVarInt(stream: java.io.InputStream): long
        public static readVarLong(stream: cn.nukkit.utils.BinaryStream): long
        public static readVarLong(stream: java.io.InputStream): long
        public static readUnsignedVarLong(stream: cn.nukkit.utils.BinaryStream): long
        public static readUnsignedVarLong(stream: java.io.InputStream): long
        static write(stream: cn.nukkit.utils.BinaryStream, value: long): void
        static write(stream: java.io.OutputStream, value: long): void
        public static writeVarInt(stream: cn.nukkit.utils.BinaryStream, value: int): void
        public static writeVarInt(stream: java.io.OutputStream, value: int): void
        public static writeUnsignedVarInt(stream: cn.nukkit.utils.BinaryStream, value: long): void
        public static writeUnsignedVarInt(stream: java.io.OutputStream, value: long): void
        public static writeVarLong(stream: cn.nukkit.utils.BinaryStream, value: long): void
        public static writeVarLong(stream: java.io.OutputStream, value: long): void
        public static writeUnsignedVarLong(stream: cn.nukkit.utils.BinaryStream, value: long): void
        public static writeUnsignedVarLong(stream: java.io.OutputStream, value: long): void

    }
}

declare module "cn.nukkit.utils.VarInt" {
    declare const VarInt = cn.nukkit.utils.VarInt;
}

declare namespace cn.nukkit.blockstate {
    declare class ByteMutableBlockState extends cn.nukkit.blockstate.MutableBlockState {
        public constructor(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties, state: byte): void
        public constructor(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties): void
        public getLegacyDamage(): int
        public getBigDamage(): int
        public getHugeDamage(): java.math.BigInteger
        public getDataStorage(): byte
        public isDefaultState(): boolean
        public setDataStorage(storage: java.lang.Number): void
        public setDataStorageFromInt(storage: int): void
        setDataStorageWithoutValidation(storage: java.lang.Number): void
        public validate(): void
        validate(state: int): void
        public setBooleanValue(propertyName: string, value: boolean): void
        public setPropertyValue(propertyName: string, value: java.io.Serializable): void
        public setIntValue(propertyName: string, value: int): void
        public getPropertyValue(propertyName: string): java.io.Serializable
        public getIntValue(propertyName: string): int
        public getBooleanValue(propertyName: string): boolean
        public getPersistenceValue(propertyName: string): string
        public getCurrentState(): cn.nukkit.blockstate.BlockState
        public getExactIntStorage(): int
        public copy(): cn.nukkit.blockstate.ByteMutableBlockState
        public toString(): string
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        public copy(): cn.nukkit.blockstate.MutableBlockState
        public getDataStorage(): java.lang.Number
        storage: byte

    }
}

declare module "cn.nukkit.blockstate.ByteMutableBlockState" {
    declare const ByteMutableBlockState = cn.nukkit.blockstate.ByteMutableBlockState;
}

declare namespace cn.nukkit.blockstate {
    declare class BlockState extends java.lang.Object implements java.io.Serializable, cn.nukkit.blockstate.IBlockState {
        static growCommonPool(blockId: int, blockData: byte): cn.nukkit.blockstate.BlockState
        static of0xF(blockId: int, blockData: byte): cn.nukkit.blockstate.BlockState
        public static of(blockId: int): cn.nukkit.blockstate.BlockState
        public static of(blockId: int, blockData: byte): cn.nukkit.blockstate.BlockState
        public static of(blockId: int, blockData: int): cn.nukkit.blockstate.BlockState
        public static of(blockId: int, blockData: long): cn.nukkit.blockstate.BlockState
        public static of(blockId: int, blockData: java.math.BigInteger): cn.nukkit.blockstate.BlockState
        public static of(blockId: int, blockData: java.lang.Number): cn.nukkit.blockstate.BlockState
        public static of(persistedStateId: string): cn.nukkit.blockstate.BlockState
        public static of(persistedStateId: string, useDefaultPropertyValues: boolean): cn.nukkit.blockstate.BlockState
        constructor(blockId: int): void
        constructor(blockId: int, blockData: byte): void
        constructor(blockId: int, blockData: int): void
        constructor(blockId: int, blockData: long): void
        constructor(blockId: int, blockData: java.math.BigInteger): void
        public getBlockId(): int
        public withData(data: int): cn.nukkit.blockstate.BlockState
        public withData(data: long): cn.nukkit.blockstate.BlockState
        public withData(data: java.math.BigInteger): cn.nukkit.blockstate.BlockState
        public withData(data: java.lang.Number): cn.nukkit.blockstate.BlockState
        public withBlockId(blockId: int): cn.nukkit.blockstate.BlockState
        public withProperty(property: java.io.Serializable, value: cn.nukkit.blockproperty.BlockProperty<any>): cn.nukkit.blockstate.BlockState
        public withProperty(propertyName: string, value: java.io.Serializable): cn.nukkit.blockstate.BlockState
        public withProperty(propertyName: string, persistenceValue: string): cn.nukkit.blockstate.BlockState
        public onlyWithProperties(properties: byte): cn.nukkit.blockstate.BlockState
        public onlyWithProperties(propertyNames: string[]): cn.nukkit.blockstate.BlockState
        public onlyWithProperty(name: string): cn.nukkit.blockstate.BlockState
        public onlyWithProperty(property: byte): cn.nukkit.blockstate.BlockState
        public onlyWithProperty(name: string, value: java.io.Serializable): cn.nukkit.blockstate.BlockState
        public onlyWithProperty(property: java.io.Serializable, value: cn.nukkit.blockproperty.BlockProperty<any>): cn.nukkit.blockstate.BlockState
        public forItem(): cn.nukkit.blockstate.BlockState
        public asItemBlock(count: int): cn.nukkit.item.ItemBlock
        public getDataStorage(): java.lang.Number
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getLegacyDamage(): int
        public getBigDamage(): int
        public getSignedBigDamage(): int
        public getHugeDamage(): java.math.BigInteger
        public getPropertyValue(propertyName: string): java.io.Serializable
        public getIntValue(propertyName: string): int
        public getBooleanValue(propertyName: string): boolean
        public getPersistenceValue(propertyName: string): string
        public getCurrentState(): cn.nukkit.blockstate.BlockState
        public getBitSize(): int
        public getExactIntStorage(): int
        public isDefaultState(): boolean
        public equals(o: java.lang.Object): boolean
        public hashCode(): int
        static compareDataEquality(a: java.lang.Number, b: java.lang.Number): boolean
        public validate(): void
        public isCachedValidationValid(): boolean
        public getCachedValidation(): cn.nukkit.utils.OptionalBoolean
        public getBlock(): cn.nukkit.block.Block
        public getBlock(level: cn.nukkit.level.Level, x: int, y: int, z: int, layer: int, repair: boolean, callback: java.util.function.Consumer<cn.nukkit.blockstate.BlockStateRepair>): cn.nukkit.block.Block
        public toString(): string
        lambda$getBlock$7(rep: cn.nukkit.blockstate.BlockStateRepair): void
        lambda$getBlock$6(r: cn.nukkit.blockstate.BlockStateRepair): void
        lambda$asItemBlock$5(itemState: cn.nukkit.blockstate.MutableBlockState, property: string): void
        static lambda$of$4(namespacedId: string): java.util.NoSuchElementException
        static lambda$of$3(blockId: int, blockData: java.math.BigInteger, k: string): cn.nukkit.blockstate.BlockState
        static lambda$of$2(blockId: int, blockData: long, var2: string): cn.nukkit.blockstate.BlockState
        static lambda$of$1(blockId: int, blockData: int, k: string): cn.nukkit.blockstate.BlockState
        static lambda$of$0(blockId: int, blockData: byte, k: string): cn.nukkit.blockstate.BlockState
        static log: org.apache.logging.log4j.Logger
        static serialVersionUID: long
        static SIXTEEN: java.math.BigInteger
        static BYTE_LIMIT: java.math.BigInteger
        static INT_LIMIT: java.math.BigInteger
        static LONG_LIMIT: java.math.BigInteger
        static ZERO_STORAGE: cn.nukkit.blockstate.BlockState$ZeroStorage
        static STATES_COMMON: cn.nukkit.blockstate.BlockState[][]
        static STATES_UNCOMMON: java.util.concurrent.ConcurrentMap<string, cn.nukkit.blockstate.BlockState>
        public static AIR: cn.nukkit.blockstate.BlockState
        blockId: int
        storage: cn.nukkit.blockstate.BlockState$Storage
        valid: cn.nukkit.utils.OptionalBoolean

    }
}

declare module "cn.nukkit.blockstate.BlockState" {
    declare const BlockState = cn.nukkit.blockstate.BlockState;
}

declare namespace cn.nukkit.blockstate {
    declare class IntMutableBlockState extends cn.nukkit.blockstate.MutableBlockState {
        public constructor(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties, state: int): void
        public constructor(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties): void
        public getLegacyDamage(): int
        public getBigDamage(): int
        public getHugeDamage(): java.math.BigInteger
        public getDataStorage(): int
        public isDefaultState(): boolean
        public setDataStorage(storage: java.lang.Number): void
        public setDataStorageFromInt(storage: int): void
        setDataStorageWithoutValidation(storage: java.lang.Number): void
        public validate(): void
        validate(state: int): void
        public setBooleanValue(propertyName: string, value: boolean): void
        public setPropertyValue(propertyName: string, value: java.io.Serializable): void
        public setIntValue(propertyName: string, value: int): void
        public getPropertyValue(propertyName: string): java.io.Serializable
        public getIntValue(propertyName: string): int
        public getBooleanValue(propertyName: string): boolean
        public getPersistenceValue(propertyName: string): string
        public getCurrentState(): cn.nukkit.blockstate.BlockState
        public getExactIntStorage(): int
        public copy(): cn.nukkit.blockstate.IntMutableBlockState
        public toString(): string
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        public copy(): cn.nukkit.blockstate.MutableBlockState
        public getDataStorage(): java.lang.Number
        storage: int

    }
}

declare module "cn.nukkit.blockstate.IntMutableBlockState" {
    declare const IntMutableBlockState = cn.nukkit.blockstate.IntMutableBlockState;
}

declare namespace cn.nukkit.blockstate {
    declare class MutableBlockState extends java.lang.Object implements cn.nukkit.blockstate.IMutableBlockState {
        constructor(blockId: int, properties: cn.nukkit.blockproperty.BlockProperties): void
        setDataStorageWithoutValidation(storage: java.lang.Number): void
        public setState(state: cn.nukkit.blockstate.IBlockState): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockId(): int
        public getFullId(): int
        public getBigId(): long
        public getBitSize(): int
        public validate(): void
        public copy(): cn.nukkit.blockstate.MutableBlockState
        public toString(): string
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        blockId: int
        properties: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.blockstate.MutableBlockState" {
    declare const MutableBlockState = cn.nukkit.blockstate.MutableBlockState;
}

declare namespace cn.nukkit.blockstate {
    declare interface IBlockState {
        public getBlockId(): int
        public getDataStorage(): java.lang.Number
        public isDefaultState(): boolean
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getLegacyDamage(): int
        public getBigDamage(): int
        public getSignedBigDamage(): int
        public getHugeDamage(): java.math.BigInteger
        public getPropertyValue(var0: string): java.io.Serializable
        public getPropertyValue(property: void, var1: java.io.Serializable, var2: cn.nukkit.blockproperty.BlockProperty<void>): void
        public getUncheckedPropertyValue(property: void, var1: java.io.Serializable, var2: cn.nukkit.blockproperty.BlockProperty<void>): void
        public getIntValue(var0: string): int
        public getIntValue(property: byte): int
        public getBooleanValue(var0: string): boolean
        public getBooleanValue(property: byte): boolean
        public getPersistenceValue(var0: string): string
        public getPersistenceValue(property: byte): string
        public getPersistenceName(): string
        public getStateId(): string
        public getMinimalistStateId(): string
        public getLegacyStateId(): string
        public getCurrentState(): cn.nukkit.blockstate.BlockState
        public getBlock(): cn.nukkit.block.Block
        public getBlock(level: cn.nukkit.level.Level, x: int, y: int, z: int): cn.nukkit.block.Block
        public getBlock(level: cn.nukkit.level.Level, x: int, y: int, z: int, layer: int): cn.nukkit.block.Block
        public getBlock(level: cn.nukkit.level.Level, x: int, y: int, z: int, layer: int, repair: boolean): cn.nukkit.block.Block
        public getBlock(level: cn.nukkit.level.Level, x: int, y: int, z: int, layer: int, repair: boolean, callback: java.util.function.Consumer<cn.nukkit.blockstate.BlockStateRepair>): cn.nukkit.block.Block
        public getBlock(position: cn.nukkit.level.Position): cn.nukkit.block.Block
        public getBlock(position: cn.nukkit.block.Block): cn.nukkit.block.Block
        public getBlock(position: cn.nukkit.level.Position, layer: int): cn.nukkit.block.Block
        public getBlockRepairing(pos: cn.nukkit.block.Block): cn.nukkit.block.Block
        public getBlockRepairing(position: cn.nukkit.level.Position, layer: int): cn.nukkit.block.Block
        public getBlockRepairing(level: cn.nukkit.level.Level, pos: cn.nukkit.math.BlockVector3, layer: int): cn.nukkit.block.Block
        public getBlockRepairing(level: cn.nukkit.level.Level, pos: cn.nukkit.math.Vector3): cn.nukkit.block.Block
        public getBlockRepairing(level: cn.nukkit.level.Level, pos: cn.nukkit.math.Vector3, layer: int): cn.nukkit.block.Block
        public getBlockRepairing(level: cn.nukkit.level.Level, x: int, y: int, z: int): cn.nukkit.block.Block
        public getBlockRepairing(level: cn.nukkit.level.Level, x: int, y: int, z: int, layer: int): cn.nukkit.block.Block
        public getBlockRepairing(level: cn.nukkit.level.Level, x: int, y: int, z: int, layer: int, callback: java.util.function.Consumer<cn.nukkit.blockstate.BlockStateRepair>): cn.nukkit.block.Block
        public getRuntimeId(): int
        public getFullId(): int
        public getBigId(): long
        public getProperty(propertyName: string): cn.nukkit.blockproperty.BlockProperty
        public getCheckedProperty(): cn.nukkit.blockproperty.BlockProperty<string, char>
        public getPropertyNames(): java.util.Set<string>
        public getCheckedPropertyValue(propertyName: java.lang.Object, tClass: string): java.lang.Class<any>
        public getUncheckedPropertyValue(propertyName: java.lang.Object): string
        public getBitSize(): int
        public getExactIntStorage(): int
        public asItemBlock(): cn.nukkit.item.ItemBlock
        public asItemBlock(count: int): cn.nukkit.item.ItemBlock
        static lambda$getBlockRepairing$6(manager: cn.nukkit.plugin.PluginManager, repair: cn.nukkit.blockstate.BlockStateRepair): void
        static lambda$getMinimalistStateId$5(stateId: java.lang.StringBuilder, name: string, value: string): void
        static lambda$getMinimalistStateId$4(propertyMap: java.util.Map, entry: java.util.AbstractMap$SimpleEntry): void
        static lambda$getMinimalistStateId$3(entry: java.util.AbstractMap$SimpleEntry): boolean
        lambda$getMinimalistStateId$2(properties: cn.nukkit.blockproperty.BlockProperties, name: string): java.util.AbstractMap$SimpleEntry
        static lambda$getStateId$1(stateId: java.lang.StringBuilder, name: string, value: string): void
        lambda$getStateId$0(propertyMap: java.util.Map, properties: cn.nukkit.blockproperty.BlockProperties, name: string): void

    }
}

declare module "cn.nukkit.blockstate.IBlockState" {
    declare type IBlockState = cn.nukkit.blockstate.IBlockState;
}

declare namespace cn.nukkit.form.element {
    declare class Element extends java.lang.Object {
        public constructor(): void

    }
}

declare module "cn.nukkit.form.element.Element" {
    declare const Element = cn.nukkit.form.element.Element;
}

declare namespace cn.nukkit.form.element {
    declare class ElementStepSlider extends cn.nukkit.form.element.Element {
        public constructor(text: string): void
        public constructor(text: string, steps: java.util.List<string>): void
        public constructor(text: string, steps: java.util.List<string>, defaultStep: int): void
        public getDefaultStepIndex(): int
        public setDefaultOptionIndex(index: int): void
        public getText(): string
        public setText(text: string): void
        public getSteps(): java.util.List<string>
        public addStep(step: string): void
        public addStep(step: string, isDefault: boolean): void
        type: string
        text: string
        steps: java.util.List<string>
        defaultStepIndex: int

    }
}

declare module "cn.nukkit.form.element.ElementStepSlider" {
    declare const ElementStepSlider = cn.nukkit.form.element.ElementStepSlider;
}

declare namespace cn.nukkit.form.element {
    declare class ElementSlider extends cn.nukkit.form.element.Element {
        public constructor(text: string, min: float, max: float): void
        public constructor(text: string, min: float, max: float, step: int): void
        public constructor(text: string, min: float, max: float, step: int, defaultValue: float): void
        public getText(): string
        public setText(text: string): void
        public getMin(): float
        public setMin(min: float): void
        public getMax(): float
        public setMax(max: float): void
        public getStep(): int
        public setStep(step: int): void
        public getDefaultValue(): float
        public setDefaultValue(defaultValue: float): void
        type: string
        text: string
        min: float
        max: float
        step: int
        defaultValue: float

    }
}

declare module "cn.nukkit.form.element.ElementSlider" {
    declare const ElementSlider = cn.nukkit.form.element.ElementSlider;
}

declare namespace cn.nukkit.form.element {
    declare class ElementInput extends cn.nukkit.form.element.Element {
        public constructor(text: string): void
        public constructor(text: string, placeholder: string): void
        public constructor(text: string, placeholder: string, defaultText: string): void
        public getText(): string
        public setText(text: string): void
        public getPlaceHolder(): string
        public setPlaceHolder(placeholder: string): void
        public getDefaultText(): string
        public setDefaultText(defaultText: string): void
        type: string
        text: string
        placeholder: string
        defaultText: string

    }
}

declare module "cn.nukkit.form.element.ElementInput" {
    declare const ElementInput = cn.nukkit.form.element.ElementInput;
}

declare namespace cn.nukkit.form.element {
    declare class ElementDropdown extends cn.nukkit.form.element.Element {
        public constructor(text: string): void
        public constructor(text: string, options: java.util.List<string>): void
        public constructor(text: string, options: java.util.List<string>, defaultOption: int): void
        public getDefaultOptionIndex(): int
        public setDefaultOptionIndex(index: int): void
        public getOptions(): java.util.List<string>
        public getText(): string
        public setText(text: string): void
        public addOption(option: string): void
        public addOption(option: string, isDefault: boolean): void
        type: string
        text: string
        options: java.util.List<string>
        defaultOptionIndex: int

    }
}

declare module "cn.nukkit.form.element.ElementDropdown" {
    declare const ElementDropdown = cn.nukkit.form.element.ElementDropdown;
}

declare namespace cn.nukkit.form.element {
    declare class ElementToggle extends cn.nukkit.form.element.Element {
        public constructor(text: string): void
        public constructor(text: string, defaultValue: boolean): void
        public getText(): string
        public setText(text: string): void
        public isDefaultValue(): boolean
        public setDefaultValue(defaultValue: boolean): void
        type: string
        text: string
        defaultValue: boolean

    }
}

declare module "cn.nukkit.form.element.ElementToggle" {
    declare const ElementToggle = cn.nukkit.form.element.ElementToggle;
}

declare namespace cn.nukkit.form.response {
    declare class FormResponseModal extends cn.nukkit.form.response.FormResponse {
        public constructor(clickedButtonId: int, clickedButtonText: string): void
        public getClickedButtonId(): int
        public getClickedButtonText(): string
        clickedButtonId: int
        clickedButtonText: string

    }
}

declare module "cn.nukkit.form.response.FormResponseModal" {
    declare const FormResponseModal = cn.nukkit.form.response.FormResponseModal;
}

declare namespace cn.nukkit.form.response {
    declare class FormResponseData extends java.lang.Object {
        public constructor(id: int, content: string): void
        public getElementID(): int
        public getElementContent(): string
        elementID: int
        elementContent: string

    }
}

declare module "cn.nukkit.form.response.FormResponseData" {
    declare const FormResponseData = cn.nukkit.form.response.FormResponseData;
}

declare namespace cn.nukkit.form.response {
    declare class FormResponseSimple extends cn.nukkit.form.response.FormResponse {
        public constructor(clickedButtonId: int, clickedButton: cn.nukkit.form.element.ElementButton): void
        public getClickedButtonId(): int
        public getClickedButton(): cn.nukkit.form.element.ElementButton
        clickedButtonId: int
        clickedButton: cn.nukkit.form.element.ElementButton

    }
}

declare module "cn.nukkit.form.response.FormResponseSimple" {
    declare const FormResponseSimple = cn.nukkit.form.response.FormResponseSimple;
}

declare namespace cn.nukkit.form.window {
    declare class FormWindowModal extends cn.nukkit.form.window.FormWindow {
        public constructor(title: string, content: string, trueButtonText: string, falseButtonText: string): void
        public getTitle(): string
        public setTitle(title: string): void
        public getContent(): string
        public setContent(content: string): void
        public getButton1(): string
        public setButton1(button1: string): void
        public getButton2(): string
        public setButton2(button2: string): void
        public getResponse(): cn.nukkit.form.response.FormResponseModal
        public setResponse(data: string): void
        public getResponse(): cn.nukkit.form.response.FormResponse
        type: string
        title: string
        content: string
        button1: string
        button2: string
        response: cn.nukkit.form.response.FormResponseModal

    }
}

declare module "cn.nukkit.form.window.FormWindowModal" {
    declare const FormWindowModal = cn.nukkit.form.window.FormWindowModal;
}

declare namespace cn.nukkit.form.window {
    declare class FormWindowSimple extends cn.nukkit.form.window.FormWindow {
        public constructor(title: string, content: string): void
        public constructor(title: string, content: string, buttons: java.util.List<cn.nukkit.form.element.ElementButton>): void
        public getTitle(): string
        public setTitle(title: string): void
        public getContent(): string
        public setContent(content: string): void
        public getButtons(): java.util.List<cn.nukkit.form.element.ElementButton>
        public addButton(button: cn.nukkit.form.element.ElementButton): void
        public getResponse(): cn.nukkit.form.response.FormResponseSimple
        public setResponse(data: string): void
        public getResponse(): cn.nukkit.form.response.FormResponse
        type: string
        title: string
        content: string
        buttons: java.util.List<cn.nukkit.form.element.ElementButton>
        response: cn.nukkit.form.response.FormResponseSimple

    }
}

declare module "cn.nukkit.form.window.FormWindowSimple" {
    declare const FormWindowSimple = cn.nukkit.form.window.FormWindowSimple;
}

declare namespace cn.nukkit {
    declare class Server$1 extends java.util.HashMap {
        constructor(this$0: cn.nukkit.Server): void
        public put(key: int, value: cn.nukkit.level.Level): cn.nukkit.level.Level
        public remove(key: java.lang.Object, value: java.lang.Object): boolean
        public remove(key: java.lang.Object): cn.nukkit.level.Level
        public remove(var0: java.lang.Object): java.lang.Object
        public put(var0: java.lang.Object, var1: java.lang.Object): java.lang.Object
        this$0: cn.nukkit.Server

    }
}

declare module "cn.nukkit.Server$1" {
    declare const Server$1 = cn.nukkit.Server$1;
}

declare namespace cn.nukkit.blockproperty.exception {
    declare class InvalidBlockPropertyPersistenceValueException extends cn.nukkit.blockproperty.exception.InvalidBlockPropertyException {
        public constructor(property: byte, currentValue: string, invalidValue: string): void
        public constructor(property: byte, currentValue: string, invalidValue: string, message: string): void
        public constructor(property: byte, currentValue: string, invalidValue: string, message: string, cause: java.lang.Throwable): void
        public constructor(property: byte, currentValue: string, invalidValue: string, cause: java.lang.Throwable): void
        static buildMessage(currentValue: java.lang.Object, invalidValue: java.lang.Object): string
        public getCurrentValue(): string
        public getInvalidValue(): string
        static serialVersionUID: long
        currentValue: string
        invalidValue: string

    }
}

declare module "cn.nukkit.blockproperty.exception.InvalidBlockPropertyPersistenceValueException" {
    declare const InvalidBlockPropertyPersistenceValueException = cn.nukkit.blockproperty.exception.InvalidBlockPropertyPersistenceValueException;
}

declare namespace cn.nukkit.blockproperty.exception {
    declare class InvalidBlockPropertyException extends java.lang.IllegalArgumentException {
        public constructor(property: byte): void
        public constructor(property: byte, message: string): void
        public constructor(property: byte, message: string, cause: java.lang.Throwable): void
        public constructor(property: byte, cause: java.lang.Throwable): void
        static buildMessage(property: byte): string
        public getProperty(): byte
        static serialVersionUID: long
        property: byte

    }
}

declare module "cn.nukkit.blockproperty.exception.InvalidBlockPropertyException" {
    declare const InvalidBlockPropertyException = cn.nukkit.blockproperty.exception.InvalidBlockPropertyException;
}

declare namespace cn.nukkit.blockproperty.exception {
    declare class InvalidBlockPropertyMetaException extends cn.nukkit.blockproperty.exception.InvalidBlockPropertyException {
        public constructor(property: byte, currentMeta: java.lang.Number, invalidMeta: java.lang.Number): void
        public constructor(property: byte, currentMeta: java.lang.Number, invalidMeta: java.lang.Number, message: string): void
        public constructor(property: byte, currentMeta: java.lang.Number, invalidMeta: java.lang.Number, message: string, cause: java.lang.Throwable): void
        public constructor(property: byte, currentMeta: java.lang.Number, invalidMeta: java.lang.Number, cause: java.lang.Throwable): void
        static buildMessage(currentValue: java.lang.Object, invalidValue: java.lang.Object): string
        public getCurrentMeta(): java.lang.Number
        public getInvalidMeta(): java.lang.Number
        static serialVersionUID: long
        currentMeta: java.lang.Number
        invalidMeta: java.lang.Number

    }
}

declare module "cn.nukkit.blockproperty.exception.InvalidBlockPropertyMetaException" {
    declare const InvalidBlockPropertyMetaException = cn.nukkit.blockproperty.exception.InvalidBlockPropertyMetaException;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class StoneSlab1Type extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.StoneSlab1Type[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.StoneSlab1Type
        constructor(): void
        constructor(var0: string): void
        constructor(var0: cn.nukkit.utils.BlockColor): void
        constructor(var0: cn.nukkit.utils.BlockColor, var1: string): void
        public getColor(): cn.nukkit.utils.BlockColor
        public getEnglishName(): string
        static $values(): cn.nukkit.blockproperty.value.StoneSlab1Type[]
        public static SMOOTH_STONE: cn.nukkit.blockproperty.value.StoneSlab1Type
        public static SANDSTONE: cn.nukkit.blockproperty.value.StoneSlab1Type
        public static WOOD: cn.nukkit.blockproperty.value.StoneSlab1Type
        public static COBBLESTONE: cn.nukkit.blockproperty.value.StoneSlab1Type
        public static BRICK: cn.nukkit.blockproperty.value.StoneSlab1Type
        public static STONE_BRICK: cn.nukkit.blockproperty.value.StoneSlab1Type
        public static QUARTZ: cn.nukkit.blockproperty.value.StoneSlab1Type
        public static NETHER_BRICK: cn.nukkit.blockproperty.value.StoneSlab1Type
        public static PROPERTY: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.StoneSlab1Type>
        color: cn.nukkit.utils.BlockColor
        englishName: string
        static $VALUES: cn.nukkit.blockproperty.value.StoneSlab1Type[]

    }
}

declare module "cn.nukkit.blockproperty.value.StoneSlab1Type" {
    declare const StoneSlab1Type = cn.nukkit.blockproperty.value.StoneSlab1Type;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class ChiselType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.ChiselType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.ChiselType
        constructor(): void
        static $values(): cn.nukkit.blockproperty.value.ChiselType[]
        public static DEFAULT: cn.nukkit.blockproperty.value.ChiselType
        public static CHISELED: cn.nukkit.blockproperty.value.ChiselType
        public static LINES: cn.nukkit.blockproperty.value.ChiselType
        public static SMOOTH: cn.nukkit.blockproperty.value.ChiselType
        static $VALUES: cn.nukkit.blockproperty.value.ChiselType[]

    }
}

declare module "cn.nukkit.blockproperty.value.ChiselType" {
    declare const ChiselType = cn.nukkit.blockproperty.value.ChiselType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class CrackState$1 extends cn.nukkit.blockproperty.value.CrackState {
        constructor(var0: string, var1: int): void
        public getNext(): cn.nukkit.blockproperty.value.CrackState

    }
}

declare module "cn.nukkit.blockproperty.value.CrackState$1" {
    declare const CrackState$1 = cn.nukkit.blockproperty.value.CrackState$1;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class StoneType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.StoneType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.StoneType
        public getEnglishName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        constructor(var0: string, var1: cn.nukkit.utils.BlockColor): void
        static $values(): cn.nukkit.blockproperty.value.StoneType[]
        public static STONE: cn.nukkit.blockproperty.value.StoneType
        public static GRANITE: cn.nukkit.blockproperty.value.StoneType
        public static GRANITE_SMOOTH: cn.nukkit.blockproperty.value.StoneType
        public static DIORITE: cn.nukkit.blockproperty.value.StoneType
        public static DIORITE_SMOOTH: cn.nukkit.blockproperty.value.StoneType
        public static ANDESITE: cn.nukkit.blockproperty.value.StoneType
        public static ANDESITE_SMOOTH: cn.nukkit.blockproperty.value.StoneType
        englishName: string
        color: cn.nukkit.utils.BlockColor
        static $VALUES: cn.nukkit.blockproperty.value.StoneType[]

    }
}

declare module "cn.nukkit.blockproperty.value.StoneType" {
    declare const StoneType = cn.nukkit.blockproperty.value.StoneType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class SmallFlowerType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.SmallFlowerType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.SmallFlowerType
        public getDyeColor(): cn.nukkit.utils.DyeColor
        public getEnglishName(): string
        public getBlockId(): int
        public getBlock(): cn.nukkit.block.BlockFlower
        constructor(var0: string, var1: cn.nukkit.utils.DyeColor, englishName: int): void
        static $values(): cn.nukkit.blockproperty.value.SmallFlowerType[]
        public static POPPY: cn.nukkit.blockproperty.value.SmallFlowerType
        public static ORCHID: cn.nukkit.blockproperty.value.SmallFlowerType
        public static ALLIUM: cn.nukkit.blockproperty.value.SmallFlowerType
        public static HOUSTONIA: cn.nukkit.blockproperty.value.SmallFlowerType
        public static TULIP_RED: cn.nukkit.blockproperty.value.SmallFlowerType
        public static TULIP_ORANGE: cn.nukkit.blockproperty.value.SmallFlowerType
        public static TULIP_WHITE: cn.nukkit.blockproperty.value.SmallFlowerType
        public static TULIP_PINK: cn.nukkit.blockproperty.value.SmallFlowerType
        public static OXEYE: cn.nukkit.blockproperty.value.SmallFlowerType
        public static CORNFLOWER: cn.nukkit.blockproperty.value.SmallFlowerType
        public static LILY_OF_THE_VALLEY: cn.nukkit.blockproperty.value.SmallFlowerType
        public static DANDELION: cn.nukkit.blockproperty.value.SmallFlowerType
        public static WITHER_ROSE: cn.nukkit.blockproperty.value.SmallFlowerType
        englishName: string
        dyeColor: cn.nukkit.utils.DyeColor
        blockId: int
        static $VALUES: cn.nukkit.blockproperty.value.SmallFlowerType[]

    }
}

declare module "cn.nukkit.blockproperty.value.SmallFlowerType" {
    declare const SmallFlowerType = cn.nukkit.blockproperty.value.SmallFlowerType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class SandStoneType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.SandStoneType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.SandStoneType
        public getEnglishName(): string
        constructor(var0: string): void
        static $values(): cn.nukkit.blockproperty.value.SandStoneType[]
        public static DEFAULT: cn.nukkit.blockproperty.value.SandStoneType
        public static HEIROGLYPHS: cn.nukkit.blockproperty.value.SandStoneType
        public static CUT: cn.nukkit.blockproperty.value.SandStoneType
        public static SMOOTH: cn.nukkit.blockproperty.value.SandStoneType
        englishName: string
        static $VALUES: cn.nukkit.blockproperty.value.SandStoneType[]

    }
}

declare module "cn.nukkit.blockproperty.value.SandStoneType" {
    declare const SandStoneType = cn.nukkit.blockproperty.value.SandStoneType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class MonsterEggStoneType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.MonsterEggStoneType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.MonsterEggStoneType
        constructor(): void
        static $values(): cn.nukkit.blockproperty.value.MonsterEggStoneType[]
        public static STONE: cn.nukkit.blockproperty.value.MonsterEggStoneType
        public static COBBLESTONE: cn.nukkit.blockproperty.value.MonsterEggStoneType
        public static STONE_BRICK: cn.nukkit.blockproperty.value.MonsterEggStoneType
        public static MOSSY_STONE_BRICK: cn.nukkit.blockproperty.value.MonsterEggStoneType
        public static CRACKED_STONE_BRICK: cn.nukkit.blockproperty.value.MonsterEggStoneType
        public static CHISELED_STONE_BRICK: cn.nukkit.blockproperty.value.MonsterEggStoneType
        static $VALUES: cn.nukkit.blockproperty.value.MonsterEggStoneType[]

    }
}

declare module "cn.nukkit.blockproperty.value.MonsterEggStoneType" {
    declare const MonsterEggStoneType = cn.nukkit.blockproperty.value.MonsterEggStoneType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class CoralType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.CoralType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.CoralType
        constructor(): void
        static $values(): cn.nukkit.blockproperty.value.CoralType[]
        public static BLUE: cn.nukkit.blockproperty.value.CoralType
        public static PINK: cn.nukkit.blockproperty.value.CoralType
        public static PURPLE: cn.nukkit.blockproperty.value.CoralType
        public static RED: cn.nukkit.blockproperty.value.CoralType
        public static YELLOW: cn.nukkit.blockproperty.value.CoralType
        static $VALUES: cn.nukkit.blockproperty.value.CoralType[]

    }
}

declare module "cn.nukkit.blockproperty.value.CoralType" {
    declare const CoralType = cn.nukkit.blockproperty.value.CoralType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class SeaGrassType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.SeaGrassType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.SeaGrassType
        constructor(): void
        static $values(): cn.nukkit.blockproperty.value.SeaGrassType[]
        public static DEFAULT: cn.nukkit.blockproperty.value.SeaGrassType
        public static DOUBLE_TOP: cn.nukkit.blockproperty.value.SeaGrassType
        public static DOUBLE_BOT: cn.nukkit.blockproperty.value.SeaGrassType
        static $VALUES: cn.nukkit.blockproperty.value.SeaGrassType[]

    }
}

declare module "cn.nukkit.blockproperty.value.SeaGrassType" {
    declare const SeaGrassType = cn.nukkit.blockproperty.value.SeaGrassType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class AttachmentType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.AttachmentType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.AttachmentType
        constructor(): void
        static $values(): cn.nukkit.blockproperty.value.AttachmentType[]
        public static STANDING: cn.nukkit.blockproperty.value.AttachmentType
        public static HANGING: cn.nukkit.blockproperty.value.AttachmentType
        public static SIDE: cn.nukkit.blockproperty.value.AttachmentType
        public static MULTIPLE: cn.nukkit.blockproperty.value.AttachmentType
        static $VALUES: cn.nukkit.blockproperty.value.AttachmentType[]

    }
}

declare module "cn.nukkit.blockproperty.value.AttachmentType" {
    declare const AttachmentType = cn.nukkit.blockproperty.value.AttachmentType;
}

declare namespace cn.nukkit.blockproperty.value {
    declare class StoneBrickType extends java.lang.Enum {
        public static values(): cn.nukkit.blockproperty.value.StoneBrickType[]
        public static valueOf(name: string): cn.nukkit.blockproperty.value.StoneBrickType
        public getEnglishName(): string
        constructor(var0: string): void
        static $values(): cn.nukkit.blockproperty.value.StoneBrickType[]
        public static DEFAULT: cn.nukkit.blockproperty.value.StoneBrickType
        public static MOSSY: cn.nukkit.blockproperty.value.StoneBrickType
        public static CRACKED: cn.nukkit.blockproperty.value.StoneBrickType
        public static CHISELED: cn.nukkit.blockproperty.value.StoneBrickType
        public static SMOOTH: cn.nukkit.blockproperty.value.StoneBrickType
        englishName: string
        static $VALUES: cn.nukkit.blockproperty.value.StoneBrickType[]

    }
}

declare module "cn.nukkit.blockproperty.value.StoneBrickType" {
    declare const StoneBrickType = cn.nukkit.blockproperty.value.StoneBrickType;
}

declare namespace cn.nukkit.blockproperty {
    declare class IntBlockProperty extends cn.nukkit.blockproperty.BlockProperty {
        public constructor(name: string, exportedToItem: boolean, maxValue: int, minValue: int, bitSize: int, persistenceName: string): void
        public constructor(name: string, exportedToItem: boolean, maxValue: int, minValue: int, bitSize: int): void
        public constructor(name: string, exportedToItem: boolean, maxValue: int, minValue: int): void
        public constructor(name: string, exportedToItem: boolean, maxValue: int): void
        public copy(): cn.nukkit.blockproperty.IntBlockProperty
        public exportingToItems(exportedToItem: boolean): cn.nukkit.blockproperty.IntBlockProperty
        public getMetaForValue(value: int): int
        public getMetaForValue(value: int): int
        public getValueForMeta(meta: int): int
        public getIntValueForMeta(meta: int): int
        public getPersistenceValueForMeta(meta: int): string
        public getMetaForPersistenceValue(persistenceValue: string): int
        validateDirectly(value: int): void
        validateDirectly(newValue: int): void
        validateMetaDirectly(meta: int): void
        public clamp(value: int): int
        public getMaxValue(): int
        public getMinValue(): int
        public getDefaultValue(): int
        public isDefaultIntValue(value: int): boolean
        public getDefaultIntValue(): int
        public isDefaultValue(value: int): boolean
        public getValueClass(): java.lang.Class<int>
        public exportingToItems(var0: boolean): cn.nukkit.blockproperty.BlockProperty
        public copy(): cn.nukkit.blockproperty.BlockProperty
        public getDefaultValue(): java.io.Serializable
        public isDefaultValue(var0: java.io.Serializable): boolean
        validateDirectly(var0: java.io.Serializable): void
        public getValueForMeta(var0: int): java.io.Serializable
        public getMetaForValue(var0: java.io.Serializable): int
        static serialVersionUID: long
        minValue: int
        maxValue: int

    }
}

declare module "cn.nukkit.blockproperty.IntBlockProperty" {
    declare const IntBlockProperty = cn.nukkit.blockproperty.IntBlockProperty;
}

declare namespace cn.nukkit.blockproperty {
    declare class ArrayBlockProperty extends cn.nukkit.blockproperty.BlockProperty {
        static checkUniverseLength(): java.lang.Object
        public constructor(name: string, exportedToItem: boolean, universe: int, bitSize: string): void
        public constructor(name: string, exportedToItem: boolean, universe: int, bitSize: string, persistenceName: boolean): void
        public constructor(name: string, exportedToItem: boolean, universe: int, bitSize: string, persistenceName: boolean, ordinal: string[]): void
        public constructor(name: string, exportedToItem: boolean, universe: int): void
        public constructor(name: string, exportedToItem: boolean): void
        public constructor(name: string, exportedToItem: boolean, enumClass: java.lang.Class<any>): void
        public copy(): cn.nukkit.blockproperty.ArrayBlockProperty<any>
        public exportingToItems(exportedToItem: boolean): cn.nukkit.blockproperty.ArrayBlockProperty<any>
        public ordinal(ordinal: boolean): cn.nukkit.blockproperty.ArrayBlockProperty<any>
        public getMetaForValue(): int
        public getValueForMeta(): int
        public getIntValueForMeta(meta: int): int
        public getPersistenceValueForMeta(meta: int): string
        public getMetaForPersistenceValue(persistenceValue: string): int
        validateDirectly(): void
        validateMetaDirectly(meta: int): void
        public getValueClass(): java.lang.Class<any>
        public getUniverse(): any
        public isOrdinal(): boolean
        public getDefaultValue(): any
        public isDefaultValue(): boolean
        public exportingToItems(var0: boolean): cn.nukkit.blockproperty.BlockProperty
        public copy(): cn.nukkit.blockproperty.BlockProperty
        static lambda$new$0(x$0: int): string[]
        static serialVersionUID: long
        universe: any
        persistenceNames: string[]
        eClass: java.lang.Class<any>
        ordinal: boolean

    }
}

declare module "cn.nukkit.blockproperty.ArrayBlockProperty" {
    declare const ArrayBlockProperty = cn.nukkit.blockproperty.ArrayBlockProperty;
}

declare namespace cn.nukkit.blockproperty {
    declare class BlockProperty extends java.lang.Object implements java.io.Serializable {
        public constructor(name: string, exportedToItem: boolean, bitSize: int, persistenceName: string): void
        computeRightMask(bitOffset: int): int
        computeBigRightMask(bitOffset: int): long
        computeHugeRightMask(bitOffset: int): java.math.BigInteger
        computeValueMask(bitOffset: int): int
        computeBigValueMask(bitOffset: int): long
        computeHugeValueMask(bitOffset: int): java.math.BigInteger
        public setValue(currentMeta: int, bitOffset: int): int
        public setValue(currentBigMeta: long, var1: int): long
        public setValue(currentHugeMeta: java.math.BigInteger, bitOffset: int): java.math.BigInteger
        public getMetaFromInt(currentMeta: int, bitOffset: int): int
        public getMetaFromLong(currentMeta: long, var1: int): int
        public getMetaFromBigInt(currentMeta: java.math.BigInteger, bitOffset: int): int
        public getValue(currentMeta: int): int
        public getValue(currentBigMeta: long): int
        public getValue(currentHugeMeta: java.math.BigInteger): int
        public getIntValue(currentMeta: int, bitOffset: int): int
        public getIntValue(currentMeta: long, var1: int): int
        public getIntValue(currentMeta: java.math.BigInteger, bitOffset: int): int
        public getPersistenceValue(currentMeta: int, bitOffset: int): string
        public getPersistenceValue(currentMeta: long, var1: int): string
        public getPersistenceValue(currentMeta: java.math.BigInteger, bitOffset: int): string
        public getMetaForValue(): int
        public getValueForMeta(): int
        public getIntValueForMeta(var0: int): int
        public getPersistenceValueForMeta(var0: int): string
        public getMetaForPersistenceValue(var0: string): int
        validateDirectly(): void
        validateMetaDirectly(var0: int): void
        public validateMeta(meta: int, offset: int): void
        public validateMeta(meta: long, var1: int): void
        public validateMeta(meta: java.math.BigInteger, offset: int): void
        public getBitSize(): int
        public getName(): string
        public getPersistenceName(): string
        public getValueClass(): java.lang.Class<any>
        public isExportedToItem(): boolean
        public toString(): string
        public isDefaultValue(): boolean
        public isDefaultPersistentValue(value: string): boolean
        public getDefaultValue(): any
        public isDefaultIntValue(value: int): boolean
        public isDefaultBooleanValue(value: boolean): boolean
        public getDefaultIntValue(): int
        public getDefaultBooleanValue(): boolean
        public copy(): cn.nukkit.blockproperty.BlockProperty<any>
        public exportingToItems(var0: boolean): cn.nukkit.blockproperty.BlockProperty<any>
        static serialVersionUID: long
        bitSize: int
        name: string
        persistenceName: string
        exportedToItem: boolean

    }
}

declare module "cn.nukkit.blockproperty.BlockProperty" {
    declare const BlockProperty = cn.nukkit.blockproperty.BlockProperty;
}

declare namespace cn.nukkit.blockproperty {
    declare class UnsignedIntBlockProperty extends cn.nukkit.blockproperty.BlockProperty {
        public constructor(name: string, exportedToItem: boolean, maxValue: int, minValue: int, bitSize: int, persistenceName: string): void
        public constructor(name: string, exportedToItem: boolean, maxValue: int, minValue: int, bitSize: int): void
        public constructor(name: string, exportedToItem: boolean, maxValue: int, minValue: int): void
        public constructor(name: string, exportedToItem: boolean, maxValue: int): void
        public copy(): cn.nukkit.blockproperty.UnsignedIntBlockProperty
        public exportingToItems(exportedToItem: boolean): cn.nukkit.blockproperty.UnsignedIntBlockProperty
        static removeSign(value: int): long
        static addSign(value: long): int
        public getMetaForValue(value: int): int
        public getValueForMeta(meta: int): int
        public getIntValueForMeta(meta: int): int
        public getPersistenceValueForMeta(meta: int): string
        public getMetaForPersistenceValue(persistenceValue: string): int
        validateDirectly(value: int): void
        validateDirectly(unsigned: long): void
        validateMetaDirectly(meta: int): void
        public getValueClass(): java.lang.Class<int>
        public getMaxValue(): long
        public getMinValue(): long
        public getDefaultValue(): int
        public isDefaultValue(value: int): boolean
        public isDefaultIntValue(value: int): boolean
        public getDefaultIntValue(): int
        public exportingToItems(var0: boolean): cn.nukkit.blockproperty.BlockProperty
        public copy(): cn.nukkit.blockproperty.BlockProperty
        public getDefaultValue(): java.io.Serializable
        public isDefaultValue(var0: java.io.Serializable): boolean
        validateDirectly(var0: java.io.Serializable): void
        public getValueForMeta(var0: int): java.io.Serializable
        public getMetaForValue(var0: java.io.Serializable): int
        static serialVersionUID: long
        minValue: long
        maxValue: long

    }
}

declare module "cn.nukkit.blockproperty.UnsignedIntBlockProperty" {
    declare const UnsignedIntBlockProperty = cn.nukkit.blockproperty.UnsignedIntBlockProperty;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityPistonArm extends cn.nukkit.blockentity.BlockEntitySpawnable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        moveCollidedEntities(): void
        moveEntity(entity: cn.nukkit.entity.Entity, moveDirection: cn.nukkit.math.BlockFace): void
        public move(extending: boolean, attachedBlocks: java.util.List<cn.nukkit.math.BlockVector3>, blocksCalculator: cn.nukkit.block.BlockPistonBase$BlocksCalculator): void
        public onUpdate(): boolean
        getExtendedProgress(progress: float): float
        public isBlockEntityValid(): boolean
        public saveNBT(): void
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        getAttachedBlocks(): cn.nukkit.nbt.tag.ListTag<cn.nukkit.nbt.tag.IntTag>
        lambda$onUpdate$0(pos: cn.nukkit.level.Position): void
        public static MOVE_STEP: float
        public progress: float
        public lastProgress: float
        public facing: cn.nukkit.math.BlockFace
        public powered: boolean
        public extending: boolean
        public blocksCalculator: cn.nukkit.block.BlockPistonBase$BlocksCalculator
        public sticky: boolean
        public state: byte
        public newState: byte
        public attachedBlocks: java.util.List<cn.nukkit.math.BlockVector3>
        public finished: boolean

    }
}

declare module "cn.nukkit.blockentity.BlockEntityPistonArm" {
    declare const BlockEntityPistonArm = cn.nukkit.blockentity.BlockEntityPistonArm;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntitySculkShrieker extends cn.nukkit.blockentity.BlockEntity {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public isBlockEntityValid(): boolean

    }
}

declare module "cn.nukkit.blockentity.BlockEntitySculkShrieker" {
    declare const BlockEntitySculkShrieker = cn.nukkit.blockentity.BlockEntitySculkShrieker;
}

declare namespace cn.nukkit.blockentity {
    declare class BlockEntityCampfire extends cn.nukkit.blockentity.BlockEntitySpawnable implements cn.nukkit.inventory.InventoryHolder, cn.nukkit.blockentity.BlockEntityContainer {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initBlockEntity(): void
        public onUpdate(): boolean
        public getKeepItem(slot: int): boolean
        public setKeepItem(slot: int, keep: boolean): void
        public saveNBT(): void
        public loadNBT(): void
        public setRecipe(index: int, recipe: cn.nukkit.inventory.CampfireRecipe): void
        public close(): void
        public onBreak(): void
        public getName(): string
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag
        public isBlockEntityValid(): boolean
        public getSize(): int
        public getItem(index: int): cn.nukkit.item.Item
        public setItem(index: int, item: cn.nukkit.item.Item): void
        public getInventory(): cn.nukkit.inventory.CampfireInventory
        public getInventory(): cn.nukkit.inventory.Inventory
        inventory: cn.nukkit.inventory.CampfireInventory
        burnTime: int[]
        recipes: cn.nukkit.inventory.CampfireRecipe[]
        keepItem: boolean[]

    }
}

declare module "cn.nukkit.blockentity.BlockEntityCampfire" {
    declare const BlockEntityCampfire = cn.nukkit.blockentity.BlockEntityCampfire;
}

declare namespace cn.nukkit.item {
    declare class ItemScute extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemScute" {
    declare const ItemScute = cn.nukkit.item.ItemScute;
}

declare namespace cn.nukkit.item {
    declare class ItemBlazePowder extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemBlazePowder" {
    declare const ItemBlazePowder = cn.nukkit.item.ItemBlazePowder;
}

declare namespace cn.nukkit.item {
    declare class ItemMinecartHopper extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public canBeActivated(): boolean
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemMinecartHopper" {
    declare const ItemMinecartHopper = cn.nukkit.item.ItemMinecartHopper;
}

declare namespace cn.nukkit.item {
    declare class ItemEnderPearl extends cn.nukkit.item.ProjectileItem {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int
        public getProjectileEntityType(): string
        public getThrowForce(): float
        correctProjectile(player: cn.nukkit.Player, projectile: cn.nukkit.entity.Entity): cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.item.ItemEnderPearl" {
    declare const ItemEnderPearl = cn.nukkit.item.ItemEnderPearl;
}

declare namespace cn.nukkit.item {
    declare class ItemNetherSprouts extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemNetherSprouts" {
    declare const ItemNetherSprouts = cn.nukkit.item.ItemNetherSprouts;
}

declare namespace cn.nukkit.item {
    declare class ItemMinecart extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public canBeActivated(): boolean
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemMinecart" {
    declare const ItemMinecart = cn.nukkit.item.ItemMinecart;
}

declare namespace cn.nukkit.item {
    declare class ItemDoorCrimson extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemDoorCrimson" {
    declare const ItemDoorCrimson = cn.nukkit.item.ItemDoorCrimson;
}

declare namespace cn.nukkit.item {
    declare class StringItemUnknown extends cn.nukkit.item.StringItem {
        public constructor(id: string): void

    }
}

declare module "cn.nukkit.item.StringItemUnknown" {
    declare const StringItemUnknown = cn.nukkit.item.StringItemUnknown;
}

declare namespace cn.nukkit.item {
    declare class ItemIngotNetherite extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public isLavaResistant(): boolean

    }
}

declare module "cn.nukkit.item.ItemIngotNetherite" {
    declare const ItemIngotNetherite = cn.nukkit.item.ItemIngotNetherite;
}

declare namespace cn.nukkit.item {
    declare class ItemPumpkinPie extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemPumpkinPie" {
    declare const ItemPumpkinPie = cn.nukkit.item.ItemPumpkinPie;
}

declare namespace cn.nukkit.item {
    declare class ItemMelon extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemMelon" {
    declare const ItemMelon = cn.nukkit.item.ItemMelon;
}

declare namespace cn.nukkit.item {
    declare class Item$ItemJsonComponents$CanDestory extends java.lang.Object {
        public constructor(): void
        public blocks: string[]

    }
}

declare module "cn.nukkit.item.Item$ItemJsonComponents$CanDestory" {
    declare const Item$ItemJsonComponents$CanDestory = cn.nukkit.item.Item$ItemJsonComponents$CanDestory;
}

declare namespace cn.nukkit.item {
    declare class ItemChestplateLeather extends cn.nukkit.item.ItemColorArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isChestplate(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemChestplateLeather" {
    declare const ItemChestplateLeather = cn.nukkit.item.ItemChestplateLeather;
}

declare namespace cn.nukkit.item {
    declare class ItemShovelStone extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isShovel(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemShovelStone" {
    declare const ItemShovelStone = cn.nukkit.item.ItemShovelStone;
}

declare namespace cn.nukkit.item {
    declare class ItemSwordWood extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isSword(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemSwordWood" {
    declare const ItemSwordWood = cn.nukkit.item.ItemSwordWood;
}

declare namespace cn.nukkit.item {
    declare class ItemHorseArmorIron extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemHorseArmorIron" {
    declare const ItemHorseArmorIron = cn.nukkit.item.ItemHorseArmorIron;
}

declare namespace cn.nukkit.item {
    declare class ItemWheat extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemWheat" {
    declare const ItemWheat = cn.nukkit.item.ItemWheat;
}

declare namespace cn.nukkit.item {
    declare class ItemHoneycomb extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemHoneycomb" {
    declare const ItemHoneycomb = cn.nukkit.item.ItemHoneycomb;
}

declare namespace cn.nukkit.item {
    declare class StringItem extends cn.nukkit.item.Item {
        static notEmpty(value: string): string
        public constructor(id: string, name: string): void
        public hasCompoundTag(): boolean
        public hasCustomCompoundTag(): boolean
        public getCustomCompoundTag(): byte[]
        public getNamedTag(): cn.nukkit.nbt.tag.CompoundTag
        public setCompoundTag(tags: byte[]): cn.nukkit.item.Item
        public setNamedTag(tag: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.item.Item
        public clearNamedTag(): cn.nukkit.item.Item
        public getId(): int
        public getNamespaceId(): string
        public clone(): cn.nukkit.item.StringItem
        public clone(): cn.nukkit.item.Item
        public clone(): java.lang.Object
        id: string
        customCompound: byte[]

    }
}

declare module "cn.nukkit.item.StringItem" {
    declare const StringItem = cn.nukkit.item.StringItem;
}

declare namespace cn.nukkit.item {
    declare class ItemBootsIron extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isBoots(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemBootsIron" {
    declare const ItemBootsIron = cn.nukkit.item.ItemBootsIron;
}

declare namespace cn.nukkit.item {
    declare class ItemTurtleShell extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isHelmet(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int
        public getToughness(): int

    }
}

declare module "cn.nukkit.item.ItemTurtleShell" {
    declare const ItemTurtleShell = cn.nukkit.item.ItemTurtleShell;
}

declare namespace cn.nukkit.item {
    declare class ItemEndCrystal extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public canBeActivated(): boolean
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean

    }
}

declare module "cn.nukkit.item.ItemEndCrystal" {
    declare const ItemEndCrystal = cn.nukkit.item.ItemEndCrystal;
}

declare namespace cn.nukkit.item {
    declare class ItemFirework$FireworkExplosion extends java.lang.Object {
        public constructor(): void
        public getColors(): java.util.List<cn.nukkit.utils.DyeColor>
        public getFades(): java.util.List<cn.nukkit.utils.DyeColor>
        public hasFlicker(): boolean
        public hasTrail(): boolean
        public getType(): cn.nukkit.item.ItemFirework$FireworkExplosion$ExplosionType
        public setFlicker(flicker: boolean): cn.nukkit.item.ItemFirework$FireworkExplosion
        public setTrail(trail: boolean): cn.nukkit.item.ItemFirework$FireworkExplosion
        public type(type: cn.nukkit.item.ItemFirework$FireworkExplosion$ExplosionType): cn.nukkit.item.ItemFirework$FireworkExplosion
        public addColor(color: cn.nukkit.utils.DyeColor): cn.nukkit.item.ItemFirework$FireworkExplosion
        public addFade(fade: cn.nukkit.utils.DyeColor): cn.nukkit.item.ItemFirework$FireworkExplosion
        colors: java.util.List<cn.nukkit.utils.DyeColor>
        fades: java.util.List<cn.nukkit.utils.DyeColor>
        flicker: boolean
        trail: boolean
        type: cn.nukkit.item.ItemFirework$FireworkExplosion$ExplosionType

    }
}

declare module "cn.nukkit.item.ItemFirework$FireworkExplosion" {
    declare const ItemFirework$FireworkExplosion = cn.nukkit.item.ItemFirework$FireworkExplosion;
}

declare namespace cn.nukkit.item {
    declare class ItemAxeNetherite extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isAxe(): boolean
        public getTier(): int
        public getAttackDamage(): int
        public isLavaResistant(): boolean

    }
}

declare module "cn.nukkit.item.ItemAxeNetherite" {
    declare const ItemAxeNetherite = cn.nukkit.item.ItemAxeNetherite;
}

declare namespace cn.nukkit.item {
    declare class ItemNuggetIron extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemNuggetIron" {
    declare const ItemNuggetIron = cn.nukkit.item.ItemNuggetIron;
}

declare namespace cn.nukkit.item {
    declare class ItemBannerPattern extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        constructor(id: int, meta: int, count: int, name: string): void
        public getMaxStackSize(): int
        public setDamage(meta: int): void
        public getPatternType(): cn.nukkit.utils.BannerPattern$Type
        updateName(): void
        public static PATTERN_CREEPER_CHARGE: int
        public static PATTERN_SKULL_CHARGE: int
        public static PATTERN_FLOWER_CHARGE: int
        public static PATTERN_THING: int
        public static PATTERN_FIELD_MASONED: int
        public static PATTERN_BORDURE_INDENTED: int
        public static PATTERN_SNOUT: int

    }
}

declare module "cn.nukkit.item.ItemBannerPattern" {
    declare const ItemBannerPattern = cn.nukkit.item.ItemBannerPattern;
}

declare namespace cn.nukkit.item {
    declare class ItemSwordGold extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isSword(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemSwordGold" {
    declare const ItemSwordGold = cn.nukkit.item.ItemSwordGold;
}

declare namespace cn.nukkit.item {
    declare class ItemPorkchopRaw extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemPorkchopRaw" {
    declare const ItemPorkchopRaw = cn.nukkit.item.ItemPorkchopRaw;
}

declare namespace cn.nukkit.item {
    declare class ItemTool extends cn.nukkit.item.Item implements cn.nukkit.item.ItemDurable {
        public static getBestTool(toolType: int): cn.nukkit.item.Item
        public constructor(id: int): void
        public constructor(id: int, meta: int): void
        public constructor(id: int, meta: int, count: int): void
        public constructor(id: int, meta: int, count: int, name: string): void
        public getMaxStackSize(): int
        public useOn(block: cn.nukkit.block.Block): boolean
        public useOn(entity: cn.nukkit.entity.Entity): boolean
        isDurable(): boolean
        public isUnbreakable(): boolean
        public isPickaxe(): boolean
        public isAxe(): boolean
        public isSword(): boolean
        public isShovel(): boolean
        public isHoe(): boolean
        public isShears(): boolean
        public isTool(): boolean
        public getEnchantAbility(): int
        public noDamageOnAttack(): boolean
        public noDamageOnBreak(): boolean
        public static TIER_WOODEN: int
        public static TIER_GOLD: int
        public static TIER_STONE: int
        public static TIER_IRON: int
        public static TIER_DIAMOND: int
        public static TIER_NETHERITE: int
        public static TYPE_NONE: int
        public static TYPE_SWORD: int
        public static TYPE_SHOVEL: int
        public static TYPE_PICKAXE: int
        public static TYPE_AXE: int
        public static TYPE_SHEARS: int
        public static TYPE_HOE: int
        public static TYPE_HANDS_ONLY: int
        public static DURABILITY_WOODEN: int
        public static DURABILITY_GOLD: int
        public static DURABILITY_STONE: int
        public static DURABILITY_IRON: int
        public static DURABILITY_DIAMOND: int
        public static DURABILITY_NETHERITE: int
        public static DURABILITY_FLINT_STEEL: int
        public static DURABILITY_SHEARS: int
        public static DURABILITY_BOW: int
        public static DURABILITY_TRIDENT: int
        public static DURABILITY_FISHING_ROD: int
        public static DURABILITY_CROSSBOW: int
        public static DURABILITY_CARROT_ON_A_STICK: int
        public static DURABILITY_WARPED_FUNGUS_ON_A_STICK: int
        public static DURABILITY_SHIELD: int

    }
}

declare module "cn.nukkit.item.ItemTool" {
    declare const ItemTool = cn.nukkit.item.ItemTool;
}

declare namespace cn.nukkit.item {
    declare class ItemRabbitStew extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemRabbitStew" {
    declare const ItemRabbitStew = cn.nukkit.item.ItemRabbitStew;
}

declare namespace cn.nukkit.item {
    declare class ItemBrick extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemBrick" {
    declare const ItemBrick = cn.nukkit.item.ItemBrick;
}

declare namespace cn.nukkit.item {
    declare class ItemWarpedSign extends cn.nukkit.item.ItemSign {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemWarpedSign" {
    declare const ItemWarpedSign = cn.nukkit.item.ItemWarpedSign;
}

declare namespace cn.nukkit.item {
    declare class ItemSeedsMelon extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemSeedsMelon" {
    declare const ItemSeedsMelon = cn.nukkit.item.ItemSeedsMelon;
}

declare namespace cn.nukkit.item {
    declare class ItemRawMaterial extends cn.nukkit.item.StringItem {
        public constructor(id: string, name: string): void

    }
}

declare module "cn.nukkit.item.ItemRawMaterial" {
    declare const ItemRawMaterial = cn.nukkit.item.ItemRawMaterial;
}

declare namespace cn.nukkit.item {
    declare class ItemSweetBerries extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemSweetBerries" {
    declare const ItemSweetBerries = cn.nukkit.item.ItemSweetBerries;
}

declare namespace cn.nukkit.item {
    declare class ItemSpiderEyeFermented extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemSpiderEyeFermented" {
    declare const ItemSpiderEyeFermented = cn.nukkit.item.ItemSpiderEyeFermented;
}

declare namespace cn.nukkit.item {
    declare class ItemBeetrootSoup extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemBeetrootSoup" {
    declare const ItemBeetrootSoup = cn.nukkit.item.ItemBeetrootSoup;
}

declare namespace cn.nukkit.item {
    declare class ItemRecordWard extends cn.nukkit.item.ItemRecord {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getSoundId(): string

    }
}

declare module "cn.nukkit.item.ItemRecordWard" {
    declare const ItemRecordWard = cn.nukkit.item.ItemRecordWard;
}

declare namespace cn.nukkit.item {
    declare class ItemPotato extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        constructor(id: int, meta: int, count: int, name: string): void

    }
}

declare module "cn.nukkit.item.ItemPotato" {
    declare const ItemPotato = cn.nukkit.item.ItemPotato;
}

declare namespace cn.nukkit.item {
    declare class ItemDoorDarkOak extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemDoorDarkOak" {
    declare const ItemDoorDarkOak = cn.nukkit.item.ItemDoorDarkOak;
}

declare namespace cn.nukkit.item {
    declare class ItemCauldron extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemCauldron" {
    declare const ItemCauldron = cn.nukkit.item.ItemCauldron;
}

declare namespace cn.nukkit.item {
    declare class ItemRawIron extends cn.nukkit.item.ItemRawMaterial {
        public constructor(): void

    }
}

declare module "cn.nukkit.item.ItemRawIron" {
    declare const ItemRawIron = cn.nukkit.item.ItemRawIron;
}

declare namespace cn.nukkit.item {
    declare class ItemHoeWood extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isHoe(): boolean
        public getTier(): int

    }
}

declare module "cn.nukkit.item.ItemHoeWood" {
    declare const ItemHoeWood = cn.nukkit.item.ItemHoeWood;
}

declare namespace cn.nukkit.item {
    declare class ItemAmethystShard extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(id: int): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public constructor(id: int, meta: int): void
        public constructor(id: int, meta: int, count: int): void
        public constructor(id: int, meta: int, count: int, name: string): void

    }
}

declare module "cn.nukkit.item.ItemAmethystShard" {
    declare const ItemAmethystShard = cn.nukkit.item.ItemAmethystShard;
}

declare namespace cn.nukkit.item {
    declare class ItemHelmetDiamond extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isHelmet(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int
        public getToughness(): int

    }
}

declare module "cn.nukkit.item.ItemHelmetDiamond" {
    declare const ItemHelmetDiamond = cn.nukkit.item.ItemHelmetDiamond;
}

declare namespace cn.nukkit.item {
    declare class ItemBootsGold extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isBoots(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemBootsGold" {
    declare const ItemBootsGold = cn.nukkit.item.ItemBootsGold;
}

declare namespace cn.nukkit.item {
    declare class ItemBrewingStand extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemBrewingStand" {
    declare const ItemBrewingStand = cn.nukkit.item.ItemBrewingStand;
}

declare namespace cn.nukkit.item {
    declare class ItemShovelDiamond extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isShovel(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemShovelDiamond" {
    declare const ItemShovelDiamond = cn.nukkit.item.ItemShovelDiamond;
}

declare namespace cn.nukkit.item {
    declare class ItemRecord extends cn.nukkit.item.Item {
        public constructor(id: int, meta: int, count: int): void
        public getMaxStackSize(): int
        public getSoundId(): string

    }
}

declare module "cn.nukkit.item.ItemRecord" {
    declare const ItemRecord = cn.nukkit.item.ItemRecord;
}

declare namespace cn.nukkit.item {
    declare class ItemHorseArmorDiamond extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemHorseArmorDiamond" {
    declare const ItemHorseArmorDiamond = cn.nukkit.item.ItemHorseArmorDiamond;
}

declare namespace cn.nukkit.item {
    declare class ItemKelp extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemKelp" {
    declare const ItemKelp = cn.nukkit.item.ItemKelp;
}

declare namespace cn.nukkit.item {
    declare class UnknownNetworkIdException extends java.lang.IllegalStateException {
        public constructor(): void
        public constructor(s: string): void
        public constructor(message: string, cause: java.lang.Throwable): void
        public constructor(cause: java.lang.Throwable): void
        public constructor(item: cn.nukkit.item.Item): void
        public constructor(item: cn.nukkit.item.Item, s: string): void
        public constructor(item: cn.nukkit.item.Item, message: string, cause: java.lang.Throwable): void
        public constructor(item: cn.nukkit.item.Item, cause: java.lang.Throwable): void
        public getItem(): cn.nukkit.item.Item
        static copy(item: cn.nukkit.item.Item): cn.nukkit.item.Item
        item: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.item.UnknownNetworkIdException" {
    declare const UnknownNetworkIdException = cn.nukkit.item.UnknownNetworkIdException;
}

declare namespace cn.nukkit.item {
    declare class ItemPrismarineShard extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemPrismarineShard" {
    declare const ItemPrismarineShard = cn.nukkit.item.ItemPrismarineShard;
}

declare namespace cn.nukkit.item {
    declare class ItemQuartz extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemQuartz" {
    declare const ItemQuartz = cn.nukkit.item.ItemQuartz;
}

declare namespace cn.nukkit.item {
    declare class ItemChorusFruitPopped extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemChorusFruitPopped" {
    declare const ItemChorusFruitPopped = cn.nukkit.item.ItemChorusFruitPopped;
}

declare namespace cn.nukkit.item {
    declare class ItemSpawnEgg extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        constructor(id: int, meta: int, count: int, name: string): void
        public setDamage(meta: int): void
        updateName(): void
        public canBeActivated(): boolean
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean
        public getEntityNetworkId(): int
        public getEntityName(): string

    }
}

declare module "cn.nukkit.item.ItemSpawnEgg" {
    declare const ItemSpawnEgg = cn.nukkit.item.ItemSpawnEgg;
}

declare namespace cn.nukkit.item {
    declare class ItemGlowstoneDust extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemGlowstoneDust" {
    declare const ItemGlowstoneDust = cn.nukkit.item.ItemGlowstoneDust;
}

declare namespace cn.nukkit.item {
    declare class ItemGlowBerries extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public canBeActivated(): boolean
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean

    }
}

declare module "cn.nukkit.item.ItemGlowBerries" {
    declare const ItemGlowBerries = cn.nukkit.item.ItemGlowBerries;
}

declare namespace cn.nukkit.item {
    declare class ItemRecordOtherside extends cn.nukkit.item.ItemRecord {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getSoundId(): string

    }
}

declare module "cn.nukkit.item.ItemRecordOtherside" {
    declare const ItemRecordOtherside = cn.nukkit.item.ItemRecordOtherside;
}

declare namespace cn.nukkit.item {
    declare class ItemEmptyMap extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public setDamage(meta: int): void
        updateName(): void
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean

    }
}

declare module "cn.nukkit.item.ItemEmptyMap" {
    declare const ItemEmptyMap = cn.nukkit.item.ItemEmptyMap;
}

declare namespace cn.nukkit.item {
    declare class ItemShears extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isShears(): boolean

    }
}

declare module "cn.nukkit.item.ItemShears" {
    declare const ItemShears = cn.nukkit.item.ItemShears;
}

declare namespace cn.nukkit.item {
    declare class ItemPufferfish extends cn.nukkit.item.ItemFish {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemPufferfish" {
    declare const ItemPufferfish = cn.nukkit.item.ItemPufferfish;
}

declare namespace cn.nukkit.item {
    declare class ItemChickenCooked extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemChickenCooked" {
    declare const ItemChickenCooked = cn.nukkit.item.ItemChickenCooked;
}

declare namespace cn.nukkit.item {
    declare class ItemBootsChain extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isBoots(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemBootsChain" {
    declare const ItemBootsChain = cn.nukkit.item.ItemBootsChain;
}

declare namespace cn.nukkit.item {
    declare class ItemDye extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(dyeColor: cn.nukkit.utils.DyeColor): void
        public constructor(dyeColor: cn.nukkit.utils.DyeColor, amount: int): void
        public constructor(meta: int, amount: int): void
        constructor(id: int, meta: int, count: int, name: string): void
        public isFertilizer(): boolean
        public isLapisLazuli(): boolean
        public isCocoaBeans(): boolean
        public static getColor(meta: int): cn.nukkit.utils.BlockColor
        public getDyeColor(): cn.nukkit.utils.DyeColor
        public static getColorName(meta: int): string
        public static WHITE: int
        public static ORANGE: int
        public static MAGENTA: int
        public static LIGHT_BLUE: int
        public static YELLOW: int
        public static LIME: int
        public static PINK: int
        public static GRAY: int
        public static LIGHT_GRAY: int
        public static CYAN: int
        public static PURPLE: int
        public static BLUE: int
        public static BROWN: int
        public static GREEN: int
        public static RED: int
        public static BLACK: int
        public static BONE_MEAL: int

    }
}

declare module "cn.nukkit.item.ItemDye" {
    declare const ItemDye = cn.nukkit.item.ItemDye;
}

declare namespace cn.nukkit.item {
    declare class ItemBucket extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        constructor(id: int, meta: int, count: int, name: string): void
        static getName(meta: int): string
        public static getDamageByTarget(target: int): int
        public isEmpty(): boolean
        public isWater(): boolean
        public isLava(): boolean
        public isPowderSnow(): boolean
        public getFishEntityId(): string
        public getMaxStackSize(): int
        public canBeActivated(): boolean
        public getTargetBlock(): cn.nukkit.block.Block
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean
        canBeUsedOnDimension(dimension: int): boolean
        afterUse(level: cn.nukkit.level.Level, block: cn.nukkit.block.Block): void
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean
        public onUse(player: cn.nukkit.Player, ticksUsed: int): boolean

    }
}

declare module "cn.nukkit.item.ItemBucket" {
    declare const ItemBucket = cn.nukkit.item.ItemBucket;
}

declare namespace cn.nukkit.item {
    declare class ItemIngotIron extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemIngotIron" {
    declare const ItemIngotIron = cn.nukkit.item.ItemIngotIron;
}

declare namespace cn.nukkit.item {
    declare class ItemSeedsBeetroot extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemSeedsBeetroot" {
    declare const ItemSeedsBeetroot = cn.nukkit.item.ItemSeedsBeetroot;
}

declare namespace cn.nukkit.item {
    declare class ItemNetherWart extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public setDamage(meta: int): void

    }
}

declare module "cn.nukkit.item.ItemNetherWart" {
    declare const ItemNetherWart = cn.nukkit.item.ItemNetherWart;
}

declare namespace cn.nukkit.item {
    declare class ItemPickaxeGold extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isPickaxe(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemPickaxeGold" {
    declare const ItemPickaxeGold = cn.nukkit.item.ItemPickaxeGold;
}

declare namespace cn.nukkit.item {
    declare class ItemCoal extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        constructor(id: int, meta: int, count: int, name: string): void
        public getDamage(): int
        public isCharcoal(): boolean

    }
}

declare module "cn.nukkit.item.ItemCoal" {
    declare const ItemCoal = cn.nukkit.item.ItemCoal;
}

declare namespace cn.nukkit.item {
    declare class ItemPotatoBaked extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemPotatoBaked" {
    declare const ItemPotatoBaked = cn.nukkit.item.ItemPotatoBaked;
}

declare namespace cn.nukkit.item {
    declare class ItemPotionSplash extends cn.nukkit.item.ProjectileItem {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public setDamage(meta: int): void
        updateName(): void
        public getMaxStackSize(): int
        public canBeActivated(): boolean
        public getProjectileEntityType(): string
        public getThrowForce(): float
        correctNBT(nbt: cn.nukkit.nbt.tag.CompoundTag): void

    }
}

declare module "cn.nukkit.item.ItemPotionSplash" {
    declare const ItemPotionSplash = cn.nukkit.item.ItemPotionSplash;
}

declare namespace cn.nukkit.item {
    declare class ItemBread extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemBread" {
    declare const ItemBread = cn.nukkit.item.ItemBread;
}

declare namespace cn.nukkit.item {
    declare class ItemSwordDiamond extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isSword(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemSwordDiamond" {
    declare const ItemSwordDiamond = cn.nukkit.item.ItemSwordDiamond;
}

declare namespace cn.nukkit.item {
    declare class ItemBookAndQuill extends cn.nukkit.item.ItemBookWritable {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemBookAndQuill" {
    declare const ItemBookAndQuill = cn.nukkit.item.ItemBookAndQuill;
}

declare namespace cn.nukkit.item {
    declare class ItemHoeGold extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isHoe(): boolean
        public getTier(): int

    }
}

declare module "cn.nukkit.item.ItemHoeGold" {
    declare const ItemHoeGold = cn.nukkit.item.ItemHoeGold;
}

declare namespace cn.nukkit.item {
    declare class ItemStick extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemStick" {
    declare const ItemStick = cn.nukkit.item.ItemStick;
}

declare namespace cn.nukkit.item {
    declare class ItemLeggingsDiamond extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public isLeggings(): boolean
        public getTier(): int
        public getArmorPoints(): int
        public getMaxDurability(): int
        public getToughness(): int

    }
}

declare module "cn.nukkit.item.ItemLeggingsDiamond" {
    declare const ItemLeggingsDiamond = cn.nukkit.item.ItemLeggingsDiamond;
}

declare namespace cn.nukkit.item {
    declare class ItemLeggingsLeather extends cn.nukkit.item.ItemColorArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isLeggings(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemLeggingsLeather" {
    declare const ItemLeggingsLeather = cn.nukkit.item.ItemLeggingsLeather;
}

declare namespace cn.nukkit.item {
    declare class ItemAxeIron extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isAxe(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemAxeIron" {
    declare const ItemAxeIron = cn.nukkit.item.ItemAxeIron;
}

declare namespace cn.nukkit.item {
    declare class Item$ItemJsonComponents extends java.lang.Object {
        public static fromJson(json: string): cn.nukkit.item.Item$ItemJsonComponents
        constructor(): void
        static gson: com.google.gson.Gson
        public canPlaceOn: cn.nukkit.item.Item$ItemJsonComponents$CanPlaceOn
        public canDestroy: cn.nukkit.item.Item$ItemJsonComponents$CanDestory
        public itemLock: cn.nukkit.item.Item$ItemJsonComponents$ItemLock
        public keepOnDeath: cn.nukkit.item.Item$ItemJsonComponents$KeepOnDeath

    }
}

declare module "cn.nukkit.item.Item$ItemJsonComponents" {
    declare const Item$ItemJsonComponents = cn.nukkit.item.Item$ItemJsonComponents;
}

declare namespace cn.nukkit.item {
    declare class ItemPainting extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public canBeActivated(): boolean
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean
        static offset(value: int): double
        static DIRECTION: int[]
        static RIGHT: int[]
        static OFFSET: double

    }
}

declare module "cn.nukkit.item.ItemPainting" {
    declare const ItemPainting = cn.nukkit.item.ItemPainting;
}

declare namespace cn.nukkit.item {
    declare class ItemCampfireSoul extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemCampfireSoul" {
    declare const ItemCampfireSoul = cn.nukkit.item.ItemCampfireSoul;
}

declare namespace cn.nukkit.item {
    declare class ItemHoeDiamond extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isHoe(): boolean
        public getTier(): int

    }
}

declare module "cn.nukkit.item.ItemHoeDiamond" {
    declare const ItemHoeDiamond = cn.nukkit.item.ItemHoeDiamond;
}

declare namespace cn.nukkit.item {
    declare class ItemSugar extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemSugar" {
    declare const ItemSugar = cn.nukkit.item.ItemSugar;
}

declare namespace cn.nukkit.item {
    declare class ItemBowl extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemBowl" {
    declare const ItemBowl = cn.nukkit.item.ItemBowl;
}

declare namespace cn.nukkit.item {
    declare class ItemClay extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemClay" {
    declare const ItemClay = cn.nukkit.item.ItemClay;
}

declare namespace cn.nukkit.item {
    declare class ItemSwordStone extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isSword(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemSwordStone" {
    declare const ItemSwordStone = cn.nukkit.item.ItemSwordStone;
}

declare namespace cn.nukkit.item {
    declare class ItemLead extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemLead" {
    declare const ItemLead = cn.nukkit.item.ItemLead;
}

declare namespace cn.nukkit.item {
    declare class ItemSkull extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public setDamage(meta: int): void
        updateName(): void
        public static getItemSkullName(meta: int): string
        public static SKELETON_SKULL: int
        public static WITHER_SKELETON_SKULL: int
        public static ZOMBIE_HEAD: int
        public static HEAD: int
        public static CREEPER_HEAD: int
        public static DRAGON_HEAD: int

    }
}

declare module "cn.nukkit.item.ItemSkull" {
    declare const ItemSkull = cn.nukkit.item.ItemSkull;
}

declare namespace cn.nukkit.item {
    declare class Item$ItemJsonComponents$CanPlaceOn extends java.lang.Object {
        public constructor(): void
        public blocks: string[]

    }
}

declare module "cn.nukkit.item.Item$ItemJsonComponents$CanPlaceOn" {
    declare const Item$ItemJsonComponents$CanPlaceOn = cn.nukkit.item.Item$ItemJsonComponents$CanPlaceOn;
}

declare namespace cn.nukkit.item {
    declare class ItemChestplateDiamond extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isChestplate(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int
        public getToughness(): int

    }
}

declare module "cn.nukkit.item.ItemChestplateDiamond" {
    declare const ItemChestplateDiamond = cn.nukkit.item.ItemChestplateDiamond;
}

declare namespace cn.nukkit.item {
    declare class ItemRabbitFoot extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemRabbitFoot" {
    declare const ItemRabbitFoot = cn.nukkit.item.ItemRabbitFoot;
}

declare namespace cn.nukkit.item {
    declare class ItemDoorJungle extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemDoorJungle" {
    declare const ItemDoorJungle = cn.nukkit.item.ItemDoorJungle;
}

declare namespace cn.nukkit.item {
    declare class ItemRecord13 extends cn.nukkit.item.ItemRecord {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getSoundId(): string

    }
}

declare module "cn.nukkit.item.ItemRecord13" {
    declare const ItemRecord13 = cn.nukkit.item.ItemRecord13;
}

declare namespace cn.nukkit.item {
    declare class ItemBoat extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        constructor(id: int, meta: int, count: int, name: string): void
        public setDamage(meta: int): void
        adjustName(): void
        public canBeActivated(): boolean
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemBoat" {
    declare const ItemBoat = cn.nukkit.item.ItemBoat;
}

declare namespace cn.nukkit.item {
    declare class Item$ItemJsonComponents$ItemLock extends java.lang.Object {
        public constructor(): void
        public static LOCK_IN_INVENTORY: string
        public static LOCK_IN_SLOT: string
        mode: string

    }
}

declare module "cn.nukkit.item.Item$ItemJsonComponents$ItemLock" {
    declare const Item$ItemJsonComponents$ItemLock = cn.nukkit.item.Item$ItemJsonComponents$ItemLock;
}

declare namespace cn.nukkit.item {
    declare class ItemItemFrame extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemItemFrame" {
    declare const ItemItemFrame = cn.nukkit.item.ItemItemFrame;
}

declare namespace cn.nukkit.item {
    declare class ItemRecord11 extends cn.nukkit.item.ItemRecord {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getSoundId(): string

    }
}

declare module "cn.nukkit.item.ItemRecord11" {
    declare const ItemRecord11 = cn.nukkit.item.ItemRecord11;
}

declare namespace cn.nukkit.item {
    declare class ItemCake extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemCake" {
    declare const ItemCake = cn.nukkit.item.ItemCake;
}

declare namespace cn.nukkit.item {
    declare class ItemGlassBottle extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public canBeActivated(): boolean
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean

    }
}

declare module "cn.nukkit.item.ItemGlassBottle" {
    declare const ItemGlassBottle = cn.nukkit.item.ItemGlassBottle;
}

declare namespace cn.nukkit.item {
    declare class ItemRecordMellohi extends cn.nukkit.item.ItemRecord {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getSoundId(): string

    }
}

declare module "cn.nukkit.item.ItemRecordMellohi" {
    declare const ItemRecordMellohi = cn.nukkit.item.ItemRecordMellohi;
}

declare namespace cn.nukkit.item {
    declare class ItemMuttonCooked extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemMuttonCooked" {
    declare const ItemMuttonCooked = cn.nukkit.item.ItemMuttonCooked;
}

declare namespace cn.nukkit.item {
    declare class ItemAcaciaSign extends cn.nukkit.item.ItemSign {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemAcaciaSign" {
    declare const ItemAcaciaSign = cn.nukkit.item.ItemAcaciaSign;
}

declare namespace cn.nukkit.item {
    declare class ItemCompassLodestone extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int
        public setTrackingPosition(position: cn.nukkit.positiontracking.NamedPosition): void
        public getTrackingPosition(): cn.nukkit.positiontracking.NamedPosition
        public getTrackingHandle(): int
        public setTrackingHandle(trackingHandle: int): void

    }
}

declare module "cn.nukkit.item.ItemCompassLodestone" {
    declare const ItemCompassLodestone = cn.nukkit.item.ItemCompassLodestone;
}

declare namespace cn.nukkit.item.randomitem {
    declare class RandomItem extends java.lang.Object {
        public constructor(): void
        public static putSelector(selector: cn.nukkit.item.randomitem.Selector): cn.nukkit.item.randomitem.Selector
        public static putSelector(selector: cn.nukkit.item.randomitem.Selector, chance: float): cn.nukkit.item.randomitem.Selector
        static selectFrom(selector: cn.nukkit.item.randomitem.Selector): java.lang.Object
        static lambda$selectFrom$0(selector: cn.nukkit.item.randomitem.Selector, child: java.util.Map, s: cn.nukkit.item.randomitem.Selector, f: float): void
        static selectors: java.util.Map<cn.nukkit.item.randomitem.Selector, float>
        public static ROOT: cn.nukkit.item.randomitem.Selector

    }
}

declare module "cn.nukkit.item.randomitem.RandomItem" {
    declare const RandomItem = cn.nukkit.item.randomitem.RandomItem;
}

declare namespace cn.nukkit.item.randomitem {
    declare class Fishing extends java.lang.Object {
        public constructor(): void
        public static getFishingResult(rod: cn.nukkit.item.Item): cn.nukkit.item.Item
        public static getFishingResult(fortuneLevel: int, lureLevel: int): cn.nukkit.item.Item
        public static ROOT_FISHING: cn.nukkit.item.randomitem.Selector
        public static FISHES: cn.nukkit.item.randomitem.Selector
        public static TREASURES: cn.nukkit.item.randomitem.Selector
        public static JUNKS: cn.nukkit.item.randomitem.Selector
        public static FISH: cn.nukkit.item.randomitem.Selector
        public static SALMON: cn.nukkit.item.randomitem.Selector
        public static CLOWNFISH: cn.nukkit.item.randomitem.Selector
        public static PUFFERFISH: cn.nukkit.item.randomitem.Selector
        public static TREASURE_BOW: cn.nukkit.item.randomitem.Selector
        public static TREASURE_ENCHANTED_BOOK: cn.nukkit.item.randomitem.Selector
        public static TREASURE_FISHING_ROD: cn.nukkit.item.randomitem.Selector
        public static TREASURE_NAME_TAG: cn.nukkit.item.randomitem.Selector
        public static TREASURE_SADDLE: cn.nukkit.item.randomitem.Selector
        public static TREASURE_NAUTILUS_SHELL: cn.nukkit.item.randomitem.Selector
        public static JUNK_BOWL: cn.nukkit.item.randomitem.Selector
        public static JUNK_FISHING_ROD: cn.nukkit.item.randomitem.Selector
        public static JUNK_LEATHER: cn.nukkit.item.randomitem.Selector
        public static JUNK_LEATHER_BOOTS: cn.nukkit.item.randomitem.Selector
        public static JUNK_ROTTEN_FLESH: cn.nukkit.item.randomitem.Selector
        public static JUNK_STICK: cn.nukkit.item.randomitem.Selector
        public static JUNK_STRING_ITEM: cn.nukkit.item.randomitem.Selector
        public static JUNK_WATTER_BOTTLE: cn.nukkit.item.randomitem.Selector
        public static JUNK_BONE: cn.nukkit.item.randomitem.Selector
        public static JUNK_TRIPWIRE_HOOK: cn.nukkit.item.randomitem.Selector

    }
}

declare module "cn.nukkit.item.randomitem.Fishing" {
    declare const Fishing = cn.nukkit.item.randomitem.Fishing;
}

declare namespace cn.nukkit.item.randomitem {
    declare class Selector extends java.lang.Object {
        public constructor(parent: cn.nukkit.item.randomitem.Selector): void
        public setParent(parent: cn.nukkit.item.randomitem.Selector): cn.nukkit.item.randomitem.Selector
        public getParent(): cn.nukkit.item.randomitem.Selector
        public select(): java.lang.Object
        public static selectRandom(selectorChanceMap: java.util.Map<cn.nukkit.item.randomitem.Selector, float>): cn.nukkit.item.randomitem.Selector
        static lambda$selectRandom$1(flag: float[], resultChance: float, found: boolean[], temp: cn.nukkit.item.randomitem.Selector[], o: cn.nukkit.item.randomitem.Selector, f: float): void
        static lambda$selectRandom$0(totalChance: float[], f: float): void
        parent: cn.nukkit.item.randomitem.Selector

    }
}

declare module "cn.nukkit.item.randomitem.Selector" {
    declare const Selector = cn.nukkit.item.randomitem.Selector;
}

declare namespace cn.nukkit.item.randomitem {
    declare class ConstantItemSelector extends cn.nukkit.item.randomitem.Selector {
        public constructor(id: int, parent: cn.nukkit.item.randomitem.Selector): void
        public constructor(id: int, meta: int, parent: cn.nukkit.item.randomitem.Selector): void
        public constructor(id: int, meta: int, count: int, parent: cn.nukkit.item.randomitem.Selector): void
        public constructor(item: cn.nukkit.item.Item, parent: cn.nukkit.item.randomitem.Selector): void
        public getItem(): cn.nukkit.item.Item
        public select(): java.lang.Object
        item: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.item.randomitem.ConstantItemSelector" {
    declare const ConstantItemSelector = cn.nukkit.item.randomitem.ConstantItemSelector;
}

declare namespace cn.nukkit.item {
    declare class ItemChain extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemChain" {
    declare const ItemChain = cn.nukkit.item.ItemChain;
}

declare namespace cn.nukkit.item {
    declare class ItemAppleGold extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean

    }
}

declare module "cn.nukkit.item.ItemAppleGold" {
    declare const ItemAppleGold = cn.nukkit.item.ItemAppleGold;
}

declare namespace cn.nukkit.item {
    declare class ItemRecordCat extends cn.nukkit.item.ItemRecord {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getSoundId(): string

    }
}

declare module "cn.nukkit.item.ItemRecordCat" {
    declare const ItemRecordCat = cn.nukkit.item.ItemRecordCat;
}

declare namespace cn.nukkit.item {
    declare class ItemBootsDiamond extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isBoots(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int
        public getToughness(): int

    }
}

declare module "cn.nukkit.item.ItemBootsDiamond" {
    declare const ItemBootsDiamond = cn.nukkit.item.ItemBootsDiamond;
}

declare namespace cn.nukkit.item {
    declare class ItemGunpowder extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemGunpowder" {
    declare const ItemGunpowder = cn.nukkit.item.ItemGunpowder;
}

declare namespace cn.nukkit.item {
    declare interface ItemDurable {

    }
}

declare module "cn.nukkit.item.ItemDurable" {
    declare type ItemDurable = cn.nukkit.item.ItemDurable;
}

declare namespace cn.nukkit.item {
    declare class ItemRabbitCooked extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemRabbitCooked" {
    declare const ItemRabbitCooked = cn.nukkit.item.ItemRabbitCooked;
}

declare namespace cn.nukkit.item {
    declare class ItemRedstoneRepeater extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemRedstoneRepeater" {
    declare const ItemRedstoneRepeater = cn.nukkit.item.ItemRedstoneRepeater;
}

declare namespace cn.nukkit.item {
    declare class ItemExpBottle extends cn.nukkit.item.ProjectileItem {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getProjectileEntityType(): string
        public getThrowForce(): float

    }
}

declare module "cn.nukkit.item.ItemExpBottle" {
    declare const ItemExpBottle = cn.nukkit.item.ItemExpBottle;
}

declare namespace cn.nukkit.item {
    declare class ItemColorArmor extends cn.nukkit.item.ItemArmor {
        public constructor(id: int): void
        public constructor(id: int, meta: int): void
        public constructor(id: int, meta: int, count: int): void
        public constructor(id: int, meta: int, count: int, name: string): void
        public setColor(dyeColor: int): cn.nukkit.item.ItemColorArmor
        public setColor(dyeColor: cn.nukkit.utils.DyeColor): cn.nukkit.item.ItemColorArmor
        public setColor(color: cn.nukkit.utils.BlockColor): cn.nukkit.item.ItemColorArmor
        public setColor(r: int, g: int, b: int): cn.nukkit.item.ItemColorArmor
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.item.ItemColorArmor" {
    declare const ItemColorArmor = cn.nukkit.item.ItemColorArmor;
}

declare namespace cn.nukkit.item {
    declare class ItemHelmetLeather extends cn.nukkit.item.ItemColorArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isHelmet(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemHelmetLeather" {
    declare const ItemHelmetLeather = cn.nukkit.item.ItemHelmetLeather;
}

declare namespace cn.nukkit.item {
    declare class ItemDragonBreath extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemDragonBreath" {
    declare const ItemDragonBreath = cn.nukkit.item.ItemDragonBreath;
}

declare namespace cn.nukkit.item {
    declare class ItemHorseArmorLeather extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemHorseArmorLeather" {
    declare const ItemHorseArmorLeather = cn.nukkit.item.ItemHorseArmorLeather;
}

declare namespace cn.nukkit.item {
    declare class ItemDoorWood extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemDoorWood" {
    declare const ItemDoorWood = cn.nukkit.item.ItemDoorWood;
}

declare namespace cn.nukkit.item {
    declare class ItemShovelWood extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isShovel(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemShovelWood" {
    declare const ItemShovelWood = cn.nukkit.item.ItemShovelWood;
}

declare namespace cn.nukkit.item {
    declare class ItemBlazeRod extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemBlazeRod" {
    declare const ItemBlazeRod = cn.nukkit.item.ItemBlazeRod;
}

declare namespace cn.nukkit.item {
    declare class RuntimeItems$1 extends com.google.gson.reflect.TypeToken {
        constructor(): void

    }
}

declare module "cn.nukkit.item.RuntimeItems$1" {
    declare const RuntimeItems$1 = cn.nukkit.item.RuntimeItems$1;
}

declare namespace cn.nukkit.item {
    declare class ItemDarkOakSign extends cn.nukkit.item.ItemSign {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemDarkOakSign" {
    declare const ItemDarkOakSign = cn.nukkit.item.ItemDarkOakSign;
}

declare namespace cn.nukkit.item {
    declare class ItemPickaxeIron extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isPickaxe(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemPickaxeIron" {
    declare const ItemPickaxeIron = cn.nukkit.item.ItemPickaxeIron;
}

declare namespace cn.nukkit.item {
    declare class ItemMap extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public setDamage(meta: int): void
        updateName(): void
        public setImage(file: java.io.File): void
        public setImage(image: java.awt.image.BufferedImage): void
        loadImageFromNBT(): java.awt.image.BufferedImage
        public getMapId(): long
        public sendImage(p: cn.nukkit.Player): void
        public trySendImage(p: cn.nukkit.Player): boolean
        public canBeActivated(): boolean
        public getMaxStackSize(): int
        static log: org.apache.logging.log4j.Logger
        public static mapCount: int
        image: java.awt.image.BufferedImage

    }
}

declare module "cn.nukkit.item.ItemMap" {
    declare const ItemMap = cn.nukkit.item.ItemMap;
}

declare namespace cn.nukkit.item {
    declare class ItemSeedsWheat extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemSeedsWheat" {
    declare const ItemSeedsWheat = cn.nukkit.item.ItemSeedsWheat;
}

declare namespace cn.nukkit.item {
    declare class ItemSlimeball extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemSlimeball" {
    declare const ItemSlimeball = cn.nukkit.item.ItemSlimeball;
}

declare namespace cn.nukkit.item {
    declare class ItemHopper extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemHopper" {
    declare const ItemHopper = cn.nukkit.item.ItemHopper;
}

declare namespace cn.nukkit.item {
    declare class ItemLeather extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemLeather" {
    declare const ItemLeather = cn.nukkit.item.ItemLeather;
}

declare namespace cn.nukkit.item {
    declare class RuntimeItemMapping extends java.lang.Object {
        public constructor(itemDataPalette: byte[], legacyNetworkMap: it.unimi.dsi.fastutil.ints.Int2IntMap, networkLegacyMap: it.unimi.dsi.fastutil.ints.Int2IntMap): void
        public constructor(itemDataPalette: byte[], legacyNetworkMap: it.unimi.dsi.fastutil.ints.Int2IntMap, networkLegacyMap: it.unimi.dsi.fastutil.ints.Int2IntMap, namespaceNetworkMap: java.util.Map<string, int>, networkNamespaceMap: it.unimi.dsi.fastutil.ints.Int2ObjectMap<string>): void
        public constructor(entries: java.util.Collection<cn.nukkit.item.RuntimeItems$Entry>): void
        generatePalette(): void
        public registerCustomItem(itemCustom: cn.nukkit.item.customitem.ItemCustom): void
        public deleteCustomItem(itemCustom: cn.nukkit.item.customitem.ItemCustom): void
        public getNetworkFullId(item: cn.nukkit.item.Item): int
        public getLegacyFullId(networkId: int): int
        public getItemDataPalette(): byte[]
        public getNamespacedIdByNetworkId(networkId: int): string
        public getNetworkIdByNamespaceId(namespaceId: string): java.util.OptionalInt
        public getItemByNamespaceId(namespaceId: string, amount: int): cn.nukkit.item.Item
        public registerNamespacedIdItem(namespacedId: string, constructor: java.lang.reflect.Constructor<cn.nukkit.item.Item>): void
        public registerNamespacedIdItem(item: cn.nukkit.item.StringItem): void
        public registerNamespacedIdItem(item: java.lang.Class<cn.nukkit.item.StringItem>): void
        static itemSupplier(constructor: java.lang.reflect.Constructor<cn.nukkit.item.Item>): java.util.function.Supplier<cn.nukkit.item.Item>
        static lambda$itemSupplier$4(constructor: java.lang.reflect.Constructor): cn.nukkit.item.Item
        static lambda$getItemByNamespaceId$3(namespaceId: string): java.lang.IllegalArgumentException
        static lambda$getNetworkFullId$2(item: cn.nukkit.item.Item): java.lang.IllegalArgumentException
        static lambda$new$1(e: java.util.Map$Entry): java.util.AbstractMap$SimpleEntry
        static lambda$new$0(e: java.util.Map$Entry): java.util.AbstractMap$SimpleEntry
        static log: org.apache.logging.log4j.Logger
        entries: java.util.Collection<cn.nukkit.item.RuntimeItems$Entry>
        legacyNetworkMap: it.unimi.dsi.fastutil.ints.Int2IntMap
        networkLegacyMap: it.unimi.dsi.fastutil.ints.Int2IntMap
        itemDataPalette: byte[]
        namespaceNetworkMap: java.util.Map<string, java.util.OptionalInt>
        networkNamespaceMap: it.unimi.dsi.fastutil.ints.Int2ObjectMap<string>
        namespacedIdItem: java.util.Map<string, java.util.function.Supplier<cn.nukkit.item.Item>>
        customItemEntries: java.util.HashMap<string, cn.nukkit.item.RuntimeItems$Entry>

    }
}

declare module "cn.nukkit.item.RuntimeItemMapping" {
    declare const RuntimeItemMapping = cn.nukkit.item.RuntimeItemMapping;
}

declare namespace cn.nukkit.item {
    declare class ItemHelmetChain extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isHelmet(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemHelmetChain" {
    declare const ItemHelmetChain = cn.nukkit.item.ItemHelmetChain;
}

declare namespace cn.nukkit.item {
    declare class ItemFirework extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public canBeActivated(): boolean
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean
        public addExplosion(explosion: cn.nukkit.item.ItemFirework$FireworkExplosion): void
        public clearExplosions(): void
        spawnFirework(level: cn.nukkit.level.Level, pos: cn.nukkit.math.Vector3): void
        spawnElytraFirework(level: cn.nukkit.level.Level, pos: cn.nukkit.math.Vector3, player: cn.nukkit.Player): void

    }
}

declare module "cn.nukkit.item.ItemFirework" {
    declare const ItemFirework = cn.nukkit.item.ItemFirework;
}

declare namespace cn.nukkit.item {
    declare class ItemBookWritten extends cn.nukkit.item.ItemBookWritable {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int
        public writeBook(author: string, title: string, pages: string[]): cn.nukkit.item.Item
        public writeBook(author: string, title: string, pages: cn.nukkit.nbt.tag.ListTag<cn.nukkit.nbt.tag.CompoundTag>): cn.nukkit.item.Item
        public signBook(title: string, author: string, xuid: string, generation: int): boolean
        public getGeneration(): int
        public setGeneration(generation: int): void
        public getAuthor(): string
        public setAuthor(author: string): void
        public getTitle(): string
        public setTitle(title: string): void
        public getXUID(): string
        public setXUID(title: string): void
        public static GENERATION_ORIGINAL: int
        public static GENERATION_COPY: int
        public static GENERATION_COPY_OF_COPY: int
        public static GENERATION_TATTERED: int

    }
}

declare module "cn.nukkit.item.ItemBookWritten" {
    declare const ItemBookWritten = cn.nukkit.item.ItemBookWritten;
}

declare namespace cn.nukkit.item {
    declare class ItemShulkerShell extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemShulkerShell" {
    declare const ItemShulkerShell = cn.nukkit.item.ItemShulkerShell;
}

declare namespace cn.nukkit.item {
    declare class ItemWarpedFungusOnAStick extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int
        public getMaxDurability(): int
        public noDamageOnBreak(): boolean

    }
}

declare module "cn.nukkit.item.ItemWarpedFungusOnAStick" {
    declare const ItemWarpedFungusOnAStick = cn.nukkit.item.ItemWarpedFungusOnAStick;
}

declare namespace cn.nukkit.item {
    declare class ItemCarrotGolden extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemCarrotGolden" {
    declare const ItemCarrotGolden = cn.nukkit.item.ItemCarrotGolden;
}

declare namespace cn.nukkit.item {
    declare class ItemPickaxeNetherite extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isPickaxe(): boolean
        public getTier(): int
        public getAttackDamage(): int
        public isLavaResistant(): boolean

    }
}

declare module "cn.nukkit.item.ItemPickaxeNetherite" {
    declare const ItemPickaxeNetherite = cn.nukkit.item.ItemPickaxeNetherite;
}

declare namespace cn.nukkit.item {
    declare class ItemRecordMall extends cn.nukkit.item.ItemRecord {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getSoundId(): string

    }
}

declare module "cn.nukkit.item.ItemRecordMall" {
    declare const ItemRecordMall = cn.nukkit.item.ItemRecordMall;
}

declare namespace cn.nukkit.item {
    declare class ItemLeggingsGold extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isLeggings(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemLeggingsGold" {
    declare const ItemLeggingsGold = cn.nukkit.item.ItemLeggingsGold;
}

declare namespace cn.nukkit.item {
    declare class ItemChestplateNetherite extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isChestplate(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int
        public getToughness(): int
        public isLavaResistant(): boolean

    }
}

declare module "cn.nukkit.item.ItemChestplateNetherite" {
    declare const ItemChestplateNetherite = cn.nukkit.item.ItemChestplateNetherite;
}

declare namespace cn.nukkit.item {
    declare class ItemEmerald extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemEmerald" {
    declare const ItemEmerald = cn.nukkit.item.ItemEmerald;
}

declare namespace cn.nukkit.item {
    declare class ItemRecordBlocks extends cn.nukkit.item.ItemRecord {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getSoundId(): string

    }
}

declare module "cn.nukkit.item.ItemRecordBlocks" {
    declare const ItemRecordBlocks = cn.nukkit.item.ItemRecordBlocks;
}

declare namespace cn.nukkit.item {
    declare class ItemSaddle extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemSaddle" {
    declare const ItemSaddle = cn.nukkit.item.ItemSaddle;
}

declare namespace cn.nukkit.item {
    declare class ItemFlowerPot extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemFlowerPot" {
    declare const ItemFlowerPot = cn.nukkit.item.ItemFlowerPot;
}

declare namespace cn.nukkit.item {
    declare class ItemSalmon extends cn.nukkit.item.ItemFish {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemSalmon" {
    declare const ItemSalmon = cn.nukkit.item.ItemSalmon;
}

declare namespace cn.nukkit.item {
    declare class ItemBootsLeather extends cn.nukkit.item.ItemColorArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isBoots(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemBootsLeather" {
    declare const ItemBootsLeather = cn.nukkit.item.ItemBootsLeather;
}

declare namespace cn.nukkit.item {
    declare interface ItemID {
        public static STRING_IDENTIFIED_ITEM: int
        public static IRON_SHOVEL: int
        public static IRON_PICKAXE: int
        public static IRON_AXE: int
        public static FLINT_STEEL: int
        public static FLINT_AND_STEEL: int
        public static APPLE: int
        public static BOW: int
        public static ARROW: int
        public static COAL: int
        public static DIAMOND: int
        public static IRON_INGOT: int
        public static GOLD_INGOT: int
        public static IRON_SWORD: int
        public static WOODEN_SWORD: int
        public static WOODEN_SHOVEL: int
        public static WOODEN_PICKAXE: int
        public static WOODEN_AXE: int
        public static STONE_SWORD: int
        public static STONE_SHOVEL: int
        public static STONE_PICKAXE: int
        public static STONE_AXE: int
        public static DIAMOND_SWORD: int
        public static DIAMOND_SHOVEL: int
        public static DIAMOND_PICKAXE: int
        public static DIAMOND_AXE: int
        public static STICK: int
        public static STICKS: int
        public static BOWL: int
        public static MUSHROOM_STEW: int
        public static GOLD_SWORD: int
        public static GOLDEN_SWORD: int
        public static GOLD_SHOVEL: int
        public static GOLDEN_SHOVEL: int
        public static GOLD_PICKAXE: int
        public static GOLDEN_PICKAXE: int
        public static GOLD_AXE: int
        public static GOLDEN_AXE: int
        public static STRING: int
        public static FEATHER: int
        public static GUNPOWDER: int
        public static WOODEN_HOE: int
        public static STONE_HOE: int
        public static IRON_HOE: int
        public static DIAMOND_HOE: int
        public static GOLD_HOE: int
        public static GOLDEN_HOE: int
        public static SEEDS: int
        public static WHEAT_SEEDS: int
        public static WHEAT: int
        public static BREAD: int
        public static LEATHER_CAP: int
        public static LEATHER_TUNIC: int
        public static LEATHER_PANTS: int
        public static LEATHER_BOOTS: int
        public static CHAIN_HELMET: int
        public static CHAIN_CHESTPLATE: int
        public static CHAIN_LEGGINGS: int
        public static CHAIN_BOOTS: int
        public static IRON_HELMET: int
        public static IRON_CHESTPLATE: int
        public static IRON_LEGGINGS: int
        public static IRON_BOOTS: int
        public static DIAMOND_HELMET: int
        public static DIAMOND_CHESTPLATE: int
        public static DIAMOND_LEGGINGS: int
        public static DIAMOND_BOOTS: int
        public static GOLD_HELMET: int
        public static GOLD_CHESTPLATE: int
        public static GOLD_LEGGINGS: int
        public static GOLD_BOOTS: int
        public static FLINT: int
        public static RAW_PORKCHOP: int
        public static COOKED_PORKCHOP: int
        public static PAINTING: int
        public static GOLDEN_APPLE: int
        public static SIGN: int
        public static WOODEN_DOOR: int
        public static BUCKET: int
        public static MINECART: int
        public static SADDLE: int
        public static IRON_DOOR: int
        public static REDSTONE: int
        public static REDSTONE_DUST: int
        public static SNOWBALL: int
        public static BOAT: int
        public static LEATHER: int
        public static KELP: int
        public static BRICK: int
        public static CLAY: int
        public static SUGARCANE: int
        public static SUGAR_CANE: int
        public static SUGAR_CANES: int
        public static PAPER: int
        public static BOOK: int
        public static SLIMEBALL: int
        public static MINECART_WITH_CHEST: int
        public static EGG: int
        public static COMPASS: int
        public static FISHING_ROD: int
        public static CLOCK: int
        public static GLOWSTONE_DUST: int
        public static RAW_FISH: int
        public static COOKED_FISH: int
        public static DYE: int
        public static BONE: int
        public static SUGAR: int
        public static CAKE: int
        public static BED: int
        public static REPEATER: int
        public static COOKIE: int
        public static MAP: int
        public static SHEARS: int
        public static MELON: int
        public static MELON_SLICE: int
        public static PUMPKIN_SEEDS: int
        public static MELON_SEEDS: int
        public static RAW_BEEF: int
        public static STEAK: int
        public static COOKED_BEEF: int
        public static RAW_CHICKEN: int
        public static COOKED_CHICKEN: int
        public static ROTTEN_FLESH: int
        public static ENDER_PEARL: int
        public static BLAZE_ROD: int
        public static GHAST_TEAR: int
        public static GOLD_NUGGET: int
        public static GOLDEN_NUGGET: int
        public static NETHER_WART: int
        public static POTION: int
        public static GLASS_BOTTLE: int
        public static BOTTLE: int
        public static SPIDER_EYE: int
        public static FERMENTED_SPIDER_EYE: int
        public static BLAZE_POWDER: int
        public static MAGMA_CREAM: int
        public static BREWING_STAND: int
        public static BREWING: int
        public static CAULDRON: int
        public static ENDER_EYE: int
        public static GLISTERING_MELON: int
        public static SPAWN_EGG: int
        public static EXPERIENCE_BOTTLE: int
        public static FIRE_CHARGE: int
        public static BOOK_AND_QUILL: int
        public static WRITTEN_BOOK: int
        public static EMERALD: int
        public static ITEM_FRAME: int
        public static FLOWER_POT: int
        public static CARROT: int
        public static CARROTS: int
        public static POTATO: int
        public static POTATOES: int
        public static BAKED_POTATO: int
        public static BAKED_POTATOES: int
        public static POISONOUS_POTATO: int
        public static EMPTY_MAP: int
        public static GOLDEN_CARROT: int
        public static SKULL: int
        public static CARROT_ON_A_STICK: int
        public static NETHER_STAR: int
        public static PUMPKIN_PIE: int
        public static FIREWORKS: int
        public static FIREWORKSCHARGE: int
        public static ENCHANTED_BOOK: int
        public static ENCHANT_BOOK: int
        public static COMPARATOR: int
        public static NETHER_BRICK: int
        public static QUARTZ: int
        public static NETHER_QUARTZ: int
        public static MINECART_WITH_TNT: int
        public static MINECART_WITH_HOPPER: int
        public static PRISMARINE_SHARD: int
        public static HOPPER: int
        public static RAW_RABBIT: int
        public static COOKED_RABBIT: int
        public static RABBIT_STEW: int
        public static RABBIT_FOOT: int
        public static RABBIT_HIDE: int
        public static LEATHER_HORSE_ARMOR: int
        public static IRON_HORSE_ARMOR: int
        public static GOLD_HORSE_ARMOR: int
        public static DIAMOND_HORSE_ARMOR: int
        public static LEAD: int
        public static NAME_TAG: int
        public static PRISMARINE_CRYSTALS: int
        public static RAW_MUTTON: int
        public static COOKED_MUTTON: int
        public static ARMOR_STAND: int
        public static END_CRYSTAL: int
        public static SPRUCE_DOOR: int
        public static BIRCH_DOOR: int
        public static JUNGLE_DOOR: int
        public static ACACIA_DOOR: int
        public static DARK_OAK_DOOR: int
        public static CHORUS_FRUIT: int
        public static POPPED_CHORUS_FRUIT: int
        public static BANNER_PATTERN: int
        public static DRAGON_BREATH: int
        public static SPLASH_POTION: int
        public static LINGERING_POTION: int
        public static COMMAND_BLOCK_MINECART: int
        public static ELYTRA: int
        public static SHULKER_SHELL: int
        public static BANNER: int
        public static TOTEM: int
        public static IRON_NUGGET: int
        public static TRIDENT: int
        public static BEETROOT: int
        public static BEETROOT_SEEDS: int
        public static BEETROOT_SEED: int
        public static BEETROOT_SOUP: int
        public static RAW_SALMON: int
        public static CLOWNFISH: int
        public static PUFFERFISH: int
        public static COOKED_SALMON: int
        public static DRIED_KELP: int
        public static NAUTILUS_SHELL: int
        public static GOLDEN_APPLE_ENCHANTED: int
        public static HEART_OF_THE_SEA: int
        public static SCUTE: int
        public static TURTLE_SHELL: int
        public static PHANTOM_MEMBRANE: int
        public static CROSSBOW: int
        public static SPRUCE_SIGN: int
        public static BIRCH_SIGN: int
        public static JUNGLE_SIGN: int
        public static ACACIA_SIGN: int
        public static DARKOAK_SIGN: int
        public static DARK_OAK_SIGN: int
        public static SWEET_BERRIES: int
        public static RECORD_13: int
        public static RECORD_CAT: int
        public static RECORD_BLOCKS: int
        public static RECORD_CHIRP: int
        public static RECORD_FAR: int
        public static RECORD_MALL: int
        public static RECORD_MELLOHI: int
        public static RECORD_STAL: int
        public static RECORD_STRAD: int
        public static RECORD_WARD: int
        public static RECORD_11: int
        public static RECORD_WAIT: int
        public static SHIELD: int
        public static GLOW_ITEM_FRAME: int
        public static ITEM_MANGROVE_DOOR: int
        public static MANGROVE_SIGN: int
        public static GLOW_BERRIES: int
        public static CAMPFIRE: int
        public static SUSPICIOUS_STEW: int
        public static HONEYCOMB: int
        public static HONEY_BOTTLE: int
        public static LODESTONECOMPASS: int
        public static LODESTONE_COMPASS: int
        public static NETHERITE_INGOT: int
        public static NETHERITE_SWORD: int
        public static NETHERITE_SHOVEL: int
        public static NETHERITE_PICKAXE: int
        public static NETHERITE_AXE: int
        public static NETHERITE_HOE: int
        public static NETHERITE_HELMET: int
        public static NETHERITE_CHESTPLATE: int
        public static NETHERITE_LEGGINGS: int
        public static NETHERITE_BOOTS: int
        public static NETHERITE_SCRAP: int
        public static CRIMSON_SIGN: int
        public static WARPED_SIGN: int
        public static CRIMSON_DOOR: int
        public static WARPED_DOOR: int
        public static WARPED_FUNGUS_ON_A_STICK: int
        public static CHAIN: int
        public static RECORD_PIGSTEP: int
        public static NETHER_SPROUTS: int
        public static AMETHYST_SHARD: int
        public static SPYGLASS: int
        public static RECORD_OTHERSIDE: int
        public static SOUL_CAMPFIRE: int

    }
}

declare module "cn.nukkit.item.ItemID" {
    declare type ItemID = cn.nukkit.item.ItemID;
}

declare namespace cn.nukkit.item {
    declare class ItemRedstoneComparator extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemRedstoneComparator" {
    declare const ItemRedstoneComparator = cn.nukkit.item.ItemRedstoneComparator;
}

declare namespace cn.nukkit.item {
    declare class ItemFlint extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemFlint" {
    declare const ItemFlint = cn.nukkit.item.ItemFlint;
}

declare namespace cn.nukkit.item {
    declare class ItemSpruceSign extends cn.nukkit.item.ItemSign {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemSpruceSign" {
    declare const ItemSpruceSign = cn.nukkit.item.ItemSpruceSign;
}

declare namespace cn.nukkit.item {
    declare class ItemRecordFar extends cn.nukkit.item.ItemRecord {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getSoundId(): string

    }
}

declare module "cn.nukkit.item.ItemRecordFar" {
    declare const ItemRecordFar = cn.nukkit.item.ItemRecordFar;
}

declare namespace cn.nukkit.item {
    declare class ItemDoorAcacia extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemDoorAcacia" {
    declare const ItemDoorAcacia = cn.nukkit.item.ItemDoorAcacia;
}

declare namespace cn.nukkit.item {
    declare class ItemAxeGold extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isAxe(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemAxeGold" {
    declare const ItemAxeGold = cn.nukkit.item.ItemAxeGold;
}

declare namespace cn.nukkit.item {
    declare class ItemBookEnchanted extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int
        public applyEnchantments(): boolean

    }
}

declare module "cn.nukkit.item.ItemBookEnchanted" {
    declare const ItemBookEnchanted = cn.nukkit.item.ItemBookEnchanted;
}

declare namespace cn.nukkit.item {
    declare class ItemAxeDiamond extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isAxe(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemAxeDiamond" {
    declare const ItemAxeDiamond = cn.nukkit.item.ItemAxeDiamond;
}

declare namespace cn.nukkit.item {
    declare class ItemElytra extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isArmor(): boolean
        public isChestplate(): boolean

    }
}

declare module "cn.nukkit.item.ItemElytra" {
    declare const ItemElytra = cn.nukkit.item.ItemElytra;
}

declare namespace cn.nukkit.item {
    declare class ItemBlock extends cn.nukkit.item.Item {
        public constructor(block: cn.nukkit.block.Block): void
        public constructor(block: cn.nukkit.block.Block, meta: int): void
        public constructor(block: cn.nukkit.block.Block, meta: int, count: int): void
        public setDamage(meta: int): void
        public clone(): cn.nukkit.item.ItemBlock
        public getBlock(): cn.nukkit.block.Block
        public isLavaResistant(): boolean
        public getNamespaceId(): string
        public clone(): cn.nukkit.item.Item
        public clone(): java.lang.Object
        static log: org.apache.logging.log4j.Logger

    }
}

declare module "cn.nukkit.item.ItemBlock" {
    declare const ItemBlock = cn.nukkit.item.ItemBlock;
}

declare namespace cn.nukkit.item {
    declare class ItemPotion extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public setDamage(meta: int): void
        updateName(): void
        static buildName(potionId: int, type: string, includeLevel: boolean): string
        public getMaxStackSize(): int
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean
        public onUse(player: cn.nukkit.Player, ticksUsed: int): boolean
        public getPotion(): cn.nukkit.potion.Potion
        static getPotion(damage: int): cn.nukkit.potion.Potion
        public static NO_EFFECTS: int
        public static MUNDANE: int
        public static MUNDANE_II: int
        public static THICK: int
        public static AWKWARD: int
        public static NIGHT_VISION: int
        public static NIGHT_VISION_LONG: int
        public static INVISIBLE: int
        public static INVISIBLE_LONG: int
        public static LEAPING: int
        public static LEAPING_LONG: int
        public static LEAPING_II: int
        public static FIRE_RESISTANCE: int
        public static FIRE_RESISTANCE_LONG: int
        public static SPEED: int
        public static SPEED_LONG: int
        public static SPEED_II: int
        public static SLOWNESS: int
        public static SLOWNESS_LONG: int
        public static WATER_BREATHING: int
        public static WATER_BREATHING_LONG: int
        public static INSTANT_HEALTH: int
        public static INSTANT_HEALTH_II: int
        public static HARMING: int
        public static HARMING_II: int
        public static POISON: int
        public static POISON_LONG: int
        public static POISON_II: int
        public static REGENERATION: int
        public static REGENERATION_LONG: int
        public static REGENERATION_II: int
        public static STRENGTH: int
        public static STRENGTH_LONG: int
        public static STRENGTH_II: int
        public static WEAKNESS: int
        public static WEAKNESS_LONG: int
        public static DECAY: int

    }
}

declare module "cn.nukkit.item.ItemPotion" {
    declare const ItemPotion = cn.nukkit.item.ItemPotion;
}

declare namespace cn.nukkit.item {
    declare class ItemBook extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getEnchantAbility(): int

    }
}

declare module "cn.nukkit.item.ItemBook" {
    declare const ItemBook = cn.nukkit.item.ItemBook;
}

declare namespace cn.nukkit.item {
    declare class ItemCarrot extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemCarrot" {
    declare const ItemCarrot = cn.nukkit.item.ItemCarrot;
}

declare namespace cn.nukkit.item {
    declare class ItemSugarcane extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemSugarcane" {
    declare const ItemSugarcane = cn.nukkit.item.ItemSugarcane;
}

declare namespace cn.nukkit.item {
    declare class ItemBeefRaw extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemBeefRaw" {
    declare const ItemBeefRaw = cn.nukkit.item.ItemBeefRaw;
}

declare namespace cn.nukkit.item {
    declare class ItemRecordStal extends cn.nukkit.item.ItemRecord {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getSoundId(): string

    }
}

declare module "cn.nukkit.item.ItemRecordStal" {
    declare const ItemRecordStal = cn.nukkit.item.ItemRecordStal;
}

declare namespace cn.nukkit.item {
    declare class ItemSteak extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemSteak" {
    declare const ItemSteak = cn.nukkit.item.ItemSteak;
}

declare namespace cn.nukkit.item {
    declare class ItemApple extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemApple" {
    declare const ItemApple = cn.nukkit.item.ItemApple;
}

declare namespace cn.nukkit.item {
    declare class ItemArmorStand extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public canBeActivated(): boolean
        public getMaxStackSize(): int
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean
        removeForPlacement(block: cn.nukkit.block.Block): boolean

    }
}

declare module "cn.nukkit.item.ItemArmorStand" {
    declare const ItemArmorStand = cn.nukkit.item.ItemArmorStand;
}

declare namespace cn.nukkit.item {
    declare class ItemHoneyBottle extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean
        public onUse(player: cn.nukkit.Player, ticksUsed: int): boolean

    }
}

declare module "cn.nukkit.item.ItemHoneyBottle" {
    declare const ItemHoneyBottle = cn.nukkit.item.ItemHoneyBottle;
}

declare namespace cn.nukkit.item {
    declare class ItemSwordIron extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isSword(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemSwordIron" {
    declare const ItemSwordIron = cn.nukkit.item.ItemSwordIron;
}

declare namespace cn.nukkit.item {
    declare class ItemFireworkStar extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemFireworkStar" {
    declare const ItemFireworkStar = cn.nukkit.item.ItemFireworkStar;
}

declare namespace cn.nukkit.item {
    declare class ItemLeggingsNetherite extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public isLeggings(): boolean
        public getTier(): int
        public getArmorPoints(): int
        public getMaxDurability(): int
        public getToughness(): int
        public isLavaResistant(): boolean

    }
}

declare module "cn.nukkit.item.ItemLeggingsNetherite" {
    declare const ItemLeggingsNetherite = cn.nukkit.item.ItemLeggingsNetherite;
}

declare namespace cn.nukkit.item {
    declare class ItemNetherBrick extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemNetherBrick" {
    declare const ItemNetherBrick = cn.nukkit.item.ItemNetherBrick;
}

declare namespace cn.nukkit.item {
    declare class ItemSnowball extends cn.nukkit.item.ProjectileItem {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int
        public getProjectileEntityType(): string
        public getThrowForce(): float

    }
}

declare module "cn.nukkit.item.ItemSnowball" {
    declare const ItemSnowball = cn.nukkit.item.ItemSnowball;
}

declare namespace cn.nukkit.item {
    declare class ItemGhastTear extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemGhastTear" {
    declare const ItemGhastTear = cn.nukkit.item.ItemGhastTear;
}

declare namespace cn.nukkit.item {
    declare class ItemChestplateChain extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isChestplate(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemChestplateChain" {
    declare const ItemChestplateChain = cn.nukkit.item.ItemChestplateChain;
}

declare namespace cn.nukkit.item {
    declare class ItemBeetroot extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemBeetroot" {
    declare const ItemBeetroot = cn.nukkit.item.ItemBeetroot;
}

declare namespace cn.nukkit.item {
    declare class ItemArmor extends cn.nukkit.item.Item implements cn.nukkit.item.ItemDurable {
        public constructor(id: int): void
        public constructor(id: int, meta: int): void
        public constructor(id: int, meta: int, count: int): void
        public constructor(id: int, meta: int, count: int, name: string): void
        public getMaxStackSize(): int
        public isArmor(): boolean
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean
        public getEnchantAbility(): int
        public isUnbreakable(): boolean
        public static TIER_LEATHER: int
        public static TIER_IRON: int
        public static TIER_CHAIN: int
        public static TIER_GOLD: int
        public static TIER_DIAMOND: int
        public static TIER_NETHERITE: int
        public static TIER_OTHER: int

    }
}

declare module "cn.nukkit.item.ItemArmor" {
    declare const ItemArmor = cn.nukkit.item.ItemArmor;
}

declare namespace cn.nukkit.item {
    declare class ItemChestplateGold extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isChestplate(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemChestplateGold" {
    declare const ItemChestplateGold = cn.nukkit.item.ItemChestplateGold;
}

declare namespace cn.nukkit.item {
    declare class ItemFishCooked extends cn.nukkit.item.ItemFish {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemFishCooked" {
    declare const ItemFishCooked = cn.nukkit.item.ItemFishCooked;
}

declare namespace cn.nukkit.item {
    declare class ItemPickaxeDiamond extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isPickaxe(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemPickaxeDiamond" {
    declare const ItemPickaxeDiamond = cn.nukkit.item.ItemPickaxeDiamond;
}

declare namespace cn.nukkit.item {
    declare class ItemShovelGold extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isShovel(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemShovelGold" {
    declare const ItemShovelGold = cn.nukkit.item.ItemShovelGold;
}

declare namespace cn.nukkit.item {
    declare class ItemMinecartTNT extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public canBeActivated(): boolean
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemMinecartTNT" {
    declare const ItemMinecartTNT = cn.nukkit.item.ItemMinecartTNT;
}

declare namespace cn.nukkit.item {
    declare class ItemAxeWood extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxDurability(): int
        public isAxe(): boolean
        public getTier(): int
        public getAttackDamage(): int

    }
}

declare module "cn.nukkit.item.ItemAxeWood" {
    declare const ItemAxeWood = cn.nukkit.item.ItemAxeWood;
}

declare namespace cn.nukkit.item {
    declare class ItemBootsNetherite extends cn.nukkit.item.ItemArmor {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getTier(): int
        public isBoots(): boolean
        public getArmorPoints(): int
        public getMaxDurability(): int
        public getToughness(): int
        public isLavaResistant(): boolean

    }
}

declare module "cn.nukkit.item.ItemBootsNetherite" {
    declare const ItemBootsNetherite = cn.nukkit.item.ItemBootsNetherite;
}

declare namespace cn.nukkit.item {
    declare class ItemNautilusShell extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemNautilusShell" {
    declare const ItemNautilusShell = cn.nukkit.item.ItemNautilusShell;
}

declare namespace cn.nukkit.item {
    declare class ItemHeartOfTheSea extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemHeartOfTheSea" {
    declare const ItemHeartOfTheSea = cn.nukkit.item.ItemHeartOfTheSea;
}

declare namespace cn.nukkit.item {
    declare class ItemFireCharge extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public canBeActivated(): boolean
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean

    }
}

declare module "cn.nukkit.item.ItemFireCharge" {
    declare const ItemFireCharge = cn.nukkit.item.ItemFireCharge;
}

declare namespace cn.nukkit.item {
    declare class ItemSign extends cn.nukkit.item.Item {
        public constructor(): void
        public constructor(meta: int): void
        constructor(id: int, meta: int, count: int, name: string, block: cn.nukkit.block.BlockSignPost): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int

    }
}

declare module "cn.nukkit.item.ItemSign" {
    declare const ItemSign = cn.nukkit.item.ItemSign;
}

declare namespace cn.nukkit.item {
    declare class ItemAppleGoldEnchanted extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean

    }
}

declare module "cn.nukkit.item.ItemAppleGoldEnchanted" {
    declare const ItemAppleGoldEnchanted = cn.nukkit.item.ItemAppleGoldEnchanted;
}

declare namespace cn.nukkit.item {
    declare class ItemShield extends cn.nukkit.item.ItemTool {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void
        public getMaxStackSize(): int
        public getMaxDurability(): int

    }
}

declare module "cn.nukkit.item.ItemShield" {
    declare const ItemShield = cn.nukkit.item.ItemShield;
}

declare namespace cn.nukkit.item {
    declare class RuntimeItems$Entry extends java.lang.Object {
        public toString(): string
        public constructor(): void
        public constructor(name: string, id: int, oldId: int, oldData: int, deprecated: boolean, isComponentItem: boolean): void
        name: string
        id: int
        oldId: int
        oldData: int
        deprecated: boolean
        isComponentItem: boolean

    }
}

declare module "cn.nukkit.item.RuntimeItems$Entry" {
    declare const RuntimeItems$Entry = cn.nukkit.item.RuntimeItems$Entry;
}

declare namespace cn.nukkit.item {
    declare class ItemCookie extends cn.nukkit.item.ItemEdible {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(meta: int, count: int): void

    }
}

declare module "cn.nukkit.item.ItemCookie" {
    declare const ItemCookie = cn.nukkit.item.ItemCookie;
}

declare namespace cn.nukkit.permission {
    declare class BanList extends java.lang.Object {
        public constructor(file: string): void
        public isEnable(): boolean
        public setEnable(enable: boolean): void
        public getEntires(): java.util.LinkedHashMap<string, cn.nukkit.permission.BanEntry>
        public isBanned(name: string): boolean
        public add(entry: cn.nukkit.permission.BanEntry): void
        public addBan(target: string): cn.nukkit.permission.BanEntry
        public addBan(target: string, reason: string): cn.nukkit.permission.BanEntry
        public addBan(target: string, reason: string, expireDate: java.util.Date): cn.nukkit.permission.BanEntry
        public addBan(target: string, reason: string, expireDate: java.util.Date, source: string): cn.nukkit.permission.BanEntry
        public remove(name: string): void
        public removeExpired(): void
        public load(): void
        public save(): void
        static log: org.apache.logging.log4j.Logger
        list: java.util.LinkedHashMap<string, cn.nukkit.permission.BanEntry>
        file: string
        enable: boolean

    }
}

declare module "cn.nukkit.permission.BanList" {
    declare const BanList = cn.nukkit.permission.BanList;
}

declare namespace cn.nukkit.permission {
    declare class BanEntry$1 extends com.google.gson.reflect.TypeToken {
        constructor(): void

    }
}

declare module "cn.nukkit.permission.BanEntry$1" {
    declare const BanEntry$1 = cn.nukkit.permission.BanEntry$1;
}

declare namespace cn.nukkit.permission {
    declare interface ServerOperator {
        public isOp(): boolean
        public setOp(var0: boolean): void

    }
}

declare module "cn.nukkit.permission.ServerOperator" {
    declare type ServerOperator = cn.nukkit.permission.ServerOperator;
}

declare namespace cn.nukkit.permission {
    declare class PermissibleBase extends java.lang.Object implements cn.nukkit.permission.Permissible {
        public constructor(opable: cn.nukkit.permission.ServerOperator): void
        public isOp(): boolean
        public setOp(value: boolean): void
        public isPermissionSet(name: string): boolean
        public isPermissionSet(permission: cn.nukkit.permission.Permission): boolean
        public hasPermission(name: string): boolean
        public hasPermission(permission: cn.nukkit.permission.Permission): boolean
        public addAttachment(plugin: cn.nukkit.plugin.Plugin): cn.nukkit.permission.PermissionAttachment
        public addAttachment(plugin: cn.nukkit.plugin.Plugin, name: string): cn.nukkit.permission.PermissionAttachment
        public addAttachment(plugin: cn.nukkit.plugin.Plugin, name: string, value: boolean): cn.nukkit.permission.PermissionAttachment
        public removeAttachment(attachment: cn.nukkit.permission.PermissionAttachment): void
        public recalculatePermissions(): void
        public clearPermissions(): void
        calculateChildPermissions(children: java.util.Map<string, boolean>, invert: boolean, attachment: cn.nukkit.permission.PermissionAttachment): void
        public getEffectivePermissions(): java.util.Map<string, cn.nukkit.permission.PermissionAttachmentInfo>
        opable: cn.nukkit.permission.ServerOperator
        parent: cn.nukkit.permission.Permissible
        attachments: java.util.Set<cn.nukkit.permission.PermissionAttachment>
        permissions: java.util.Map<string, cn.nukkit.permission.PermissionAttachmentInfo>

    }
}

declare module "cn.nukkit.permission.PermissibleBase" {
    declare const PermissibleBase = cn.nukkit.permission.PermissibleBase;
}

declare namespace cn.nukkit.permission {
    declare class Permission extends java.lang.Object {
        public static getByName(value: string): string
        public constructor(name: string): void
        public constructor(name: string, description: string): void
        public constructor(name: string, description: string, defualtValue: string): void
        public constructor(name: string, description: string, defualtValue: string, children: java.util.Map<string, boolean>): void
        public getName(): string
        public getChildren(): java.util.Map<string, boolean>
        public getDefault(): string
        public setDefault(value: string): void
        public getDescription(): string
        public setDescription(description: string): void
        public getPermissibles(): java.util.Set<cn.nukkit.permission.Permissible>
        public recalculatePermissibles(): void
        public addParent(permission: cn.nukkit.permission.Permission, value: boolean): void
        public addParent(name: string, value: boolean): cn.nukkit.permission.Permission
        public static loadPermissions(data: java.util.Map<string, java.lang.Object>): java.util.List<cn.nukkit.permission.Permission>
        public static loadPermissions(data: java.util.Map<string, java.lang.Object>, defaultValue: string): java.util.List<cn.nukkit.permission.Permission>
        public static loadPermission(name: string, data: java.util.Map<string, java.lang.Object>): cn.nukkit.permission.Permission
        public static loadPermission(name: string, data: java.util.Map<string, java.lang.Object>, defaultValue: string): cn.nukkit.permission.Permission
        public static loadPermission(name: string, data: java.util.Map<string, java.lang.Object>, defaultValue: string, output: java.util.List<cn.nukkit.permission.Permission>): cn.nukkit.permission.Permission
        public static DEFAULT_OP: string
        public static DEFAULT_NOT_OP: string
        public static DEFAULT_TRUE: string
        public static DEFAULT_FALSE: string
        public static DEFAULT_PERMISSION: string
        name: string
        description: string
        children: java.util.Map<string, boolean>
        defaultValue: string

    }
}

declare module "cn.nukkit.permission.Permission" {
    declare const Permission = cn.nukkit.permission.Permission;
}

declare namespace cn.nukkit.permission {
    declare class BanEntry extends java.lang.Object {
        public constructor(name: string): void
        public getName(): string
        public getCreationDate(): java.util.Date
        public setCreationDate(creationDate: java.util.Date): void
        public getSource(): string
        public setSource(source: string): void
        public getExpirationDate(): java.util.Date
        public setExpirationDate(expirationDate: java.util.Date): void
        public hasExpired(): boolean
        public getReason(): string
        public setReason(reason: string): void
        public getMap(): java.util.LinkedHashMap<string, string>
        public static fromMap(map: java.util.Map<string, string>): cn.nukkit.permission.BanEntry
        public getString(): string
        public static fromString(str: string): cn.nukkit.permission.BanEntry
        static log: org.apache.logging.log4j.Logger
        public static format: string
        name: string
        creationDate: java.util.Date
        source: string
        expirationDate: java.util.Date
        reason: string

    }
}

declare module "cn.nukkit.permission.BanEntry" {
    declare const BanEntry = cn.nukkit.permission.BanEntry;
}

declare namespace cn.nukkit.permission {
    declare interface PermissionRemovedExecutor {
        public attachmentRemoved(var0: cn.nukkit.permission.PermissionAttachment): void

    }
}

declare module "cn.nukkit.permission.PermissionRemovedExecutor" {
    declare type PermissionRemovedExecutor = cn.nukkit.permission.PermissionRemovedExecutor;
}

declare namespace cn.nukkit.permission {
    declare class PermissionAttachmentInfo extends java.lang.Object {
        public constructor(permissible: cn.nukkit.permission.Permissible, permission: string, attachment: cn.nukkit.permission.PermissionAttachment, value: boolean): void
        public getPermissible(): cn.nukkit.permission.Permissible
        public getPermission(): string
        public getAttachment(): cn.nukkit.permission.PermissionAttachment
        public getValue(): boolean
        permissible: cn.nukkit.permission.Permissible
        permission: string
        attachment: cn.nukkit.permission.PermissionAttachment
        value: boolean

    }
}

declare module "cn.nukkit.permission.PermissionAttachmentInfo" {
    declare const PermissionAttachmentInfo = cn.nukkit.permission.PermissionAttachmentInfo;
}

declare namespace cn.nukkit.permission {
    declare class BanList$1 extends com.google.gson.reflect.TypeToken {
        constructor(this$0: cn.nukkit.permission.BanList): void
        this$0: cn.nukkit.permission.BanList

    }
}

declare module "cn.nukkit.permission.BanList$1" {
    declare const BanList$1 = cn.nukkit.permission.BanList$1;
}

declare namespace cn.nukkit.permission {
    declare class DefaultPermissions extends java.lang.Object {
        public constructor(): void
        public static registerPermission(perm: cn.nukkit.permission.Permission): cn.nukkit.permission.Permission
        public static registerPermission(perm: cn.nukkit.permission.Permission, parent: cn.nukkit.permission.Permission): cn.nukkit.permission.Permission
        public static registerCorePermissions(): void
        public static ROOT: string

    }
}

declare module "cn.nukkit.permission.DefaultPermissions" {
    declare const DefaultPermissions = cn.nukkit.permission.DefaultPermissions;
}

declare namespace cn.nukkit.permission {
    declare class PermissionAttachment extends java.lang.Object {
        public constructor(plugin: cn.nukkit.plugin.Plugin, permissible: cn.nukkit.permission.Permissible): void
        public getPlugin(): cn.nukkit.plugin.Plugin
        public setRemovalCallback(executor: cn.nukkit.permission.PermissionRemovedExecutor): void
        public getRemovalCallback(): cn.nukkit.permission.PermissionRemovedExecutor
        public getPermissions(): java.util.Map<string, boolean>
        public clearPermissions(): void
        public setPermissions(permissions: java.util.Map<string, boolean>): void
        public unsetPermissions(permissions: java.util.List<string>): void
        public setPermission(permission: cn.nukkit.permission.Permission, value: boolean): void
        public setPermission(name: string, value: boolean): void
        public unsetPermission(permission: cn.nukkit.permission.Permission, value: boolean): void
        public unsetPermission(name: string, value: boolean): void
        public remove(): void
        removed: cn.nukkit.permission.PermissionRemovedExecutor
        permissions: java.util.Map<string, boolean>
        permissible: cn.nukkit.permission.Permissible
        plugin: cn.nukkit.plugin.Plugin

    }
}

declare module "cn.nukkit.permission.PermissionAttachment" {
    declare const PermissionAttachment = cn.nukkit.permission.PermissionAttachment;
}

declare namespace cn.nukkit.permission {
    declare interface Permissible extends cn.nukkit.permission.ServerOperator {
        public isPermissionSet(var0: string): boolean
        public isPermissionSet(var0: cn.nukkit.permission.Permission): boolean
        public hasPermission(var0: string): boolean
        public hasPermission(var0: cn.nukkit.permission.Permission): boolean
        public addAttachment(var0: cn.nukkit.plugin.Plugin): cn.nukkit.permission.PermissionAttachment
        public addAttachment(var0: cn.nukkit.plugin.Plugin, var1: string): cn.nukkit.permission.PermissionAttachment
        public addAttachment(var0: cn.nukkit.plugin.Plugin, var1: string, var2: boolean): cn.nukkit.permission.PermissionAttachment
        public removeAttachment(var0: cn.nukkit.permission.PermissionAttachment): void
        public recalculatePermissions(): void
        public getEffectivePermissions(): java.util.Map<string, cn.nukkit.permission.PermissionAttachmentInfo>

    }
}

declare module "cn.nukkit.permission.Permissible" {
    declare type Permissible = cn.nukkit.permission.Permissible;
}

declare namespace cn.nukkit.dispenser {
    declare class ProjectileDispenseBehavior extends cn.nukkit.dispenser.DefaultDispenseBehavior {
        public constructor(entity: string): void
        public dispense(source: cn.nukkit.block.BlockDispenser, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item): cn.nukkit.item.Item
        getMotion(): double
        getAccuracy(): float
        getEntityType(): string
        correctNBT(nbt: cn.nukkit.nbt.tag.CompoundTag): void
        entityType: string

    }
}

declare module "cn.nukkit.dispenser.ProjectileDispenseBehavior" {
    declare const ProjectileDispenseBehavior = cn.nukkit.dispenser.ProjectileDispenseBehavior;
}

declare namespace cn.nukkit.dispenser {
    declare interface DispenseBehavior {
        public dispense(var0: cn.nukkit.block.BlockDispenser, var1: cn.nukkit.math.BlockFace, var2: cn.nukkit.item.Item): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.dispenser.DispenseBehavior" {
    declare type DispenseBehavior = cn.nukkit.dispenser.DispenseBehavior;
}

declare namespace cn.nukkit.dispenser {
    declare class BoatDispenseBehavior extends cn.nukkit.dispenser.DefaultDispenseBehavior {
        public constructor(): void
        public dispense(block: cn.nukkit.block.BlockDispenser, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.dispenser.BoatDispenseBehavior" {
    declare const BoatDispenseBehavior = cn.nukkit.dispenser.BoatDispenseBehavior;
}

declare namespace cn.nukkit.dispenser {
    declare class DispenseBehaviorRegister$1 extends cn.nukkit.dispenser.ProjectileDispenseBehavior {
        constructor(entity: string): void
        getMotion(): double

    }
}

declare module "cn.nukkit.dispenser.DispenseBehaviorRegister$1" {
    declare const DispenseBehaviorRegister$1 = cn.nukkit.dispenser.DispenseBehaviorRegister$1;
}

declare namespace cn.nukkit.dispenser {
    declare class DyeDispenseBehavior extends cn.nukkit.dispenser.DefaultDispenseBehavior {
        public constructor(): void
        public dispense(block: cn.nukkit.block.BlockDispenser, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.dispenser.DyeDispenseBehavior" {
    declare const DyeDispenseBehavior = cn.nukkit.dispenser.DyeDispenseBehavior;
}

declare namespace cn.nukkit.dispenser {
    declare class EmptyBucketDispenseBehavior extends cn.nukkit.dispenser.DefaultDispenseBehavior {
        public constructor(): void
        public dispense(block: cn.nukkit.block.BlockDispenser, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.dispenser.EmptyBucketDispenseBehavior" {
    declare const EmptyBucketDispenseBehavior = cn.nukkit.dispenser.EmptyBucketDispenseBehavior;
}

declare namespace cn.nukkit.dispenser {
    declare class FlintAndSteelDispenseBehavior extends cn.nukkit.dispenser.DefaultDispenseBehavior {
        public constructor(): void
        public dispense(block: cn.nukkit.block.BlockDispenser, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.dispenser.FlintAndSteelDispenseBehavior" {
    declare const FlintAndSteelDispenseBehavior = cn.nukkit.dispenser.FlintAndSteelDispenseBehavior;
}

declare namespace cn.nukkit.dispenser {
    declare class DropperDispenseBehavior extends cn.nukkit.dispenser.DefaultDispenseBehavior {
        public constructor(): void
        public dispense(block: cn.nukkit.block.BlockDispenser, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.dispenser.DropperDispenseBehavior" {
    declare const DropperDispenseBehavior = cn.nukkit.dispenser.DropperDispenseBehavior;
}

declare namespace cn.nukkit.dispenser {
    declare class DispenseBehaviorRegister$3 extends cn.nukkit.dispenser.ProjectileDispenseBehavior {
        constructor(entity: string): void
        getAccuracy(): float
        getMotion(): double

    }
}

declare module "cn.nukkit.dispenser.DispenseBehaviorRegister$3" {
    declare const DispenseBehaviorRegister$3 = cn.nukkit.dispenser.DispenseBehaviorRegister$3;
}

declare namespace cn.nukkit.dispenser {
    declare class TNTDispenseBehavior extends cn.nukkit.dispenser.DefaultDispenseBehavior {
        public constructor(): void
        public dispense(block: cn.nukkit.block.BlockDispenser, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.dispenser.TNTDispenseBehavior" {
    declare const TNTDispenseBehavior = cn.nukkit.dispenser.TNTDispenseBehavior;
}

declare namespace cn.nukkit.dispenser {
    declare class SpawnEggDispenseBehavior extends cn.nukkit.dispenser.DefaultDispenseBehavior {
        public constructor(): void
        public dispense(block: cn.nukkit.block.BlockDispenser, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.dispenser.SpawnEggDispenseBehavior" {
    declare const SpawnEggDispenseBehavior = cn.nukkit.dispenser.SpawnEggDispenseBehavior;
}

declare namespace cn.nukkit.dispenser {
    declare class ShulkerBoxDispenseBehavior extends cn.nukkit.dispenser.DefaultDispenseBehavior {
        public constructor(): void
        public dispense(block: cn.nukkit.block.BlockDispenser, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.dispenser.ShulkerBoxDispenseBehavior" {
    declare const ShulkerBoxDispenseBehavior = cn.nukkit.dispenser.ShulkerBoxDispenseBehavior;
}

declare namespace cn.nukkit.dispenser {
    declare class BucketDispenseBehavior extends cn.nukkit.dispenser.DefaultDispenseBehavior {
        public constructor(): void
        public dispense(block: cn.nukkit.block.BlockDispenser, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.dispenser.BucketDispenseBehavior" {
    declare const BucketDispenseBehavior = cn.nukkit.dispenser.BucketDispenseBehavior;
}

declare namespace cn.nukkit.dispenser {
    declare class DefaultDispenseBehavior extends java.lang.Object implements cn.nukkit.dispenser.DispenseBehavior {
        public constructor(): void
        public dispense(block: cn.nukkit.block.BlockDispenser, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item): cn.nukkit.item.Item
        getParticleMetadataForFace(face: cn.nukkit.math.BlockFace): int
        public success: boolean

    }
}

declare module "cn.nukkit.dispenser.DefaultDispenseBehavior" {
    declare const DefaultDispenseBehavior = cn.nukkit.dispenser.DefaultDispenseBehavior;
}

declare namespace cn.nukkit.dispenser {
    declare class DispenseBehaviorRegister extends java.lang.Object {
        public constructor(): void
        public static registerBehavior(itemId: int, behavior: cn.nukkit.dispenser.DispenseBehavior): void
        public static getBehavior(id: int): cn.nukkit.dispenser.DispenseBehavior
        public static removeDispenseBehavior(id: int): void
        public static init(): void
        static behaviors: java.util.Map<int, cn.nukkit.dispenser.DispenseBehavior>
        static defaultBehavior: cn.nukkit.dispenser.DispenseBehavior

    }
}

declare module "cn.nukkit.dispenser.DispenseBehaviorRegister" {
    declare const DispenseBehaviorRegister = cn.nukkit.dispenser.DispenseBehaviorRegister;
}

declare namespace cn.nukkit.dispenser {
    declare class DispenseBehaviorRegister$4 extends cn.nukkit.dispenser.ProjectileDispenseBehavior {
        constructor(entity: string): void
        getAccuracy(): float
        getMotion(): double

    }
}

declare module "cn.nukkit.dispenser.DispenseBehaviorRegister$4" {
    declare const DispenseBehaviorRegister$4 = cn.nukkit.dispenser.DispenseBehaviorRegister$4;
}

declare namespace cn.nukkit.dispenser {
    declare class FireworksDispenseBehavior extends cn.nukkit.dispenser.DefaultDispenseBehavior {
        public constructor(): void
        public dispense(block: cn.nukkit.block.BlockDispenser, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.dispenser.FireworksDispenseBehavior" {
    declare const FireworksDispenseBehavior = cn.nukkit.dispenser.FireworksDispenseBehavior;
}

declare namespace cn.nukkit.dispenser {
    declare class DispenseBehaviorRegister$2 extends cn.nukkit.dispenser.ProjectileDispenseBehavior {
        constructor(entity: string): void
        getAccuracy(): float
        getMotion(): double

    }
}

declare module "cn.nukkit.dispenser.DispenseBehaviorRegister$2" {
    declare const DispenseBehaviorRegister$2 = cn.nukkit.dispenser.DispenseBehaviorRegister$2;
}

declare namespace cn.nukkit.block {
    declare class BlockWoodStrippedOak extends cn.nukkit.block.BlockWoodStripped {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType

    }
}

declare module "cn.nukkit.block.BlockWoodStrippedOak" {
    declare const BlockWoodStrippedOak = cn.nukkit.block.BlockWoodStrippedOak;
}

declare namespace cn.nukkit.block {
    declare class BlockBricksBlackstonePolished extends cn.nukkit.block.BlockBlackstonePolished {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getHardness(): double

    }
}

declare module "cn.nukkit.block.BlockBricksBlackstonePolished" {
    declare const BlockBricksBlackstonePolished = cn.nukkit.block.BlockBricksBlackstonePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockDarkOakSignPost extends cn.nukkit.block.BlockSignPost {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getWallId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockDarkOakSignPost" {
    declare const BlockDarkOakSignPost = cn.nukkit.block.BlockDarkOakSignPost;
}

declare namespace cn.nukkit.block {
    declare class BlockPlanksCrimson extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockPlanksCrimson" {
    declare const BlockPlanksCrimson = cn.nukkit.block.BlockPlanksCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsCopperCutWeatheredWaxed extends cn.nukkit.block.BlockStairsCopperCutWeathered {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsCopperCutWeatheredWaxed" {
    declare const BlockStairsCopperCutWeatheredWaxed = cn.nukkit.block.BlockStairsCopperCutWeatheredWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabBrickBlackstonePolished extends cn.nukkit.block.BlockSlabBlackstonePolished {
        public constructor(): void
        public constructor(meta: int): void
        constructor(meta: int, doubleSlab: int): void
        public getId(): int
        public getSlabName(): string
        public getHardness(): double

    }
}

declare module "cn.nukkit.block.BlockSlabBrickBlackstonePolished" {
    declare const BlockSlabBrickBlackstonePolished = cn.nukkit.block.BlockSlabBrickBlackstonePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockObserver extends cn.nukkit.block.BlockSolidMeta implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public isPowerSource(): boolean
        public getStrongPower(side: cn.nukkit.math.BlockFace): int
        public getWeakPower(face: cn.nukkit.math.BlockFace): int
        public onUpdate(type: int): int
        public onNeighborChange(side: cn.nukkit.math.BlockFace): void
        public canHarvestWithHand(): boolean
        public getToolType(): int
        public getToolTier(): int
        public getHardness(): double
        public getResistance(): double
        public isPowered(): boolean
        public setPowered(powered: boolean): void
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockObserver" {
    declare const BlockObserver = cn.nukkit.block.BlockObserver;
}

declare namespace cn.nukkit.block {
    declare class BlockDropper extends cn.nukkit.block.BlockDispenser {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityDropper>
        public getBlockEntityType(): string
        public dispense(): void
        getDispenseBehavior(item: cn.nukkit.item.Item): cn.nukkit.dispenser.DispenseBehavior
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public getToolTier(): int

    }
}

declare module "cn.nukkit.block.BlockDropper" {
    declare const BlockDropper = cn.nukkit.block.BlockDropper;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsAcacia extends cn.nukkit.block.BlockStairsWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStairsAcacia" {
    declare const BlockStairsAcacia = cn.nukkit.block.BlockStairsAcacia;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabStone3 extends cn.nukkit.block.BlockSlab {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getSlabName(): string
        public getSlabType(): cn.nukkit.blockproperty.value.StoneSlab3Type
        public setSlabType(type: cn.nukkit.blockproperty.value.StoneSlab3Type): void
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getToolTier(): int
        public getToolType(): int
        public canHarvestWithHand(): boolean
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static END_STONE_BRICKS: int
        public static SMOOTH_RED_SANDSTONE: int
        public static POLISHED_ANDESITE: int
        public static ANDESITE: int
        public static DIORITE: int
        public static POLISHED_DIORITE: int
        public static GRANITE: int
        public static POLISHED_GRANITE: int

    }
}

declare module "cn.nukkit.block.BlockSlabStone3" {
    declare const BlockSlabStone3 = cn.nukkit.block.BlockSlabStone3;
}

declare namespace cn.nukkit.block {
    declare class BlockAzaleaLeaves extends cn.nukkit.block.BlockLeaves {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getToolType(): int
        public canHarvestWithHand(): boolean
        public canHarvest(item: cn.nukkit.item.Item): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public onUpdate(type: int): int
        findLog(current: cn.nukkit.block.Block, distance: int, visited: it.unimi.dsi.fastutil.longs.Long2LongMap): boolean
        public isCheckDecay(): boolean
        public setCheckDecay(checkDecay: boolean): void
        public isPersistent(): boolean
        public setPersistent(persistent: boolean): void
        public getBurnChance(): int
        public getWaterloggingLevel(): int
        public getBurnAbility(): int
        public breaksWhenMoved(): boolean
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        static VISIT_ORDER: cn.nukkit.math.BlockFace[]

    }
}

declare module "cn.nukkit.block.BlockAzaleaLeaves" {
    declare const BlockAzaleaLeaves = cn.nukkit.block.BlockAzaleaLeaves;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabCopperCutOxidized extends cn.nukkit.block.BlockDoubleSlabCopperCut {
        public constructor(): void
        public constructor(meta: int): void
        public getSingleSlabId(): int
        public getId(): int
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabCopperCutOxidized" {
    declare const BlockDoubleSlabCopperCutOxidized = cn.nukkit.block.BlockDoubleSlabCopperCutOxidized;
}

declare namespace cn.nukkit.block {
    declare class BlockRedstoneLampLit extends cn.nukkit.block.BlockRedstoneLamp implements cn.nukkit.utils.RedstoneComponent {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getLightLevel(): int
        public toItem(): cn.nukkit.item.Item
        public onUpdate(type: int): int

    }
}

declare module "cn.nukkit.block.BlockRedstoneLampLit" {
    declare const BlockRedstoneLampLit = cn.nukkit.block.BlockRedstoneLampLit;
}

declare namespace cn.nukkit.block {
    declare interface Oxidizable {
        public getLocation(): cn.nukkit.level.Location
        public onUpdate(type: int): int
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel
        public setOxidizationLevel(var0: cn.nukkit.blockproperty.value.OxidizationLevel): boolean
        public getStateWithOxidizationLevel(var0: cn.nukkit.blockproperty.value.OxidizationLevel): cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.block.Oxidizable" {
    declare type Oxidizable = cn.nukkit.block.Oxidizable;
}

declare namespace cn.nukkit.block {
    declare class BlockPlanksWarped extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockPlanksWarped" {
    declare const BlockPlanksWarped = cn.nukkit.block.BlockPlanksWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockDandelion extends cn.nukkit.block.BlockFlower {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getId(): int
        getUncommonFlower(): cn.nukkit.block.Block
        public setFlowerType(flowerType: cn.nukkit.blockproperty.value.SmallFlowerType): void
        public getFlowerType(): cn.nukkit.blockproperty.value.SmallFlowerType

    }
}

declare module "cn.nukkit.block.BlockDandelion" {
    declare const BlockDandelion = cn.nukkit.block.BlockDandelion;
}

declare namespace cn.nukkit.block {
    declare class BlockLightningRod extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public getName(): string
        public getId(): int
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public getWaterloggingLevel(): int
        public canBeFlowedInto(): boolean
        public getHardness(): double
        public getResistance(): double
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public getToolType(): int
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockLightningRod" {
    declare const BlockLightningRod = cn.nukkit.block.BlockLightningRod;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsCopperCutExposedWaxed extends cn.nukkit.block.BlockStairsCopperCutExposed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsCopperCutExposedWaxed" {
    declare const BlockStairsCopperCutExposedWaxed = cn.nukkit.block.BlockStairsCopperCutExposedWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockStairs extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.Faceable {
        constructor(meta: int): void
        public constructor(): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getMinY(): double
        public getMaxY(): double
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public collidesWithBB(bb: cn.nukkit.math.AxisAlignedBB): boolean
        public getWaterloggingLevel(): int
        public setUpsideDown(upsideDown: boolean): void
        public isUpsideDown(): boolean
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public static UPSIDE_DOWN: cn.nukkit.blockproperty.BooleanBlockProperty
        public static STAIRS_DIRECTION: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.math.BlockFace>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockStairs" {
    declare const BlockStairs = cn.nukkit.block.BlockStairs;
}

declare namespace cn.nukkit.block {
    declare class BlockLava extends cn.nukkit.block.BlockLiquid {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getLightLevel(): int
        public getName(): string
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        isNetherSpreadNotAllowed(spreadTarget: cn.nukkit.block.Block): boolean
        isSurroundingBlockFlammable(block: cn.nukkit.block.Block): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getBlock(meta: int): cn.nukkit.block.BlockLiquid
        public tickRate(): int
        public getFlowDecayPerBlock(): int
        checkForHarden(): void
        flowIntoBlock(block: cn.nukkit.block.Block, newFlowDecay: int): void
        public addVelocityToEntity(entity: cn.nukkit.entity.Entity, vector: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.block.BlockLava" {
    declare const BlockLava = cn.nukkit.block.BlockLava;
}

declare namespace cn.nukkit.block {
    declare class BlockPistonBase extends cn.nukkit.block.BlockSolidMeta implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.utils.Faceable, cn.nukkit.block.BlockEntityHolder {
        public static updatePistonsListenTo(pos: cn.nukkit.level.Position): void
        public static listenPistonUpdateTo(listen: cn.nukkit.level.Position, to: cn.nukkit.level.Position): void
        public static isBlockLocked(pos: cn.nukkit.level.Position): boolean
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockEntityType(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityPistonArm>
        public getResistance(): double
        public getHardness(): double
        public getWaterloggingLevel(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public isExtended(): boolean
        public onUpdate(type: int): int
        updateAroundRedstoneTorches(powered: boolean): void
        checkState(isPowered: boolean): boolean
        public isGettingPower(): boolean
        doMove(extending: boolean): boolean
        createHead(damage: int): cn.nukkit.block.BlockPistonHead
        public getPistonHeadBlockId(): int
        public static canPush(block: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, destroyBlocks: boolean, extending: boolean): boolean
        public toItem(): cn.nukkit.item.Item
        public getBlockFace(): cn.nukkit.math.BlockFace
        static log: org.apache.logging.log4j.Logger
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        static lockedBlocks: java.util.Set<cn.nukkit.level.Position>
        static lockedBy: java.util.Map<cn.nukkit.level.Position, cn.nukkit.level.Position>
        static pistonUpdateListeners: java.util.Map<cn.nukkit.level.Position, java.util.Set<cn.nukkit.level.Position>>
        public sticky: boolean

    }
}

declare module "cn.nukkit.block.BlockPistonBase" {
    declare const BlockPistonBase = cn.nukkit.block.BlockPistonBase;
}

declare namespace cn.nukkit.block {
    declare class BlockRawIron extends cn.nukkit.block.BlockRaw {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int

    }
}

declare module "cn.nukkit.block.BlockRawIron" {
    declare const BlockRawIron = cn.nukkit.block.BlockRawIron;
}

declare namespace cn.nukkit.block {
    declare class BlockButtonCrimson extends cn.nukkit.block.BlockButtonWooden {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockButtonCrimson" {
    declare const BlockButtonCrimson = cn.nukkit.block.BlockButtonCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockSculkVein extends cn.nukkit.block.BlockLichen {
        public constructor(): void
        public getName(): string
        public getId(): int

    }
}

declare module "cn.nukkit.block.BlockSculkVein" {
    declare const BlockSculkVein = cn.nukkit.block.BlockSculkVein;
}

declare namespace cn.nukkit.block {
    declare class BlockCarrot extends cn.nukkit.block.BlockCrops {
        public constructor(meta: int): void
        public constructor(): void
        public getName(): string
        public getId(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockCarrot" {
    declare const BlockCarrot = cn.nukkit.block.BlockCarrot;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsDarkOak extends cn.nukkit.block.BlockStairsWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStairsDarkOak" {
    declare const BlockStairsDarkOak = cn.nukkit.block.BlockStairsDarkOak;
}

declare namespace cn.nukkit.block {
    declare class BlockNyliumWarped extends cn.nukkit.block.BlockNylium {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockNyliumWarped" {
    declare const BlockNyliumWarped = cn.nukkit.block.BlockNyliumWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockHugeMushroomBrown extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getToolType(): int
        public getHardness(): double
        public getResistance(): double
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canSilkTouch(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public static HUGE_MUSHROOM: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockHugeMushroomBrown" {
    declare const BlockHugeMushroomBrown = cn.nukkit.block.BlockHugeMushroomBrown;
}

declare namespace cn.nukkit.block {
    declare class BlockTilesDeepslate extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public getToolType(): int
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockTilesDeepslate" {
    declare const BlockTilesDeepslate = cn.nukkit.block.BlockTilesDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabCopperCutWeathered extends cn.nukkit.block.BlockDoubleSlabCopperCut {
        public constructor(): void
        public constructor(meta: int): void
        public getSingleSlabId(): int
        public getId(): int
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabCopperCutWeathered" {
    declare const BlockDoubleSlabCopperCutWeathered = cn.nukkit.block.BlockDoubleSlabCopperCutWeathered;
}

declare namespace cn.nukkit.block {
    declare class BlockRailPowered$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$utils$Rail$Orientation: int[]

    }
}

declare module "cn.nukkit.block.BlockRailPowered$1" {
    declare const BlockRailPowered$1 = cn.nukkit.block.BlockRailPowered$1;
}

declare namespace cn.nukkit.block {
    declare class BlockFenceNetherBrick extends cn.nukkit.block.BlockFenceBase {
        public constructor(): void
        public constructor(meta: int): void
        public getToolType(): int
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockFenceNetherBrick" {
    declare const BlockFenceNetherBrick = cn.nukkit.block.BlockFenceNetherBrick;
}

declare namespace cn.nukkit.block {
    declare class BlockNetherPortal extends cn.nukkit.block.BlockFlowable implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public canBeFlowedInto(): boolean
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public canPassThrough(): boolean
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public getHardness(): double
        public getLightLevel(): int
        public toItem(): cn.nukkit.item.Item
        public onBreak(item: cn.nukkit.item.Item): boolean
        public hasEntityCollision(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public static spawnPortal(pos: cn.nukkit.level.Position): void
        public getBlockFace(): cn.nukkit.math.BlockFace
        static PORTAL_AXIS: cn.nukkit.blockproperty.ArrayBlockProperty<string>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockNetherPortal" {
    declare const BlockNetherPortal = cn.nukkit.block.BlockNetherPortal;
}

declare namespace cn.nukkit.block {
    declare class BlockNetherrack extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public getName(): string
        public getToolTier(): int
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public canBeActivated(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockNetherrack" {
    declare const BlockNetherrack = cn.nukkit.block.BlockNetherrack;
}

declare namespace cn.nukkit.block {
    declare class BlockTrapdoorBirch extends cn.nukkit.block.BlockTrapdoor {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockTrapdoorBirch" {
    declare const BlockTrapdoorBirch = cn.nukkit.block.BlockTrapdoorBirch;
}

declare namespace cn.nukkit.block {
    declare class BlockFenceGateAcacia extends cn.nukkit.block.BlockFenceGate {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockFenceGateAcacia" {
    declare const BlockFenceGateAcacia = cn.nukkit.block.BlockFenceGateAcacia;
}

declare namespace cn.nukkit.block {
    declare class BlockOreCoalDeepslate extends cn.nukkit.block.BlockOreCoal {
        public constructor(): void
        public getId(): int
        public getHardness(): double
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockOreCoalDeepslate" {
    declare const BlockOreCoalDeepslate = cn.nukkit.block.BlockOreCoalDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockFenceGateCrimson extends cn.nukkit.block.BlockFenceGate {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockFenceGateCrimson" {
    declare const BlockFenceGateCrimson = cn.nukkit.block.BlockFenceGateCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockFurnace extends cn.nukkit.block.BlockFurnaceBurning {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getLightLevel(): int
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockFurnace" {
    declare const BlockFurnace = cn.nukkit.block.BlockFurnace;
}

declare namespace cn.nukkit.block {
    declare class BlockSeaLantern extends cn.nukkit.block.BlockTransparent {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getResistance(): double
        public getHardness(): double
        public getLightLevel(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor
        public canSilkTouch(): boolean

    }
}

declare module "cn.nukkit.block.BlockSeaLantern" {
    declare const BlockSeaLantern = cn.nukkit.block.BlockSeaLantern;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsSandstone extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsSandstone" {
    declare const BlockStairsSandstone = cn.nukkit.block.BlockStairsSandstone;
}

declare namespace cn.nukkit.block {
    declare class BlockOreCopper extends cn.nukkit.block.BlockOre {
        public constructor(): void
        public getName(): string
        public getId(): int
        getRawMaterial(): cn.nukkit.item.MinecraftItemID
        getDropMultiplier(): float

    }
}

declare module "cn.nukkit.block.BlockOreCopper" {
    declare const BlockOreCopper = cn.nukkit.block.BlockOreCopper;
}

declare namespace cn.nukkit.block {
    declare class BlockCrimsonWallSign extends cn.nukkit.block.BlockWallSign {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        getPostId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockCrimsonWallSign" {
    declare const BlockCrimsonWallSign = cn.nukkit.block.BlockCrimsonWallSign;
}

declare namespace cn.nukkit.block {
    declare class BlockBirchWallSign extends cn.nukkit.block.BlockWallSign {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        getPostId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockBirchWallSign" {
    declare const BlockBirchWallSign = cn.nukkit.block.BlockBirchWallSign;
}

declare namespace cn.nukkit.block {
    declare class BlockBigDripleaf$TiltAction extends java.lang.Object {
        public constructor(this$0: cn.nukkit.block.BlockBigDripleaf, targetState: cn.nukkit.block.BlockBigDripleaf$Tilt, delay: int, nextAction: cn.nukkit.block.BlockBigDripleaf$TiltAction): void
        public targetState: cn.nukkit.block.BlockBigDripleaf$Tilt
        public delay: int
        public nextAction: cn.nukkit.block.BlockBigDripleaf$TiltAction
        this$0: cn.nukkit.block.BlockBigDripleaf

    }
}

declare module "cn.nukkit.block.BlockBigDripleaf$TiltAction" {
    declare const BlockBigDripleaf$TiltAction = cn.nukkit.block.BlockBigDripleaf$TiltAction;
}

declare namespace cn.nukkit.block {
    declare class BlockTNT extends cn.nukkit.block.BlockSolid implements cn.nukkit.utils.RedstoneComponent {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public canBeActivated(): boolean
        public getBurnChance(): int
        public getBurnAbility(): int
        public prime(): void
        public prime(fuse: int): void
        public prime(fuse: int, source: cn.nukkit.entity.Entity): void
        public onUpdate(type: int): int
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onProjectileHit(projectile: cn.nukkit.entity.Entity, position: cn.nukkit.level.Position, motion: cn.nukkit.math.Vector3): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public static EXPLODE_ON_BREAK: cn.nukkit.blockproperty.BooleanBlockProperty
        public static ALLOW_UNDERWATER: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockTNT" {
    declare const BlockTNT = cn.nukkit.block.BlockTNT;
}

declare namespace cn.nukkit.block {
    declare class BlockSeagrass extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canBeReplaced(): boolean
        public getWaterloggingLevel(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getToolType(): int
        public toItem(): cn.nukkit.item.Item
        public static SEA_GRASS_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.SeaGrassType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockSeagrass" {
    declare const BlockSeagrass = cn.nukkit.block.BlockSeagrass;
}

declare namespace cn.nukkit.block {
    declare class BlockMangrovePropagule extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public grow(): void
        public getColor(): cn.nukkit.utils.BlockColor
        public static HANGING: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPAGULE_STAGE: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockMangrovePropagule" {
    declare const BlockMangrovePropagule = cn.nukkit.block.BlockMangrovePropagule;
}

declare namespace cn.nukkit.block {
    declare class BlockTurtleEgg extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getCracks(): cn.nukkit.blockproperty.value.CrackState
        public setCracks(cracks: cn.nukkit.blockproperty.value.CrackState): void
        public getHardness(): double
        public getResistance(): double
        public getEggCount(): int
        public setEggCount(eggCount: int): void
        public getCrackState(): int
        public setCrackState(crackState: int): void
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public hasEntityCollision(): boolean
        public getMinX(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxZ(): double
        public getMaxY(): double
        recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public onUpdate(type: int): int
        public hatch(): void
        public hatch(eggs: int): void
        public hatch(eggs: int, newState: cn.nukkit.block.Block): void
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public toItem(): cn.nukkit.item.Item
        public onBreak(item: cn.nukkit.item.Item): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public isValidSupport(support: cn.nukkit.block.Block): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canSilkTouch(): boolean
        public getWaterloggingLevel(): int
        public canPassThrough(): boolean
        public canBeFlowedInto(): boolean
        public clone(): cn.nukkit.block.BlockTurtleEgg
        public getColor(): cn.nukkit.utils.BlockColor
        public clone(): cn.nukkit.block.Block
        public clone(): cn.nukkit.math.AxisAlignedBB
        public clone(): cn.nukkit.level.Position
        public clone(): cn.nukkit.positiontracking.NamedPosition
        public clone(): cn.nukkit.math.Vector3
        public clone(): java.lang.Object
        public static EGG_COUNT: cn.nukkit.blockproperty.BlockProperty<int>
        public static CRACK_STATE: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.CrackState>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static CRACK_STATE_NO_CRACKS: int
        public static CRACK_STATE_CRACKED: int
        public static CRACK_STATE_MAX_CRACKED: int

    }
}

declare module "cn.nukkit.block.BlockTurtleEgg" {
    declare const BlockTurtleEgg = cn.nukkit.block.BlockTurtleEgg;
}

declare namespace cn.nukkit.block {
    declare class BlockPressurePlateWarped extends cn.nukkit.block.BlockPressurePlateWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockPressurePlateWarped" {
    declare const BlockPressurePlateWarped = cn.nukkit.block.BlockPressurePlateWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockWarpedSignPost extends cn.nukkit.block.BlockSignPost {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getWallId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockWarpedSignPost" {
    declare const BlockWarpedSignPost = cn.nukkit.block.BlockWarpedSignPost;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabBase extends cn.nukkit.block.BlockSolidMeta {
        public constructor(meta: int): void
        public constructor(): void
        public getName(): string
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getSlabName(): string
        public getSingleSlabId(): int
        public toItem(): cn.nukkit.item.Item
        isCorrectTool(item: cn.nukkit.item.Item): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabBase" {
    declare const BlockDoubleSlabBase = cn.nukkit.block.BlockDoubleSlabBase;
}

declare namespace cn.nukkit.block {
    declare class BlockJukebox extends cn.nukkit.block.BlockSolid implements cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityJukebox>
        public getBlockEntityType(): string
        public canBeActivated(): boolean
        public toItem(): cn.nukkit.item.Item
        public getHardness(): double
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockJukebox" {
    declare const BlockJukebox = cn.nukkit.block.BlockJukebox;
}

declare namespace cn.nukkit.block {
    declare class BlockBricksRedNether extends cn.nukkit.block.BlockNetherBrick {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getToolType(): int
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockBricksRedNether" {
    declare const BlockBricksRedNether = cn.nukkit.block.BlockBricksRedNether;
}

declare namespace cn.nukkit.block {
    declare class BlockOreEmerald extends cn.nukkit.block.BlockOre {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getToolTier(): int
        getRawMaterial(): cn.nukkit.item.MinecraftItemID
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getDropExp(): int

    }
}

declare module "cn.nukkit.block.BlockOreEmerald" {
    declare const BlockOreEmerald = cn.nukkit.block.BlockOreEmerald;
}

declare namespace cn.nukkit.block {
    declare class BlockPressurePlateBase extends cn.nukkit.block.BlockFlowable implements cn.nukkit.utils.RedstoneComponent {
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        constructor(): void
        constructor(meta: int): void
        public canPassThrough(): boolean
        public canHarvestWithHand(): boolean
        public getMinX(): double
        public getMinZ(): double
        public getMinY(): double
        public getMaxX(): double
        public getMaxZ(): double
        public getMaxY(): double
        public isPowerSource(): boolean
        public isActivated(): boolean
        public getWaterloggingLevel(): int
        public static isSupportValid(block: cn.nukkit.block.Block, blockFace: cn.nukkit.math.BlockFace): boolean
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        updateState(oldStrength: int): void
        public onBreak(item: cn.nukkit.item.Item): boolean
        public getWeakPower(side: cn.nukkit.math.BlockFace): int
        public getStrongPower(side: cn.nukkit.math.BlockFace): int
        public getRedstonePower(): int
        public setRedstonePower(power: int): void
        playOnSound(): void
        playOffSound(): void
        computeRedstoneStrength(): int
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        onPitch: float
        offPitch: float

    }
}

declare module "cn.nukkit.block.BlockPressurePlateBase" {
    declare const BlockPressurePlateBase = cn.nukkit.block.BlockPressurePlateBase;
}

declare namespace cn.nukkit.block {
    declare interface IBlockOreRedstoneGlowing extends cn.nukkit.blockstate.IMutableBlockState {
        public getUnlitState(): cn.nukkit.blockstate.BlockState
        public getLitState(): cn.nukkit.blockstate.BlockState
        public getLevel(): cn.nukkit.level.Level
        public toItem(): cn.nukkit.item.Item
        public onUpdate(type: int): int

    }
}

declare module "cn.nukkit.block.IBlockOreRedstoneGlowing" {
    declare type IBlockOreRedstoneGlowing = cn.nukkit.block.IBlockOreRedstoneGlowing;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperBase extends cn.nukkit.block.BlockSolid implements cn.nukkit.block.Oxidizable, cn.nukkit.block.Waxable {
        public constructor(): void
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public canBeActivated(): boolean
        public canHarvestWithHand(): boolean
        public getStateWithOxidizationLevel(oxidizationLevel: cn.nukkit.blockproperty.value.OxidizationLevel): cn.nukkit.blockstate.BlockState
        public setOxidizationLevel(oxidizationLevel: cn.nukkit.blockproperty.value.OxidizationLevel): boolean
        public setWaxed(waxed: boolean): boolean
        public isWaxed(): boolean
        getCopperId(waxed: boolean, oxidizationLevel: cn.nukkit.blockproperty.value.OxidizationLevel): int

    }
}

declare module "cn.nukkit.block.BlockCopperBase" {
    declare const BlockCopperBase = cn.nukkit.block.BlockCopperBase;
}

declare namespace cn.nukkit.block {
    declare class BlockFenceWarped extends cn.nukkit.block.BlockFenceBase {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getBurnChance(): int
        public getBurnAbility(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockFenceWarped" {
    declare const BlockFenceWarped = cn.nukkit.block.BlockFenceWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsCopperCut$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$blockproperty$value$OxidizationLevel: int[]

    }
}

declare module "cn.nukkit.block.BlockStairsCopperCut$1" {
    declare const BlockStairsCopperCut$1 = cn.nukkit.block.BlockStairsCopperCut$1;
}

declare namespace cn.nukkit.block {
    declare class BlockLogStrippedMangrove extends cn.nukkit.block.BlockWoodStripped {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType
        public setWoodType(woodType: cn.nukkit.blockproperty.value.WoodType): void

    }
}

declare module "cn.nukkit.block.BlockLogStrippedMangrove" {
    declare const BlockLogStrippedMangrove = cn.nukkit.block.BlockLogStrippedMangrove;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabCrimson extends cn.nukkit.block.BlockSlab {
        public constructor(): void
        public constructor(meta: int): void
        public getSlabName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean
        public getToolType(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getResistance(): double
        public getBurnChance(): int
        public getBurnAbility(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockSlabCrimson" {
    declare const BlockSlabCrimson = cn.nukkit.block.BlockSlabCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockTorch extends cn.nukkit.block.BlockFlowable implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getLightLevel(): int
        public onUpdate(type: int): int
        findValidSupport(): cn.nukkit.math.BlockFace
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public getBlockFace(meta: int): cn.nukkit.math.BlockFace
        public getTorchAttachment(): cn.nukkit.block.BlockTorch$TorchAttachment
        public setTorchAttachment(face: cn.nukkit.block.BlockTorch$TorchAttachment): void
        public static TORCH_FACING_DIRECTION: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.block.BlockTorch$TorchAttachment>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockTorch" {
    declare const BlockTorch = cn.nukkit.block.BlockTorch;
}

declare namespace cn.nukkit.block {
    declare class BlockVinesWeeping extends cn.nukkit.block.BlockVinesNether {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getId(): int
        public getName(): string
        public getGrowthDirection(): cn.nukkit.math.BlockFace
        public getVineAge(): int
        public setVineAge(vineAge: int): void
        public getMaxVineAge(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public static WEEPING_VINES_AGE: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockVinesWeeping" {
    declare const BlockVinesWeeping = cn.nukkit.block.BlockVinesWeeping;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleLightBlue extends cn.nukkit.block.BlockCandle {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        toCakeForm(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockCandleLightBlue" {
    declare const BlockCandleLightBlue = cn.nukkit.block.BlockCandleLightBlue;
}

declare namespace cn.nukkit.block {
    declare class BlockGlassTinted extends cn.nukkit.block.BlockGlass {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canSilkTouch(): boolean

    }
}

declare module "cn.nukkit.block.BlockGlassTinted" {
    declare const BlockGlassTinted = cn.nukkit.block.BlockGlassTinted;
}

declare namespace cn.nukkit.block {
    declare class BlockBlackstonePolishedChiseled extends cn.nukkit.block.BlockBlackstonePolished {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getHardness(): double

    }
}

declare module "cn.nukkit.block.BlockBlackstonePolishedChiseled" {
    declare const BlockBlackstonePolishedChiseled = cn.nukkit.block.BlockBlackstonePolishedChiseled;
}

declare namespace cn.nukkit.block {
    declare class BlockCampfire extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.Faceable, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockEntityType(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityCampfire>
        public getLightLevel(): int
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public canHarvestWithHand(): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canSilkTouch(): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public hasEntityCollision(): boolean
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        getDamageEvent(entity: cn.nukkit.entity.Entity): cn.nukkit.event.entity.EntityDamageEvent
        public canBeActivated(): boolean
        public onUpdate(type: int): int
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onProjectileHit(projectile: cn.nukkit.entity.Entity, position: cn.nukkit.level.Position, motion: cn.nukkit.math.Vector3): boolean
        public getWaterloggingLevel(): int
        public getMaxY(): double
        recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getColor(): cn.nukkit.utils.BlockColor
        public isExtinguished(): boolean
        public setExtinguished(extinguished: boolean): void
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public getName(): string
        public toItem(): cn.nukkit.item.Item
        public hasComparatorInputOverride(): boolean
        public getComparatorInputOverride(): int
        public breaksWhenMoved(): boolean
        public canBePulled(): boolean
        public canBePushed(): boolean
        static log: org.apache.logging.log4j.Logger
        public static EXTINGUISHED: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCampfire" {
    declare const BlockCampfire = cn.nukkit.block.BlockCampfire;
}

declare namespace cn.nukkit.block {
    declare class BlockMangroveLog extends cn.nukkit.block.BlockLog {
        public constructor(): void
        public constructor(meta: int): void
        public getHardness(): double
        public getResistance(): double
        public getBurnChance(): int
        public getBurnAbility(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        getStrippedState(): cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.block.BlockMangroveLog" {
    declare const BlockMangroveLog = cn.nukkit.block.BlockMangroveLog;
}

declare namespace cn.nukkit.block {
    declare class BlockLoom extends cn.nukkit.block.BlockSolidMeta implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public toItem(): cn.nukkit.item.Item
        public getToolType(): int
        public getResistance(): double
        public getHardness(): double
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockLoom" {
    declare const BlockLoom = cn.nukkit.block.BlockLoom;
}

declare namespace cn.nukkit.block {
    declare class BlockFenceGateMangrove extends cn.nukkit.block.BlockFenceGate {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockFenceGateMangrove" {
    declare const BlockFenceGateMangrove = cn.nukkit.block.BlockFenceGateMangrove;
}

declare namespace cn.nukkit.block {
    declare class BlockWallBase extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.block.BlockConnectable {
        public constructor(meta: int): void
        public constructor(): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public getHardness(): double
        public getResistance(): double
        public getWaterloggingLevel(): int
        shouldBeTall(above: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace): boolean
        shouldBeTallBasedOnBoundingBox(above: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace): boolean
        public autoConfigureState(): boolean
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public isWallPost(): boolean
        public setWallPost(wallPost: boolean): void
        public clearConnections(): void
        public getWallConnections(): java.util.Map<cn.nukkit.math.BlockFace, cn.nukkit.block.BlockWall$WallConnectionType>
        public getConnectionType(blockFace: cn.nukkit.math.BlockFace): cn.nukkit.block.BlockWall$WallConnectionType
        public setConnection(blockFace: cn.nukkit.math.BlockFace, type: cn.nukkit.block.BlockWall$WallConnectionType): boolean
        public autoUpdatePostFlag(): void
        public hasConnections(): boolean
        recheckPostConditions(above: cn.nukkit.block.Block): boolean
        public isSameHeightStraight(): boolean
        public connect(blockFace: cn.nukkit.math.BlockFace): boolean
        public connect(blockFace: cn.nukkit.math.BlockFace, recheckPost: boolean): boolean
        connect(blockFace: cn.nukkit.math.BlockFace, above: cn.nukkit.block.Block, recheckPost: boolean): boolean
        public disconnect(blockFace: cn.nukkit.math.BlockFace): boolean
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public canConnect(block: cn.nukkit.block.Block): boolean
        public isConnected(face: cn.nukkit.math.BlockFace): boolean
        public getToolType(): int
        public canHarvestWithHand(): boolean
        static log: org.apache.logging.log4j.Logger
        public static WALL_CONNECTION_TYPE_SOUTH: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.block.BlockWall$WallConnectionType>
        public static WALL_CONNECTION_TYPE_WEST: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.block.BlockWall$WallConnectionType>
        public static WALL_CONNECTION_TYPE_NORTH: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.block.BlockWall$WallConnectionType>
        public static WALL_CONNECTION_TYPE_EAST: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.block.BlockWall$WallConnectionType>
        public static WALL_POST_BIT: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        static MIN_POST_BB: double
        static MAX_POST_BB: double

    }
}

declare module "cn.nukkit.block.BlockWallBase" {
    declare const BlockWallBase = cn.nukkit.block.BlockWallBase;
}

declare namespace cn.nukkit.block {
    declare class BlockUndyedShulkerBox extends cn.nukkit.block.BlockTransparent implements cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityShulkerBox>
        public getBlockEntityType(): string
        public getHardness(): double
        public getResistance(): double
        public canBeActivated(): boolean
        public getToolType(): int
        public getWaterloggingLevel(): int
        public toItem(): cn.nukkit.item.Item
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canHarvestWithHand(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public hasComparatorInputOverride(): boolean
        public getComparatorInputOverride(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public getItemMaxStackSize(): int

    }
}

declare module "cn.nukkit.block.BlockUndyedShulkerBox" {
    declare const BlockUndyedShulkerBox = cn.nukkit.block.BlockUndyedShulkerBox;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabCopperCut$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$blockproperty$value$OxidizationLevel: int[]

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabCopperCut$1" {
    declare const BlockDoubleSlabCopperCut$1 = cn.nukkit.block.BlockDoubleSlabCopperCut$1;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabWarped extends cn.nukkit.block.BlockDoubleSlabBase {
        public constructor(): void
        public getId(): int
        public getSlabName(): string
        public getSingleSlabId(): int
        isCorrectTool(item: cn.nukkit.item.Item): boolean
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabWarped" {
    declare const BlockDoubleSlabWarped = cn.nukkit.block.BlockDoubleSlabWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockOreCoal extends cn.nukkit.block.BlockOre {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getToolTier(): int
        getRawMaterial(): cn.nukkit.item.MinecraftItemID
        public getDropExp(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockOreCoal" {
    declare const BlockOreCoal = cn.nukkit.block.BlockOreCoal;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsCrimson extends cn.nukkit.block.BlockStairsWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockStairsCrimson" {
    declare const BlockStairsCrimson = cn.nukkit.block.BlockStairsCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockPumpkin extends cn.nukkit.block.BlockSolidMeta implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public toItem(): cn.nukkit.item.Item
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockPumpkin" {
    declare const BlockPumpkin = cn.nukkit.block.BlockPumpkin;
}

declare namespace cn.nukkit.block {
    declare class BlockStemStrippedWarped extends cn.nukkit.block.BlockStemStripped {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getBurnChance(): int
        public getBurnAbility(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStemStrippedWarped" {
    declare const BlockStemStrippedWarped = cn.nukkit.block.BlockStemStrippedWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsPurpur extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStairsPurpur" {
    declare const BlockStairsPurpur = cn.nukkit.block.BlockStairsPurpur;
}

declare namespace cn.nukkit.block {
    declare class BlockStemWarped extends cn.nukkit.block.BlockStem {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        getStrippedState(): cn.nukkit.blockstate.BlockState
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStemWarped" {
    declare const BlockStemWarped = cn.nukkit.block.BlockStemWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockSandstone extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public setSandstoneType(sandStoneType: cn.nukkit.blockproperty.value.SandStoneType): void
        public getSandstoneType(): cn.nukkit.blockproperty.value.SandStoneType
        public getHardness(): double
        public getResistance(): double
        public getName(): string
        public getToolTier(): int
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean
        public static SAND_STONE_TYPE: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.blockproperty.value.SandStoneType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static NORMAL: int
        public static CHISELED: int
        public static SMOOTH: int

    }
}

declare module "cn.nukkit.block.BlockSandstone" {
    declare const BlockSandstone = cn.nukkit.block.BlockSandstone;
}

declare namespace cn.nukkit.block {
    declare class BlockIceFrosted extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getResistance(): double
        public getHardness(): double
        public getFrictionFactor(): double
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public onUpdate(type: int): int
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean
        slightlyMelt(isSource: boolean): void
        countNeighbors(): int
        public static AGE: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockIceFrosted" {
    declare const BlockIceFrosted = cn.nukkit.block.BlockIceFrosted;
}

declare namespace cn.nukkit.block {
    declare class BlockDirt extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getDirtType(): java.util.Optional<cn.nukkit.blockproperty.value.DirtType>
        public setDirtType(dirtType: cn.nukkit.blockproperty.value.DirtType): void
        public canBeActivated(): boolean
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public getName(): string
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor
        public static DIRT_TYPE: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.blockproperty.value.DirtType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockDirt" {
    declare const BlockDirt = cn.nukkit.block.BlockDirt;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabBrickBlackstonePolished extends cn.nukkit.block.BlockDoubleSlabBlackstonePolished {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getSingleSlabId(): int
        public getSlabName(): string
        public getHardness(): double

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabBrickBlackstonePolished" {
    declare const BlockDoubleSlabBrickBlackstonePolished = cn.nukkit.block.BlockDoubleSlabBrickBlackstonePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockGlass extends cn.nukkit.block.BlockTransparent {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getResistance(): double
        public getHardness(): double
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canSilkTouch(): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockGlass" {
    declare const BlockGlass = cn.nukkit.block.BlockGlass;
}

declare namespace cn.nukkit.block {
    declare class BlockBedrockInvisible extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getWaterloggingLevel(): int
        public canBeFlowedInto(): boolean
        public getHardness(): double
        public getResistance(): double
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public canBePushed(): boolean
        public canBePulled(): boolean
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockBedrockInvisible" {
    declare const BlockBedrockInvisible = cn.nukkit.block.BlockBedrockInvisible;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabStone3 extends cn.nukkit.block.BlockDoubleSlabBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getSlabType(): cn.nukkit.blockproperty.value.StoneSlab3Type
        public setSlabType(type: cn.nukkit.blockproperty.value.StoneSlab3Type): void
        public getSlabName(): string
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public getSingleSlabId(): int
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean
        public static END_STONE_BRICKS: int
        public static SMOOTH_RED_SANDSTONE: int
        public static POLISHED_ANDESITE: int
        public static ANDESITE: int
        public static DIORITE: int
        public static POLISHED_DIORITE: int
        public static GRANITE: int
        public static POLISHED_GRANITE: int

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabStone3" {
    declare const BlockDoubleSlabStone3 = cn.nukkit.block.BlockDoubleSlabStone3;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsMossyStoneBrick extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsMossyStoneBrick" {
    declare const BlockStairsMossyStoneBrick = cn.nukkit.block.BlockStairsMossyStoneBrick;
}

declare namespace cn.nukkit.block {
    declare class BlockVine$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$math$BlockFace: int[]

    }
}

declare module "cn.nukkit.block.BlockVine$1" {
    declare const BlockVine$1 = cn.nukkit.block.BlockVine$1;
}

declare namespace cn.nukkit.block {
    declare class BlockFungusCrimson extends cn.nukkit.block.BlockFungus {
        public constructor(): void
        public getId(): int
        public getName(): string
        canGrowOn(support: cn.nukkit.block.Block): boolean
        public grow(cause: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockFungusCrimson" {
    declare const BlockFungusCrimson = cn.nukkit.block.BlockFungusCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockTrapdoorDarkOak extends cn.nukkit.block.BlockTrapdoor {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockTrapdoorDarkOak" {
    declare const BlockTrapdoorDarkOak = cn.nukkit.block.BlockTrapdoorDarkOak;
}

declare namespace cn.nukkit.block {
    declare class BlockMelon extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canSilkTouch(): boolean
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean

    }
}

declare module "cn.nukkit.block.BlockMelon" {
    declare const BlockMelon = cn.nukkit.block.BlockMelon;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCakeCyan extends cn.nukkit.block.BlockCandleCake {
        public constructor(meta: int): void
        public constructor(): void
        getColorName(): string
        public getId(): int
        toCandleForm(): cn.nukkit.block.BlockCandle

    }
}

declare module "cn.nukkit.block.BlockCandleCakeCyan" {
    declare const BlockCandleCakeCyan = cn.nukkit.block.BlockCandleCakeCyan;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCakeMagenta extends cn.nukkit.block.BlockCandleCake {
        public constructor(meta: int): void
        public constructor(): void
        getColorName(): string
        public getId(): int
        toCandleForm(): cn.nukkit.block.BlockCandle

    }
}

declare module "cn.nukkit.block.BlockCandleCakeMagenta" {
    declare const BlockCandleCakeMagenta = cn.nukkit.block.BlockCandleCakeMagenta;
}

declare namespace cn.nukkit.block {
    declare class BlockSpruceSignPost extends cn.nukkit.block.BlockSignPost {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getWallId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockSpruceSignPost" {
    declare const BlockSpruceSignPost = cn.nukkit.block.BlockSpruceSignPost;
}

declare namespace cn.nukkit.block {
    declare class BlockNylium extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getToolType(): int
        public onUpdate(type: int): int
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public grow(): boolean
        public getResistance(): double
        public getHardness(): double
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canSilkTouch(): boolean
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockNylium" {
    declare const BlockNylium = cn.nukkit.block.BlockNylium;
}

declare namespace cn.nukkit.block {
    declare class BlockSporeBlossom extends cn.nukkit.block.BlockTransparent {
        public constructor(): void
        public getName(): string
        public getId(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public isSolid(): boolean
        public isTransparent(): boolean

    }
}

declare module "cn.nukkit.block.BlockSporeBlossom" {
    declare const BlockSporeBlossom = cn.nukkit.block.BlockSporeBlossom;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCakeBrown extends cn.nukkit.block.BlockCandleCake {
        public constructor(meta: int): void
        public constructor(): void
        getColorName(): string
        public getId(): int
        toCandleForm(): cn.nukkit.block.BlockCandle

    }
}

declare module "cn.nukkit.block.BlockCandleCakeBrown" {
    declare const BlockCandleCakeBrown = cn.nukkit.block.BlockCandleCakeBrown;
}

declare namespace cn.nukkit.block {
    declare class BlockWood extends cn.nukkit.block.BlockLog {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType
        public setWoodType(woodType: cn.nukkit.blockproperty.value.WoodType): void
        public getName(): string
        public forState(state: cn.nukkit.blockstate.IBlockState): cn.nukkit.block.Block
        public getBurnChance(): int
        public getBurnAbility(): int
        getStrippedState(): cn.nukkit.blockstate.BlockState
        public getColor(): cn.nukkit.utils.BlockColor
        public forState(var0: cn.nukkit.blockstate.IBlockState): cn.nukkit.blockstate.IMutableBlockState
        public static OLD_LOG_TYPE: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.blockproperty.value.WoodType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static OAK: int
        public static SPRUCE: int
        public static BIRCH: int
        public static JUNGLE: int

    }
}

declare module "cn.nukkit.block.BlockWood" {
    declare const BlockWood = cn.nukkit.block.BlockWood;
}

declare namespace cn.nukkit.block {
    declare class BlockGlowstone extends cn.nukkit.block.BlockTransparent {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getResistance(): double
        public getHardness(): double
        public getLightLevel(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor
        public canSilkTouch(): boolean

    }
}

declare module "cn.nukkit.block.BlockGlowstone" {
    declare const BlockGlowstone = cn.nukkit.block.BlockGlowstone;
}

declare namespace cn.nukkit.block {
    declare class BlockMushroomRed extends cn.nukkit.block.BlockMushroom {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        getType(): int

    }
}

declare module "cn.nukkit.block.BlockMushroomRed" {
    declare const BlockMushroomRed = cn.nukkit.block.BlockMushroomRed;
}

declare namespace cn.nukkit.block {
    declare class BlockFallableMeta extends cn.nukkit.block.BlockFallable {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockFallableMeta" {
    declare const BlockFallableMeta = cn.nukkit.block.BlockFallableMeta;
}

declare namespace cn.nukkit.block {
    declare class BlockBricksBlackstonePolishedCracked extends cn.nukkit.block.BlockBricksBlackstonePolished {
        public constructor(): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockBricksBlackstonePolishedCracked" {
    declare const BlockBricksBlackstonePolishedCracked = cn.nukkit.block.BlockBricksBlackstonePolishedCracked;
}

declare namespace cn.nukkit.block {
    declare class BlockChain extends cn.nukkit.block.BlockTransparent {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getPillarAxis(): cn.nukkit.math.BlockFace$Axis
        public setPillarAxis(axis: cn.nukkit.math.BlockFace$Axis): void
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getHardness(): double
        public getWaterloggingLevel(): int
        public getResistance(): double
        public getToolType(): int
        public getMinX(): double
        public getMaxX(): double
        public getMinZ(): double
        public getMaxZ(): double
        public toItem(): cn.nukkit.item.Item
        public getToolTier(): int
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockChain" {
    declare const BlockChain = cn.nukkit.block.BlockChain;
}

declare namespace cn.nukkit.block {
    declare class BlockFarmland extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public getMaxY(): double
        public onUpdate(type: int): int
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public isTransparent(): boolean
        public static MOISTURIZED_AMOUNT: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockFarmland" {
    declare const BlockFarmland = cn.nukkit.block.BlockFarmland;
}

declare namespace cn.nukkit.block {
    declare class BlockRedstoneTorchUnlit extends cn.nukkit.block.BlockTorch implements cn.nukkit.utils.RedstoneComponent {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getLightLevel(): int
        public getWeakPower(side: cn.nukkit.math.BlockFace): int
        public getStrongPower(side: cn.nukkit.math.BlockFace): int
        public toItem(): cn.nukkit.item.Item
        public onUpdate(type: int): int
        checkState(): boolean
        isPoweredFromSide(): boolean
        public tickRate(): int

    }
}

declare module "cn.nukkit.block.BlockRedstoneTorchUnlit" {
    declare const BlockRedstoneTorchUnlit = cn.nukkit.block.BlockRedstoneTorchUnlit;
}

declare namespace cn.nukkit.block {
    declare class BlockAzaleaLeavesFlowered extends cn.nukkit.block.BlockAzaleaLeaves {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int

    }
}

declare module "cn.nukkit.block.BlockAzaleaLeavesFlowered" {
    declare const BlockAzaleaLeavesFlowered = cn.nukkit.block.BlockAzaleaLeavesFlowered;
}

declare namespace cn.nukkit.block {
    declare class BlockCobweb extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getWaterloggingLevel(): int
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean
        public diffusesSkyLight(): boolean

    }
}

declare module "cn.nukkit.block.BlockCobweb" {
    declare const BlockCobweb = cn.nukkit.block.BlockCobweb;
}

declare namespace cn.nukkit.block {
    declare class BlockBlackstone extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getHardness(): double
        public getResistance(): double

    }
}

declare module "cn.nukkit.block.BlockBlackstone" {
    declare const BlockBlackstone = cn.nukkit.block.BlockBlackstone;
}

declare namespace cn.nukkit.block {
    declare class BlockTorch$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$math$BlockFace: int[]
        static $SwitchMap$cn$nukkit$block$BlockTorch$TorchAttachment: int[]

    }
}

declare module "cn.nukkit.block.BlockTorch$1" {
    declare const BlockTorch$1 = cn.nukkit.block.BlockTorch$1;
}

declare namespace cn.nukkit.block {
    declare class BlockOreDiamondDeepslate extends cn.nukkit.block.BlockOreDiamond {
        public constructor(): void
        public getId(): int
        public getHardness(): double
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockOreDiamondDeepslate" {
    declare const BlockOreDiamondDeepslate = cn.nukkit.block.BlockOreDiamondDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockFurnaceBurning extends cn.nukkit.block.BlockSolidMeta implements cn.nukkit.utils.Faceable, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityFurnace>
        public getBlockEntityType(): string
        public canBeActivated(): boolean
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getLightLevel(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public toItem(): cn.nukkit.item.Item
        public getToolTier(): int
        public hasComparatorInputOverride(): boolean
        public getComparatorInputOverride(): int
        public canHarvestWithHand(): boolean
        public getBlockFace(): cn.nukkit.math.BlockFace
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockFurnaceBurning" {
    declare const BlockFurnaceBurning = cn.nukkit.block.BlockFurnaceBurning;
}

declare namespace cn.nukkit.block {
    declare class BlockOreLapisDeepslate extends cn.nukkit.block.BlockOreLapis {
        public constructor(): void
        public getId(): int
        public getHardness(): double
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockOreLapisDeepslate" {
    declare const BlockOreLapisDeepslate = cn.nukkit.block.BlockOreLapisDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockStonecutterBlock extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public getBlockFace(): cn.nukkit.math.BlockFace
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public getWaterloggingLevel(): int
        public getToolType(): int
        public getToolTier(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public toItem(): cn.nukkit.item.Item
        public getMaxY(): double
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockStonecutterBlock" {
    declare const BlockStonecutterBlock = cn.nukkit.block.BlockStonecutterBlock;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsDiorite extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsDiorite" {
    declare const BlockStairsDiorite = cn.nukkit.block.BlockStairsDiorite;
}

declare namespace cn.nukkit.block {
    declare class BlockMeta extends cn.nukkit.block.Block {
        constructor(): void
        constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockMeta" {
    declare const BlockMeta = cn.nukkit.block.BlockMeta;
}

declare namespace cn.nukkit.block {
    declare class BlockCauldronLava extends cn.nukkit.block.BlockCauldron {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getLightLevel(): int
        public hasEntityCollision(): boolean
        recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public setFillLevel(fillLevel: int): void
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean

    }
}

declare module "cn.nukkit.block.BlockCauldronLava" {
    declare const BlockCauldronLava = cn.nukkit.block.BlockCauldronLava;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsAndesitePolished extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsAndesitePolished" {
    declare const BlockStairsAndesitePolished = cn.nukkit.block.BlockStairsAndesitePolished;
}

declare namespace cn.nukkit.block {
    declare class Loggers extends java.lang.Object {
        constructor(): void
        static logBlocKEntityHolder: org.apache.logging.log4j.Logger

    }
}

declare module "cn.nukkit.block.Loggers" {
    declare const Loggers = cn.nukkit.block.Loggers;
}

declare namespace cn.nukkit.block {
    declare class BlockWaterStill extends cn.nukkit.block.BlockWater {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getBlock(meta: int): cn.nukkit.block.BlockLiquid

    }
}

declare module "cn.nukkit.block.BlockWaterStill" {
    declare const BlockWaterStill = cn.nukkit.block.BlockWaterStill;
}

declare namespace cn.nukkit.block {
    declare class BlockPressurePlateStone extends cn.nukkit.block.BlockPressurePlateBase {
        public constructor(meta: int): void
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        computeRedstoneStrength(): int

    }
}

declare module "cn.nukkit.block.BlockPressurePlateStone" {
    declare const BlockPressurePlateStone = cn.nukkit.block.BlockPressurePlateStone;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsPrismarineBrick extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsPrismarineBrick" {
    declare const BlockStairsPrismarineBrick = cn.nukkit.block.BlockStairsPrismarineBrick;
}

declare namespace cn.nukkit.block {
    declare class BlockFenceGate extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getWaterloggingLevel(): int
        public canBeActivated(): boolean
        public getToolType(): int
        getOffsetIndex(): int
        public getMinX(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxZ(): double
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public toggle(player: cn.nukkit.Player): boolean
        public setOpen(player: cn.nukkit.Player, open: boolean): boolean
        public playOpenCloseSound(): void
        public playOpenSound(): void
        public playCloseSound(): void
        public isOpen(): boolean
        public setOpen(open: boolean): void
        public onUpdate(type: int): int
        onRedstoneUpdate(): void
        public setManualOverride(val: boolean): void
        public getManualOverride(): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public isInWall(): boolean
        public setInWall(inWall: boolean): void
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        static manualOverrides: java.util.List<cn.nukkit.level.Location>
        public static IN_WALL: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        static offMinX: double[]
        static offMinZ: double[]
        static offMaxX: double[]
        static offMaxZ: double[]

    }
}

declare module "cn.nukkit.block.BlockFenceGate" {
    declare const BlockFenceGate = cn.nukkit.block.BlockFenceGate;
}

declare namespace cn.nukkit.block {
    declare class BlockLight extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getLightLevel(): int
        public getBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getWaterloggingLevel(): int
        public canBeFlowedInto(): boolean
        public canBeReplaced(): boolean
        public canHarvestWithHand(): boolean
        public getHardness(): double
        public getResistance(): double
        public canPassThrough(): boolean
        public toItem(): cn.nukkit.item.Item
        public static LIGHT_LEVEL: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockLight" {
    declare const BlockLight = cn.nukkit.block.BlockLight;
}

declare namespace cn.nukkit.block {
    declare class BlockLeaves extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getToolType(): int
        public getType(): cn.nukkit.blockproperty.value.WoodType
        public setType(type: cn.nukkit.blockproperty.value.WoodType): void
        public getName(): string
        public getBurnChance(): int
        public getWaterloggingLevel(): int
        public getBurnAbility(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public onUpdate(type: int): int
        findLog(current: cn.nukkit.block.Block, distance: int, visited: it.unimi.dsi.fastutil.longs.Long2LongMap): boolean
        public isCheckDecay(): boolean
        public setCheckDecay(checkDecay: boolean): void
        public isPersistent(): boolean
        public setPersistent(persistent: boolean): void
        public getColor(): cn.nukkit.utils.BlockColor
        public canSilkTouch(): boolean
        canDropApple(): boolean
        getSapling(): cn.nukkit.item.Item
        public diffusesSkyLight(): boolean
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        public static OLD_LEAF_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.WoodType>
        public static PERSISTENT: cn.nukkit.blockproperty.BooleanBlockProperty
        public static UPDATE: cn.nukkit.blockproperty.BooleanBlockProperty
        public static OLD_LEAF_PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        static VISIT_ORDER: cn.nukkit.math.BlockFace[]
        public static OAK: int
        public static SPRUCE: int
        public static BIRCH: int
        public static JUNGLE: int

    }
}

declare module "cn.nukkit.block.BlockLeaves" {
    declare const BlockLeaves = cn.nukkit.block.BlockLeaves;
}

declare namespace cn.nukkit.block {
    declare class BlockPrismarine extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getName(): string
        public setPrismarineBlockType(prismarineBlockType: cn.nukkit.blockproperty.value.PrismarineBlockType): void
        public getPrismarineBlockType(): cn.nukkit.blockproperty.value.PrismarineBlockType
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public static PRISMARINE_BLOCK_TYPE: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.blockproperty.value.PrismarineBlockType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static NORMAL: int
        public static DARK: int
        public static BRICKS: int

    }
}

declare module "cn.nukkit.block.BlockPrismarine" {
    declare const BlockPrismarine = cn.nukkit.block.BlockPrismarine;
}

declare namespace cn.nukkit.block {
    declare class BlockCoralFanHang extends cn.nukkit.block.BlockCoralFan implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public isDead(): boolean
        public onUpdate(type: int): int
        public getType(): int
        public getBlockFace(): cn.nukkit.math.BlockFace
        public getRootsFace(): cn.nukkit.math.BlockFace
        public toItem(): cn.nukkit.item.Item
        public static HANG1_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.CoralType>
        public static HANG_DIRECTION: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.math.BlockFace>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCoralFanHang" {
    declare const BlockCoralFanHang = cn.nukkit.block.BlockCoralFanHang;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazedOrange extends cn.nukkit.block.BlockTerracottaGlazed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getDyeColor(): cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazedOrange" {
    declare const BlockTerracottaGlazedOrange = cn.nukkit.block.BlockTerracottaGlazedOrange;
}

declare namespace cn.nukkit.block {
    declare class BlockLadder extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public hasEntityCollision(): boolean
        public canBeClimbed(): boolean
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public getWaterloggingLevel(): int
        public getHardness(): double
        public getResistance(): double
        calculateOffsets(): void
        public setDamage(meta: int): void
        public getMinX(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxZ(): double
        recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        isSupportValid(support: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace): boolean
        public onUpdate(type: int): int
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getBlockFace(): cn.nukkit.math.BlockFace
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        offMinX: double
        offMinZ: double
        offMaxX: double
        offMaxZ: double

    }
}

declare module "cn.nukkit.block.BlockLadder" {
    declare const BlockLadder = cn.nukkit.block.BlockLadder;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsCopperCutExposed extends cn.nukkit.block.BlockStairsCopperCut {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStairsCopperCutExposed" {
    declare const BlockStairsCopperCutExposed = cn.nukkit.block.BlockStairsCopperCutExposed;
}

declare namespace cn.nukkit.block {
    declare class BlockFallable extends cn.nukkit.block.BlockSolid {
        constructor(): void
        public onUpdate(type: int): int
        public drop(customNbt: cn.nukkit.nbt.tag.CompoundTag): void
        createFallingEntity(customNbt: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.entity.item.EntityFallingBlock

    }
}

declare module "cn.nukkit.block.BlockFallable" {
    declare const BlockFallable = cn.nukkit.block.BlockFallable;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabStone extends cn.nukkit.block.BlockDoubleSlabBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public getSlabType(): cn.nukkit.blockproperty.value.StoneSlab1Type
        public getSingleSlabId(): int
        public setSlabType(type: cn.nukkit.blockproperty.value.StoneSlab1Type): void
        public getSlabName(): string
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean
        public static STONE: int
        public static SANDSTONE: int
        public static WOODEN: int
        public static COBBLESTONE: int
        public static BRICK: int
        public static STONE_BRICK: int
        public static QUARTZ: int
        public static NETHER_BRICK: int

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabStone" {
    declare const BlockDoubleSlabStone = cn.nukkit.block.BlockDoubleSlabStone;
}

declare namespace cn.nukkit.block {
    declare class BlockStemPumpkin extends cn.nukkit.block.BlockCropsStem implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getFruitId(): int
        public getSeedsId(): int
        public getName(): string
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void

    }
}

declare module "cn.nukkit.block.BlockStemPumpkin" {
    declare const BlockStemPumpkin = cn.nukkit.block.BlockStemPumpkin;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsPrismarine extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsPrismarine" {
    declare const BlockStairsPrismarine = cn.nukkit.block.BlockStairsPrismarine;
}

declare namespace cn.nukkit.block {
    declare class BlockOreRedstoneGlowing extends cn.nukkit.block.BlockOreRedstone implements cn.nukkit.block.IBlockOreRedstoneGlowing {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getLightLevel(): int
        public toItem(): cn.nukkit.item.Item
        public onUpdate(type: int): int

    }
}

declare module "cn.nukkit.block.BlockOreRedstoneGlowing" {
    declare const BlockOreRedstoneGlowing = cn.nukkit.block.BlockOreRedstoneGlowing;
}

declare namespace cn.nukkit.block {
    declare class BlockLavaStill extends cn.nukkit.block.BlockLava {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getBlock(meta: int): cn.nukkit.block.BlockLiquid
        public onUpdate(type: int): int

    }
}

declare module "cn.nukkit.block.BlockLavaStill" {
    declare const BlockLavaStill = cn.nukkit.block.BlockLavaStill;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsBrickBlackstonePolished extends cn.nukkit.block.BlockStairsBlackstonePolished {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double

    }
}

declare module "cn.nukkit.block.BlockStairsBrickBlackstonePolished" {
    declare const BlockStairsBrickBlackstonePolished = cn.nukkit.block.BlockStairsBrickBlackstonePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsTileDeepslate extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public getToolTier(): int
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStairsTileDeepslate" {
    declare const BlockStairsTileDeepslate = cn.nukkit.block.BlockStairsTileDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockRailDetector extends cn.nukkit.block.BlockRail {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public isPowerSource(): boolean
        public getWeakPower(side: cn.nukkit.math.BlockFace): int
        public getStrongPower(side: cn.nukkit.math.BlockFace): int
        public setActive(): void
        public isActive(): boolean
        public isRailActive(): cn.nukkit.utils.OptionalBoolean
        public setRailActive(active: boolean): void
        static lambda$static$0(): void
        public static activeDetectors: java.util.Set<cn.nukkit.level.Position>

    }
}

declare module "cn.nukkit.block.BlockRailDetector" {
    declare const BlockRailDetector = cn.nukkit.block.BlockRailDetector;
}

declare namespace cn.nukkit.block {
    declare class BlockWoodMangrove extends cn.nukkit.block.BlockWood {
        public constructor(): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType
        public setWoodType(woodType: cn.nukkit.blockproperty.value.WoodType): void
        public isStripped(): boolean
        public setStripped(stripped: boolean): void
        getStrippedState(): cn.nukkit.blockstate.BlockState
        public static STRIPPED_BIT: string
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockWoodMangrove" {
    declare const BlockWoodMangrove = cn.nukkit.block.BlockWoodMangrove;
}

declare namespace cn.nukkit.block {
    declare class BlockDeadBush extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getWaterloggingLevel(): int
        public canBeReplaced(): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        isSupportValid(): boolean
        public onUpdate(type: int): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDeadBush" {
    declare const BlockDeadBush = cn.nukkit.block.BlockDeadBush;
}

declare namespace cn.nukkit.block {
    declare class BlockSoulTorch extends cn.nukkit.block.BlockTorch {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getLightLevel(): int

    }
}

declare module "cn.nukkit.block.BlockSoulTorch" {
    declare const BlockSoulTorch = cn.nukkit.block.BlockSoulTorch;
}

declare namespace cn.nukkit.block {
    declare class BlockCoralFan$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$math$BlockFace: int[]

    }
}

declare module "cn.nukkit.block.BlockCoralFan$1" {
    declare const BlockCoralFan$1 = cn.nukkit.block.BlockCoralFan$1;
}

declare namespace cn.nukkit.block {
    declare class BlockCoralBlock extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public isDead(): boolean
        public setDead(dead: boolean): void
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public getToolType(): int
        public onUpdate(type: int): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCoralBlock" {
    declare const BlockCoralBlock = cn.nukkit.block.BlockCoralBlock;
}

declare namespace cn.nukkit.block {
    declare class BlockMobSpawner extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getToolType(): int
        public getToolTier(): int
        public getHardness(): double
        public getResistance(): double
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canBePushed(): boolean
        public getWaterloggingLevel(): int
        public canBePulled(): boolean
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockMobSpawner" {
    declare const BlockMobSpawner = cn.nukkit.block.BlockMobSpawner;
}

declare namespace cn.nukkit.block {
    declare class BlockNetherReactor extends cn.nukkit.block.BlockSolid implements cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public getId(): int
        public getBlockEntityType(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityNetherReactor>
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public getToolType(): int
        public getToolTier(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockNetherReactor" {
    declare const BlockNetherReactor = cn.nukkit.block.BlockNetherReactor;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabCopperCutWeathered extends cn.nukkit.block.BlockSlabCopperCut {
        public constructor(): void
        public constructor(meta: int): void
        constructor(meta: int, doubleSlab: int): void
        public getId(): int
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockSlabCopperCutWeathered" {
    declare const BlockSlabCopperCutWeathered = cn.nukkit.block.BlockSlabCopperCutWeathered;
}

declare namespace cn.nukkit.block {
    declare class BlockRootsWarped extends cn.nukkit.block.BlockRoots {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockRootsWarped" {
    declare const BlockRootsWarped = cn.nukkit.block.BlockRootsWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockGold extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getToolType(): int
        public getHardness(): double
        public getResistance(): double
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockGold" {
    declare const BlockGold = cn.nukkit.block.BlockGold;
}

declare namespace cn.nukkit.block {
    declare class BlockPressurePlateJungle extends cn.nukkit.block.BlockPressurePlateWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockPressurePlateJungle" {
    declare const BlockPressurePlateJungle = cn.nukkit.block.BlockPressurePlateJungle;
}

declare namespace cn.nukkit.block {
    declare class BlockCobblestone extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getName(): string
        public getToolTier(): int
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockCobblestone" {
    declare const BlockCobblestone = cn.nukkit.block.BlockCobblestone;
}

declare namespace cn.nukkit.block {
    declare class BlockEnchantingTable extends cn.nukkit.block.BlockTransparent implements cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getBlockEntityType(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityEnchantTable>
        public getToolType(): int
        public getHardness(): double
        public getResistance(): double
        public getWaterloggingLevel(): int
        public getLightLevel(): int
        public canBeActivated(): boolean
        public getMaxY(): double
        public getToolTier(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public canHarvestWithHand(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public isSolid(side: cn.nukkit.math.BlockFace): boolean

    }
}

declare module "cn.nukkit.block.BlockEnchantingTable" {
    declare const BlockEnchantingTable = cn.nukkit.block.BlockEnchantingTable;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabRedSandstone extends cn.nukkit.block.BlockDoubleSlabBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getSlabType(): cn.nukkit.blockproperty.value.StoneSlab2Type
        public setSlabType(type: cn.nukkit.blockproperty.value.StoneSlab2Type): void
        public getSlabName(): string
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public getSingleSlabId(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabRedSandstone" {
    declare const BlockDoubleSlabRedSandstone = cn.nukkit.block.BlockDoubleSlabRedSandstone;
}

declare namespace cn.nukkit.block {
    declare class BlockBeeNest extends cn.nukkit.block.BlockBeehive {
        public constructor(): void
        constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getBurnChance(): int
        public getBurnAbility(): int
        public getHardness(): double
        public getResistance(): double
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockBeeNest" {
    declare const BlockBeeNest = cn.nukkit.block.BlockBeeNest;
}

declare namespace cn.nukkit.block {
    declare class BlockReinForcedDeepSlate extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getResistance(): double

    }
}

declare module "cn.nukkit.block.BlockReinForcedDeepSlate" {
    declare const BlockReinForcedDeepSlate = cn.nukkit.block.BlockReinForcedDeepSlate;
}

declare namespace cn.nukkit.block {
    declare class BlockTrapdoorSpruce extends cn.nukkit.block.BlockTrapdoor {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockTrapdoorSpruce" {
    declare const BlockTrapdoorSpruce = cn.nukkit.block.BlockTrapdoorSpruce;
}

declare namespace cn.nukkit.block {
    declare class BlockLever$LeverOrientation extends java.lang.Enum {
        public static values(): cn.nukkit.block.BlockLever$LeverOrientation[]
        public static valueOf(name: string): cn.nukkit.block.BlockLever$LeverOrientation
        constructor(var0: int, var1: string, meta: cn.nukkit.math.BlockFace): void
        public getMetadata(): int
        public getFacing(): cn.nukkit.math.BlockFace
        public toString(): string
        public static byMetadata(meta: int): cn.nukkit.block.BlockLever$LeverOrientation
        public static forFacings(clickedSide: cn.nukkit.math.BlockFace, playerDirection: cn.nukkit.math.BlockFace): cn.nukkit.block.BlockLever$LeverOrientation
        public getName(): string
        static $values(): cn.nukkit.block.BlockLever$LeverOrientation[]
        public static DOWN_X: cn.nukkit.block.BlockLever$LeverOrientation
        public static EAST: cn.nukkit.block.BlockLever$LeverOrientation
        public static WEST: cn.nukkit.block.BlockLever$LeverOrientation
        public static SOUTH: cn.nukkit.block.BlockLever$LeverOrientation
        public static NORTH: cn.nukkit.block.BlockLever$LeverOrientation
        public static UP_Z: cn.nukkit.block.BlockLever$LeverOrientation
        public static UP_X: cn.nukkit.block.BlockLever$LeverOrientation
        public static DOWN_Z: cn.nukkit.block.BlockLever$LeverOrientation
        static META_LOOKUP: cn.nukkit.block.BlockLever$LeverOrientation[]
        meta: int
        name: string
        facing: cn.nukkit.math.BlockFace
        static $VALUES: cn.nukkit.block.BlockLever$LeverOrientation[]

    }
}

declare module "cn.nukkit.block.BlockLever$LeverOrientation" {
    declare const BlockLever$LeverOrientation = cn.nukkit.block.BlockLever$LeverOrientation;
}

declare namespace cn.nukkit.block {
    declare class BlockAir extends cn.nukkit.block.BlockTransparent {
        public constructor(): void
        public getId(): int
        public getName(): string
        public canPassThrough(): boolean
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public canBeFlowedInto(): boolean
        public canBePlaced(): boolean
        public canBeReplaced(): boolean
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public getBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockAir" {
    declare const BlockAir = cn.nukkit.block.BlockAir;
}

declare namespace cn.nukkit.block {
    declare class BlockVine extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(meta: int): void
        public constructor(): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public canPassThrough(): boolean
        public hasEntityCollision(): boolean
        public canBeReplaced(): boolean
        public canBeClimbed(): boolean
        public getWaterloggingLevel(): int
        public canBeFlowedInto(): boolean
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public toItem(): cn.nukkit.item.Item
        public onUpdate(type: int): int
        canSpread(): boolean
        putVine(block: cn.nukkit.block.Block, meta: int, source: cn.nukkit.block.Block): void
        putVineOnHorizontalFace(block: cn.nukkit.block.Block, meta: int, source: cn.nukkit.block.Block): void
        getFaces(): java.util.Set<cn.nukkit.math.BlockFace>
        public static getMetaFromFaces(faces: java.util.Set<cn.nukkit.math.BlockFace>): int
        public static getMetaFromFace(face: cn.nukkit.math.BlockFace): int
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        public canSilkTouch(): boolean
        static VINE_DIRECTION_BITS: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockVine" {
    declare const BlockVine = cn.nukkit.block.BlockVine;
}

declare namespace cn.nukkit.block {
    declare class BlockSand extends cn.nukkit.block.BlockFallableMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public static SAND_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.SandType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static DEFAULT: int
        public static RED: int

    }
}

declare module "cn.nukkit.block.BlockSand" {
    declare const BlockSand = cn.nukkit.block.BlockSand;
}

declare namespace cn.nukkit.block {
    declare class BlockBricksDeepslate extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public getToolType(): int
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockBricksDeepslate" {
    declare const BlockBricksDeepslate = cn.nukkit.block.BlockBricksDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockFungus extends cn.nukkit.block.BlockFlowable {
        constructor(): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        canGrowOn(var0: cn.nukkit.block.Block): boolean
        isValidSupport(support: cn.nukkit.block.Block): boolean
        public canBeActivated(): boolean
        public grow(var0: cn.nukkit.Player): boolean

    }
}

declare module "cn.nukkit.block.BlockFungus" {
    declare const BlockFungus = cn.nukkit.block.BlockFungus;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCyan extends cn.nukkit.block.BlockCandle {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        toCakeForm(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockCandleCyan" {
    declare const BlockCandleCyan = cn.nukkit.block.BlockCandleCyan;
}

declare namespace cn.nukkit.block {
    declare class BlockSmokerBurning extends cn.nukkit.block.BlockFurnaceBurning {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getBlockEntityType(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntitySmoker>
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockSmokerBurning" {
    declare const BlockSmokerBurning = cn.nukkit.block.BlockSmokerBurning;
}

declare namespace cn.nukkit.block {
    declare class BlockNoteblock$Instrument extends java.lang.Enum {
        public static values(): cn.nukkit.block.BlockNoteblock$Instrument[]
        public static valueOf(name: string): cn.nukkit.block.BlockNoteblock$Instrument
        constructor(var0: cn.nukkit.level.Sound): void
        public getSound(): cn.nukkit.level.Sound
        static $values(): cn.nukkit.block.BlockNoteblock$Instrument[]
        public static PIANO: cn.nukkit.block.BlockNoteblock$Instrument
        public static BASS_DRUM: cn.nukkit.block.BlockNoteblock$Instrument
        public static DRUM: cn.nukkit.block.BlockNoteblock$Instrument
        public static STICKS: cn.nukkit.block.BlockNoteblock$Instrument
        public static BASS: cn.nukkit.block.BlockNoteblock$Instrument
        public static GLOCKENSPIEL: cn.nukkit.block.BlockNoteblock$Instrument
        public static FLUTE: cn.nukkit.block.BlockNoteblock$Instrument
        public static CHIME: cn.nukkit.block.BlockNoteblock$Instrument
        public static GUITAR: cn.nukkit.block.BlockNoteblock$Instrument
        public static XYLOPHONE: cn.nukkit.block.BlockNoteblock$Instrument
        public static VIBRAPHONE: cn.nukkit.block.BlockNoteblock$Instrument
        public static COW_BELL: cn.nukkit.block.BlockNoteblock$Instrument
        public static DIDGERIDOO: cn.nukkit.block.BlockNoteblock$Instrument
        public static SQUARE_WAVE: cn.nukkit.block.BlockNoteblock$Instrument
        public static BANJO: cn.nukkit.block.BlockNoteblock$Instrument
        public static ELECTRIC_PIANO: cn.nukkit.block.BlockNoteblock$Instrument
        sound: cn.nukkit.level.Sound
        static $VALUES: cn.nukkit.block.BlockNoteblock$Instrument[]

    }
}

declare module "cn.nukkit.block.BlockNoteblock$Instrument" {
    declare const BlockNoteblock$Instrument = cn.nukkit.block.BlockNoteblock$Instrument;
}

declare namespace cn.nukkit.block {
    declare class BlockTripWire extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(meta: int): void
        public constructor(): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public canPassThrough(): boolean
        public getWaterloggingLevel(): int
        public canBeFlowedInto(): boolean
        public getResistance(): double
        public getHardness(): double
        public getBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public toItem(): cn.nukkit.item.Item
        public isPowered(): boolean
        public isAttached(): boolean
        public isDisarmed(): boolean
        public setPowered(value: boolean): void
        public setAttached(value: boolean): void
        public setDisarmed(value: boolean): void
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        updateHook(scheduleUpdate: boolean): void
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public getMaxY(): double
        recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public static ATTACHED: cn.nukkit.blockproperty.BooleanBlockProperty
        public static DISARMED: cn.nukkit.blockproperty.BooleanBlockProperty
        public static SUSPENDED: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockTripWire" {
    declare const BlockTripWire = cn.nukkit.block.BlockTripWire;
}

declare namespace cn.nukkit.block {
    declare class BlockButtonDarkOak extends cn.nukkit.block.BlockButtonWooden {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockButtonDarkOak" {
    declare const BlockButtonDarkOak = cn.nukkit.block.BlockButtonDarkOak;
}

declare namespace cn.nukkit.block {
    declare class BlockPressurePlateBirch extends cn.nukkit.block.BlockPressurePlateWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockPressurePlateBirch" {
    declare const BlockPressurePlateBirch = cn.nukkit.block.BlockPressurePlateBirch;
}

declare namespace cn.nukkit.block {
    declare class BlockBuddingAmethyst extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getResistance(): double
        public getHardness(): double
        public getColor(): cn.nukkit.utils.BlockColor
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public onUpdate(type: int): int
        public tryGrow(time: int): void
        static RANDOM: cn.nukkit.math.NukkitRandom

    }
}

declare module "cn.nukkit.block.BlockBuddingAmethyst" {
    declare const BlockBuddingAmethyst = cn.nukkit.block.BlockBuddingAmethyst;
}

declare namespace cn.nukkit.block {
    declare class BlockFlowable extends cn.nukkit.block.BlockTransparentMeta {
        constructor(): void
        constructor(meta: int): void
        public canBeFlowedInto(): boolean
        public canPassThrough(): boolean
        public getHardness(): double
        public getResistance(): double
        public isSolid(): boolean
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB

    }
}

declare module "cn.nukkit.block.BlockFlowable" {
    declare const BlockFlowable = cn.nukkit.block.BlockFlowable;
}

declare namespace cn.nukkit.block {
    declare class BlockRedstoneComparatorUnpowered extends cn.nukkit.block.BlockRedstoneComparator {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        getUnpowered(): cn.nukkit.block.BlockRedstoneComparator
        getUnpowered(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockRedstoneComparatorUnpowered" {
    declare const BlockRedstoneComparatorUnpowered = cn.nukkit.block.BlockRedstoneComparatorUnpowered;
}

declare namespace cn.nukkit.block {
    declare class BlockSugarcane extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public toItem(): cn.nukkit.item.Item
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        isSupportValid(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public static AGE: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockSugarcane" {
    declare const BlockSugarcane = cn.nukkit.block.BlockSugarcane;
}

declare namespace cn.nukkit.block {
    declare class BlockSponge extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        performWaterAbsorb(block: cn.nukkit.block.Block): boolean
        static lambda$place$0(b: cn.nukkit.block.Block): boolean
        public static SPONGE_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.SpongeType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static DRY: int
        public static WET: int
        static NAMES: string[]

    }
}

declare module "cn.nukkit.block.BlockSponge" {
    declare const BlockSponge = cn.nukkit.block.BlockSponge;
}

declare namespace cn.nukkit.block {
    declare class BlockButtonStone extends cn.nukkit.block.BlockButton {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]

    }
}

declare module "cn.nukkit.block.BlockButtonStone" {
    declare const BlockButtonStone = cn.nukkit.block.BlockButtonStone;
}

declare namespace cn.nukkit.block {
    declare class BlockCopperCutExposedWaxed extends cn.nukkit.block.BlockCopperCutExposed {
        public constructor(): void
        public getName(): string
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockCopperCutExposedWaxed" {
    declare const BlockCopperCutExposedWaxed = cn.nukkit.block.BlockCopperCutExposedWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazedBrown extends cn.nukkit.block.BlockTerracottaGlazed {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getDyeColor(): cn.nukkit.utils.DyeColor

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazedBrown" {
    declare const BlockTerracottaGlazedBrown = cn.nukkit.block.BlockTerracottaGlazedBrown;
}

declare namespace cn.nukkit.block {
    declare class BlockChorusFlower extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        isPositionValid(): boolean
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        public onProjectileHit(projectile: cn.nukkit.entity.Entity, position: cn.nukkit.level.Position, motion: cn.nukkit.math.Vector3): boolean
        public getMaxAge(): int
        public getAge(): int
        public setAge(age: int): void
        public isFullyAged(): boolean
        isHorizontalAir(block: cn.nukkit.block.Block): boolean
        isHorizontalAirExcept(block: cn.nukkit.block.Block, except: cn.nukkit.math.BlockFace): boolean
        public static AGE: cn.nukkit.blockproperty.IntBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockChorusFlower" {
    declare const BlockChorusFlower = cn.nukkit.block.BlockChorusFlower;
}

declare namespace cn.nukkit.block {
    declare class BlockLever extends cn.nukkit.block.BlockFlowable implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public canBeActivated(): boolean
        public getHardness(): double
        public getResistance(): double
        public toItem(): cn.nukkit.item.Item
        public isPowerOn(): boolean
        public setPowerOn(powerOn: boolean): void
        public getLeverOrientation(): cn.nukkit.block.BlockLever$LeverOrientation
        public setLeverOrientation(value: cn.nukkit.block.BlockLever$LeverOrientation): void
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public static isSupportValid(support: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public getWeakPower(side: cn.nukkit.math.BlockFace): int
        public getStrongPower(side: cn.nukkit.math.BlockFace): int
        public isPowerSource(): boolean
        public getWaterloggingLevel(): int
        public canBeFlowedInto(): boolean
        public getBlockFace(): cn.nukkit.math.BlockFace
        public getColor(): cn.nukkit.utils.BlockColor
        public static LEVER_DIRECTION: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.block.BlockLever$LeverOrientation>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockLever" {
    declare const BlockLever = cn.nukkit.block.BlockLever;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsWarped extends cn.nukkit.block.BlockStairsWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockStairsWarped" {
    declare const BlockStairsWarped = cn.nukkit.block.BlockStairsWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabRedSandstone extends cn.nukkit.block.BlockSlab {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getSlabName(): string
        public getSlabType(): cn.nukkit.blockproperty.value.StoneSlab2Type
        public setSlabType(type: cn.nukkit.blockproperty.value.StoneSlab2Type): void
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getToolType(): int
        public getToolTier(): int
        public canHarvestWithHand(): boolean
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static RED_SANDSTONE: int
        public static PURPUR: int
        public static PRISMARINE: int
        public static PRISMARINE_BRICKS: int
        public static DARK_PRISMARINE: int
        public static MOSSY_COBBLESTONE: int
        public static SMOOTH_SANDSTONE: int
        public static RED_NETHER_BRICK: int

    }
}

declare module "cn.nukkit.block.BlockSlabRedSandstone" {
    declare const BlockSlabRedSandstone = cn.nukkit.block.BlockSlabRedSandstone;
}

declare namespace cn.nukkit.block {
    declare class BlockCommandBlockChain extends cn.nukkit.block.BlockCommandBlock {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockCommandBlockChain" {
    declare const BlockCommandBlockChain = cn.nukkit.block.BlockCommandBlockChain;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabCopperCutOxidizedWaxed extends cn.nukkit.block.BlockSlabCopperCutOxidized {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public isWaxed(): boolean

    }
}

declare module "cn.nukkit.block.BlockSlabCopperCutOxidizedWaxed" {
    declare const BlockSlabCopperCutOxidizedWaxed = cn.nukkit.block.BlockSlabCopperCutOxidizedWaxed;
}

declare namespace cn.nukkit.block {
    declare class BlockTrappedChest extends cn.nukkit.block.BlockChest {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public getWeakPower(face: cn.nukkit.math.BlockFace): int
        public getStrongPower(side: cn.nukkit.math.BlockFace): int
        public isPowerSource(): boolean

    }
}

declare module "cn.nukkit.block.BlockTrappedChest" {
    declare const BlockTrappedChest = cn.nukkit.block.BlockTrappedChest;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabBrickDeepslate extends cn.nukkit.block.BlockDoubleSlabBase {
        public constructor(): void
        constructor(meta: int): void
        public getId(): int
        public getSingleSlabId(): int
        public getSlabName(): string
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public getToolTier(): int
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabBrickDeepslate" {
    declare const BlockDoubleSlabBrickDeepslate = cn.nukkit.block.BlockDoubleSlabBrickDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsGranite extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsGranite" {
    declare const BlockStairsGranite = cn.nukkit.block.BlockStairsGranite;
}

declare namespace cn.nukkit.block {
    declare class BlockSmoker extends cn.nukkit.block.BlockSmokerBurning {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getLightLevel(): int

    }
}

declare module "cn.nukkit.block.BlockSmoker" {
    declare const BlockSmoker = cn.nukkit.block.BlockSmoker;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleRed extends cn.nukkit.block.BlockCandle {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        toCakeForm(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockCandleRed" {
    declare const BlockCandleRed = cn.nukkit.block.BlockCandleRed;
}

declare namespace cn.nukkit.block {
    declare class BlockMudBrickSlab extends cn.nukkit.block.BlockSlab {
        public constructor(): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getSlabName(): string
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean

    }
}

declare module "cn.nukkit.block.BlockMudBrickSlab" {
    declare const BlockMudBrickSlab = cn.nukkit.block.BlockMudBrickSlab;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsSpruce extends cn.nukkit.block.BlockStairsWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStairsSpruce" {
    declare const BlockStairsSpruce = cn.nukkit.block.BlockStairsSpruce;
}

declare namespace cn.nukkit.block {
    declare class BlockDaylightDetectorInverted extends cn.nukkit.block.BlockDaylightDetector {
        public constructor(): void
        public getId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public isInverted(): boolean

    }
}

declare module "cn.nukkit.block.BlockDaylightDetectorInverted" {
    declare const BlockDaylightDetectorInverted = cn.nukkit.block.BlockDaylightDetectorInverted;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCakePurple extends cn.nukkit.block.BlockCandleCake {
        public constructor(meta: int): void
        public constructor(): void
        getColorName(): string
        public getId(): int
        toCandleForm(): cn.nukkit.block.BlockCandle

    }
}

declare module "cn.nukkit.block.BlockCandleCakePurple" {
    declare const BlockCandleCakePurple = cn.nukkit.block.BlockCandleCakePurple;
}

declare namespace cn.nukkit.block {
    declare class BlockMudBrickWall extends cn.nukkit.block.BlockWallBase {
        public constructor(): void
        public getName(): string
        public getId(): int

    }
}

declare module "cn.nukkit.block.BlockMudBrickWall" {
    declare const BlockMudBrickWall = cn.nukkit.block.BlockMudBrickWall;
}

declare namespace cn.nukkit.block {
    declare class BlockOreQuartz extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getDropExp(): int
        public canHarvestWithHand(): boolean
        public canSilkTouch(): boolean

    }
}

declare module "cn.nukkit.block.BlockOreQuartz" {
    declare const BlockOreQuartz = cn.nukkit.block.BlockOreQuartz;
}

declare namespace cn.nukkit.block {
    declare interface BlockID {
        public static AIR: int
        public static STONE: int
        public static GRASS: int
        public static DIRT: int
        public static COBBLESTONE: int
        public static COBBLE: int
        public static PLANKS: int
        public static PLANK: int
        public static WOODEN_PLANK: int
        public static WOODEN_PLANKS: int
        public static SAPLING: int
        public static SAPLINGS: int
        public static BEDROCK: int
        public static FLOWING_WATER: int
        public static WATER: int
        public static STILL_WATER: int
        public static FLOWING_LAVA: int
        public static LAVA: int
        public static STILL_LAVA: int
        public static SAND: int
        public static GRAVEL: int
        public static GOLD_ORE: int
        public static IRON_ORE: int
        public static COAL_ORE: int
        public static LOG: int
        public static WOOD: int
        public static TRUNK: int
        public static LEAVES: int
        public static LEAVE: int
        public static SPONGE: int
        public static GLASS: int
        public static LAPIS_ORE: int
        public static LAPIS_BLOCK: int
        public static DISPENSER: int
        public static SANDSTONE: int
        public static NOTEBLOCK: int
        public static BED_BLOCK: int
        public static POWERED_RAIL: int
        public static DETECTOR_RAIL: int
        public static STICKY_PISTON: int
        public static COBWEB: int
        public static TALL_GRASS: int
        public static BUSH: int
        public static DEAD_BUSH: int
        public static PISTON: int
        public static PISTON_ARM_COLLISION: int
        public static WOOL: int
        public static DANDELION: int
        public static RED_FLOWER: int
        public static POPPY: int
        public static ROSE: int
        public static FLOWER: int
        public static BROWN_MUSHROOM: int
        public static RED_MUSHROOM: int
        public static GOLD_BLOCK: int
        public static IRON_BLOCK: int
        public static DOUBLE_STONE_SLAB: int
        public static DOUBLE_SLAB: int
        public static DOUBLE_SLABS: int
        public static DOUBLE_STONE_BLOCK_SLAB: int
        public static STONE_SLAB: int
        public static SLAB: int
        public static SLABS: int
        public static STONE_BLOCK_SLAB: int
        public static BRICKS_BLOCK: int
        public static BRICKS: int
        public static TNT: int
        public static BOOKSHELF: int
        public static MOSSY_COBBLESTONE: int
        public static MOSS_STONE: int
        public static MOSSY_STONE: int
        public static OBSIDIAN: int
        public static TORCH: int
        public static FIRE: int
        public static MOB_SPAWNER: int
        public static MONSTER_SPAWNER: int
        public static OAK_STAIRS: int
        public static WOOD_STAIRS: int
        public static WOODEN_STAIRS: int
        public static OAK_WOOD_STAIRS: int
        public static OAK_WOODEN_STAIRS: int
        public static CHEST: int
        public static REDSTONE_WIRE: int
        public static DIAMOND_ORE: int
        public static DIAMOND_BLOCK: int
        public static CRAFTING_TABLE: int
        public static WORKBENCH: int
        public static WHEAT_BLOCK: int
        public static FARMLAND: int
        public static FURNACE: int
        public static LIT_FURNACE: int
        public static BURNING_FURNACE: int
        public static SIGN_POST: int
        public static OAK_DOOR_BLOCK: int
        public static DOOR_BLOCK: int
        public static WOODEN_DOOR_BLOCK: int
        public static WOOD_DOOR_BLOCK: int
        public static LADDER: int
        public static RAIL: int
        public static STONE_STAIRS: int
        public static COBBLESTONE_STAIRS: int
        public static COBBLE_STAIRS: int
        public static WALL_SIGN: int
        public static LEVER: int
        public static STONE_PRESSURE_PLATE: int
        public static IRON_DOOR_BLOCK: int
        public static WOODEN_PRESSURE_PLATE: int
        public static REDSTONE_ORE: int
        public static LIT_REDSTONE_ORE: int
        public static GLOWING_REDSTONE_ORE: int
        public static UNLIT_REDSTONE_TORCH: int
        public static REDSTONE_TORCH: int
        public static STONE_BUTTON: int
        public static SNOW_LAYER: int
        public static SNOW: int
        public static ICE: int
        public static SNOW_BLOCK: int
        public static CACTUS: int
        public static CLAY_BLOCK: int
        public static REEDS: int
        public static SUGARCANE_BLOCK: int
        public static JUKEBOX: int
        public static FENCE: int
        public static PUMPKIN: int
        public static NETHERRACK: int
        public static SOUL_SAND: int
        public static GLOWSTONE: int
        public static GLOWSTONE_BLOCK: int
        public static NETHER_PORTAL: int
        public static LIT_PUMPKIN: int
        public static JACK_O_LANTERN: int
        public static CAKE_BLOCK: int
        public static UNPOWERED_REPEATER: int
        public static POWERED_REPEATER: int
        public static INVISIBLE_BEDROCK: int
        public static TRAPDOOR: int
        public static MONSTER_EGG: int
        public static STONEBRICK: int
        public static STONE_BRICKS: int
        public static STONE_BRICK: int
        public static BROWN_MUSHROOM_BLOCK: int
        public static RED_MUSHROOM_BLOCK: int
        public static IRON_BARS: int
        public static IRON_BAR: int
        public static GLASS_PANE: int
        public static GLASS_PANEL: int
        public static MELON_BLOCK: int
        public static PUMPKIN_STEM: int
        public static MELON_STEM: int
        public static VINE: int
        public static VINES: int
        public static FENCE_GATE: int
        public static FENCE_GATE_OAK: int
        public static BRICK_STAIRS: int
        public static STONE_BRICK_STAIRS: int
        public static MYCELIUM: int
        public static WATERLILY: int
        public static WATER_LILY: int
        public static LILY_PAD: int
        public static NETHER_BRICK_BLOCK: int
        public static NETHER_BRICKS: int
        public static NETHER_BRICK_FENCE: int
        public static NETHER_BRICKS_STAIRS: int
        public static NETHER_WART_BLOCK: int
        public static ENCHANTING_TABLE: int
        public static ENCHANT_TABLE: int
        public static ENCHANTMENT_TABLE: int
        public static BREWING_STAND_BLOCK: int
        public static BREWING_BLOCK: int
        public static CAULDRON_BLOCK: int
        public static END_PORTAL: int
        public static END_PORTAL_FRAME: int
        public static END_STONE: int
        public static DRAGON_EGG: int
        public static REDSTONE_LAMP: int
        public static LIT_REDSTONE_LAMP: int
        public static DROPPER: int
        public static ACTIVATOR_RAIL: int
        public static COCOA: int
        public static COCOA_BLOCK: int
        public static SANDSTONE_STAIRS: int
        public static EMERALD_ORE: int
        public static ENDER_CHEST: int
        public static TRIPWIRE_HOOK: int
        public static TRIP_WIRE: int
        public static EMERALD_BLOCK: int
        public static SPRUCE_STAIRS: int
        public static SPRUCE_WOOD_STAIRS: int
        public static SPRUCE_WOODEN_STAIRS: int
        public static BIRCH_STAIRS: int
        public static BIRCH_WOOD_STAIRS: int
        public static BIRCH_WOODEN_STAIRS: int
        public static JUNGLE_STAIRS: int
        public static JUNGLE_WOOD_STAIRS: int
        public static JUNGLE_WOODEN_STAIRS: int
        public static COMMAND_BLOCK: int
        public static BEACON: int
        public static COBBLE_WALL: int
        public static STONE_WALL: int
        public static COBBLESTONE_WALL: int
        public static FLOWER_POT_BLOCK: int
        public static CARROT_BLOCK: int
        public static POTATO_BLOCK: int
        public static WOODEN_BUTTON: int
        public static SKULL_BLOCK: int
        public static ANVIL: int
        public static TRAPPED_CHEST: int
        public static LIGHT_WEIGHTED_PRESSURE_PLATE: int
        public static HEAVY_WEIGHTED_PRESSURE_PLATE: int
        public static UNPOWERED_COMPARATOR: int
        public static POWERED_COMPARATOR: int
        public static DAYLIGHT_DETECTOR: int
        public static REDSTONE_BLOCK: int
        public static QUARTZ_ORE: int
        public static HOPPER_BLOCK: int
        public static QUARTZ_BLOCK: int
        public static QUARTZ_STAIRS: int
        public static DOUBLE_WOOD_SLAB: int
        public static DOUBLE_WOODEN_SLAB: int
        public static DOUBLE_WOOD_SLABS: int
        public static DOUBLE_WOODEN_SLABS: int
        public static WOOD_SLAB: int
        public static WOODEN_SLAB: int
        public static WOOD_SLABS: int
        public static WOODEN_SLABS: int
        public static STAINED_TERRACOTTA: int
        public static STAINED_HARDENED_CLAY: int
        public static STAINED_GLASS_PANE: int
        public static LEAVES2: int
        public static LEAVE2: int
        public static WOOD2: int
        public static TRUNK2: int
        public static LOG2: int
        public static ACACIA_WOOD_STAIRS: int
        public static ACACIA_WOODEN_STAIRS: int
        public static DARK_OAK_WOOD_STAIRS: int
        public static DARK_OAK_WOODEN_STAIRS: int
        public static SLIME_BLOCK: int
        public static IRON_TRAPDOOR: int
        public static PRISMARINE: int
        public static SEA_LANTERN: int
        public static HAY_BALE: int
        public static CARPET: int
        public static TERRACOTTA: int
        public static HARDENED_CLAY: int
        public static COAL_BLOCK: int
        public static PACKED_ICE: int
        public static DOUBLE_PLANT: int
        public static STANDING_BANNER: int
        public static WALL_BANNER: int
        public static DAYLIGHT_DETECTOR_INVERTED: int
        public static RED_SANDSTONE: int
        public static RED_SANDSTONE_STAIRS: int
        public static DOUBLE_RED_SANDSTONE_SLAB: int
        public static DOUBLE_STONE_BLOCK_SLAB2: int
        public static RED_SANDSTONE_SLAB: int
        public static STONE_BLOCK_SLAB2: int
        public static FENCE_GATE_SPRUCE: int
        public static FENCE_GATE_BIRCH: int
        public static FENCE_GATE_JUNGLE: int
        public static FENCE_GATE_DARK_OAK: int
        public static FENCE_GATE_ACACIA: int
        public static REPEATING_COMMAND_BLOCK: int
        public static CHAIN_COMMAND_BLOCK: int
        public static SPRUCE_DOOR_BLOCK: int
        public static BIRCH_DOOR_BLOCK: int
        public static JUNGLE_DOOR_BLOCK: int
        public static ACACIA_DOOR_BLOCK: int
        public static DARK_OAK_DOOR_BLOCK: int
        public static GRASS_PATH: int
        public static ITEM_FRAME_BLOCK: int
        public static CHORUS_FLOWER: int
        public static PURPUR_BLOCK: int
        public static PURPUR_STAIRS: int
        public static UNDYED_SHULKER_BOX: int
        public static END_BRICKS: int
        public static ICE_FROSTED: int
        public static END_ROD: int
        public static END_GATEWAY: int
        public static ALLOW: int
        public static DENY: int
        public static BORDER_BLOCK: int
        public static MAGMA: int
        public static BLOCK_NETHER_WART_BLOCK: int
        public static RED_NETHER_BRICK: int
        public static BONE_BLOCK: int
        public static STRUCTURE_VOID: int
        public static SHULKER_BOX: int
        public static PURPLE_GLAZED_TERRACOTTA: int
        public static WHITE_GLAZED_TERRACOTTA: int
        public static ORANGE_GLAZED_TERRACOTTA: int
        public static MAGENTA_GLAZED_TERRACOTTA: int
        public static LIGHT_BLUE_GLAZED_TERRACOTTA: int
        public static YELLOW_GLAZED_TERRACOTTA: int
        public static LIME_GLAZED_TERRACOTTA: int
        public static PINK_GLAZED_TERRACOTTA: int
        public static GRAY_GLAZED_TERRACOTTA: int
        public static SILVER_GLAZED_TERRACOTTA: int
        public static CYAN_GLAZED_TERRACOTTA: int
        public static BLUE_GLAZED_TERRACOTTA: int
        public static BROWN_GLAZED_TERRACOTTA: int
        public static GREEN_GLAZED_TERRACOTTA: int
        public static RED_GLAZED_TERRACOTTA: int
        public static BLACK_GLAZED_TERRACOTTA: int
        public static CONCRETE: int
        public static CONCRETEPOWDER: int
        public static CONCRETE_POWDER: int
        public static CHORUS_PLANT: int
        public static STAINED_GLASS: int
        public static PODZOL: int
        public static BEETROOT_BLOCK: int
        public static STONECUTTER: int
        public static GLOWING_OBSIDIAN: int
        public static NETHERREACTOR: int
        public static NETHER_REACTOR: int
        public static INFO_UPDATE: int
        public static INFO_UPDATE2: int
        public static PISTON_EXTENSION: int
        public static MOVING_BLOCK: int
        public static OBSERVER: int
        public static STRUCTURE_BLOCK: int
        public static PRISMARINE_STAIRS: int
        public static DARK_PRISMARINE_STAIRS: int
        public static PRISMARINE_BRICKS_STAIRS: int
        public static STRIPPED_SPRUCE_LOG: int
        public static STRIPPED_BIRCH_LOG: int
        public static STRIPPED_JUNGLE_LOG: int
        public static STRIPPED_ACACIA_LOG: int
        public static STRIPPED_DARK_OAK_LOG: int
        public static STRIPPED_OAK_LOG: int
        public static BLUE_ICE: int
        public static SEAGRASS: int
        public static CORAL: int
        public static CORAL_BLOCK: int
        public static CORAL_FAN: int
        public static CORAL_FAN_DEAD: int
        public static CORAL_FAN_HANG: int
        public static CORAL_FAN_HANG2: int
        public static CORAL_FAN_HANG3: int
        public static BLOCK_KELP: int
        public static DRIED_KELP_BLOCK: int
        public static ACACIA_BUTTON: int
        public static BIRCH_BUTTON: int
        public static DARK_OAK_BUTTON: int
        public static JUNGLE_BUTTON: int
        public static SPRUCE_BUTTON: int
        public static ACACIA_TRAPDOOR: int
        public static BIRCH_TRAPDOOR: int
        public static DARK_OAK_TRAPDOOR: int
        public static JUNGLE_TRAPDOOR: int
        public static SPRUCE_TRAPDOOR: int
        public static ACACIA_PRESSURE_PLATE: int
        public static BIRCH_PRESSURE_PLATE: int
        public static DARK_OAK_PRESSURE_PLATE: int
        public static JUNGLE_PRESSURE_PLATE: int
        public static SPRUCE_PRESSURE_PLATE: int
        public static CARVED_PUMPKIN: int
        public static SEA_PICKLE: int
        public static CONDUIT: int
        public static TURTLE_EGG: int
        public static BUBBLE_COLUMN: int
        public static BARRIER: int
        public static STONE_SLAB3: int
        public static STONE_BLOCK_SLAB3: int
        public static BAMBOO: int
        public static BAMBOO_SAPLING: int
        public static SCAFFOLDING: int
        public static STONE_SLAB4: int
        public static STONE_BLOCK_SLAB4: int
        public static DOUBLE_STONE_SLAB3: int
        public static DOUBLE_STONE_BLOCK_SLAB3: int
        public static DOUBLE_STONE_SLAB4: int
        public static DOUBLE_STONE_BLOCK_SLAB4: int
        public static GRANITE_STAIRS: int
        public static DIORITE_STAIRS: int
        public static ANDESITE_STAIRS: int
        public static POLISHED_GRANITE_STAIRS: int
        public static POLISHED_DIORITE_STAIRS: int
        public static POLISHED_ANDESITE_STAIRS: int
        public static MOSSY_STONE_BRICK_STAIRS: int
        public static SMOOTH_RED_SANDSTONE_STAIRS: int
        public static SMOOTH_SANDSTONE_STAIRS: int
        public static END_BRICK_STAIRS: int
        public static MOSSY_COBBLESTONE_STAIRS: int
        public static NORMAL_STONE_STAIRS: int
        public static SPRUCE_STANDING_SIGN: int
        public static SPRUCE_WALL_SIGN: int
        public static SMOOTH_STONE: int
        public static RED_NETHER_BRICK_STAIRS: int
        public static SMOOTH_QUARTZ_STAIRS: int
        public static BIRCH_STANDING_SIGN: int
        public static BIRCH_WALL_SIGN: int
        public static JUNGLE_STANDING_SIGN: int
        public static JUNGLE_WALL_SIGN: int
        public static ACACIA_STANDING_SIGN: int
        public static ACACIA_WALL_SIGN: int
        public static DARKOAK_STANDING_SIGN: int
        public static DARK_OAK_STANDING_SIGN: int
        public static DARKOAK_WALL_SIGN: int
        public static DARK_OAK_WALL_SIGN: int
        public static LECTERN: int
        public static GRINDSTONE: int
        public static BLAST_FURNACE: int
        public static STONECUTTER_BLOCK: int
        public static SMOKER: int
        public static LIT_SMOKER: int
        public static CARTOGRAPHY_TABLE: int
        public static FLETCHING_TABLE: int
        public static SMITHING_TABLE: int
        public static BARREL: int
        public static LOOM: int
        public static BELL: int
        public static SWEET_BERRY_BUSH: int
        public static LANTERN: int
        public static CAMPFIRE_BLOCK: int
        public static LAVA_CAULDRON: int
        public static JIGSAW: int
        public static WOOD_BARK: int
        public static COMPOSTER: int
        public static LIT_BLAST_FURNACE: int
        public static LIGHT_BLOCK: int
        public static WITHER_ROSE: int
        public static STICKY_PISTON_ARM_COLLISION: int
        public static PISTON_HEAD_STICKY: int
        public static BEE_NEST: int
        public static BEEHIVE: int
        public static HONEY_BLOCK: int
        public static HONEYCOMB_BLOCK: int
        public static LODESTONE: int
        public static CRIMSON_ROOTS: int
        public static WARPED_ROOTS: int
        public static CRIMSON_STEM: int
        public static WARPED_STEM: int
        public static WARPED_WART_BLOCK: int
        public static CRIMSON_FUNGUS: int
        public static WARPED_FUNGUS: int
        public static SHROOMLIGHT: int
        public static WEEPING_VINES: int
        public static CRIMSON_NYLIUM: int
        public static WARPED_NYLIUM: int
        public static BASALT: int
        public static POLISHED_BASALT: int
        public static SOUL_SOIL: int
        public static SOUL_FIRE: int
        public static NETHER_SPROUTS_BLOCK: int
        public static TARGET: int
        public static STRIPPED_CRIMSON_STEM: int
        public static STRIPPED_WARPED_STEM: int
        public static CRIMSON_PLANKS: int
        public static WARPED_PLANKS: int
        public static CRIMSON_DOOR_BLOCK: int
        public static WARPED_DOOR_BLOCK: int
        public static CRIMSON_TRAPDOOR: int
        public static WARPED_TRAPDOOR: int
        public static CRIMSON_STANDING_SIGN: int
        public static WARPED_STANDING_SIGN: int
        public static CRIMSON_WALL_SIGN: int
        public static WARPED_WALL_SIGN: int
        public static CRIMSON_STAIRS: int
        public static WARPED_STAIRS: int
        public static CRIMSON_FENCE: int
        public static WARPED_FENCE: int
        public static CRIMSON_FENCE_GATE: int
        public static WARPED_FENCE_GATE: int
        public static CRIMSON_BUTTON: int
        public static WARPED_BUTTON: int
        public static CRIMSON_PRESSURE_PLATE: int
        public static WARPED_PRESSURE_PLATE: int
        public static CRIMSON_SLAB: int
        public static WARPED_SLAB: int
        public static CRIMSON_DOUBLE_SLAB: int
        public static WARPED_DOUBLE_SLAB: int
        public static SOUL_TORCH: int
        public static SOUL_LANTERN: int
        public static NETHERITE_BLOCK: int
        public static ANCIENT_DERBRIS: int
        public static RESPAWN_ANCHOR: int
        public static BLACKSTONE: int
        public static POLISHED_BLACKSTONE_BRICKS: int
        public static POLISHED_BLACKSTONE_BRICK_STAIRS: int
        public static BLACKSTONE_STAIRS: int
        public static BLACKSTONE_WALL: int
        public static POLISHED_BLACKSTONE_BRICK_WALL: int
        public static CHISELED_POLISHED_BLACKSTONE: int
        public static CRACKED_POLISHED_BLACKSTONE_BRICKS: int
        public static GILDED_BLACKSTONE: int
        public static BLACKSTONE_SLAB: int
        public static BLACKSTONE_DOUBLE_SLAB: int
        public static POLISHED_BLACKSTONE_BRICK_SLAB: int
        public static POLISHED_BLACKSTONE_BRICK_DOUBLE_SLAB: int
        public static CHAIN_BLOCK: int
        public static TWISTING_VINES: int
        public static NETHER_GOLD_ORE: int
        public static CRYING_OBSIDIAN: int
        public static SOUL_CAMPFIRE_BLOCK: int
        public static POLISHED_BLACKSTONE: int
        public static POLISHED_BLACKSTONE_STAIRS: int
        public static POLISHED_BLACKSTONE_SLAB: int
        public static POLISHED_BLACKSTONE_DOUBLE_SLAB: int
        public static POLISHED_BLACKSTONE_PRESSURE_PLATE: int
        public static POLISHED_BLACKSTONE_BUTTON: int
        public static POLISHED_BLACKSTONE_WALL: int
        public static WARPED_HYPHAE: int
        public static CRIMSON_HYPHAE: int
        public static STRIPPED_CRIMSON_HYPHAE: int
        public static STRIPPED_WARPED_HYPHAE: int
        public static CHISELED_NETHER_BRICKS: int
        public static CRACKED_NETHER_BRICKS: int
        public static QUARTZ_BRICKS: int
        public static POWDER_SNOW: int
        public static SCULK_SENSOR: int
        public static POINTED_DRIPSTONE: int
        public static COPPER_ORE: int
        public static LIGHTNING_ROD: int
        public static DRIPSTONE_BLOCK: int
        public static DIRT_WITH_ROOTS: int
        public static HANGING_ROOTS: int
        public static MOSS_BLOCK: int
        public static SPORE_BLOSSOM: int
        public static CAVE_VINES: int
        public static BIG_DRIPLEAF: int
        public static AZALEA_LEAVES: int
        public static AZALEA_LEAVES_FLOWERED: int
        public static CALCITE: int
        public static AMETHYST_BLOCK: int
        public static BUDDING_AMETHYST: int
        public static AMETHYST_CLUSTER: int
        public static LARGE_AMETHYST_BUD: int
        public static MEDIUM_AMETHYST_BUD: int
        public static SMALL_AMETHYST_BUD: int
        public static TUFF: int
        public static TINTED_GLASS: int
        public static MOSS_CARPET: int
        public static SMALL_DRIPLEAF_BLOCK: int
        public static AZALEA: int
        public static FLOWERING_AZALEA: int
        public static GLOW_FRAME: int
        public static COPPER_BLOCK: int
        public static EXPOSED_COPPER: int
        public static WEATHERED_COPPER: int
        public static OXIDIZED_COPPER: int
        public static WAXED_COPPER: int
        public static WAXED_EXPOSED_COPPER: int
        public static WAXED_WEATHERED_COPPER: int
        public static CUT_COPPER: int
        public static EXPOSED_CUT_COPPER: int
        public static WEATHERED_CUT_COPPER: int
        public static OXIDIZED_CUT_COPPER: int
        public static WAXED_CUT_COPPER: int
        public static WAXED_EXPOSED_CUT_COPPER: int
        public static WAXED_WEATHERED_CUT_COPPER: int
        public static CUT_COPPER_STAIRS: int
        public static EXPOSED_CUT_COPPER_STAIRS: int
        public static WEATHERED_CUT_COPPER_STAIRS: int
        public static OXIDIZED_CUT_COPPER_STAIRS: int
        public static WAXED_CUT_COPPER_STAIRS: int
        public static WAXED_EXPOSED_CUT_COPPER_STAIRS: int
        public static WAXED_WEATHERED_CUT_COPPER_STAIRS: int
        public static CUT_COPPER_SLAB: int
        public static EXPOSED_CUT_COPPER_SLAB: int
        public static WEATHERED_CUT_COPPER_SLAB: int
        public static OXIDIZED_CUT_COPPER_SLAB: int
        public static WAXED_CUT_COPPER_SLAB: int
        public static WAXED_EXPOSED_CUT_COPPER_SLAB: int
        public static WAXED_WEATHERED_CUT_COPPER_SLAB: int
        public static DOUBLE_CUT_COPPER_SLAB: int
        public static EXPOSED_DOUBLE_CUT_COPPER_SLAB: int
        public static WEATHERED_DOUBLE_CUT_COPPER_SLAB: int
        public static OXIDIZED_DOUBLE_CUT_COPPER_SLAB: int
        public static WAXED_DOUBLE_CUT_COPPER_SLAB: int
        public static WAXED_EXPOSED_DOUBLE_CUT_COPPER_SLAB: int
        public static WAXED_WEATHERED_DOUBLE_CUT_COPPER_SLAB: int
        public static CAVE_VINES_BODY_WITH_BERRIES: int
        public static CAVE_VINES_HEAD_WITH_BERRIES: int
        public static SMOOTH_BASALT: int
        public static DEEPSLATE: int
        public static COBBLED_DEEPSLATE: int
        public static COBBLED_DEEPSLATE_SLAB: int
        public static COBBLED_DEEPSLATE_STAIRS: int
        public static COBBLED_DEEPSLATE_WALL: int
        public static POLISHED_DEEPSLATE: int
        public static POLISHED_DEEPSLATE_SLAB: int
        public static POLISHED_DEEPSLATE_STAIRS: int
        public static POLISHED_DEEPSLATE_WALL: int
        public static DEEPSLATE_TILES: int
        public static DEEPSLATE_TILE_SLAB: int
        public static DEEPSLATE_TILE_STAIRS: int
        public static DEEPSLATE_TILE_WALL: int
        public static DEEPSLATE_BRICKS: int
        public static DEEPSLATE_BRICK_SLAB: int
        public static DEEPSLATE_BRICK_STAIRS: int
        public static DEEPSLATE_BRICK_WALL: int
        public static CHISELED_DEEPSLATE: int
        public static COBBLED_DEEPSLATE_DOUBLE_SLAB: int
        public static POLISHED_DEEPSLATE_DOUBLE_SLAB: int
        public static DEEPSLATE_TILE_DOUBLE_SLAB: int
        public static DEEPSLATE_BRICK_DOUBLE_SLAB: int
        public static DEEPSLATE_LAPIS_ORE: int
        public static DEEPSLATE_IRON_ORE: int
        public static DEEPSLATE_GOLD_ORE: int
        public static DEEPSLATE_REDSTONE_ORE: int
        public static LIT_DEEPSLATE_REDSTONE_ORE: int
        public static DEEPSLATE_DIAMOND_ORE: int
        public static DEEPSLATE_COAL_ORE: int
        public static DEEPSLATE_EMERALD_ORE: int
        public static DEEPSLATE_COPPER_ORE: int
        public static CRACKED_DEEPSLATE_TILES: int
        public static CRACKED_DEEPSLATE_BRICKS: int
        public static GLOW_LICHEN: int
        public static CANDLE: int
        public static WHITE_CANDLE: int
        public static ORANGE_CANDLE: int
        public static MAGENTA_CANDLE: int
        public static LIGHT_BLUE_CANDLE: int
        public static YELLOW_CANDLE: int
        public static LIME_CANDLE: int
        public static PINK_CANDLE: int
        public static GRAY_CANDLE: int
        public static LIGHT_GRAY_CANDLE: int
        public static CYAN_CANDLE: int
        public static PURPLE_CANDLE: int
        public static BLUE_CANDLE: int
        public static BROWN_CANDLE: int
        public static GREEN_CANDLE: int
        public static RED_CANDLE: int
        public static BLACK_CANDLE: int
        public static CANDLE_CAKE: int
        public static WHITE_CANDLE_CAKE: int
        public static ORANGE_CANDLE_CAKE: int
        public static MAGENTA_CANDLE_CAKE: int
        public static LIGHT_BLUE_CANDLE_CAKE: int
        public static YELLOW_CANDLE_CAKE: int
        public static LIME_CANDLE_CAKE: int
        public static PINK_CANDLE_CAKE: int
        public static GRAY_CANDLE_CAKE: int
        public static LIGHT_GRAY_CANDLE_CAKE: int
        public static CYAN_CANDLE_CAKE: int
        public static PURPLE_CANDLE_CAKE: int
        public static BLUE_CANDLE_CAKE: int
        public static BROWN_CANDLE_CAKE: int
        public static GREEN_CANDLE_CAKE: int
        public static RED_CANDLE_CAKE: int
        public static BLACK_CANDLE_CAKE: int
        public static WAXED_OXIDIZED_COPPER: int
        public static WAXED_OXIDIZED_CUT_COPPER: int
        public static WAXED_OXIDIZED_CUT_COPPER_STAIRS: int
        public static WAXED_OXIDIZED_CUT_COPPER_SLAB: int
        public static WAXED_OXIDIZED_DOUBLE_CUT_COPPER_SLAB: int
        public static RAW_IRON_BLOCK: int
        public static RAW_COPPER_BLOCK: int
        public static RAW_GOLD_BLOCK: int
        public static INFESTED_DEEPSLATE: int
        public static SCULK: int
        public static SCULK_VEIN: int
        public static SCULK_CATALYST: int
        public static SCULK_SHRIEKER: int
        public static REINFORCED_DEEPSLATE: int
        public static FROG_SPAWN: int
        public static PEARLESCENT_FROGLIGHT: int
        public static VERDANT_FROGLIGHT: int
        public static OCHRE_FROGLIGHT: int
        public static MANGROVE_LEAVES: int
        public static MUD: int
        public static MANGROVE_PROPAGULE: int
        public static MUD_BRICKS: int
        public static MANGROVE_PROPAGULE_HANGING: int
        public static PACKED_MUD: int
        public static MUD_BRICK_SLAB: int
        public static MUD_BRICK_DOUBLE_SLAB: int
        public static MUD_BRICK_STAIRS: int
        public static MUD_BRICK_WALL: int
        public static MANGROVE_ROOTS: int
        public static MUDDY_MANGROVE_ROOTS: int
        public static MANGROVE_LOG: int
        public static STRIPPED_MANGROVE_LOG: int
        public static MANGROVE_PLANKS: int
        public static MANGROVE_BUTTON: int
        public static MANGROVE_STAIRS: int
        public static MANGROVE_SLAB: int
        public static MANGROVE_PRESSURE_PLATE: int
        public static MANGROVE_FENCE: int
        public static MANGROVE_FENCE_GATE: int
        public static MANGROVE_DOOR: int
        public static MANGROVE_STANDING_SIGN: int
        public static MANGROVE_WALL_SIGN: int
        public static MANGROVE_TRAPDOOR: int
        public static MANGROVE_WOOD: int
        public static STRIPPED_MANGROVE_WOOD: int
        public static DOUBLE_MANGROVE_SLAB: int

    }
}

declare module "cn.nukkit.block.BlockID" {
    declare type BlockID = cn.nukkit.block.BlockID;
}

declare namespace cn.nukkit.block {
    declare class BlockCarpet extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public constructor(dyeColor: cn.nukkit.utils.DyeColor): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public getName(): string
        public canPassThrough(): boolean
        public getWaterloggingLevel(): int
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getMaxY(): double
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getDyeColor(): cn.nukkit.utils.DyeColor
        public setDyeColor(color: cn.nukkit.utils.DyeColor): void
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockCarpet" {
    declare const BlockCarpet = cn.nukkit.block.BlockCarpet;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleLime extends cn.nukkit.block.BlockCandle {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        toCakeForm(): cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.block.BlockCandleLime" {
    declare const BlockCandleLime = cn.nukkit.block.BlockCandleLime;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabBlackstone extends cn.nukkit.block.BlockDoubleSlabBase {
        public constructor(): void
        constructor(meta: int): void
        public getSlabName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public getSingleSlabId(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabBlackstone" {
    declare const BlockDoubleSlabBlackstone = cn.nukkit.block.BlockDoubleSlabBlackstone;
}

declare namespace cn.nukkit.block {
    declare class BlockLichen extends cn.nukkit.block.BlockTransparent {
        public constructor(): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getGrowthSides(): cn.nukkit.math.BlockFace[]
        public witherAtSide(side: cn.nukkit.math.BlockFace): void
        public isGrowthToSide(side: cn.nukkit.math.BlockFace): boolean
        public growToSide(side: cn.nukkit.math.BlockFace): void
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public getHardness(): double
        public getResistance(): double
        public canPassThrough(): boolean
        public getWaterloggingLevel(): int
        public canSilkTouch(): boolean
        public getToolType(): int
        public getToolTier(): int
        public canHarvest(item: cn.nukkit.item.Item): boolean
        public canHarvestWithHand(): boolean
        public sticksToPiston(): boolean
        public breaksWhenMoved(): boolean
        public canBeReplaced(): boolean
        public canBeFlowedInto(): boolean
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public toItem(): cn.nukkit.item.Item
        lambda$place$1(block: cn.nukkit.block.Block, side: cn.nukkit.math.BlockFace): boolean
        static lambda$getGrowthSides$0(x$0: int): cn.nukkit.math.BlockFace[]
        public static MULTI_FACE_DIRECTION_BITS: cn.nukkit.blockproperty.IntBlockProperty
        public static RANDOM: cn.nukkit.math.NukkitRandom
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockLichen" {
    declare const BlockLichen = cn.nukkit.block.BlockLichen;
}

declare namespace cn.nukkit.block {
    declare class BlockLantern extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        isBlockAboveValid(): boolean
        isBlockUnderValid(): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public getLightLevel(): int
        public getResistance(): double
        public getHardness(): double
        public canHarvestWithHand(): boolean
        public getToolType(): int
        public getMinX(): double
        public getMinY(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxY(): double
        public getMaxZ(): double
        public canPassThrough(): boolean
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getColor(): cn.nukkit.utils.BlockColor
        public getToolTier(): int
        public isHanging(): boolean
        public setHanging(hanging: boolean): void
        public getWaterloggingLevel(): int
        public static HANGING: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockLantern" {
    declare const BlockLantern = cn.nukkit.block.BlockLantern;
}

declare namespace cn.nukkit.block {
    declare class BlockMonsterEgg extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getMonsterEggStoneType(): cn.nukkit.blockproperty.value.MonsterEggStoneType
        public setMonsterEggStoneType(value: cn.nukkit.blockproperty.value.MonsterEggStoneType): void
        public getHardness(): double
        public getResistance(): double
        public getName(): string
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public static MONSTER_EGG_STONE_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty<cn.nukkit.blockproperty.value.MonsterEggStoneType>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties
        public static STONE: int
        public static COBBLESTONE: int
        public static STONE_BRICK: int
        public static MOSSY_BRICK: int
        public static CRACKED_BRICK: int
        public static CHISELED_BRICK: int
        static NAMES: string[]

    }
}

declare module "cn.nukkit.block.BlockMonsterEgg" {
    declare const BlockMonsterEgg = cn.nukkit.block.BlockMonsterEgg;
}

declare namespace cn.nukkit.block {
    declare class BlockJungleWallSign extends cn.nukkit.block.BlockWallSign {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        getPostId(): int
        public getName(): string
        public toItem(): cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.block.BlockJungleWallSign" {
    declare const BlockJungleWallSign = cn.nukkit.block.BlockJungleWallSign;
}

declare namespace cn.nukkit.block {
    declare class BlockSlabBlackstone extends cn.nukkit.block.BlockSlab {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getSlabName(): string
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean
        public getToolType(): int
        public getResistance(): double
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockSlabBlackstone" {
    declare const BlockSlabBlackstone = cn.nukkit.block.BlockSlabBlackstone;
}

declare namespace cn.nukkit.block {
    declare class BlockWeightedPressurePlateLight extends cn.nukkit.block.BlockPressurePlateBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        computeRedstoneStrength(): int
        public getMaxWeight(): int

    }
}

declare module "cn.nukkit.block.BlockWeightedPressurePlateLight" {
    declare const BlockWeightedPressurePlateLight = cn.nukkit.block.BlockWeightedPressurePlateLight;
}

declare namespace cn.nukkit.block {
    declare class BlockDoorMangrove extends cn.nukkit.block.BlockDoorWood {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoorMangrove" {
    declare const BlockDoorMangrove = cn.nukkit.block.BlockDoorMangrove;
}

declare namespace cn.nukkit.block {
    declare class BlockCraftingTable extends cn.nukkit.block.BlockSolid {
        public constructor(): void
        public getName(): string
        public getId(): int
        public canBeActivated(): boolean
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockCraftingTable" {
    declare const BlockCraftingTable = cn.nukkit.block.BlockCraftingTable;
}

declare namespace cn.nukkit.block {
    declare class BlockSignPost extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.Faceable, cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntitySign>
        public getBlockEntityType(): string
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public getName(): string
        public getBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getWaterloggingLevel(): int
        getPostId(): int
        public getWallId(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public toItem(): cn.nukkit.item.Item
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getSignDirection(): cn.nukkit.math.CompassRoseDirection
        public setSignDirection(direction: cn.nukkit.math.CompassRoseDirection): void
        public getBlockFace(): cn.nukkit.math.BlockFace
        public setBlockFace(face: cn.nukkit.math.BlockFace): void
        public breaksWhenMoved(): boolean
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        static log: org.apache.logging.log4j.Logger
        public static GROUND_SIGN_DIRECTION: cn.nukkit.blockproperty.BlockProperty<cn.nukkit.math.CompassRoseDirection>
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockSignPost" {
    declare const BlockSignPost = cn.nukkit.block.BlockSignPost;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabDeepslatePolished extends cn.nukkit.block.BlockDoubleSlabBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getSingleSlabId(): int
        public getSlabName(): string
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public getToolTier(): int
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabDeepslatePolished" {
    declare const BlockDoubleSlabDeepslatePolished = cn.nukkit.block.BlockDoubleSlabDeepslatePolished;
}

declare namespace cn.nukkit.block {
    declare class BlockFireSoul extends cn.nukkit.block.BlockFire {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public onUpdate(type: int): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockFireSoul" {
    declare const BlockFireSoul = cn.nukkit.block.BlockFireSoul;
}

declare namespace cn.nukkit.block {
    declare class BlockPumpkinLit extends cn.nukkit.block.BlockPumpkin {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public getLightLevel(): int
        public canBeActivated(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean

    }
}

declare module "cn.nukkit.block.BlockPumpkinLit" {
    declare const BlockPumpkinLit = cn.nukkit.block.BlockPumpkinLit;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsCopperCut extends cn.nukkit.block.BlockStairsCopperBase {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        getCopperId(waxed: boolean, oxidizationLevel: cn.nukkit.blockproperty.value.OxidizationLevel): int
        public getOxidizationLevel(): cn.nukkit.blockproperty.value.OxidizationLevel

    }
}

declare module "cn.nukkit.block.BlockStairsCopperCut" {
    declare const BlockStairsCopperCut = cn.nukkit.block.BlockStairsCopperCut;
}

declare namespace cn.nukkit.block {
    declare class BlockSmoothBasalt extends cn.nukkit.block.BlockBasalt {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getPillarAxis(): cn.nukkit.math.BlockFace$Axis
        public setPillarAxis(axis: cn.nukkit.math.BlockFace$Axis): void
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockSmoothBasalt" {
    declare const BlockSmoothBasalt = cn.nukkit.block.BlockSmoothBasalt;
}

declare namespace cn.nukkit.block {
    declare class BlockCandleCakeGreen extends cn.nukkit.block.BlockCandleCake {
        public constructor(meta: int): void
        public constructor(): void
        getColorName(): string
        public getId(): int
        toCandleForm(): cn.nukkit.block.BlockCandle

    }
}

declare module "cn.nukkit.block.BlockCandleCakeGreen" {
    declare const BlockCandleCakeGreen = cn.nukkit.block.BlockCandleCakeGreen;
}

declare namespace cn.nukkit.block {
    declare class BlockPowderSnow extends cn.nukkit.block.BlockTransparentMeta {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public isTransparent(): boolean
        public canPassThrough(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void

    }
}

declare module "cn.nukkit.block.BlockPowderSnow" {
    declare const BlockPowderSnow = cn.nukkit.block.BlockPowderSnow;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsBrick extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsBrick" {
    declare const BlockStairsBrick = cn.nukkit.block.BlockStairsBrick;
}

declare namespace cn.nukkit.block {
    declare class BlockPressurePlateDarkOak extends cn.nukkit.block.BlockPressurePlateWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockPressurePlateDarkOak" {
    declare const BlockPressurePlateDarkOak = cn.nukkit.block.BlockPressurePlateDarkOak;
}

declare namespace cn.nukkit.block {
    declare class BlockOreRedstoneDeepslate extends cn.nukkit.block.BlockOreRedstone {
        public constructor(): void
        public getId(): int
        public getHardness(): double
        public getName(): string
        public getLitState(): cn.nukkit.blockstate.BlockState
        public getUnlitState(): cn.nukkit.blockstate.BlockState
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockOreRedstoneDeepslate" {
    declare const BlockOreRedstoneDeepslate = cn.nukkit.block.BlockOreRedstoneDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockRailActivator$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$utils$Rail$Orientation: int[]

    }
}

declare module "cn.nukkit.block.BlockRailActivator$1" {
    declare const BlockRailActivator$1 = cn.nukkit.block.BlockRailActivator$1;
}

declare namespace cn.nukkit.block {
    declare class BlockStairsDarkPrismarine extends cn.nukkit.block.BlockStairs {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public getToolTier(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockStairsDarkPrismarine" {
    declare const BlockStairsDarkPrismarine = cn.nukkit.block.BlockStairsDarkPrismarine;
}

declare namespace cn.nukkit.block {
    declare class BlockSculkSensor extends cn.nukkit.block.BlockSolid implements cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public getName(): string
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntitySculkSensor>
        public getBlockEntityType(): string
        public static POWERED_BIT: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockSculkSensor" {
    declare const BlockSculkSensor = cn.nukkit.block.BlockSculkSensor;
}

declare namespace cn.nukkit.block {
    declare class BlockDoorWarped extends cn.nukkit.block.BlockDoorWood {
        public constructor(): void
        public constructor(meta: int): void
        public getName(): string
        public getId(): int
        public toItem(): cn.nukkit.item.Item
        public getColor(): cn.nukkit.utils.BlockColor
        public getBurnChance(): int
        public getBurnAbility(): int

    }
}

declare module "cn.nukkit.block.BlockDoorWarped" {
    declare const BlockDoorWarped = cn.nukkit.block.BlockDoorWarped;
}

declare namespace cn.nukkit.block {
    declare class BlockRedstone extends cn.nukkit.block.BlockSolidMeta implements cn.nukkit.utils.RedstoneComponent {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public getName(): string
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onBreak(item: cn.nukkit.item.Item): boolean
        public isPowerSource(): boolean
        public getWeakPower(face: cn.nukkit.math.BlockFace): int
        public canHarvestWithHand(): boolean

    }
}

declare module "cn.nukkit.block.BlockRedstone" {
    declare const BlockRedstone = cn.nukkit.block.BlockRedstone;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabTileDeepslate extends cn.nukkit.block.BlockDoubleSlabBase {
        public constructor(): void
        constructor(meta: int): void
        public getId(): int
        public getSingleSlabId(): int
        public getSlabName(): string
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public canHarvestWithHand(): boolean
        public getToolTier(): int
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabTileDeepslate" {
    declare const BlockDoubleSlabTileDeepslate = cn.nukkit.block.BlockDoubleSlabTileDeepslate;
}

declare namespace cn.nukkit.block {
    declare class BlockOreGoldNether extends cn.nukkit.block.BlockOreGold {
        public constructor(): void
        public getId(): int
        public getToolTier(): int
        public getName(): string
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        getRawMaterial(): cn.nukkit.item.MinecraftItemID
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockOreGoldNether" {
    declare const BlockOreGoldNether = cn.nukkit.block.BlockOreGoldNether;
}

declare namespace cn.nukkit.block {
    declare class BlockPressurePlateSpruce extends cn.nukkit.block.BlockPressurePlateWood {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string

    }
}

declare module "cn.nukkit.block.BlockPressurePlateSpruce" {
    declare const BlockPressurePlateSpruce = cn.nukkit.block.BlockPressurePlateSpruce;
}

declare namespace cn.nukkit.block {
    declare class BlockBeacon extends cn.nukkit.block.BlockTransparent implements cn.nukkit.block.BlockEntityHolder {
        public constructor(): void
        public getId(): int
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntityBeacon>
        public getBlockEntityType(): string
        public getHardness(): double
        public getResistance(): double
        public getLightLevel(): int
        public getToolType(): int
        public getName(): string
        public canBeActivated(): boolean
        public getWaterloggingLevel(): int
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canBePushed(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public canBePulled(): boolean

    }
}

declare module "cn.nukkit.block.BlockBeacon" {
    declare const BlockBeacon = cn.nukkit.block.BlockBeacon;
}

declare namespace cn.nukkit.block {
    declare class BlockDoubleSlabDeepslateCobbled extends cn.nukkit.block.BlockDoubleSlabBase {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getSlabName(): string
        public getSingleSlabId(): int

    }
}

declare module "cn.nukkit.block.BlockDoubleSlabDeepslateCobbled" {
    declare const BlockDoubleSlabDeepslateCobbled = cn.nukkit.block.BlockDoubleSlabDeepslateCobbled;
}

declare namespace cn.nukkit.block {
    declare class BlockCoralFanDead extends cn.nukkit.block.BlockCoralFan {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor
        public isDead(): boolean
        public onUpdate(type: int): int

    }
}

declare module "cn.nukkit.block.BlockCoralFanDead" {
    declare const BlockCoralFanDead = cn.nukkit.block.BlockCoralFanDead;
}

declare namespace cn.nukkit.block {
    declare class BlockSkull extends cn.nukkit.block.BlockTransparentMeta implements cn.nukkit.utils.RedstoneComponent, cn.nukkit.block.BlockEntityHolder, cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getBlockEntityType(): string
        public getBlockEntityClass(): java.lang.Class<cn.nukkit.blockentity.BlockEntitySkull>
        public getHardness(): double
        public getResistance(): double
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public getWaterloggingLevel(): int
        public canBeFlowedInto(): boolean
        public getName(): string
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public toItem(): cn.nukkit.item.Item
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        public getBlockFace(): cn.nukkit.math.BlockFace
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public static NO_DROP: cn.nukkit.blockproperty.BooleanBlockProperty
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockSkull" {
    declare const BlockSkull = cn.nukkit.block.BlockSkull;
}

declare namespace cn.nukkit.block {
    declare class BlockAzalea extends cn.nukkit.block.BlockFlowable {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getName(): string
        public getId(): int
        public getWaterloggingLevel(): int
        public getHardness(): double
        public getResistance(): double
        public getToolType(): int
        public canHarvestWithHand(): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public onUpdate(type: int): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        public canBeActivated(): boolean
        public isSameType(pos: cn.nukkit.math.Vector3, type: cn.nukkit.blockproperty.value.WoodType): boolean
        grow(): void
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockAzalea" {
    declare const BlockAzalea = cn.nukkit.block.BlockAzalea;
}

declare namespace cn.nukkit.block {
    declare class BlockConcrete extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getResistance(): double
        public getHardness(): double
        public getName(): string
        public getToolType(): int
        public getToolTier(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public getDyeColor(): cn.nukkit.utils.DyeColor
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockConcrete" {
    declare const BlockConcrete = cn.nukkit.block.BlockConcrete;
}

declare namespace cn.nukkit.block {
    declare class BlockStemStrippedCrimson extends cn.nukkit.block.BlockStemStripped {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getName(): string
        public getColor(): cn.nukkit.utils.BlockColor

    }
}

declare module "cn.nukkit.block.BlockStemStrippedCrimson" {
    declare const BlockStemStrippedCrimson = cn.nukkit.block.BlockStemStrippedCrimson;
}

declare namespace cn.nukkit.block {
    declare class BlockPlanks extends cn.nukkit.block.BlockSolidMeta {
        public constructor(): void
        public constructor(meta: int): void
        public getId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getHardness(): double
        public getResistance(): double
        public getBurnChance(): int
        public getBurnAbility(): int
        public getName(): string
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType
        public setWoodType(type: cn.nukkit.blockproperty.value.WoodType): void
        public getToolType(): int
        public getColor(): cn.nukkit.utils.BlockColor
        public static OAK: int
        public static SPRUCE: int
        public static BIRCH: int
        public static JUNGLE: int
        public static ACACIA: int
        public static DARK_OAK: int
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockPlanks" {
    declare const BlockPlanks = cn.nukkit.block.BlockPlanks;
}

declare namespace cn.nukkit.block {
    declare class BlockTerracottaGlazed extends cn.nukkit.block.BlockSolidMeta implements cn.nukkit.utils.Faceable {
        public constructor(): void
        public constructor(meta: int): void
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getResistance(): double
        public getHardness(): double
        public getToolType(): int
        public getToolTier(): int
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canHarvestWithHand(): boolean
        public getBlockFace(): cn.nukkit.math.BlockFace
        public static PROPERTIES: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.block.BlockTerracottaGlazed" {
    declare const BlockTerracottaGlazed = cn.nukkit.block.BlockTerracottaGlazed;
}

declare namespace cn.nukkit.scheduler {
    declare class AsyncPool$1 extends java.lang.Thread {
        constructor(this$0: cn.nukkit.scheduler.AsyncPool, target: java.lang.Runnable): void
        this$0: cn.nukkit.scheduler.AsyncPool

    }
}

declare module "cn.nukkit.scheduler.AsyncPool$1" {
    declare const AsyncPool$1 = cn.nukkit.scheduler.AsyncPool$1;
}

declare namespace cn.nukkit.scheduler {
    declare class BlockUpdateScheduler extends java.lang.Object {
        public constructor(level: cn.nukkit.level.Level, currentTick: long): void
        public tick(currentTick: long): void
        perform(tick: long): void
        public getPendingBlockUpdates(boundingBox: cn.nukkit.math.AxisAlignedBB): java.util.Set<cn.nukkit.utils.BlockUpdateEntry>
        public isBlockTickPending(pos: cn.nukkit.math.Vector3, block: cn.nukkit.block.Block): boolean
        getMinTime(entry: cn.nukkit.utils.BlockUpdateEntry): long
        public add(entry: cn.nukkit.utils.BlockUpdateEntry): void
        public contains(entry: cn.nukkit.utils.BlockUpdateEntry): boolean
        public remove(entry: cn.nukkit.utils.BlockUpdateEntry): boolean
        public remove(pos: cn.nukkit.math.Vector3): boolean
        level: cn.nukkit.level.Level
        lastTick: long
        queuedUpdates: java.util.Map<long, java.util.LinkedHashSet<cn.nukkit.utils.BlockUpdateEntry>>
        pendingUpdates: java.util.Set<cn.nukkit.utils.BlockUpdateEntry>

    }
}

declare module "cn.nukkit.scheduler.BlockUpdateScheduler" {
    declare const BlockUpdateScheduler = cn.nukkit.scheduler.BlockUpdateScheduler;
}

declare namespace cn.nukkit.scheduler {
    declare class AsyncWorker extends java.lang.Thread implements cn.nukkit.InterruptibleThread {
        public constructor(): void
        public stack(task: cn.nukkit.scheduler.AsyncTask): void
        public unstack(): void
        public unstack(task: cn.nukkit.scheduler.AsyncTask): void
        public run(): void
        stack: java.util.LinkedList<cn.nukkit.scheduler.AsyncTask>

    }
}

declare module "cn.nukkit.scheduler.AsyncWorker" {
    declare const AsyncWorker = cn.nukkit.scheduler.AsyncWorker;
}

declare namespace cn.nukkit.scheduler {
    declare class Task extends java.lang.Object implements java.lang.Runnable {
        public constructor(): void
        public getHandler(): cn.nukkit.scheduler.TaskHandler
        public getTaskId(): int
        public setHandler(taskHandler: cn.nukkit.scheduler.TaskHandler): void
        public onRun(var0: int): void
        public run(): void
        public onCancel(): void
        public cancel(): void
        static log: org.apache.logging.log4j.Logger
        taskHandler: cn.nukkit.scheduler.TaskHandler

    }
}

declare module "cn.nukkit.scheduler.Task" {
    declare const Task = cn.nukkit.scheduler.Task;
}

declare namespace cn.nukkit.scheduler {
    declare class FileWriteTask extends cn.nukkit.scheduler.AsyncTask {
        public constructor(path: string, contents: string): void
        public constructor(path: string, contents: byte[]): void
        public constructor(path: string, contents: java.io.InputStream): void
        public constructor(file: java.io.File, contents: string): void
        public constructor(file: java.io.File, contents: byte[]): void
        public constructor(file: java.io.File, contents: java.io.InputStream): void
        public onRun(): void
        static log: org.apache.logging.log4j.Logger
        file: java.io.File
        contents: java.io.InputStream

    }
}

declare module "cn.nukkit.scheduler.FileWriteTask" {
    declare const FileWriteTask = cn.nukkit.scheduler.FileWriteTask;
}

declare namespace cn.nukkit.scheduler {
    declare class AsyncTask extends java.lang.Object implements java.lang.Runnable {
        public constructor(): void
        public run(): void
        public isFinished(): boolean
        public getResult(): java.lang.Object
        public hasResult(): boolean
        public setResult(result: java.lang.Object): void
        public setTaskId(taskId: int): void
        public getTaskId(): int
        public getFromThreadStore(identifier: string): java.lang.Object
        public saveToThreadStore(identifier: string, value: java.lang.Object): void
        public onRun(): void
        public onCompletion(server: cn.nukkit.Server): void
        public cleanObject(): void
        public static collectTask(): void
        static log: org.apache.logging.log4j.Logger
        public static FINISHED_LIST: java.util.Queue<cn.nukkit.scheduler.AsyncTask>
        result: java.lang.Object
        taskId: int
        finished: boolean

    }
}

declare module "cn.nukkit.scheduler.AsyncTask" {
    declare const AsyncTask = cn.nukkit.scheduler.AsyncTask;
}

declare namespace cn.nukkit.scheduler {
    declare class PluginTask extends cn.nukkit.scheduler.Task {
        public constructor(): void
        public getOwner(): any
        owner: any

    }
}

declare module "cn.nukkit.scheduler.PluginTask" {
    declare const PluginTask = cn.nukkit.scheduler.PluginTask;
}

declare namespace cn.nukkit.inventory {
    declare class CraftingManager$Entry extends java.lang.Object {
        public constructor(resultItemId: int, resultMeta: int, ingredientItemId: int, ingredientMeta: int, recipeShape: string, resultAmount: int): void
        resultItemId: int
        resultMeta: int
        ingredientItemId: int
        ingredientMeta: int
        recipeShape: string
        resultAmount: int

    }
}

declare module "cn.nukkit.inventory.CraftingManager$Entry" {
    declare const CraftingManager$Entry = cn.nukkit.inventory.CraftingManager$Entry;
}

declare namespace cn.nukkit.inventory {
    declare class RecipeType extends java.lang.Enum {
        public static values(): cn.nukkit.inventory.RecipeType[]
        public static valueOf(name: string): cn.nukkit.inventory.RecipeType
        constructor(var0: int): void
        static $values(): cn.nukkit.inventory.RecipeType[]
        public static SHAPELESS: cn.nukkit.inventory.RecipeType
        public static SHAPED: cn.nukkit.inventory.RecipeType
        public static FURNACE: cn.nukkit.inventory.RecipeType
        public static FURNACE_DATA: cn.nukkit.inventory.RecipeType
        public static MULTI: cn.nukkit.inventory.RecipeType
        public static SHULKER_BOX: cn.nukkit.inventory.RecipeType
        public static SHAPELESS_CHEMISTRY: cn.nukkit.inventory.RecipeType
        public static SHAPED_CHEMISTRY: cn.nukkit.inventory.RecipeType
        public static BLAST_FURNACE: cn.nukkit.inventory.RecipeType
        public static BLAST_FURNACE_DATA: cn.nukkit.inventory.RecipeType
        public static SMOKER: cn.nukkit.inventory.RecipeType
        public static SMOKER_DATA: cn.nukkit.inventory.RecipeType
        public static CAMPFIRE: cn.nukkit.inventory.RecipeType
        public static CAMPFIRE_DATA: cn.nukkit.inventory.RecipeType
        public static STONECUTTER: cn.nukkit.inventory.RecipeType
        public static CARTOGRAPHY: cn.nukkit.inventory.RecipeType
        public static REPAIR: cn.nukkit.inventory.RecipeType
        public static SMITHING: cn.nukkit.inventory.RecipeType
        public networkType: int
        static $VALUES: cn.nukkit.inventory.RecipeType[]

    }
}

declare module "cn.nukkit.inventory.RecipeType" {
    declare const RecipeType = cn.nukkit.inventory.RecipeType;
}

declare namespace cn.nukkit.inventory {
    declare class ContainerInventory extends cn.nukkit.inventory.BaseInventory {
        public constructor(holder: cn.nukkit.inventory.InventoryHolder, type: cn.nukkit.inventory.InventoryType): void
        public constructor(holder: cn.nukkit.inventory.InventoryHolder, type: cn.nukkit.inventory.InventoryType, items: java.util.Map<int, cn.nukkit.item.Item>): void
        public constructor(holder: cn.nukkit.inventory.InventoryHolder, type: cn.nukkit.inventory.InventoryType, items: java.util.Map<int, cn.nukkit.item.Item>, overrideSize: int): void
        public constructor(holder: cn.nukkit.inventory.InventoryHolder, type: cn.nukkit.inventory.InventoryType, items: java.util.Map<int, cn.nukkit.item.Item>, overrideSize: int, overrideTitle: string): void
        public onOpen(who: cn.nukkit.Player): void
        public onClose(who: cn.nukkit.Player): void
        public static calculateRedstone(inv: cn.nukkit.inventory.Inventory): int

    }
}

declare module "cn.nukkit.inventory.ContainerInventory" {
    declare const ContainerInventory = cn.nukkit.inventory.ContainerInventory;
}

declare namespace cn.nukkit.inventory {
    declare class SmokerRecipe extends java.lang.Object implements cn.nukkit.inventory.SmeltingRecipe {
        public constructor(result: cn.nukkit.item.Item, ingredient: cn.nukkit.item.Item): void
        public setInput(item: cn.nukkit.item.Item): void
        public getInput(): cn.nukkit.item.Item
        public getResult(): cn.nukkit.item.Item
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void
        public getType(): cn.nukkit.inventory.RecipeType
        output: cn.nukkit.item.Item
        ingredient: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.inventory.SmokerRecipe" {
    declare const SmokerRecipe = cn.nukkit.inventory.SmokerRecipe;
}

declare namespace cn.nukkit.inventory {
    declare class PlayerEnderChestInventory extends cn.nukkit.inventory.BaseInventory {
        public constructor(player: cn.nukkit.entity.EntityHumanType): void
        public getHolder(): cn.nukkit.entity.EntityHuman
        public onOpen(who: cn.nukkit.Player): void
        public onClose(who: cn.nukkit.Player): void
        public getHolder(): cn.nukkit.inventory.InventoryHolder

    }
}

declare module "cn.nukkit.inventory.PlayerEnderChestInventory" {
    declare const PlayerEnderChestInventory = cn.nukkit.inventory.PlayerEnderChestInventory;
}

declare namespace cn.nukkit.inventory {
    declare class InventoryType extends java.lang.Enum {
        public static values(): cn.nukkit.inventory.InventoryType[]
        public static valueOf(name: string): cn.nukkit.inventory.InventoryType
        constructor(var0: int, var1: string, defaultSize: int): void
        public getDefaultSize(): int
        public getDefaultTitle(): string
        public getNetworkType(): int
        static $values(): cn.nukkit.inventory.InventoryType[]
        public static CHEST: cn.nukkit.inventory.InventoryType
        public static ENDER_CHEST: cn.nukkit.inventory.InventoryType
        public static DOUBLE_CHEST: cn.nukkit.inventory.InventoryType
        public static PLAYER: cn.nukkit.inventory.InventoryType
        public static FURNACE: cn.nukkit.inventory.InventoryType
        public static CRAFTING: cn.nukkit.inventory.InventoryType
        public static WORKBENCH: cn.nukkit.inventory.InventoryType
        public static BREWING_STAND: cn.nukkit.inventory.InventoryType
        public static ANVIL: cn.nukkit.inventory.InventoryType
        public static ENCHANT_TABLE: cn.nukkit.inventory.InventoryType
        public static DISPENSER: cn.nukkit.inventory.InventoryType
        public static DROPPER: cn.nukkit.inventory.InventoryType
        public static HOPPER: cn.nukkit.inventory.InventoryType
        public static UI: cn.nukkit.inventory.InventoryType
        public static CURSOR: cn.nukkit.inventory.InventoryType
        public static SHULKER_BOX: cn.nukkit.inventory.InventoryType
        public static BEACON: cn.nukkit.inventory.InventoryType
        public static GRINDSTONE: cn.nukkit.inventory.InventoryType
        public static BLAST_FURNACE: cn.nukkit.inventory.InventoryType
        public static SMOKER: cn.nukkit.inventory.InventoryType
        public static STONECUTTER: cn.nukkit.inventory.InventoryType
        public static CARTOGRAPHY: cn.nukkit.inventory.InventoryType
        public static HUD: cn.nukkit.inventory.InventoryType
        public static CHEST_BOAT: cn.nukkit.inventory.InventoryType
        public static BARREL: cn.nukkit.inventory.InventoryType
        public static CAMPFIRE: cn.nukkit.inventory.InventoryType
        public static ENTITY_EQUIPMENT: cn.nukkit.inventory.InventoryType
        public static ENTITY_ARMOR: cn.nukkit.inventory.InventoryType
        public static MINECART_CHEST: cn.nukkit.inventory.InventoryType
        public static MINECART_HOPPER: cn.nukkit.inventory.InventoryType
        public static OFFHAND: cn.nukkit.inventory.InventoryType
        public static TRADING: cn.nukkit.inventory.InventoryType
        public static SMITHING_TABLE: cn.nukkit.inventory.InventoryType
        size: int
        title: string
        typeId: int
        static $VALUES: cn.nukkit.inventory.InventoryType[]

    }
}

declare module "cn.nukkit.inventory.InventoryType" {
    declare const InventoryType = cn.nukkit.inventory.InventoryType;
}

declare namespace cn.nukkit.inventory {
    declare class DropperInventory extends cn.nukkit.inventory.EjectableInventory {
        public constructor(blockEntity: cn.nukkit.blockentity.BlockEntityDropper): void
        public getHolder(): cn.nukkit.blockentity.BlockEntityDropper
        public getHolder(): cn.nukkit.inventory.InventoryHolder

    }
}

declare module "cn.nukkit.inventory.DropperInventory" {
    declare const DropperInventory = cn.nukkit.inventory.DropperInventory;
}

declare namespace cn.nukkit.inventory {
    declare class EntityEquipmentInventory extends cn.nukkit.inventory.BaseInventory {
        public constructor(entity: cn.nukkit.entity.Entity): void
        public getName(): string
        public getSize(): int
        public getEntity(): cn.nukkit.entity.Entity
        public getHolder(): cn.nukkit.inventory.InventoryHolder
        public sendSlot(index: int, players: cn.nukkit.Player[]): void
        public sendSlot(index: int, player: cn.nukkit.Player): void
        public getViewers(): java.util.Set<cn.nukkit.Player>
        public open(who: cn.nukkit.Player): boolean
        public onClose(who: cn.nukkit.Player): void
        public getItemInHand(): cn.nukkit.item.Item
        public getItemInOffhand(): cn.nukkit.item.Item
        public setItemInHand(item: cn.nukkit.item.Item): boolean
        public setItemInHand(item: cn.nukkit.item.Item, send: boolean): boolean
        public setItemInOffhand(item: cn.nukkit.item.Item, send: boolean): boolean
        public sendContents(target: cn.nukkit.Player): void
        public sendContents(target: cn.nukkit.Player[]): void
        entity: cn.nukkit.entity.Entity
        public static MAIN_HAND: int
        public static OFFHAND: int

    }
}

declare module "cn.nukkit.inventory.EntityEquipmentInventory" {
    declare const EntityEquipmentInventory = cn.nukkit.inventory.EntityEquipmentInventory;
}

declare namespace cn.nukkit.inventory {
    declare class CartographyRecipe extends cn.nukkit.inventory.ShapelessRecipe {
        public constructor(result: cn.nukkit.item.Item, ingredients: java.util.Collection<cn.nukkit.item.Item>): void
        public constructor(recipeId: string, priority: int, result: cn.nukkit.item.Item, ingredients: java.util.Collection<cn.nukkit.item.Item>): void
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void
        public getType(): cn.nukkit.inventory.RecipeType

    }
}

declare module "cn.nukkit.inventory.CartographyRecipe" {
    declare const CartographyRecipe = cn.nukkit.inventory.CartographyRecipe;
}

declare namespace cn.nukkit.inventory {
    declare class ContainerRecipe extends cn.nukkit.inventory.MixRecipe {
        public constructor(input: cn.nukkit.item.Item, ingredient: cn.nukkit.item.Item, output: cn.nukkit.item.Item): void
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void
        public getType(): cn.nukkit.inventory.RecipeType

    }
}

declare module "cn.nukkit.inventory.ContainerRecipe" {
    declare const ContainerRecipe = cn.nukkit.inventory.ContainerRecipe;
}

declare namespace cn.nukkit.inventory {
    declare class PlayerCursorInventory extends cn.nukkit.inventory.PlayerUIComponent {
        constructor(playerUI: cn.nukkit.inventory.PlayerUIInventory): void
        public getHolder(): cn.nukkit.Player
        public getType(): cn.nukkit.inventory.InventoryType
        public sendContents(players: cn.nukkit.Player[]): void
        public getHolder(): cn.nukkit.inventory.InventoryHolder
        playerUI: cn.nukkit.inventory.PlayerUIInventory

    }
}

declare module "cn.nukkit.inventory.PlayerCursorInventory" {
    declare const PlayerCursorInventory = cn.nukkit.inventory.PlayerCursorInventory;
}

declare namespace cn.nukkit.inventory {
    declare interface InventoryHolder {
        public getInventory(): cn.nukkit.inventory.Inventory

    }
}

declare module "cn.nukkit.inventory.InventoryHolder" {
    declare type InventoryHolder = cn.nukkit.inventory.InventoryHolder;
}

declare namespace cn.nukkit.inventory {
    declare class SmithingInventory extends cn.nukkit.inventory.FakeBlockUIComponent {
        public constructor(playerUI: cn.nukkit.inventory.PlayerUIInventory, position: cn.nukkit.level.Position): void
        public matchRecipe(): cn.nukkit.inventory.SmithingRecipe
        public onSlotChange(index: int, before: cn.nukkit.item.Item, send: boolean): void
        public updateResult(): void
        setResult(result: cn.nukkit.item.Item): void
        public getResult(): cn.nukkit.item.Item
        public getEquipment(): cn.nukkit.item.Item
        public setEquipment(equipment: cn.nukkit.item.Item): void
        public getIngredient(): cn.nukkit.item.Item
        public setIngredient(ingredient: cn.nukkit.item.Item): void
        public onOpen(who: cn.nukkit.Player): void
        public onClose(who: cn.nukkit.Player): void
        static EQUIPMENT: int
        static INGREDIENT: int
        public static SMITHING_EQUIPMENT_UI_SLOT: int
        public static SMITHING_INGREDIENT_UI_SLOT: int

    }
}

declare module "cn.nukkit.inventory.SmithingInventory" {
    declare const SmithingInventory = cn.nukkit.inventory.SmithingInventory;
}

declare namespace cn.nukkit.inventory {
    declare class CommandBlockInventory extends java.lang.Object implements cn.nukkit.inventory.Inventory {
        public constructor(holder: cn.nukkit.level.Position, viewers: java.util.Set<cn.nukkit.Player>): void
        public getSize(): int
        public getMaxStackSize(): int
        public setMaxStackSize(size: int): void
        public getName(): string
        public getTitle(): string
        public getItem(index: int): cn.nukkit.item.Item
        public setItem(index: int, item: cn.nukkit.item.Item, send: boolean): boolean
        public addItem(slots: cn.nukkit.item.Item[]): cn.nukkit.item.Item[]
        public canAddItem(item: cn.nukkit.item.Item): boolean
        public removeItem(slots: cn.nukkit.item.Item[]): cn.nukkit.item.Item[]
        public getContents(): java.util.Map<int, cn.nukkit.item.Item>
        public setContents(items: java.util.Map<int, cn.nukkit.item.Item>): void
        public sendContents(player: cn.nukkit.Player): void
        public sendContents(players: cn.nukkit.Player[]): void
        public sendContents(players: java.util.Collection<cn.nukkit.Player>): void
        public sendSlot(index: int, player: cn.nukkit.Player): void
        public sendSlot(index: int, players: cn.nukkit.Player[]): void
        public sendSlot(index: int, players: java.util.Collection<cn.nukkit.Player>): void
        public contains(item: cn.nukkit.item.Item): boolean
        public all(item: cn.nukkit.item.Item): java.util.Map<int, cn.nukkit.item.Item>
        public first(item: cn.nukkit.item.Item, exact: boolean): int
        public firstEmpty(item: cn.nukkit.item.Item): int
        public decreaseCount(slot: int): void
        public remove(item: cn.nukkit.item.Item): void
        public clear(index: int, send: boolean): boolean
        public clearAll(): void
        public isFull(): boolean
        public isEmpty(): boolean
        public getViewers(): java.util.Set<cn.nukkit.Player>
        public getType(): cn.nukkit.inventory.InventoryType
        public getHolder(): cn.nukkit.inventory.InventoryHolder
        public onOpen(who: cn.nukkit.Player): void
        public open(who: cn.nukkit.Player): boolean
        public close(who: cn.nukkit.Player): void
        public onClose(who: cn.nukkit.Player): void
        public onSlotChange(index: int, before: cn.nukkit.item.Item, send: boolean): void
        public addListener(listener: cn.nukkit.inventory.InventoryListener): void
        public removeListener(listener: cn.nukkit.inventory.InventoryListener): void
        holder: cn.nukkit.level.Position
        viewers: java.util.Set<cn.nukkit.Player>
        listeners: java.util.List<cn.nukkit.inventory.InventoryListener>

    }
}

declare module "cn.nukkit.inventory.CommandBlockInventory" {
    declare const CommandBlockInventory = cn.nukkit.inventory.CommandBlockInventory;
}

declare namespace cn.nukkit.inventory {
    declare class CampfireInventory extends cn.nukkit.inventory.ContainerInventory {
        public constructor(campfire: cn.nukkit.blockentity.BlockEntityCampfire): void
        public constructor(furnace: cn.nukkit.blockentity.BlockEntityCampfire, inventoryType: cn.nukkit.inventory.InventoryType): void
        public getHolder(): cn.nukkit.blockentity.BlockEntityCampfire
        public onSlotChange(index: int, before: cn.nukkit.item.Item, send: boolean): void
        public getMaxStackSize(): int
        public canAddItem(item: cn.nukkit.item.Item): boolean
        public getHolder(): cn.nukkit.inventory.InventoryHolder

    }
}

declare module "cn.nukkit.inventory.CampfireInventory" {
    declare const CampfireInventory = cn.nukkit.inventory.CampfireInventory;
}

declare namespace cn.nukkit.inventory {
    declare class RepairRecipe extends java.lang.Object implements cn.nukkit.inventory.Recipe {
        public constructor(inventoryType: cn.nukkit.inventory.InventoryType, result: cn.nukkit.item.Item, ingredients: java.util.Collection<cn.nukkit.item.Item>): void
        public getResult(): cn.nukkit.item.Item
        public getIngredientList(): java.util.List<cn.nukkit.item.Item>
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void
        public getType(): cn.nukkit.inventory.RecipeType
        public getInventoryType(): cn.nukkit.inventory.InventoryType
        result: cn.nukkit.item.Item
        ingredients: java.util.List<cn.nukkit.item.Item>
        inventoryType: cn.nukkit.inventory.InventoryType

    }
}

declare module "cn.nukkit.inventory.RepairRecipe" {
    declare const RepairRecipe = cn.nukkit.inventory.RepairRecipe;
}

declare namespace cn.nukkit.inventory {
    declare class ShapedRecipe extends java.lang.Object implements cn.nukkit.inventory.CraftingRecipe {
        public constructor(primaryResult: cn.nukkit.item.Item, shape: string[], ingredients: java.util.Map<char, cn.nukkit.item.Item>, extraResults: java.util.List<cn.nukkit.item.Item>): void
        public constructor(recipeId: string, priority: int, primaryResult: cn.nukkit.item.Item, shape: string[], ingredients: java.util.Map<char, cn.nukkit.item.Item>, extraResults: java.util.List<cn.nukkit.item.Item>): void
        public getWidth(): int
        public getHeight(): int
        public getResult(): cn.nukkit.item.Item
        public getRecipeId(): string
        public getId(): java.util.UUID
        public setId(uuid: java.util.UUID): void
        public setIngredient(key: string, item: cn.nukkit.item.Item): cn.nukkit.inventory.ShapedRecipe
        public setIngredient(key: char, item: cn.nukkit.item.Item): cn.nukkit.inventory.ShapedRecipe
        public getIngredientList(): java.util.List<cn.nukkit.item.Item>
        public getIngredientMap(): java.util.Map<int, java.util.Map<int, cn.nukkit.item.Item>>
        public getIngredient(x: int, y: int): cn.nukkit.item.Item
        public getShape(): string[]
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void
        public getType(): cn.nukkit.inventory.RecipeType
        public getExtraResults(): java.util.List<cn.nukkit.item.Item>
        public getAllResults(): java.util.List<cn.nukkit.item.Item>
        public getPriority(): int
        public matchItems(inputList: java.util.List<cn.nukkit.item.Item>, extraOutputList: java.util.List<cn.nukkit.item.Item>, multiplier: int): boolean
        public matchItems(inputList: java.util.List<cn.nukkit.item.Item>, extraOutputList: java.util.List<cn.nukkit.item.Item>): boolean
        public toString(): string
        public requiresCraftingTable(): boolean
        public getIngredientsAggregate(): java.util.List<cn.nukkit.item.Item>
        static lambda$toString$0(joiner: java.util.StringJoiner, character: char, item: cn.nukkit.item.Item): void
        recipeId: string
        primaryResult: cn.nukkit.item.Item
        extraResults: java.util.List<cn.nukkit.item.Item>
        ingredientsAggregate: java.util.List<cn.nukkit.item.Item>
        least: long
        most: long
        shape: string[]
        priority: int
        ingredients: io.netty.util.collection.CharObjectHashMap<cn.nukkit.item.Item>

    }
}

declare module "cn.nukkit.inventory.ShapedRecipe" {
    declare const ShapedRecipe = cn.nukkit.inventory.ShapedRecipe;
}

declare namespace cn.nukkit.inventory {
    declare class FakeBlockUIComponent extends cn.nukkit.inventory.PlayerUIComponent {
        constructor(playerUI: cn.nukkit.inventory.PlayerUIInventory, type: cn.nukkit.inventory.InventoryType, offset: int, position: cn.nukkit.level.Position): void
        public getHolder(): cn.nukkit.inventory.FakeBlockMenu
        public getType(): cn.nukkit.inventory.InventoryType
        public open(who: cn.nukkit.Player): boolean
        public close(who: cn.nukkit.Player): void
        public onOpen(who: cn.nukkit.Player): void
        public onClose(who: cn.nukkit.Player): void
        public sendContents(players: cn.nukkit.Player[]): void
        public getHolder(): cn.nukkit.inventory.InventoryHolder
        type: cn.nukkit.inventory.InventoryType

    }
}

declare module "cn.nukkit.inventory.FakeBlockUIComponent" {
    declare const FakeBlockUIComponent = cn.nukkit.inventory.FakeBlockUIComponent;
}

declare namespace cn.nukkit.inventory {
    declare class MixRecipe extends java.lang.Object implements cn.nukkit.inventory.Recipe {
        public constructor(input: cn.nukkit.item.Item, ingredient: cn.nukkit.item.Item, output: cn.nukkit.item.Item): void
        public getIngredient(): cn.nukkit.item.Item
        public getInput(): cn.nukkit.item.Item
        public getResult(): cn.nukkit.item.Item
        public toString(): string
        input: cn.nukkit.item.Item
        ingredient: cn.nukkit.item.Item
        output: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.inventory.MixRecipe" {
    declare const MixRecipe = cn.nukkit.inventory.MixRecipe;
}

declare namespace cn.nukkit.inventory {
    declare class StonecutterRecipe extends java.lang.Object implements cn.nukkit.inventory.Recipe {
        public constructor(result: cn.nukkit.item.Item, ingredient: cn.nukkit.item.Item): void
        public constructor(recipeId: string, priority: int, result: cn.nukkit.item.Item, ingredient: cn.nukkit.item.Item): void
        public getResult(): cn.nukkit.item.Item
        public getRecipeId(): string
        public getId(): java.util.UUID
        public setId(uuid: java.util.UUID): void
        public getIngredient(): cn.nukkit.item.Item
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void
        public getType(): cn.nukkit.inventory.RecipeType
        public getPriority(): int
        public toString(): string
        recipeId: string
        output: cn.nukkit.item.Item
        least: long
        most: long
        ingredient: cn.nukkit.item.Item
        priority: int

    }
}

declare module "cn.nukkit.inventory.StonecutterRecipe" {
    declare const StonecutterRecipe = cn.nukkit.inventory.StonecutterRecipe;
}

declare namespace cn.nukkit.inventory {
    declare class PlayerUIComponent extends cn.nukkit.inventory.BaseInventory {
        constructor(playerUI: cn.nukkit.inventory.PlayerUIInventory, offset: int, size: int): void
        public getSize(): int
        public getMaxStackSize(): int
        public setMaxStackSize(size: int): void
        public getTitle(): string
        public getItem(index: int): cn.nukkit.item.Item
        public setItem(index: int, item: cn.nukkit.item.Item, send: boolean): boolean
        public clear(index: int, send: boolean): boolean
        public getContents(): java.util.Map<int, cn.nukkit.item.Item>
        public sendContents(players: cn.nukkit.Player[]): void
        public sendSlot(index: int, players: cn.nukkit.Player[]): void
        public getViewers(): java.util.Set<cn.nukkit.Player>
        public getType(): cn.nukkit.inventory.InventoryType
        public onOpen(who: cn.nukkit.Player): void
        public open(who: cn.nukkit.Player): boolean
        public close(who: cn.nukkit.Player): void
        public onClose(who: cn.nukkit.Player): void
        public onSlotChange(index: int, before: cn.nukkit.item.Item, send: boolean): void
        lambda$getContents$0(slot: int): boolean
        public static CREATED_ITEM_OUTPUT_UI_SLOT: int
        playerUI: cn.nukkit.inventory.PlayerUIInventory
        offset: int
        size: int

    }
}

declare module "cn.nukkit.inventory.PlayerUIComponent" {
    declare const PlayerUIComponent = cn.nukkit.inventory.PlayerUIComponent;
}

declare namespace cn.nukkit.inventory {
    declare interface InventoryListener {
        public onInventoryChanged(var0: cn.nukkit.inventory.Inventory, var1: cn.nukkit.item.Item, var2: int): void

    }
}

declare module "cn.nukkit.inventory.InventoryListener" {
    declare type InventoryListener = cn.nukkit.inventory.InventoryListener;
}

declare namespace cn.nukkit.inventory {
    declare class ChestInventory extends cn.nukkit.inventory.ContainerInventory {
        public constructor(chest: cn.nukkit.blockentity.BlockEntityChest): void
        public getHolder(): cn.nukkit.blockentity.BlockEntityChest
        public onOpen(who: cn.nukkit.Player): void
        public onClose(who: cn.nukkit.Player): void
        public setDoubleInventory(doubleInventory: cn.nukkit.inventory.DoubleChestInventory): void
        public getDoubleInventory(): cn.nukkit.inventory.DoubleChestInventory
        public sendSlot(index: int, players: cn.nukkit.Player[]): void
        public getHolder(): cn.nukkit.inventory.InventoryHolder
        doubleInventory: cn.nukkit.inventory.DoubleChestInventory

    }
}

declare module "cn.nukkit.inventory.ChestInventory" {
    declare const ChestInventory = cn.nukkit.inventory.ChestInventory;
}

declare namespace cn.nukkit.inventory {
    declare class BeaconInventory extends cn.nukkit.inventory.FakeBlockUIComponent {
        public constructor(playerUI: cn.nukkit.inventory.PlayerUIInventory, position: cn.nukkit.level.Position): void
        public onClose(who: cn.nukkit.Player): void

    }
}

declare module "cn.nukkit.inventory.BeaconInventory" {
    declare const BeaconInventory = cn.nukkit.inventory.BeaconInventory;
}

declare namespace cn.nukkit.inventory {
    declare class CraftingManager extends java.lang.Object {
        public getShapedRecipeMap(): it.unimi.dsi.fastutil.ints.Int2ObjectMap<java.util.Map<java.util.UUID, cn.nukkit.inventory.ShapedRecipe>>
        public getFurnaceRecipesMap(): it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.inventory.FurnaceRecipe>
        public getBlastFurnaceRecipeMap(): it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.inventory.BlastFurnaceRecipe>
        public getSmokerRecipeMap(): it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.inventory.SmokerRecipe>
        public getCampfireRecipeMap(): it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.inventory.CampfireRecipe>
        public getMultiRecipeMap(): java.util.Map<java.util.UUID, cn.nukkit.inventory.MultiRecipe>
        public getBrewingRecipeMap(): it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.inventory.BrewingRecipe>
        public getContainerRecipeMap(): it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.inventory.ContainerRecipe>
        public getStonecutterRecipeMap(): it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.inventory.StonecutterRecipe>
        getShapelessRecipeMap(): it.unimi.dsi.fastutil.ints.Int2ObjectMap<java.util.Map<java.util.UUID, cn.nukkit.inventory.ShapelessRecipe>>
        public getCartographyRecipeMap(): it.unimi.dsi.fastutil.ints.Int2ObjectMap<java.util.Map<java.util.UUID, cn.nukkit.inventory.CartographyRecipe>>
        public getSmithingRecipeMap(): it.unimi.dsi.fastutil.ints.Int2ObjectMap<java.util.Map<java.util.UUID, cn.nukkit.inventory.SmithingRecipe>>
        public static getCraftingPacket(): cn.nukkit.network.protocol.DataPacket
        public getRecipes(): java.util.Collection<cn.nukkit.inventory.Recipe>
        public getFurnaceRecipes(): java.util.Map<int, cn.nukkit.inventory.FurnaceRecipe>
        public constructor(): void
        loadRecipes(config: cn.nukkit.utils.Config): void
        parseRecipeItem(data: java.util.Map<string, java.lang.Object>): cn.nukkit.item.Item
        public rebuildPacket(): void
        public matchFurnaceRecipe(input: cn.nukkit.item.Item): cn.nukkit.inventory.FurnaceRecipe
        public matchCampfireRecipe(input: cn.nukkit.item.Item): cn.nukkit.inventory.CampfireRecipe
        public matchBlastFurnaceRecipe(input: cn.nukkit.item.Item): cn.nukkit.inventory.BlastFurnaceRecipe
        public matchSmokerRecipe(input: cn.nukkit.item.Item): cn.nukkit.inventory.SmokerRecipe
        public static getMultiItemHash(items: java.util.Collection<cn.nukkit.item.Item>): java.util.UUID
        public static getFullItemHash(item: cn.nukkit.item.Item): int
        public registerStonecutterRecipe(recipe: cn.nukkit.inventory.StonecutterRecipe): void
        public registerFurnaceRecipe(recipe: cn.nukkit.inventory.FurnaceRecipe): void
        public registerBlastFurnaceRecipe(recipe: cn.nukkit.inventory.BlastFurnaceRecipe): void
        public registerSmokerRecipe(recipe: cn.nukkit.inventory.SmokerRecipe): void
        public registerCampfireRecipe(recipe: cn.nukkit.inventory.CampfireRecipe): void
        public static getItemHash(item: cn.nukkit.item.Item): int
        public static getItemHash(item: cn.nukkit.item.Item, meta: int): int
        public registerShapedRecipe(recipe: cn.nukkit.inventory.ShapedRecipe): void
        public registerRecipe(recipe: cn.nukkit.inventory.Recipe): void
        public registerCartographyRecipe(recipe: cn.nukkit.inventory.CartographyRecipe): void
        public registerShapelessRecipe(recipe: cn.nukkit.inventory.ShapelessRecipe): void
        public registerSmithingRecipe(recipe: cn.nukkit.inventory.SmithingRecipe): void
        public matchSmithingRecipe(equipment: cn.nukkit.item.Item, ingredient: cn.nukkit.item.Item): cn.nukkit.inventory.SmithingRecipe
        public matchSmithingRecipe(inputList: java.util.List<cn.nukkit.item.Item>): cn.nukkit.inventory.SmithingRecipe
        public matchSmithingRecipe(equipment: cn.nukkit.item.Item, ingredient: cn.nukkit.item.Item, primaryOutput: cn.nukkit.item.Item): cn.nukkit.inventory.SmithingRecipe
        public matchSmithingRecipe(inputList: java.util.List<cn.nukkit.item.Item>, primaryOutput: cn.nukkit.item.Item): cn.nukkit.inventory.SmithingRecipe
        public static getPotionHash(ingredient: cn.nukkit.item.Item, potion: cn.nukkit.item.Item): int
        public static getContainerHash(ingredient: cn.nukkit.item.Item, container: cn.nukkit.item.Item): int
        public registerBrewingRecipe(recipe: cn.nukkit.inventory.BrewingRecipe): void
        public registerContainerRecipe(recipe: cn.nukkit.inventory.ContainerRecipe): void
        public matchBrewingRecipe(input: cn.nukkit.item.Item, potion: cn.nukkit.item.Item): cn.nukkit.inventory.BrewingRecipe
        public matchContainerRecipe(input: cn.nukkit.item.Item, potion: cn.nukkit.item.Item): cn.nukkit.inventory.ContainerRecipe
        public matchStonecutterRecipe(output: cn.nukkit.item.Item): cn.nukkit.inventory.StonecutterRecipe
        public matchCartographyRecipe(inputList: java.util.List<cn.nukkit.item.Item>, primaryOutput: cn.nukkit.item.Item, extraOutputList: java.util.List<cn.nukkit.item.Item>): cn.nukkit.inventory.CartographyRecipe
        public matchRecipe(inputList: java.util.List<cn.nukkit.item.Item>, primaryOutput: cn.nukkit.item.Item, extraOutputList: java.util.List<cn.nukkit.item.Item>): cn.nukkit.inventory.CraftingRecipe
        matchItemsAccumulation(recipe: cn.nukkit.inventory.SmithingRecipe, inputList: java.util.List<cn.nukkit.item.Item>, primaryOutput: cn.nukkit.item.Item): boolean
        matchItemsAccumulation(recipe: cn.nukkit.inventory.CraftingRecipe, inputList: java.util.List<cn.nukkit.item.Item>, primaryOutput: cn.nukkit.item.Item, extraOutputList: java.util.List<cn.nukkit.item.Item>): boolean
        public registerMultiRecipe(recipe: cn.nukkit.inventory.MultiRecipe): void
        lambda$matchSmithingRecipe$9(inputList: java.util.List): cn.nukkit.inventory.SmithingRecipe
        static lambda$matchSmithingRecipe$8(inputList: java.util.List, recipe: cn.nukkit.inventory.SmithingRecipe): boolean
        static lambda$matchSmithingRecipe$7(map: java.util.Map): java.util.stream.Stream
        static lambda$matchSmithingRecipe$6(inputHash: java.util.UUID, entry: java.util.Map$Entry): boolean
        static lambda$matchSmithingRecipe$5(map: java.util.Map): java.util.stream.Stream
        static lambda$registerSmithingRecipe$4(k: int): java.util.Map
        static lambda$registerShapelessRecipe$3(k: int): java.util.Map
        static lambda$registerCartographyRecipe$2(k: int): java.util.Map
        static lambda$registerShapedRecipe$1(k: int): java.util.Map
        static lambda$static$0(i1: cn.nukkit.item.Item, i2: cn.nukkit.item.Item): int
        static log: org.apache.logging.log4j.Logger
        public static packet: cn.nukkit.network.protocol.DataPacket
        static RECIPE_COUNT: int
        shapedRecipeMap: it.unimi.dsi.fastutil.ints.Int2ObjectMap<java.util.Map<java.util.UUID, cn.nukkit.inventory.ShapedRecipe>>
        furnaceRecipeMap: it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.inventory.FurnaceRecipe>
        blastFurnaceRecipeMap: it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.inventory.BlastFurnaceRecipe>
        campfireRecipeMap: it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.inventory.CampfireRecipe>
        smokerRecipeMap: it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.inventory.SmokerRecipe>
        multiRecipeMap: java.util.Map<java.util.UUID, cn.nukkit.inventory.MultiRecipe>
        brewingRecipeMap: it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.inventory.BrewingRecipe>
        containerRecipeMap: it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.inventory.ContainerRecipe>
        stonecutterRecipeMap: it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.inventory.StonecutterRecipe>
        shapelessRecipeMap: it.unimi.dsi.fastutil.ints.Int2ObjectMap<java.util.Map<java.util.UUID, cn.nukkit.inventory.ShapelessRecipe>>
        cartographyRecipeMap: it.unimi.dsi.fastutil.ints.Int2ObjectMap<java.util.Map<java.util.UUID, cn.nukkit.inventory.CartographyRecipe>>
        smithingRecipeMap: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap<java.util.Map<java.util.UUID, cn.nukkit.inventory.SmithingRecipe>>
        recipeList: java.util.Deque<cn.nukkit.inventory.Recipe>
        public recipes: java.util.Collection<cn.nukkit.inventory.Recipe>
        shapedRecipes: java.util.Map<int, java.util.Map<java.util.UUID, cn.nukkit.inventory.ShapedRecipe>>
        public furnaceRecipes: java.util.Map<int, cn.nukkit.inventory.FurnaceRecipe>
        public blastFurnaceRecipes: java.util.Map<int, cn.nukkit.inventory.BlastFurnaceRecipe>
        public smokerRecipes: java.util.Map<int, cn.nukkit.inventory.SmokerRecipe>
        public campfireRecipes: java.util.Map<int, cn.nukkit.inventory.CampfireRecipe>
        public multiRecipes: java.util.Map<java.util.UUID, cn.nukkit.inventory.MultiRecipe>
        public brewingRecipes: java.util.Map<int, cn.nukkit.inventory.BrewingRecipe>
        public containerRecipes: java.util.Map<int, cn.nukkit.inventory.ContainerRecipe>
        public stonecutterRecipes: java.util.Map<int, cn.nukkit.inventory.StonecutterRecipe>
        shapelessRecipes: java.util.Map<int, java.util.Map<java.util.UUID, cn.nukkit.inventory.ShapelessRecipe>>
        cartographyRecipes: java.util.Map<int, java.util.Map<java.util.UUID, cn.nukkit.inventory.CartographyRecipe>>
        public static recipeComparator: java.util.Comparator<cn.nukkit.item.Item>

    }
}

declare module "cn.nukkit.inventory.CraftingManager" {
    declare const CraftingManager = cn.nukkit.inventory.CraftingManager;
}

declare namespace cn.nukkit.inventory.transaction.action {
    declare class RepairItemAction extends cn.nukkit.inventory.transaction.action.NoOpIventoryAction {
        public constructor(sourceItem: cn.nukkit.item.Item, targetItem: cn.nukkit.item.Item, type: int): void
        public isValid(source: cn.nukkit.Player): boolean
        public getType(): int
        public toString(): string
        type: int

    }
}

declare module "cn.nukkit.inventory.transaction.action.RepairItemAction" {
    declare const RepairItemAction = cn.nukkit.inventory.transaction.action.RepairItemAction;
}

declare namespace cn.nukkit.inventory.transaction.action {
    declare class CraftingTakeResultAction extends cn.nukkit.inventory.transaction.action.InventoryAction {
        public constructor(sourceItem: cn.nukkit.item.Item, targetItem: cn.nukkit.item.Item): void
        public onAddToTransaction(transaction: cn.nukkit.inventory.transaction.InventoryTransaction): void
        public isValid(source: cn.nukkit.Player): boolean
        public execute(source: cn.nukkit.Player): boolean
        public onExecuteSuccess($source: cn.nukkit.Player): void
        public onExecuteFail(source: cn.nukkit.Player): void
        public toString(): string

    }
}

declare module "cn.nukkit.inventory.transaction.action.CraftingTakeResultAction" {
    declare const CraftingTakeResultAction = cn.nukkit.inventory.transaction.action.CraftingTakeResultAction;
}

declare namespace cn.nukkit.inventory.transaction.action {
    declare class EnchantingAction extends cn.nukkit.inventory.transaction.action.NoOpIventoryAction {
        public constructor(source: cn.nukkit.item.Item, target: cn.nukkit.item.Item, type: int): void
        public isValid(source: cn.nukkit.Player): boolean
        public getType(): int
        public toString(): string
        type: int

    }
}

declare module "cn.nukkit.inventory.transaction.action.EnchantingAction" {
    declare const EnchantingAction = cn.nukkit.inventory.transaction.action.EnchantingAction;
}

declare namespace cn.nukkit.inventory.transaction.action {
    declare class CraftingTakeResultExperienceAction extends cn.nukkit.inventory.transaction.action.CraftingTakeResultAction {
        public constructor(sourceItem: cn.nukkit.item.Item, targetItem: cn.nukkit.item.Item, experience: int): void
        public getExperience(): int
        public execute(source: cn.nukkit.Player): boolean
        public toString(): string
        experience: int

    }
}

declare module "cn.nukkit.inventory.transaction.action.CraftingTakeResultExperienceAction" {
    declare const CraftingTakeResultExperienceAction = cn.nukkit.inventory.transaction.action.CraftingTakeResultExperienceAction;
}

declare namespace cn.nukkit.inventory.transaction.action {
    declare class GrindstoneItemAction extends cn.nukkit.inventory.transaction.action.InventoryAction {
        public constructor(sourceItem: cn.nukkit.item.Item, targetItem: cn.nukkit.item.Item, type: int, experience: int): void
        public isValid(source: cn.nukkit.Player): boolean
        public execute(source: cn.nukkit.Player): boolean
        public onExecuteSuccess(source: cn.nukkit.Player): void
        public onExecuteFail(source: cn.nukkit.Player): void
        public getExperience(): int
        public getType(): int
        type: int
        experience: int

    }
}

declare module "cn.nukkit.inventory.transaction.action.GrindstoneItemAction" {
    declare const GrindstoneItemAction = cn.nukkit.inventory.transaction.action.GrindstoneItemAction;
}

declare namespace cn.nukkit.inventory.transaction {
    declare class RepairItemTransaction$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$item$enchantment$Enchantment$Rarity: int[]

    }
}

declare module "cn.nukkit.inventory.transaction.RepairItemTransaction$1" {
    declare const RepairItemTransaction$1 = cn.nukkit.inventory.transaction.RepairItemTransaction$1;
}

declare namespace cn.nukkit.inventory.transaction {
    declare class InventoryTransaction extends java.lang.Object {
        public constructor(source: cn.nukkit.Player, actions: java.util.List<cn.nukkit.inventory.transaction.action.InventoryAction>): void
        public constructor(source: cn.nukkit.Player, actions: java.util.List<cn.nukkit.inventory.transaction.action.InventoryAction>, init: boolean): void
        init(source: cn.nukkit.Player, actions: java.util.List<cn.nukkit.inventory.transaction.action.InventoryAction>): void
        public getSource(): cn.nukkit.Player
        public getCreationTime(): long
        public getInventories(): java.util.Set<cn.nukkit.inventory.Inventory>
        public getActionList(): java.util.List<cn.nukkit.inventory.transaction.action.InventoryAction>
        public getActions(): java.util.Set<cn.nukkit.inventory.transaction.action.InventoryAction>
        public addAction(action: cn.nukkit.inventory.transaction.action.InventoryAction): void
        public addInventory(inventory: cn.nukkit.inventory.Inventory): void
        matchItems(needItems: java.util.List<cn.nukkit.item.Item>, haveItems: java.util.List<cn.nukkit.item.Item>): boolean
        sendInventories(): void
        public canExecute(): boolean
        callExecuteEvent(): boolean
        public execute(): boolean
        public hasExecuted(): boolean
        creationTime: long
        hasExecuted: boolean
        source: cn.nukkit.Player
        inventories: java.util.Set<cn.nukkit.inventory.Inventory>
        actions: java.util.List<cn.nukkit.inventory.transaction.action.InventoryAction>

    }
}

declare module "cn.nukkit.inventory.transaction.InventoryTransaction" {
    declare const InventoryTransaction = cn.nukkit.inventory.transaction.InventoryTransaction;
}

declare namespace cn.nukkit.inventory.transaction {
    declare class SmithingTransaction extends cn.nukkit.inventory.transaction.InventoryTransaction {
        public constructor(source: cn.nukkit.Player, actions: java.util.List<cn.nukkit.inventory.transaction.action.InventoryAction>): void
        public addAction(action: cn.nukkit.inventory.transaction.action.InventoryAction): void
        public canExecute(): boolean
        public execute(): boolean
        public getEquipmentItem(): cn.nukkit.item.Item
        public getIngredientItem(): cn.nukkit.item.Item
        public getOutputItem(): cn.nukkit.item.Item
        public static checkForItemPart(actions: java.util.List<cn.nukkit.inventory.transaction.action.InventoryAction>): boolean
        static lambda$checkForItemPart$0(it: cn.nukkit.inventory.transaction.action.InventoryAction): boolean
        equipmentItem: cn.nukkit.item.Item
        ingredientItem: cn.nukkit.item.Item
        outputItem: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.inventory.transaction.SmithingTransaction" {
    declare const SmithingTransaction = cn.nukkit.inventory.transaction.SmithingTransaction;
}

declare namespace cn.nukkit.inventory.transaction {
    declare class CraftingTransaction extends cn.nukkit.inventory.transaction.InventoryTransaction {
        public constructor(source: cn.nukkit.Player, actions: java.util.List<cn.nukkit.inventory.transaction.action.InventoryAction>): void
        public setInput(item: cn.nukkit.item.Item): void
        public getInputList(): java.util.List<cn.nukkit.item.Item>
        public setExtraOutput(item: cn.nukkit.item.Item): void
        public getPrimaryOutput(): cn.nukkit.item.Item
        public setPrimaryOutput(item: cn.nukkit.item.Item): void
        public getRecipe(): cn.nukkit.inventory.CraftingRecipe
        public getTransactionRecipe(): cn.nukkit.inventory.Recipe
        setTransactionRecipe(recipe: cn.nukkit.inventory.Recipe): void
        public canExecute(): boolean
        callExecuteEvent(): boolean
        sendInventories(): void
        public execute(): boolean
        public checkForCraftingPart(actions: java.util.List<cn.nukkit.inventory.transaction.action.InventoryAction>): boolean
        public setReadyToExecute(readyToExecute: boolean): void
        public isReadyToExecute(): boolean
        lambda$canExecute$5(a: cn.nukkit.inventory.transaction.action.SlotChangeAction): void
        static lambda$canExecute$4(a: cn.nukkit.inventory.transaction.action.SlotChangeAction): boolean
        static lambda$canExecute$3(uiInventory: cn.nukkit.inventory.PlayerUIInventory, a: cn.nukkit.inventory.transaction.action.SlotChangeAction): boolean
        static lambda$canExecute$2(a: cn.nukkit.inventory.transaction.action.InventoryAction): cn.nukkit.inventory.transaction.action.SlotChangeAction
        static lambda$canExecute$1(a: cn.nukkit.inventory.transaction.action.InventoryAction): boolean
        static lambda$canExecute$0(action: cn.nukkit.inventory.transaction.action.InventoryAction): boolean
        gridSize: int
        inputs: java.util.List<cn.nukkit.item.Item>
        secondaryOutputs: java.util.List<cn.nukkit.item.Item>
        primaryOutput: cn.nukkit.item.Item
        recipe: cn.nukkit.inventory.CraftingRecipe
        transactionRecipe: cn.nukkit.inventory.Recipe
        craftingType: int
        readyToExecute: boolean

    }
}

declare module "cn.nukkit.inventory.transaction.CraftingTransaction" {
    declare const CraftingTransaction = cn.nukkit.inventory.transaction.CraftingTransaction;
}

declare namespace cn.nukkit.inventory {
    declare class MinecartChestInventory extends cn.nukkit.inventory.ContainerInventory {
        public constructor(minecart: cn.nukkit.entity.item.EntityMinecartChest): void
        public getHolder(): cn.nukkit.entity.item.EntityMinecartChest
        public getHolder(): cn.nukkit.inventory.InventoryHolder

    }
}

declare module "cn.nukkit.inventory.MinecartChestInventory" {
    declare const MinecartChestInventory = cn.nukkit.inventory.MinecartChestInventory;
}

declare namespace cn.nukkit.inventory {
    declare class CraftingGrid extends cn.nukkit.inventory.PlayerUIComponent {
        constructor(playerUI: cn.nukkit.inventory.PlayerUIInventory): void
        constructor(playerUI: cn.nukkit.inventory.PlayerUIInventory, offset: int, size: int): void

    }
}

declare module "cn.nukkit.inventory.CraftingGrid" {
    declare const CraftingGrid = cn.nukkit.inventory.CraftingGrid;
}

declare namespace cn.nukkit.inventory {
    declare class HopperInventory extends cn.nukkit.inventory.ContainerInventory {
        public constructor(hopper: cn.nukkit.blockentity.BlockEntityHopper): void
        public getHolder(): cn.nukkit.blockentity.BlockEntityHopper
        public getHolder(): cn.nukkit.inventory.InventoryHolder

    }
}

declare module "cn.nukkit.inventory.HopperInventory" {
    declare const HopperInventory = cn.nukkit.inventory.HopperInventory;
}

declare namespace cn.nukkit.inventory {
    declare class ShulkerBoxRecipe extends cn.nukkit.inventory.ShapelessRecipe {
        public constructor(result: cn.nukkit.item.Item, ingredients: java.util.Collection<cn.nukkit.item.Item>): void
        public constructor(recipeId: string, priority: int, result: cn.nukkit.item.Item, ingredients: java.util.Collection<cn.nukkit.item.Item>): void
        public getType(): cn.nukkit.inventory.RecipeType

    }
}

declare module "cn.nukkit.inventory.ShulkerBoxRecipe" {
    declare const ShulkerBoxRecipe = cn.nukkit.inventory.ShulkerBoxRecipe;
}

declare namespace cn.nukkit.inventory {
    declare class BarrelInventory extends cn.nukkit.inventory.ContainerInventory {
        public constructor(barrel: cn.nukkit.blockentity.BlockEntityBarrel): void
        public getHolder(): cn.nukkit.blockentity.BlockEntityBarrel
        public onOpen(who: cn.nukkit.Player): void
        public onClose(who: cn.nukkit.Player): void
        public getHolder(): cn.nukkit.inventory.InventoryHolder

    }
}

declare module "cn.nukkit.inventory.BarrelInventory" {
    declare const BarrelInventory = cn.nukkit.inventory.BarrelInventory;
}

declare namespace cn.nukkit.level.particle {
    declare class InkParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void
        public constructor(pos: cn.nukkit.math.Vector3, scale: int): void

    }
}

declare module "cn.nukkit.level.particle.InkParticle" {
    declare const InkParticle = cn.nukkit.level.particle.InkParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class LavaParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.LavaParticle" {
    declare const LavaParticle = cn.nukkit.level.particle.LavaParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class ScrapeParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void
        public encode(): cn.nukkit.network.protocol.DataPacket[]

    }
}

declare module "cn.nukkit.level.particle.ScrapeParticle" {
    declare const ScrapeParticle = cn.nukkit.level.particle.ScrapeParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class PortalParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.PortalParticle" {
    declare const PortalParticle = cn.nukkit.level.particle.PortalParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class BoneMealParticle extends cn.nukkit.level.particle.Particle {
        public constructor(pos: cn.nukkit.math.Vector3): void
        public encode(): cn.nukkit.network.protocol.DataPacket[]
        position: cn.nukkit.math.Vector3

    }
}

declare module "cn.nukkit.level.particle.BoneMealParticle" {
    declare const BoneMealParticle = cn.nukkit.level.particle.BoneMealParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class ElectricSparkParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void
        public encode(): cn.nukkit.network.protocol.DataPacket[]

    }
}

declare module "cn.nukkit.level.particle.ElectricSparkParticle" {
    declare const ElectricSparkParticle = cn.nukkit.level.particle.ElectricSparkParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class AngryVillagerParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.AngryVillagerParticle" {
    declare const AngryVillagerParticle = cn.nukkit.level.particle.AngryVillagerParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class BlockForceFieldParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void
        public constructor(pos: cn.nukkit.math.Vector3, scale: int): void

    }
}

declare module "cn.nukkit.level.particle.BlockForceFieldParticle" {
    declare const BlockForceFieldParticle = cn.nukkit.level.particle.BlockForceFieldParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class CloudParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void
        public constructor(pos: cn.nukkit.math.Vector3, scale: int): void

    }
}

declare module "cn.nukkit.level.particle.CloudParticle" {
    declare const CloudParticle = cn.nukkit.level.particle.CloudParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class SpellParticle extends cn.nukkit.level.particle.Particle {
        public constructor(pos: cn.nukkit.math.Vector3): void
        public constructor(pos: cn.nukkit.math.Vector3, data: int): void
        public constructor(pos: cn.nukkit.math.Vector3, blockColor: cn.nukkit.utils.BlockColor): void
        public constructor(pos: cn.nukkit.math.Vector3, r: int, g: int, b: int): void
        constructor(pos: cn.nukkit.math.Vector3, r: int, g: int, b: int, a: int): void
        public encode(): cn.nukkit.network.protocol.DataPacket[]
        data: int

    }
}

declare module "cn.nukkit.level.particle.SpellParticle" {
    declare const SpellParticle = cn.nukkit.level.particle.SpellParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class ItemBreakParticle extends cn.nukkit.level.particle.Particle {
        public constructor(pos: cn.nukkit.math.Vector3, item: cn.nukkit.item.Item): void
        public encode(): cn.nukkit.network.protocol.DataPacket[]
        data: int

    }
}

declare module "cn.nukkit.level.particle.ItemBreakParticle" {
    declare const ItemBreakParticle = cn.nukkit.level.particle.ItemBreakParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class BubbleParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.BubbleParticle" {
    declare const BubbleParticle = cn.nukkit.level.particle.BubbleParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class SporeParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.SporeParticle" {
    declare const SporeParticle = cn.nukkit.level.particle.SporeParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class SplashParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.SplashParticle" {
    declare const SplashParticle = cn.nukkit.level.particle.SplashParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class FlameParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.FlameParticle" {
    declare const FlameParticle = cn.nukkit.level.particle.FlameParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class WaterDripParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.WaterDripParticle" {
    declare const WaterDripParticle = cn.nukkit.level.particle.WaterDripParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class MobSpawnParticle extends cn.nukkit.level.particle.Particle {
        public constructor(pos: cn.nukkit.math.Vector3, width: float, height: float): void
        public encode(): cn.nukkit.network.protocol.DataPacket[]
        width: int
        height: int

    }
}

declare module "cn.nukkit.level.particle.MobSpawnParticle" {
    declare const MobSpawnParticle = cn.nukkit.level.particle.MobSpawnParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class LavaDripParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.LavaDripParticle" {
    declare const LavaDripParticle = cn.nukkit.level.particle.LavaDripParticle;
}

declare namespace cn.nukkit.level.particle {
    declare class EnchantParticle extends cn.nukkit.level.particle.GenericParticle {
        public constructor(pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.particle.EnchantParticle" {
    declare const EnchantParticle = cn.nukkit.level.particle.EnchantParticle;
}

declare namespace cn.nukkit.level {
    declare interface ChunkManager {
        public getBlockIdAt(var0: int, var1: int, var2: int, var3: int): int
        public getBlockIdAt(var0: int, var1: int, var2: int): int
        public setBlockFullIdAt(var0: int, var1: int, var2: int, var3: int, var4: int): void
        public setBlockFullIdAt(var0: int, var1: int, var2: int, var3: int): void
        public setBlockIdAt(var0: int, var1: int, var2: int, var3: int, var4: int): void
        public setBlockIdAt(var0: int, var1: int, var2: int, var3: int): void
        public setBlockAtLayer(var0: int, var1: int, var2: int, var3: int, var4: int, var5: int): boolean
        public setBlockAtLayer(x: int, y: int, z: int, layer: int, id: int): boolean
        public setBlockAt(x: int, y: int, z: int, id: int): void
        public setBlockStateAt(var0: int, var1: int, var2: int, var3: int, var4: cn.nukkit.blockstate.BlockState): boolean
        public setBlockStateAt(x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): boolean
        public getBlockStateAt(var0: int, var1: int, var2: int, var3: int): cn.nukkit.blockstate.BlockState
        public getBlockStateAt(x: int, y: int, z: int): cn.nukkit.blockstate.BlockState
        public setBlockAt(var0: int, var1: int, var2: int, var3: int, var4: int): void
        public getBlockDataAt(var0: int, var1: int, var2: int, var3: int): int
        public getBlockDataAt(var0: int, var1: int, var2: int): int
        public setBlockDataAt(var0: int, var1: int, var2: int, var3: int, var4: int): void
        public setBlockDataAt(var0: int, var1: int, var2: int, var3: int): void
        public getChunk(var0: int, var1: int): cn.nukkit.level.format.generic.BaseFullChunk
        public getChunk(pos: cn.nukkit.math.ChunkVector2): cn.nukkit.level.format.generic.BaseFullChunk
        public setChunk(var0: int, var1: int): void
        public setChunk(var0: int, var1: int, var2: cn.nukkit.level.format.generic.BaseFullChunk): void
        public getSeed(): long

    }
}

declare module "cn.nukkit.level.ChunkManager" {
    declare type ChunkManager = cn.nukkit.level.ChunkManager;
}

declare namespace cn.nukkit.level {
    declare class ChunkPosition extends java.lang.Object {
        public constructor(i: int, j: int, k: int): void
        public constructor(vec3d: cn.nukkit.math.Vector3): void
        public equals(object: java.lang.Object): boolean
        public hashCode(): int
        public x: int
        public y: int
        public z: int

    }
}

declare module "cn.nukkit.level.ChunkPosition" {
    declare const ChunkPosition = cn.nukkit.level.ChunkPosition;
}

declare namespace cn.nukkit.level {
    declare class GameRules$Type$3 extends cn.nukkit.level.GameRules$Type {
        constructor(var0: string, var1: int): void
        write(pk: cn.nukkit.utils.BinaryStream, value: cn.nukkit.level.GameRules$Value): void

    }
}

declare module "cn.nukkit.level.GameRules$Type$3" {
    declare const GameRules$Type$3 = cn.nukkit.level.GameRules$Type$3;
}

declare namespace cn.nukkit.level.generator {
    declare class PopChunkManager extends cn.nukkit.level.generator.SimpleChunkManager {
        public constructor(seed: long): void
        public cleanChunks(seed: long): void
        public getChunk(chunkX: int, chunkZ: int): cn.nukkit.level.format.generic.BaseFullChunk
        public setChunk(chunkX: int, chunkZ: int, chunk: cn.nukkit.level.format.generic.BaseFullChunk): void
        clean: boolean
        chunks: cn.nukkit.level.format.generic.BaseFullChunk[]
        CX: int
        CZ: int

    }
}

declare module "cn.nukkit.level.generator.PopChunkManager" {
    declare const PopChunkManager = cn.nukkit.level.generator.PopChunkManager;
}

declare namespace cn.nukkit.level.generator.object.end {
    declare class ObjectEndSpike extends cn.nukkit.level.generator.object.BasicGenerator {
        public constructor(position: cn.nukkit.math.Vector3, radius: int, height: int, hasIronBars: boolean): void
        public generate(level: cn.nukkit.level.ChunkManager, rand: cn.nukkit.math.NukkitRandom, position: cn.nukkit.math.Vector3): boolean
        public generate(level: cn.nukkit.level.ChunkManager, rand: cn.nukkit.math.NukkitRandom): boolean
        static STATE_BEDROCK_INFINIBURN: cn.nukkit.blockstate.BlockState
        static STATE_OBSIDIAN: cn.nukkit.blockstate.BlockState
        static STATE_IRON_BARS: cn.nukkit.blockstate.BlockState
        static STATE_AIR: cn.nukkit.blockstate.BlockState
        position: cn.nukkit.math.Vector3
        radius: int
        height: int
        hasIronBars: boolean
        tempPosition: cn.nukkit.math.Vector3

    }
}

declare module "cn.nukkit.level.generator.object.end.ObjectEndSpike" {
    declare const ObjectEndSpike = cn.nukkit.level.generator.object.end.ObjectEndSpike;
}

declare namespace cn.nukkit.level.generator.object.end {
    declare class ObjectEndGateway extends cn.nukkit.level.generator.object.BasicGenerator {
        public constructor(): void
        public generate(level: cn.nukkit.level.ChunkManager, rand: cn.nukkit.math.NukkitRandom, position: cn.nukkit.math.Vector3): boolean
        public generate(level: cn.nukkit.level.ChunkManager, rand: cn.nukkit.math.NukkitRandom, position: cn.nukkit.math.Vector3, exitPortal: cn.nukkit.math.BlockVector3): boolean
        static STATE_BEDROCK: cn.nukkit.blockstate.BlockState
        static STATE_END_GATEWAY: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.level.generator.object.end.ObjectEndGateway" {
    declare const ObjectEndGateway = cn.nukkit.level.generator.object.end.ObjectEndGateway;
}

declare namespace cn.nukkit.level.generator.object.end {
    declare class ObjectChorusTree extends cn.nukkit.level.generator.object.BasicGenerator {
        public constructor(): void
        public generate(level: cn.nukkit.level.ChunkManager, rand: cn.nukkit.math.NukkitRandom, position: cn.nukkit.math.Vector3): boolean
        public generate(level: cn.nukkit.level.ChunkManager, rand: cn.nukkit.math.NukkitRandom, position: cn.nukkit.math.Vector3, maxSize: int): boolean
        public growImmediately(level: cn.nukkit.level.ChunkManager, random: cn.nukkit.math.NukkitRandom, position: cn.nukkit.math.Vector3, maxSize: int, age: int): void
        isHorizontalAir(level: cn.nukkit.level.ChunkManager, vector3: cn.nukkit.math.Vector3): boolean
        isHorizontalAirExcept(level: cn.nukkit.level.ChunkManager, vector3: cn.nukkit.math.Vector3, except: cn.nukkit.math.BlockFace): boolean
        static STATE_CHORUS_FLOWER_FULLY_AGED: cn.nukkit.blockstate.BlockState
        static STATE_CHORUS_PLANT: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.level.generator.object.end.ObjectChorusTree" {
    declare const ObjectChorusTree = cn.nukkit.level.generator.object.end.ObjectChorusTree;
}

declare namespace cn.nukkit.level.generator.object.end {
    declare class ObjectEndIsland extends cn.nukkit.level.generator.object.BasicGenerator {
        public constructor(): void
        public generate(level: cn.nukkit.level.ChunkManager, rand: cn.nukkit.math.NukkitRandom, position: cn.nukkit.math.Vector3): boolean
        static STATE_END_STONE: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.level.generator.object.end.ObjectEndIsland" {
    declare const ObjectEndIsland = cn.nukkit.level.generator.object.end.ObjectEndIsland;
}

declare namespace cn.nukkit.level.generator.object.ore {
    declare class OreType extends java.lang.Object {
        public constructor(material: cn.nukkit.block.Block, clusterCount: int, clusterSize: int, minHeight: int, maxHeight: int): void
        public constructor(material: cn.nukkit.block.Block, clusterCount: int, clusterSize: int, minHeight: int, maxHeight: int, replaceBlockId: int): void
        public spawn(level: cn.nukkit.level.ChunkManager, rand: cn.nukkit.math.NukkitRandom, replaceId: int, x: int, y: int, z: int): boolean
        public static EMPTY_ARRAY: cn.nukkit.level.generator.object.ore.OreType[]
        public fullId: int
        public blockId: int
        public blockData: int
        public clusterCount: int
        public clusterSize: int
        public maxHeight: int
        public minHeight: int
        public replaceBlockId: int

    }
}

declare module "cn.nukkit.level.generator.object.ore.OreType" {
    declare const OreType = cn.nukkit.level.generator.object.ore.OreType;
}

declare namespace cn.nukkit.level.generator.object {
    declare class BasicGenerator extends java.lang.Object {
        public constructor(): void
        public generate(var0: cn.nukkit.level.ChunkManager, var1: cn.nukkit.math.NukkitRandom, var2: cn.nukkit.math.Vector3): boolean
        public setDecorationDefaults(): void
        setBlockAndNotifyAdequately(level: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.BlockVector3, state: cn.nukkit.block.Block): void
        setBlockAndNotifyAdequately(level: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.Vector3, state: cn.nukkit.block.Block): void
        setBlock(level: cn.nukkit.level.ChunkManager, v: cn.nukkit.math.Vector3, b: cn.nukkit.block.Block): void

    }
}

declare module "cn.nukkit.level.generator.object.BasicGenerator" {
    declare const BasicGenerator = cn.nukkit.level.generator.object.BasicGenerator;
}

declare namespace cn.nukkit.level.generator.object {
    declare class ObjectTallGrass extends java.lang.Object {
        public constructor(): void
        public static growGrass(level: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.Vector3, random: cn.nukkit.math.NukkitRandom): void
        public static growGrass(level: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.Vector3, random: cn.nukkit.math.NukkitRandom, count: int, radius: int): void

    }
}

declare module "cn.nukkit.level.generator.object.ObjectTallGrass" {
    declare const ObjectTallGrass = cn.nukkit.level.generator.object.ObjectTallGrass;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class TreeGenerator extends cn.nukkit.level.generator.object.BasicGenerator {
        public constructor(): void
        canGrowInto(id: int): boolean
        public generateSaplings(level: cn.nukkit.level.Level, random: java.util.Random, pos: cn.nukkit.math.Vector3): void
        setDirtAt(level: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.BlockVector3): void
        setDirtAt(level: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.level.generator.object.tree.TreeGenerator" {
    declare const TreeGenerator = cn.nukkit.level.generator.object.tree.TreeGenerator;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class ObjectSavannaTree extends cn.nukkit.level.generator.object.tree.TreeGenerator {
        public constructor(): void
        public generate(level: cn.nukkit.level.ChunkManager, rand: cn.nukkit.math.NukkitRandom, position: cn.nukkit.math.Vector3): boolean
        placeLogAt(worldIn: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.Vector3): void
        placeLeafAt(worldIn: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.Vector3): void
        static TRUNK: cn.nukkit.block.Block
        static LEAF: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.level.generator.object.tree.ObjectSavannaTree" {
    declare const ObjectSavannaTree = cn.nukkit.level.generator.object.tree.ObjectSavannaTree;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class ObjectCrimsonTree extends cn.nukkit.level.generator.object.tree.ObjectNetherTree {
        public constructor(): void
        public getTrunkBlock(): int
        public getLeafBlock(): int

    }
}

declare module "cn.nukkit.level.generator.object.tree.ObjectCrimsonTree" {
    declare const ObjectCrimsonTree = cn.nukkit.level.generator.object.tree.ObjectCrimsonTree;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class ObjectNetherTree extends cn.nukkit.level.generator.object.tree.ObjectTree {
        public constructor(): void
        public constructor(treeHeight: int): void
        public getType(): int
        public getTreeHeight(): int
        public placeObject(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom): void
        placeTrunk(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom, trunkHeight: int): void
        treeHeight: int

    }
}

declare module "cn.nukkit.level.generator.object.tree.ObjectNetherTree" {
    declare const ObjectNetherTree = cn.nukkit.level.generator.object.tree.ObjectNetherTree;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class ObjectTallBirchTree extends cn.nukkit.level.generator.object.tree.ObjectBirchTree {
        public constructor(): void
        public placeObject(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom): void

    }
}

declare module "cn.nukkit.level.generator.object.tree.ObjectTallBirchTree" {
    declare const ObjectTallBirchTree = cn.nukkit.level.generator.object.tree.ObjectTallBirchTree;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class ObjectOakTree extends cn.nukkit.level.generator.object.tree.ObjectTree {
        public constructor(): void
        public getTrunkBlock(): int
        public getLeafBlock(): int
        public getType(): int
        public getTreeHeight(): int
        public placeObject(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom): void
        treeHeight: int

    }
}

declare module "cn.nukkit.level.generator.object.tree.ObjectOakTree" {
    declare const ObjectOakTree = cn.nukkit.level.generator.object.tree.ObjectOakTree;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class ObjectJungleTree extends cn.nukkit.level.generator.object.tree.ObjectTree {
        public constructor(): void
        public getTrunkBlock(): int
        public getLeafBlock(): int
        public getType(): int
        public getTreeHeight(): int
        public placeObject(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom): void
        treeHeight: int

    }
}

declare module "cn.nukkit.level.generator.object.tree.ObjectJungleTree" {
    declare const ObjectJungleTree = cn.nukkit.level.generator.object.tree.ObjectJungleTree;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class ObjectTree extends java.lang.Object {
        public constructor(): void
        overridable(id: int): boolean
        public getType(): int
        public getTrunkBlock(): int
        public getLeafBlock(): int
        public getTreeHeight(): int
        public static growTree(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom): void
        public static growTree(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom, type: int): void
        public static growTree(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom, type: cn.nukkit.blockproperty.value.WoodType, tall: boolean): void
        public canPlaceObject(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom): boolean
        public placeObject(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom): void
        placeTrunk(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom, trunkHeight: int): void

    }
}

declare module "cn.nukkit.level.generator.object.tree.ObjectTree" {
    declare const ObjectTree = cn.nukkit.level.generator.object.tree.ObjectTree;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class ObjectSwampTree extends cn.nukkit.level.generator.object.tree.TreeGenerator {
        public constructor(): void
        public generate(worldIn: cn.nukkit.level.ChunkManager, rand: cn.nukkit.math.NukkitRandom, vectorPosition: cn.nukkit.math.Vector3): boolean
        addVine(worldIn: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.BlockVector3, meta: int): void
        addHangingVine(worldIn: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.BlockVector3, meta: int): void
        metaWood: cn.nukkit.block.Block
        metaLeaves: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.level.generator.object.tree.ObjectSwampTree" {
    declare const ObjectSwampTree = cn.nukkit.level.generator.object.tree.ObjectSwampTree;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class ObjectWarpedTree extends cn.nukkit.level.generator.object.tree.ObjectNetherTree {
        public constructor(): void
        public getTrunkBlock(): int
        public getLeafBlock(): int

    }
}

declare module "cn.nukkit.level.generator.object.tree.ObjectWarpedTree" {
    declare const ObjectWarpedTree = cn.nukkit.level.generator.object.tree.ObjectWarpedTree;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class HugeTreesGenerator extends cn.nukkit.level.generator.object.tree.TreeGenerator {
        public constructor(baseHeightIn: int, extraRandomHeightIn: int, woodMetadataIn: cn.nukkit.block.Block, leavesMetadataIn: cn.nukkit.block.Block): void
        getHeight(rand: cn.nukkit.math.NukkitRandom): int
        isSpaceAt(worldIn: cn.nukkit.level.ChunkManager, leavesPos: cn.nukkit.math.Vector3, height: int): boolean
        ensureDirtsUnderneath(pos: cn.nukkit.math.Vector3, worldIn: cn.nukkit.level.ChunkManager): boolean
        ensureGrowable(worldIn: cn.nukkit.level.ChunkManager, rand: cn.nukkit.math.NukkitRandom, treePos: cn.nukkit.math.Vector3, p_175929_4_: int): boolean
        growLeavesLayerStrict(worldIn: cn.nukkit.level.ChunkManager, layerCenter: cn.nukkit.math.Vector3, width: int): void
        growLeavesLayer(worldIn: cn.nukkit.level.ChunkManager, layerCenter: cn.nukkit.math.Vector3, width: int): void
        baseHeight: int
        woodMetadata: cn.nukkit.block.Block
        leavesMetadata: cn.nukkit.block.Block
        extraRandomHeight: int

    }
}

declare module "cn.nukkit.level.generator.object.tree.HugeTreesGenerator" {
    declare const HugeTreesGenerator = cn.nukkit.level.generator.object.tree.HugeTreesGenerator;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class ObjectAzaleaTree extends cn.nukkit.level.generator.object.tree.TreeGenerator {
        public constructor(): void
        public generate(level: cn.nukkit.level.ChunkManager, rand: cn.nukkit.math.NukkitRandom, position: cn.nukkit.math.Vector3): boolean
        setDirtAt(level: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.Vector3): void
        placeLogAt(worldIn: cn.nukkit.level.ChunkManager, x: int, y: int, z: int): void
        placeLeafAt(worldIn: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom): void
        static OAK_LOG: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.level.generator.object.tree.ObjectAzaleaTree" {
    declare const ObjectAzaleaTree = cn.nukkit.level.generator.object.tree.ObjectAzaleaTree;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class ObjectBigSpruceTree extends cn.nukkit.level.generator.object.tree.ObjectSpruceTree {
        public constructor(leafStartHeightMultiplier: float, baseLeafRadius: int): void
        public placeObject(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom): void
        placeTrunk(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom, trunkHeight: int): void
        leafStartHeightMultiplier: float
        baseLeafRadius: int

    }
}

declare module "cn.nukkit.level.generator.object.tree.ObjectBigSpruceTree" {
    declare const ObjectBigSpruceTree = cn.nukkit.level.generator.object.tree.ObjectBigSpruceTree;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class ObjectTree$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$blockproperty$value$WoodType: int[]

    }
}

declare module "cn.nukkit.level.generator.object.tree.ObjectTree$1" {
    declare const ObjectTree$1 = cn.nukkit.level.generator.object.tree.ObjectTree$1;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class ObjectSpruceTree extends cn.nukkit.level.generator.object.tree.ObjectTree {
        public constructor(): void
        public getTrunkBlock(): int
        public getLeafBlock(): int
        public getType(): int
        public getTreeHeight(): int
        public placeObject(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom): void
        public placeLeaves(level: cn.nukkit.level.ChunkManager, topSize: int, lRadius: int, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom): void
        treeHeight: int

    }
}

declare module "cn.nukkit.level.generator.object.tree.ObjectSpruceTree" {
    declare const ObjectSpruceTree = cn.nukkit.level.generator.object.tree.ObjectSpruceTree;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class ObjectJungleBigTree extends cn.nukkit.level.generator.object.tree.HugeTreesGenerator {
        public constructor(baseHeightIn: int, extraRandomHeight: int, woodMetadata: cn.nukkit.block.Block, leavesMetadata: cn.nukkit.block.Block): void
        public generate(level: cn.nukkit.level.ChunkManager, rand: cn.nukkit.math.NukkitRandom, position: cn.nukkit.math.Vector3): boolean
        placeVine(level: cn.nukkit.level.ChunkManager, random: cn.nukkit.math.NukkitRandom, pos: cn.nukkit.math.Vector3, meta: int): void
        createCrown(level: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.Vector3, i1: int): void

    }
}

declare module "cn.nukkit.level.generator.object.tree.ObjectJungleBigTree" {
    declare const ObjectJungleBigTree = cn.nukkit.level.generator.object.tree.ObjectJungleBigTree;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class ObjectDarkOakTree extends cn.nukkit.level.generator.object.tree.TreeGenerator {
        public constructor(): void
        public generate(level: cn.nukkit.level.ChunkManager, rand: cn.nukkit.math.NukkitRandom, position: cn.nukkit.math.Vector3): boolean
        placeTreeOfHeight(worldIn: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.Vector3, height: int): boolean
        placeLogAt(worldIn: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.Vector3): void
        placeLeafAt(worldIn: cn.nukkit.level.ChunkManager, x: int, y: int, z: int): void
        static DARK_OAK_LOG: cn.nukkit.block.Block
        static DARK_OAK_LEAVES: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.level.generator.object.tree.ObjectDarkOakTree" {
    declare const ObjectDarkOakTree = cn.nukkit.level.generator.object.tree.ObjectDarkOakTree;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class NewJungleTree extends cn.nukkit.level.generator.object.tree.TreeGenerator {
        public constructor(minTreeHeight: int, maxTreeHeight: int): void
        public generate(worldIn: cn.nukkit.level.ChunkManager, rand: cn.nukkit.math.NukkitRandom, vectorPosition: cn.nukkit.math.Vector3): boolean
        placeCocoa(worldIn: cn.nukkit.level.ChunkManager, age: int, pos: cn.nukkit.math.BlockVector3, side: cn.nukkit.math.BlockFace): void
        addVine(worldIn: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.BlockVector3, meta: int): void
        addHangingVine(worldIn: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.BlockVector3, meta: int): void
        isAirBlock(level: cn.nukkit.level.ChunkManager, v: cn.nukkit.math.BlockVector3): boolean
        getCocoaMeta(age: int, side: int): int
        minTreeHeight: int
        maxTreeHeight: int
        metaWood: cn.nukkit.block.Block
        metaLeaves: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.level.generator.object.tree.NewJungleTree" {
    declare const NewJungleTree = cn.nukkit.level.generator.object.tree.NewJungleTree;
}

declare namespace cn.nukkit.level.generator.object.tree {
    declare class ObjectBirchTree extends cn.nukkit.level.generator.object.tree.ObjectTree {
        public constructor(): void
        public getTrunkBlock(): int
        public getLeafBlock(): int
        public getType(): int
        public getTreeHeight(): int
        public placeObject(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom): void
        treeHeight: int

    }
}

declare module "cn.nukkit.level.generator.object.tree.ObjectBirchTree" {
    declare const ObjectBirchTree = cn.nukkit.level.generator.object.tree.ObjectBirchTree;
}

declare namespace cn.nukkit.level.generator.object {
    declare class ObjectNyliumVegetation extends java.lang.Object {
        public static growVegetation(level: cn.nukkit.level.ChunkManager, pos: cn.nukkit.math.Vector3, random: cn.nukkit.math.NukkitRandom): void
        constructor(): void

    }
}

declare module "cn.nukkit.level.generator.object.ObjectNyliumVegetation" {
    declare const ObjectNyliumVegetation = cn.nukkit.level.generator.object.ObjectNyliumVegetation;
}

declare namespace cn.nukkit.level.generator.object.mushroom {
    declare class BigMushroom extends cn.nukkit.level.generator.object.BasicGenerator {
        public constructor(mushroomType: int): void
        public constructor(): void
        public generate(level: cn.nukkit.level.ChunkManager, rand: cn.nukkit.math.NukkitRandom, position: cn.nukkit.math.Vector3): boolean
        public static NORTH_WEST: int
        public static NORTH: int
        public static NORTH_EAST: int
        public static WEST: int
        public static CENTER: int
        public static EAST: int
        public static SOUTH_WEST: int
        public static SOUTH: int
        public static SOUTH_EAST: int
        public static STEM: int
        public static ALL_INSIDE: int
        public static ALL_OUTSIDE: int
        public static ALL_STEM: int
        public static BROWN: int
        public static RED: int
        mushroomType: int

    }
}

declare module "cn.nukkit.level.generator.object.mushroom.BigMushroom" {
    declare const BigMushroom = cn.nukkit.level.generator.object.mushroom.BigMushroom;
}

declare namespace cn.nukkit.level.generator.populator.type {
    declare class Populator extends java.lang.Object implements cn.nukkit.block.BlockID {
        public constructor(): void
        public populate(var0: cn.nukkit.level.ChunkManager, var1: int, var2: int, var3: cn.nukkit.math.NukkitRandom, var4: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlock(level: cn.nukkit.level.ChunkManager, x: int, z: int, chunk: cn.nukkit.level.format.FullChunk): int

    }
}

declare module "cn.nukkit.level.generator.populator.type.Populator" {
    declare const Populator = cn.nukkit.level.generator.populator.type.Populator;
}

declare namespace cn.nukkit.level.generator.populator.type {
    declare class PopulatorSurfaceBlockPN extends cn.nukkit.level.generator.populator.type.PopulatorCount {
        public constructor(): void
        populateCount(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        canStay(var0: int, var1: int, var2: int, var3: cn.nukkit.level.format.FullChunk): boolean
        getBlockState(var0: int, var1: int, var2: cn.nukkit.math.NukkitRandom, var3: cn.nukkit.level.format.FullChunk): cn.nukkit.blockstate.BlockState
        getHighestWorkableBlock(level: cn.nukkit.level.ChunkManager, x: int, z: int, chunk: cn.nukkit.level.format.FullChunk): int
        placeBlock(x: int, y: int, z: int, blockState: cn.nukkit.blockstate.BlockState, chunk: cn.nukkit.level.format.FullChunk, random: cn.nukkit.math.NukkitRandom): void

    }
}

declare module "cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlockPN" {
    declare const PopulatorSurfaceBlockPN = cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlockPN;
}

declare namespace cn.nukkit.level.generator.populator.type {
    declare class PopulatorSurfaceBlock extends cn.nukkit.level.generator.populator.type.PopulatorCount {
        public constructor(): void
        populateCount(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        canStay(var0: int, var1: int, var2: int, var3: cn.nukkit.level.format.FullChunk): boolean
        getBlockId(var0: int, var1: int, var2: cn.nukkit.math.NukkitRandom, var3: cn.nukkit.level.format.FullChunk): int
        getHighestWorkableBlock(level: cn.nukkit.level.ChunkManager, x: int, z: int, chunk: cn.nukkit.level.format.FullChunk): int
        placeBlock(x: int, y: int, z: int, id: int, chunk: cn.nukkit.level.format.FullChunk, random: cn.nukkit.math.NukkitRandom): void

    }
}

declare module "cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock" {
    declare const PopulatorSurfaceBlock = cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock;
}

declare namespace cn.nukkit.level.generator.populator.type {
    declare class PopulatorOceanFloorSurfaceBlock extends cn.nukkit.level.generator.populator.type.PopulatorCount {
        public constructor(): void
        populateCount(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        canStay(var0: int, var1: int, var2: int, var3: cn.nukkit.level.format.FullChunk): boolean
        getBlockState(var0: int, var1: int, var2: cn.nukkit.math.NukkitRandom, var3: cn.nukkit.level.format.FullChunk): cn.nukkit.blockstate.BlockState
        getHighestWorkableBlock(level: cn.nukkit.level.ChunkManager, x: int, z: int, chunk: cn.nukkit.level.format.FullChunk): int
        placeBlock(x: int, y: int, z: int, blockState: cn.nukkit.blockstate.BlockState, chunk: cn.nukkit.level.format.FullChunk, random: cn.nukkit.math.NukkitRandom): void

    }
}

declare module "cn.nukkit.level.generator.populator.type.PopulatorOceanFloorSurfaceBlock" {
    declare const PopulatorOceanFloorSurfaceBlock = cn.nukkit.level.generator.populator.type.PopulatorOceanFloorSurfaceBlock;
}

declare namespace cn.nukkit.level.generator.populator.type {
    declare class PopulatorCount extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public setRandomAmount(randomAmount: int): void
        public setBaseAmount(baseAmount: int): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        populateCount(var0: cn.nukkit.level.ChunkManager, var1: int, var2: int, var3: cn.nukkit.math.NukkitRandom, var4: cn.nukkit.level.format.FullChunk): void
        randomAmount: int
        baseAmount: int

    }
}

declare module "cn.nukkit.level.generator.populator.type.PopulatorCount" {
    declare const PopulatorCount = cn.nukkit.level.generator.populator.type.PopulatorCount;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorMineshaft extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorMineshaft" {
    declare const PopulatorMineshaft = cn.nukkit.level.generator.populator.impl.PopulatorMineshaft;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class MushroomPopulator extends cn.nukkit.level.generator.populator.type.PopulatorCount {
        public constructor(): void
        public constructor(type: int): void
        public populateCount(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlock(level: cn.nukkit.level.ChunkManager, x: int, z: int, chunk: cn.nukkit.level.format.FullChunk): int
        type: int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.MushroomPopulator" {
    declare const MushroomPopulator = cn.nukkit.level.generator.populator.impl.MushroomPopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorSpring extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(state: cn.nukkit.blockstate.BlockState, surroundState: java.util.List<cn.nukkit.blockstate.BlockState>, tries: int, minHeight: int, maxHeight: int): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        state: cn.nukkit.blockstate.BlockState
        surroundState: java.util.List<cn.nukkit.blockstate.BlockState>
        tries: int
        minHeight: int
        maxHeight: int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorSpring" {
    declare const PopulatorSpring = cn.nukkit.level.generator.populator.impl.PopulatorSpring;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorFlower extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock {
        public constructor(): void
        public addType(a: int, b: int): void
        public getTypes(): int[]
        placeBlock(x: int, y: int, z: int, id: int, chunk: cn.nukkit.level.format.FullChunk, random: cn.nukkit.math.NukkitRandom): void
        canStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean
        getBlockId(x: int, z: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): int
        flowerTypes: int[]

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorFlower" {
    declare const PopulatorFlower = cn.nukkit.level.generator.populator.impl.PopulatorFlower;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorPumpkin extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock {
        public constructor(): void
        canStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean
        getBlockId(x: int, z: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorPumpkin" {
    declare const PopulatorPumpkin = cn.nukkit.level.generator.populator.impl.PopulatorPumpkin;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorGrass extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock {
        public constructor(): void
        canStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean
        getBlockId(x: int, z: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorGrass" {
    declare const PopulatorGrass = cn.nukkit.level.generator.populator.impl.PopulatorGrass;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorDisk extends cn.nukkit.level.generator.populator.type.PopulatorCount {
        public constructor(): void
        public constructor(probability: double, var1: cn.nukkit.blockstate.BlockState, sourceBlock: int, radiusMin: int, radiusMax: int, radiusY: java.util.List<cn.nukkit.blockstate.BlockState>): void
        public populateCount(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlock(level: cn.nukkit.level.ChunkManager, x: int, z: int, chunk: cn.nukkit.level.format.FullChunk): int
        static STATE_STILL_WATER: cn.nukkit.blockstate.BlockState
        probability: double
        sourceBlock: cn.nukkit.blockstate.BlockState
        radiusMin: int
        radiusMax: int
        radiusY: int
        replaceBlocks: java.util.List<cn.nukkit.blockstate.BlockState>

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorDisk" {
    declare const PopulatorDisk = cn.nukkit.level.generator.populator.impl.PopulatorDisk;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorKelp extends cn.nukkit.level.generator.populator.type.PopulatorOceanFloorSurfaceBlock {
        public constructor(): void
        public populateCount(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        canStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean
        getBlockState(x: int, z: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): cn.nukkit.blockstate.BlockState
        static STATE_STILL_WATER: cn.nukkit.blockstate.BlockState
        static STATE_KELP: cn.nukkit.blockstate.BlockState
        static STATE_KELP_AGE_MAX: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorKelp" {
    declare const PopulatorKelp = cn.nukkit.level.generator.populator.impl.PopulatorKelp;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorTree extends cn.nukkit.level.generator.populator.type.PopulatorCount {
        public constructor(): void
        public constructor(type: int): void
        public populateCount(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlock(x: int, z: int): int
        type: int
        level: cn.nukkit.level.ChunkManager

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorTree" {
    declare const PopulatorTree = cn.nukkit.level.generator.populator.impl.PopulatorTree;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorDeadBush extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock {
        public constructor(): void
        canStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean
        getBlockId(x: int, z: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorDeadBush" {
    declare const PopulatorDeadBush = cn.nukkit.level.generator.populator.impl.PopulatorDeadBush;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorBedrock extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorBedrock" {
    declare const PopulatorBedrock = cn.nukkit.level.generator.populator.impl.PopulatorBedrock;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorBamboo extends cn.nukkit.level.generator.populator.type.PopulatorCount {
        public constructor(): void
        canStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean
        generateBamboo(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom): void
        generatePodzol(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, random: cn.nukkit.math.NukkitRandom): void
        getMaxHeight(level: cn.nukkit.level.ChunkManager, x: int, y: int, z: int, height: int): int
        getHighestWorkableBlock(level: cn.nukkit.level.ChunkManager, x: int, z: int, chunk: cn.nukkit.level.format.FullChunk): int
        populateCount(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        public setPodzolProbability(podzolProbability: double): void
        static STATE_PODZOL: cn.nukkit.blockstate.BlockState
        static BLOCK_BAMBOO: cn.nukkit.block.BlockBamboo
        static BLOCK_BAMBOO_DEFAULT: cn.nukkit.block.Block
        static BLOCK_BAMBOO_LEAF_SMALL: cn.nukkit.block.Block
        static BLOCK_BAMBOO_LEAF_LARGE: cn.nukkit.block.Block
        static BLOCK_BAMBOO_LEAF_LARGE_AGED: cn.nukkit.block.Block
        podzolProbability: double

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorBamboo" {
    declare const PopulatorBamboo = cn.nukkit.level.generator.populator.impl.PopulatorBamboo;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorChorusTree extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(theEnd: cn.nukkit.level.generator.TheEnd): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        theEnd: cn.nukkit.level.generator.TheEnd
        objectChorusTree: cn.nukkit.level.generator.object.end.ObjectChorusTree
        static STATE_END_STONE: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorChorusTree" {
    declare const PopulatorChorusTree = cn.nukkit.level.generator.populator.impl.PopulatorChorusTree;
}

declare namespace cn.nukkit.level.generator.populator.impl.nether {
    declare class WarpedFungiTreePopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlocks(x: int, z: int): java.util.ArrayList<int>
        level: cn.nukkit.level.ChunkManager

    }
}

declare module "cn.nukkit.level.generator.populator.impl.nether.WarpedFungiTreePopulator" {
    declare const WarpedFungiTreePopulator = cn.nukkit.level.generator.populator.impl.nether.WarpedFungiTreePopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl.nether {
    declare class BasaltDeltaLavaPopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlocks(x: int, z: int): java.util.ArrayList<int>
        level: cn.nukkit.level.ChunkManager

    }
}

declare module "cn.nukkit.level.generator.populator.impl.nether.BasaltDeltaLavaPopulator" {
    declare const BasaltDeltaLavaPopulator = cn.nukkit.level.generator.populator.impl.nether.BasaltDeltaLavaPopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl.nether {
    declare class PopulatorGroundSoulFire extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlockPN {
        public constructor(): void
        canStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean
        getBlockState(x: int, z: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): cn.nukkit.blockstate.BlockState
        placeBlock(x: int, y: int, z: int, blockState: cn.nukkit.blockstate.BlockState, chunk: cn.nukkit.level.format.FullChunk, random: cn.nukkit.math.NukkitRandom): void
        getHighestWorkableBlock(level: cn.nukkit.level.ChunkManager, x: int, z: int, chunk: cn.nukkit.level.format.FullChunk): int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.nether.PopulatorGroundSoulFire" {
    declare const PopulatorGroundSoulFire = cn.nukkit.level.generator.populator.impl.nether.PopulatorGroundSoulFire;
}

declare namespace cn.nukkit.level.generator.populator.impl.nether {
    declare class PopulatorGlowStone extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlock(chunk: cn.nukkit.level.format.FullChunk, x: int, z: int): int
        checkAroundBlock(x: int, y: int, z: int, level: cn.nukkit.level.ChunkManager): boolean

    }
}

declare module "cn.nukkit.level.generator.populator.impl.nether.PopulatorGlowStone" {
    declare const PopulatorGlowStone = cn.nukkit.level.generator.populator.impl.nether.PopulatorGlowStone;
}

declare namespace cn.nukkit.level.generator.populator.impl.nether {
    declare class CrimsonGrassesPopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlocks(x: int, z: int): java.util.ArrayList<int>
        level: cn.nukkit.level.ChunkManager

    }
}

declare module "cn.nukkit.level.generator.populator.impl.nether.CrimsonGrassesPopulator" {
    declare const CrimsonGrassesPopulator = cn.nukkit.level.generator.populator.impl.nether.CrimsonGrassesPopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl.nether {
    declare class BasaltDeltaMagmaPopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlocks(x: int, z: int): java.util.ArrayList<int>
        level: cn.nukkit.level.ChunkManager

    }
}

declare module "cn.nukkit.level.generator.populator.impl.nether.BasaltDeltaMagmaPopulator" {
    declare const BasaltDeltaMagmaPopulator = cn.nukkit.level.generator.populator.impl.nether.BasaltDeltaMagmaPopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl.nether {
    declare class CrimsonWeepingVinesPopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestEndingBlock(x: int, y: int, z: int): int
        getHighestWorkableBlocks(x: int, z: int): java.util.ArrayList<int>
        level: cn.nukkit.level.ChunkManager

    }
}

declare module "cn.nukkit.level.generator.populator.impl.nether.CrimsonWeepingVinesPopulator" {
    declare const CrimsonWeepingVinesPopulator = cn.nukkit.level.generator.populator.impl.nether.CrimsonWeepingVinesPopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl.nether {
    declare class BasaltDeltaPillarPopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlocks(x: int, z: int): java.util.ArrayList<int>
        level: cn.nukkit.level.ChunkManager

    }
}

declare module "cn.nukkit.level.generator.populator.impl.nether.BasaltDeltaPillarPopulator" {
    declare const BasaltDeltaPillarPopulator = cn.nukkit.level.generator.populator.impl.nether.BasaltDeltaPillarPopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl.nether {
    declare class CrimsonFungiTreePopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlocks(x: int, z: int): java.util.ArrayList<int>
        level: cn.nukkit.level.ChunkManager

    }
}

declare module "cn.nukkit.level.generator.populator.impl.nether.CrimsonFungiTreePopulator" {
    declare const CrimsonFungiTreePopulator = cn.nukkit.level.generator.populator.impl.nether.CrimsonFungiTreePopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl.nether {
    declare class PopulatorSoulsandFossils extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlock(chunk: cn.nukkit.level.format.FullChunk, x: int, z: int): int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.nether.PopulatorSoulsandFossils" {
    declare const PopulatorSoulsandFossils = cn.nukkit.level.generator.populator.impl.nether.PopulatorSoulsandFossils;
}

declare namespace cn.nukkit.level.generator.populator.impl.nether {
    declare class WarpedGrassesPopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlocks(x: int, z: int): java.util.ArrayList<int>
        level: cn.nukkit.level.ChunkManager

    }
}

declare module "cn.nukkit.level.generator.populator.impl.nether.WarpedGrassesPopulator" {
    declare const WarpedGrassesPopulator = cn.nukkit.level.generator.populator.impl.nether.WarpedGrassesPopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl.nether {
    declare class WarpedTwistingVinesPopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestEndingBlock(x: int, y: int, z: int): int
        getHighestWorkableBlocks(x: int, z: int): java.util.ArrayList<int>
        level: cn.nukkit.level.ChunkManager

    }
}

declare module "cn.nukkit.level.generator.populator.impl.nether.WarpedTwistingVinesPopulator" {
    declare const WarpedTwistingVinesPopulator = cn.nukkit.level.generator.populator.impl.nether.WarpedTwistingVinesPopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorMelon extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock {
        public constructor(): void
        canStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean
        getBlockId(x: int, z: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorMelon" {
    declare const PopulatorMelon = cn.nukkit.level.generator.populator.impl.PopulatorMelon;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorLava extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public setRandomAmount(amount: int): void
        public setBaseAmount(amount: int): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getFlowDecay(x1: int, y1: int, z1: int, x2: int, y2: int, z2: int): int
        lavaSpread(x: int, y: int, z: int): void
        flowIntoBlock(x: int, y: int, z: int, newFlowDecay: int): void
        canFlowInto(x: int, y: int, z: int): boolean
        calculateFlowCost(xx: int, yy: int, zz: int, accumulatedCost: int, previousDirection: int): int
        getOptimalFlowDirections(xx: int, yy: int, zz: int): boolean[]
        getSmallestFlowDecay(x1: int, y1: int, z1: int, x2: int, y2: int, z2: int, decay: int): int
        getHighestWorkableBlock(chunk: cn.nukkit.level.format.FullChunk, x: int, z: int): int
        level: cn.nukkit.level.ChunkManager
        randomAmount: int
        baseAmount: int
        random: cn.nukkit.math.NukkitRandom

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorLava" {
    declare const PopulatorLava = cn.nukkit.level.generator.populator.impl.PopulatorLava;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorGroundFire extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock {
        public constructor(): void
        canStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean
        getBlockId(x: int, z: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): int
        placeBlock(x: int, y: int, z: int, id: int, chunk: cn.nukkit.level.format.FullChunk, random: cn.nukkit.math.NukkitRandom): void
        getHighestWorkableBlock(level: cn.nukkit.level.ChunkManager, x: int, z: int, chunk: cn.nukkit.level.format.FullChunk): int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorGroundFire" {
    declare const PopulatorGroundFire = cn.nukkit.level.generator.populator.impl.PopulatorGroundFire;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorOre extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public constructor(id: int): void
        public constructor(replaceId: int, oreTypes: cn.nukkit.level.generator.object.ore.OreType[]): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        public setOreTypes(oreTypes: cn.nukkit.level.generator.object.ore.OreType[]): void
        replaceId: int
        oreTypes: cn.nukkit.level.generator.object.ore.OreType[]

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorOre" {
    declare const PopulatorOre = cn.nukkit.level.generator.populator.impl.PopulatorOre;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorSeagrass extends cn.nukkit.level.generator.populator.type.PopulatorOceanFloorSurfaceBlock {
        public constructor(): void
        public constructor(tallSeagrassProbability: double): void
        public populateCount(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        canStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk): boolean
        canStay(x: int, y: int, z: int, chunk: cn.nukkit.level.format.FullChunk, tallSeagrass: boolean): boolean
        getBlockState(x: int, z: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): cn.nukkit.blockstate.BlockState
        static STATE_STILL_WATER: cn.nukkit.blockstate.BlockState
        static STATE_SEAGRASS: cn.nukkit.blockstate.BlockState
        static STATE_TALL_SEAGRASS_TOP: cn.nukkit.blockstate.BlockState
        static STATE_TALL_SEAGRASS_BOT: cn.nukkit.blockstate.BlockState
        tallSeagrassProbability: double

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorSeagrass" {
    declare const PopulatorSeagrass = cn.nukkit.level.generator.populator.impl.PopulatorSeagrass;
}

declare namespace cn.nukkit.level.generator.populator.impl {
    declare class PopulatorCaves extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        generateLargeCaveNode(seed: long, var1: cn.nukkit.level.format.FullChunk, chunk: double, x: double, var4: double): void
        generateCaveNode(seed: long, var1: cn.nukkit.level.format.FullChunk, chunk: double, x: double, var4: double, y: float, var6: float, z: float, var8: int, radius: int, angelOffset: double): void
        generateChunk(chunkX: int, chunkZ: int, generatingChunkBuffer: cn.nukkit.level.format.FullChunk): void
        public static numberInRange(random: java.util.Random, min: int, max: int): int
        checkAreaSize: int
        random: java.util.Random
        public static caveRarity: int
        public static caveFrequency: int
        public static caveMinAltitude: int
        public static caveMaxAltitude: int
        public static individualCaveRarity: int
        public static caveSystemFrequency: int
        public static caveSystemPocketChance: int
        public static caveSystemPocketMinSize: int
        public static caveSystemPocketMaxSize: int
        public static evenCaveDistribution: boolean
        public worldHeightCap: int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.PopulatorCaves" {
    declare const PopulatorCaves = cn.nukkit.level.generator.populator.impl.PopulatorCaves;
}

declare namespace cn.nukkit.level.generator.populator.impl.tree {
    declare class SpruceMegaTreePopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        constructor(type: int): void
        public setRandomAmount(randomAmount: int): void
        public setBaseAmount(baseAmount: int): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlock(x: int, z: int): int
        level: cn.nukkit.level.ChunkManager
        randomAmount: int
        baseAmount: int
        type: int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.tree.SpruceMegaTreePopulator" {
    declare const SpruceMegaTreePopulator = cn.nukkit.level.generator.populator.impl.tree.SpruceMegaTreePopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl.tree {
    declare class SpruceBigTreePopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        constructor(type: int): void
        public setRandomAmount(randomAmount: int): void
        public setBaseAmount(baseAmount: int): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlock(x: int, z: int): int
        level: cn.nukkit.level.ChunkManager
        randomAmount: int
        baseAmount: int
        type: int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.tree.SpruceBigTreePopulator" {
    declare const SpruceBigTreePopulator = cn.nukkit.level.generator.populator.impl.tree.SpruceBigTreePopulator;
}

declare namespace cn.nukkit.level.generator.populator.impl.tree {
    declare class JungleBigTreePopulator extends cn.nukkit.level.generator.populator.type.Populator {
        public constructor(): void
        public constructor(type: int): void
        public setRandomAmount(randomAmount: int): void
        public setBaseAmount(baseAmount: int): void
        public populate(level: cn.nukkit.level.ChunkManager, chunkX: int, chunkZ: int, random: cn.nukkit.math.NukkitRandom, chunk: cn.nukkit.level.format.FullChunk): void
        getHighestWorkableBlock(x: int, z: int): int
        level: cn.nukkit.level.ChunkManager
        randomAmount: int
        baseAmount: int
        type: int

    }
}

declare module "cn.nukkit.level.generator.populator.impl.tree.JungleBigTreePopulator" {
    declare const JungleBigTreePopulator = cn.nukkit.level.generator.populator.impl.tree.JungleBigTreePopulator;
}

declare namespace cn.nukkit.level {
    declare class MovingObjectPosition$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$math$BlockFace: int[]

    }
}

declare module "cn.nukkit.level.MovingObjectPosition$1" {
    declare const MovingObjectPosition$1 = cn.nukkit.level.MovingObjectPosition$1;
}

declare namespace cn.nukkit.level {
    declare class MovingObjectPosition extends java.lang.Object {
        public constructor(): void
        public getFaceHit(): cn.nukkit.math.BlockFace
        public setFaceHit(face: cn.nukkit.math.BlockFace): void
        public static fromBlock(x: int, y: int, z: int, face: cn.nukkit.math.BlockFace, hitVector: cn.nukkit.math.Vector3): cn.nukkit.level.MovingObjectPosition
        public static fromBlock(x: int, y: int, z: int, side: int, hitVector: cn.nukkit.math.Vector3): cn.nukkit.level.MovingObjectPosition
        public static fromEntity(entity: cn.nukkit.entity.Entity): cn.nukkit.level.MovingObjectPosition
        public toString(): string
        public typeOfHit: int
        public blockX: int
        public blockY: int
        public blockZ: int
        public sideHit: int
        public hitVector: cn.nukkit.math.Vector3
        public entityHit: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.level.MovingObjectPosition" {
    declare const MovingObjectPosition = cn.nukkit.level.MovingObjectPosition;
}

declare namespace cn.nukkit.level.format {
    declare class Chunk$Entry extends java.lang.Object {
        public constructor(chunkX: int, chunkZ: int): void
        public chunkX: int
        public chunkZ: int

    }
}

declare module "cn.nukkit.level.format.Chunk$Entry" {
    declare const Chunk$Entry = cn.nukkit.level.format.Chunk$Entry;
}

declare namespace cn.nukkit.level.format {
    declare interface ChunkSection {
        public getY(): int
        public getBlockId(var0: int, var1: int, var2: int): int
        public getBlockId(var0: int, var1: int, var2: int, var3: int): int
        public setBlockId(var0: int, var1: int, var2: int, var3: int): void
        public getBlockData(var0: int, var1: int, var2: int): int
        public getBlockData(var0: int, var1: int, var2: int, var3: int): int
        public setBlockData(var0: int, var1: int, var2: int, var3: int): void
        public setBlockData(var0: int, var1: int, var2: int, var3: int, var4: int): void
        public getFullBlock(var0: int, var1: int, var2: int): int
        public getFullBlock(var0: int, var1: int, var2: int, var3: int): int
        public getBlockState(x: int, y: int, z: int): cn.nukkit.blockstate.BlockState
        public getBlockState(x: int, y: int, z: int, layer: int): cn.nukkit.blockstate.BlockState
        public getAndSetBlock(var0: int, var1: int, var2: int, var3: int, var4: cn.nukkit.block.Block): cn.nukkit.block.Block
        public getAndSetBlock(var0: int, var1: int, var2: int, var3: cn.nukkit.block.Block): cn.nukkit.block.Block
        public getAndSetBlockState(var0: int, var1: int, var2: int, var3: int, var4: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState
        public getAndSetBlockState(x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState
        public setBlockId(var0: int, var1: int, var2: int, var3: int, var4: int): void
        public setFullBlockId(var0: int, var1: int, var2: int, var3: int): boolean
        public setFullBlockId(var0: int, var1: int, var2: int, var3: int, var4: int): boolean
        public setBlockAtLayer(var0: int, var1: int, var2: int, var3: int, var4: int): boolean
        public setBlock(var0: int, var1: int, var2: int, var3: int): boolean
        public setBlock(var0: int, var1: int, var2: int, var3: int, var4: int): boolean
        public setBlockAtLayer(var0: int, var1: int, var2: int, var3: int, var4: int, var5: int): boolean
        public getBlockSkyLight(var0: int, var1: int, var2: int): int
        public setBlockSkyLight(var0: int, var1: int, var2: int, var3: int): void
        public getBlockLight(var0: int, var1: int, var2: int): int
        public setBlockLight(var0: int, var1: int, var2: int, var3: int): void
        public getSkyLightArray(): byte[]
        public getLightArray(): byte[]
        public isEmpty(): boolean
        public writeTo(var0: cn.nukkit.utils.BinaryStream): void
        public getMaximumLayer(): int
        public toNBT(): cn.nukkit.nbt.tag.CompoundTag
        public copy(): cn.nukkit.level.format.ChunkSection
        public getContentVersion(): int
        public setContentVersion(contentVersion: int): void
        public hasBlocks(): boolean
        public setBlockStateAtLayer(var0: int, var1: int, var2: int, var3: int, var4: cn.nukkit.blockstate.BlockState): boolean
        public setBlockState(x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): boolean
        public getBlockChangeStateAbove(var0: int, var1: int, var2: int): int
        public delayPaletteUpdates(): void
        public scanBlocks(provider: cn.nukkit.level.format.LevelProvider, offsetX: int, offsetZ: int, min: cn.nukkit.math.BlockVector3, max: cn.nukkit.math.BlockVector3, condition: java.util.function.BiPredicate<cn.nukkit.math.BlockVector3, cn.nukkit.blockstate.BlockState>): java.util.List<cn.nukkit.block.Block>
        public compressStorageLayers(): void

    }
}

declare module "cn.nukkit.level.format.ChunkSection" {
    declare type ChunkSection = cn.nukkit.level.format.ChunkSection;
}

declare namespace cn.nukkit.level.format.updater {
    declare class ChunkUpdater extends java.lang.Object {
        public static getCurrentContentVersion(): int
        public static backwardCompatibilityUpdate(level: cn.nukkit.level.Level, chunk: cn.nukkit.level.format.generic.BaseChunk): void
        static upgradeFrameFromV11toV12(chunk: cn.nukkit.level.format.generic.BaseChunk, section: cn.nukkit.level.format.ChunkSection, updated: boolean): boolean
        static upgradeStrippedStemsFromV10toV11(chunk: cn.nukkit.level.format.generic.BaseChunk, updated: boolean, section: cn.nukkit.level.format.ChunkSection): boolean
        static upgradeWallsFromV8toV9(level: cn.nukkit.level.Level, chunk: cn.nukkit.level.format.generic.BaseChunk, updated: boolean, section: cn.nukkit.level.format.ChunkSection): boolean
        static upgradeSnowLayersFromV9toV10(level: cn.nukkit.level.Level, chunk: cn.nukkit.level.format.generic.BaseChunk, updated: boolean, section: cn.nukkit.level.format.ChunkSection): boolean
        static updateBeehiveFromV5or6or7toV8(chunk: cn.nukkit.level.format.generic.BaseChunk, updated: boolean, section: cn.nukkit.level.format.ChunkSection, updateDirection: boolean): boolean
        static updateToV8FromV0toV5(level: cn.nukkit.level.Level, chunk: cn.nukkit.level.format.generic.BaseChunk, updated: boolean, section: cn.nukkit.level.format.ChunkSection, contentVersion: int): boolean
        static walk(chunk: cn.nukkit.level.format.generic.BaseChunk, section: cn.nukkit.level.format.ChunkSection, updater: cn.nukkit.level.format.updater.Updater): boolean
        constructor(): void
        static log: org.apache.logging.log4j.Logger

    }
}

declare module "cn.nukkit.level.format.updater.ChunkUpdater" {
    declare const ChunkUpdater = cn.nukkit.level.format.updater.ChunkUpdater;
}

declare namespace cn.nukkit.level.format.updater {
    declare class BeehiveUpdater extends java.lang.Object implements cn.nukkit.level.format.updater.Updater {
        public constructor(section: cn.nukkit.level.format.ChunkSection, updateDirection: boolean): void
        public update(offsetX: int, offsetY: int, offsetZ: int, x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): boolean
        section: cn.nukkit.level.format.ChunkSection
        updateDirection: boolean

    }
}

declare module "cn.nukkit.level.format.updater.BeehiveUpdater" {
    declare const BeehiveUpdater = cn.nukkit.level.format.updater.BeehiveUpdater;
}

declare namespace cn.nukkit.level.format.updater {
    declare class SnowLayerUpdater extends java.lang.Object implements cn.nukkit.level.format.updater.Updater {
        public constructor(level: cn.nukkit.level.Level, section: cn.nukkit.level.format.ChunkSection): void
        public update(offsetX: int, offsetY: int, offsetZ: int, x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): boolean
        level: cn.nukkit.level.Level
        section: cn.nukkit.level.format.ChunkSection

    }
}

declare module "cn.nukkit.level.format.updater.SnowLayerUpdater" {
    declare const SnowLayerUpdater = cn.nukkit.level.format.updater.SnowLayerUpdater;
}

declare namespace cn.nukkit.level.format.updater {
    declare class FrameUpdater extends java.lang.Object implements cn.nukkit.level.format.updater.Updater {
        public constructor(section: cn.nukkit.level.format.ChunkSection): void
        public update(offsetX: int, offsetY: int, offsetZ: int, x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): boolean
        getNewData(fromData: int): int
        section: cn.nukkit.level.format.ChunkSection

    }
}

declare module "cn.nukkit.level.format.updater.FrameUpdater" {
    declare const FrameUpdater = cn.nukkit.level.format.updater.FrameUpdater;
}

declare namespace cn.nukkit.level.format.updater {
    declare interface Updater {
        public update(var0: int, var1: int, var2: int, var3: int, var4: int, var5: int, var6: cn.nukkit.blockstate.BlockState): boolean

    }
}

declare module "cn.nukkit.level.format.updater.Updater" {
    declare type Updater = cn.nukkit.level.format.updater.Updater;
}

declare namespace cn.nukkit.level.format.updater {
    declare class OldWoodBarkUpdater extends java.lang.Object implements cn.nukkit.level.format.updater.Updater {
        public constructor(section: cn.nukkit.level.format.ChunkSection, fromLog: int, increment: int): void
        public update(offsetX: int, offsetY: int, offsetZ: int, x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): boolean
        section: cn.nukkit.level.format.ChunkSection
        fromLog: int
        increment: int

    }
}

declare module "cn.nukkit.level.format.updater.OldWoodBarkUpdater" {
    declare const OldWoodBarkUpdater = cn.nukkit.level.format.updater.OldWoodBarkUpdater;
}

declare namespace cn.nukkit.level.format.updater {
    declare class NewLeafUpdater extends java.lang.Object implements cn.nukkit.level.format.updater.Updater {
        public constructor(section: cn.nukkit.level.format.ChunkSection): void
        public update(offsetX: int, offsetY: int, offsetZ: int, x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): boolean
        public isForceOldSystem(): boolean
        public setForceOldSystem(forceOldSystem: boolean): void
        section: cn.nukkit.level.format.ChunkSection
        forceOldSystem: boolean

    }
}

declare module "cn.nukkit.level.format.updater.NewLeafUpdater" {
    declare const NewLeafUpdater = cn.nukkit.level.format.updater.NewLeafUpdater;
}

declare namespace cn.nukkit.level.format.updater {
    declare class WallUpdater extends java.lang.Object implements cn.nukkit.level.format.updater.Updater {
        public constructor(level: cn.nukkit.level.Level, section: cn.nukkit.level.format.ChunkSection): void
        public update(offsetX: int, offsetY: int, offsetZ: int, x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): boolean
        static log: org.apache.logging.log4j.Logger
        level: cn.nukkit.level.Level
        section: cn.nukkit.level.format.ChunkSection

    }
}

declare module "cn.nukkit.level.format.updater.WallUpdater" {
    declare const WallUpdater = cn.nukkit.level.format.updater.WallUpdater;
}

declare namespace cn.nukkit.level.format.updater {
    declare class MesaBiomeUpdater extends java.lang.Object implements cn.nukkit.level.format.updater.Updater {
        public constructor(section: cn.nukkit.level.format.ChunkSection): void
        public update(offsetX: int, offsetY: int, offsetZ: int, x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): boolean
        section: cn.nukkit.level.format.ChunkSection

    }
}

declare module "cn.nukkit.level.format.updater.MesaBiomeUpdater" {
    declare const MesaBiomeUpdater = cn.nukkit.level.format.updater.MesaBiomeUpdater;
}

declare namespace cn.nukkit.level.format.updater {
    declare class DoorUpdater extends java.lang.Object implements cn.nukkit.level.format.updater.Updater {
        public constructor(chunk: cn.nukkit.level.format.Chunk, section: cn.nukkit.level.format.ChunkSection): void
        public update(offsetX: int, offsetY: int, offsetZ: int, x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): boolean
        static DOOR_OPEN_BIT: int
        static DOOR_TOP_BIT: int
        static DOOR_HINGE_BIT: int
        chunk: cn.nukkit.level.format.Chunk
        section: cn.nukkit.level.format.ChunkSection

    }
}

declare module "cn.nukkit.level.format.updater.DoorUpdater" {
    declare const DoorUpdater = cn.nukkit.level.format.updater.DoorUpdater;
}

declare namespace cn.nukkit.level.format.updater {
    declare class StemUpdater extends java.lang.Object implements cn.nukkit.level.format.updater.Updater {
        public constructor(level: cn.nukkit.level.Level, section: cn.nukkit.level.format.ChunkSection, stemId: int, productId: int): void
        public update(offsetX: int, offsetY: int, offsetZ: int, x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): boolean
        level: cn.nukkit.level.Level
        section: cn.nukkit.level.format.ChunkSection
        stemId: int
        productId: int

    }
}

declare module "cn.nukkit.level.format.updater.StemUpdater" {
    declare const StemUpdater = cn.nukkit.level.format.updater.StemUpdater;
}

declare namespace cn.nukkit.level.format.updater {
    declare class GroupedUpdaters extends java.lang.Object implements cn.nukkit.level.format.updater.Updater {
        public constructor(updaters: cn.nukkit.level.format.updater.Updater[]): void
        public update(offsetX: int, offsetY: int, offsetZ: int, x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): boolean
        updaters: cn.nukkit.level.format.updater.Updater[]

    }
}

declare module "cn.nukkit.level.format.updater.GroupedUpdaters" {
    declare const GroupedUpdaters = cn.nukkit.level.format.updater.GroupedUpdaters;
}

declare namespace cn.nukkit.level.format.updater {
    declare class StemStrippedUpdater extends java.lang.Object implements cn.nukkit.level.format.updater.Updater {
        public constructor(section: cn.nukkit.level.format.ChunkSection): void
        public update(offsetX: int, offsetY: int, offsetZ: int, x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): boolean
        section: cn.nukkit.level.format.ChunkSection
        oldProperties: cn.nukkit.blockproperty.BlockProperties

    }
}

declare module "cn.nukkit.level.format.updater.StemStrippedUpdater" {
    declare const StemStrippedUpdater = cn.nukkit.level.format.updater.StemStrippedUpdater;
}

declare namespace cn.nukkit.level.format {
    declare class LevelProviderManager extends java.lang.Object {
        public constructor(): void
        public static addProvider(server: cn.nukkit.Server, clazz: java.lang.Class<cn.nukkit.level.format.LevelProvider>): void
        public static getProvider(path: string): java.lang.Class<cn.nukkit.level.format.LevelProvider>
        public static getProviderByName(name: string): java.lang.Class<cn.nukkit.level.format.LevelProvider>
        static log: org.apache.logging.log4j.Logger
        static providers: java.util.Map<string, java.lang.Class<cn.nukkit.level.format.LevelProvider>>

    }
}

declare module "cn.nukkit.level.format.LevelProviderManager" {
    declare const LevelProviderManager = cn.nukkit.level.format.LevelProviderManager;
}

declare namespace cn.nukkit.level.format {
    declare interface Chunk extends cn.nukkit.level.format.FullChunk {
        public isSectionEmpty(var0: float): boolean
        public getSection(var0: float): cn.nukkit.level.format.ChunkSection
        public setSection(var0: float, var1: cn.nukkit.level.format.ChunkSection): boolean
        public getSections(): cn.nukkit.level.format.ChunkSection[]

    }
}

declare module "cn.nukkit.level.format.Chunk" {
    declare type Chunk = cn.nukkit.level.format.Chunk;
}

declare namespace cn.nukkit.level.format {
    declare interface LevelProvider {
        public requestChunkTask(var0: int, var1: int): cn.nukkit.scheduler.AsyncTask
        public getPath(): string
        public getGenerator(): string
        public getGeneratorOptions(): java.util.Map<string, java.lang.Object>
        public getLoadedChunk(var0: int, var1: int): cn.nukkit.level.format.generic.BaseFullChunk
        public getLoadedChunk(var0: long): cn.nukkit.level.format.generic.BaseFullChunk
        public getChunk(var0: int, var1: int): cn.nukkit.level.format.generic.BaseFullChunk
        public getChunk(var0: int, var1: int, var2: boolean): cn.nukkit.level.format.generic.BaseFullChunk
        public getEmptyChunk(var0: int, var1: int): cn.nukkit.level.format.generic.BaseFullChunk
        public saveChunks(): void
        public saveChunk(var0: int, var1: int): void
        public saveChunk(var0: int, var1: int, var2: cn.nukkit.level.format.FullChunk): void
        public unloadChunks(): void
        public loadChunk(var0: int, var1: int): boolean
        public loadChunk(var0: int, var1: int, var2: boolean): boolean
        public unloadChunk(var0: int, var1: int): boolean
        public unloadChunk(var0: int, var1: int, var2: boolean): boolean
        public isChunkGenerated(var0: int, var1: int): boolean
        public isChunkPopulated(var0: int, var1: int): boolean
        public isChunkLoaded(var0: int, var1: int): boolean
        public isChunkLoaded(var0: long): boolean
        public setChunk(var0: int, var1: int, var2: cn.nukkit.level.format.FullChunk): void
        public getName(): string
        public isRaining(): boolean
        public setRaining(var0: boolean): void
        public getRainTime(): int
        public setRainTime(var0: int): void
        public isThundering(): boolean
        public setThundering(var0: boolean): void
        public getThunderTime(): int
        public setThunderTime(var0: int): void
        public getCurrentTick(): long
        public setCurrentTick(var0: long): void
        public getTime(): long
        public setTime(var0: long): void
        public getSeed(): long
        public setSeed(var0: long): void
        public getSpawn(): cn.nukkit.math.Vector3
        public setSpawn(var0: cn.nukkit.math.Vector3): void
        public getLoadedChunks(): java.util.Map<long, cn.nukkit.level.format.FullChunk>
        public doGarbageCollection(): void
        public doGarbageCollection(time: long): void
        public getLevel(): cn.nukkit.level.Level
        public close(): void
        public saveLevelData(): void
        public updateLevelName(var0: string): void
        public getGamerules(): cn.nukkit.level.GameRules
        public setGameRules(var0: cn.nukkit.level.GameRules): void
        public getMaximumLayer(): int
        public getDimension(): int
        public isOverWorld(): boolean
        public isNether(): boolean
        public isTheEnd(): boolean
        public static ORDER_YZX: byte
        public static ORDER_ZXY: byte

    }
}

declare module "cn.nukkit.level.format.LevelProvider" {
    declare type LevelProvider = cn.nukkit.level.format.LevelProvider;
}

declare namespace cn.nukkit.level.format.generic {
    declare class EmptyChunkSection extends java.lang.Object implements cn.nukkit.level.format.ChunkSection {
        public constructor(y: int): void
        public getY(): int
        public getBlockId(x: int, y: int, z: int): int
        public getBlockId(x: int, y: int, z: int, layer: int): int
        public getFullBlock(x: int, y: int, z: int): int
        public getBlockState(x: int, y: int, z: int, layer: int): cn.nukkit.blockstate.BlockState
        public setBlockAtLayer(x: int, y: int, z: int, layer: int, blockId: int): boolean
        public getAndSetBlock(x: int, y: int, z: int, layer: int, block: cn.nukkit.block.Block): cn.nukkit.block.Block
        public getAndSetBlock(x: int, y: int, z: int, block: cn.nukkit.block.Block): cn.nukkit.block.Block
        public getAndSetBlockState(x: int, y: int, z: int, layer: int, state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState
        public setBlockId(x: int, y: int, z: int, layer: int, id: int): void
        public setBlock(x: int, y: int, z: int, blockId: int): boolean
        public setBlock(x: int, y: int, z: int, blockId: int, meta: int): boolean
        public setBlockAtLayer(x: int, y: int, z: int, layer: int, blockId: int, meta: int): boolean
        public setBlockStateAtLayer(x: int, y: int, z: int, layer: int, state: cn.nukkit.blockstate.BlockState): boolean
        public getSkyLightArray(): byte[]
        public getLightArray(): byte[]
        public setBlockId(x: int, y: int, z: int, id: int): void
        public getBlockData(x: int, y: int, z: int): int
        public getBlockData(x: int, y: int, z: int, layer: int): int
        public setBlockData(x: int, y: int, z: int, data: int): void
        public setBlockData(x: int, y: int, z: int, layer: int, data: int): void
        public setFullBlockId(x: int, y: int, z: int, fullId: int): boolean
        public setFullBlockId(x: int, y: int, z: int, layer: int, fullId: int): boolean
        public getFullBlock(x: int, y: int, z: int, layer: int): int
        public getBlockLight(x: int, y: int, z: int): int
        public setBlockLight(x: int, y: int, z: int, level: int): void
        public getBlockSkyLight(x: int, y: int, z: int): int
        public setBlockSkyLight(x: int, y: int, z: int, level: int): void
        public isEmpty(): boolean
        public writeTo(stream: cn.nukkit.utils.BinaryStream): void
        public getMaximumLayer(): int
        public toNBT(): cn.nukkit.nbt.tag.CompoundTag
        public copy(): cn.nukkit.level.format.generic.EmptyChunkSection
        public getContentVersion(): int
        public setContentVersion(contentVersion: int): void
        public getBlockChangeStateAbove(x: int, y: int, z: int): int
        public scanBlocks(provider: cn.nukkit.level.format.LevelProvider, offsetX: int, offsetZ: int, min: cn.nukkit.math.BlockVector3, max: cn.nukkit.math.BlockVector3, condition: java.util.function.BiPredicate<cn.nukkit.math.BlockVector3, cn.nukkit.blockstate.BlockState>): java.util.List<cn.nukkit.block.Block>
        public copy(): cn.nukkit.level.format.ChunkSection
        public static EMPTY: cn.nukkit.level.format.generic.EmptyChunkSection[]
        public static EMPTY24: cn.nukkit.level.format.generic.EmptyChunkSection[]
        static MODIFICATION_ERROR_MESSAGE: string
        static EMPTY_2KB: byte[]
        public static EMPTY_LIGHT_ARR: byte[]
        public static EMPTY_SKY_LIGHT_ARR: byte[]
        public static EMPTY_ID_ARRAY: byte[]
        public static EMPTY_DATA_ARRAY: byte[]
        static EMPTY_CHUNK_DATA: byte[]
        y: int

    }
}

declare module "cn.nukkit.level.format.generic.EmptyChunkSection" {
    declare const EmptyChunkSection = cn.nukkit.level.format.generic.EmptyChunkSection;
}

declare namespace cn.nukkit.level.format.generic {
    declare class BaseRegionLoader extends java.lang.Object {
        public constructor(level: cn.nukkit.level.format.LevelProvider, regionX: int, regionZ: int, ext: string): void
        public compress(): void
        public getRandomAccessFile(): java.io.RandomAccessFile
        isChunkGenerated(var0: int): boolean
        public readChunk(var0: int, var1: int): cn.nukkit.level.format.generic.BaseFullChunk
        unserializeChunk(var0: byte[]): cn.nukkit.level.format.generic.BaseFullChunk
        public chunkExists(var0: int, var1: int): boolean
        saveChunk(var0: int, var1: int, var2: byte[]): void
        public removeChunk(var0: int, var1: int): void
        public writeChunk(var0: cn.nukkit.level.format.FullChunk): void
        public close(): void
        loadLocationTable(): void
        public doSlowCleanUp(): int
        writeLocationIndex(var0: int): void
        createBlank(): void
        public getX(): int
        public getZ(): int
        public getLocationIndexes(): int[]
        public getIntLocationIndexes(): int[]
        static lambda$new$2(table: int[]): int[]
        static lambda$new$1(x$0: int): int[]
        static lambda$new$0(table: int[]): int[]
        public static VERSION: int
        public static COMPRESSION_GZIP: byte
        public static COMPRESSION_ZLIB: byte
        public static MAX_SECTOR_LENGTH: int
        public static COMPRESSION_LEVEL: int
        x: int
        z: int
        lastSector: int
        levelProvider: cn.nukkit.level.format.LevelProvider
        randomAccessFile: java.io.RandomAccessFile
        primitiveLocationTable: int
        locationTable: java.util.Map<int, int[]>
        public lastUsed: long

    }
}

declare module "cn.nukkit.level.format.generic.BaseRegionLoader" {
    declare const BaseRegionLoader = cn.nukkit.level.format.generic.BaseRegionLoader;
}

declare namespace cn.nukkit.level.format.generic {
    declare class BaseChunk extends cn.nukkit.level.format.generic.BaseFullChunk implements cn.nukkit.level.format.Chunk {
        public constructor(): void
        public backwardCompatibilityUpdate(level: cn.nukkit.level.Level): void
        public toSectionY(blockPosY: int): int
        public clone(): cn.nukkit.level.format.generic.BaseChunk
        removeInvalidTile(x: int, y: int, z: int): void
        public scanBlocks(min: cn.nukkit.math.BlockVector3, max: cn.nukkit.math.BlockVector3, condition: java.util.function.BiPredicate<cn.nukkit.math.BlockVector3, cn.nukkit.blockstate.BlockState>): java.util.stream.Stream<cn.nukkit.block.Block>
        public getFullBlock(x: int, y: int, z: int): int
        public getFullBlock(x: int, y: int, z: int, layer: int): int
        public getBlockState(x: int, y: int, z: int, layer: int): cn.nukkit.blockstate.BlockState
        public setBlockAtLayer(x: int, y: int, z: int, layer: int, blockId: int): boolean
        public setBlock(x: int, y: int, z: int, blockId: int): boolean
        public getAndSetBlock(x: int, y: int, z: int, block: cn.nukkit.block.Block): cn.nukkit.block.Block
        public getAndSetBlockState(x: int, y: int, z: int, layer: int, state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState
        public getAndSetBlock(x: int, y: int, z: int, layer: int, block: cn.nukkit.block.Block): cn.nukkit.block.Block
        public setFullBlockId(x: int, y: int, z: int, fullId: int): boolean
        public setFullBlockId(x: int, y: int, z: int, layer: int, fullId: int): boolean
        public setBlock(x: int, y: int, z: int, blockId: int, meta: int): boolean
        public setBlockAtLayer(x: int, y: int, z: int, layer: int, blockId: int, meta: int): boolean
        public setBlockStateAtLayer(x: int, y: int, z: int, layer: int, state: cn.nukkit.blockstate.BlockState): boolean
        getOrCreateMutableSection(sectionY: int): cn.nukkit.level.format.ChunkSection
        createChunkSection(sectionY: int): void
        public setBlockId(x: int, y: int, z: int, id: int): void
        public setBlockId(x: int, y: int, z: int, layer: int, id: int): void
        public getBlockId(x: int, y: int, z: int): int
        public getBlockId(x: int, y: int, z: int, layer: int): int
        public getBlockData(x: int, y: int, z: int): int
        public getBlockData(x: int, y: int, z: int, layer: int): int
        public setBlockData(x: int, y: int, z: int, data: int): void
        public setBlockData(x: int, y: int, z: int, layer: int, data: int): void
        public getBlockSkyLight(x: int, y: int, z: int): int
        public setBlockSkyLight(x: int, y: int, z: int, level: int): void
        public getBlockLight(x: int, y: int, z: int): int
        public setBlockLight(x: int, y: int, z: int, level: int): void
        public isSectionEmpty(fY: float): boolean
        public getSection(fY: float): cn.nukkit.level.format.ChunkSection
        public setSection(fY: float, section: cn.nukkit.level.format.ChunkSection): boolean
        setInternalSection(fY: float, section: cn.nukkit.level.format.ChunkSection): void
        public load(): boolean
        public load(generate: boolean): boolean
        public getBlockSkyLightArray(): byte[]
        public getBlockLightArray(): byte[]
        public getSections(): cn.nukkit.level.format.ChunkSection[]
        public getHeightMapArray(): byte[]
        public getProvider(): cn.nukkit.level.format.LevelProvider
        public setBlockStateAt(x: int, y: int, z: int, layer: int, state: cn.nukkit.blockstate.BlockState): boolean
        public getBlockStateAt(x: int, y: int, z: int, layer: int): cn.nukkit.blockstate.BlockState
        public isBlockChangeAllowed(x: int, y: int, z: int): boolean
        public findBorders(x: int, z: int): java.util.List<cn.nukkit.block.Block>
        public isBlockedByBorder(x: int, z: int): boolean
        public delayPaletteUpdates(): void
        public isPaletteUpdatesDelayed(): boolean
        public setPaletteUpdatesDelayed(delayPaletteUpdates: boolean): void
        public clone(): cn.nukkit.level.format.generic.BaseFullChunk
        public clone(): java.lang.Object
        lambda$scanBlocks$3(offsetX: int, offsetZ: int, min: cn.nukkit.math.BlockVector3, max: cn.nukkit.math.BlockVector3, condition: java.util.function.BiPredicate, section: cn.nukkit.level.format.ChunkSection): java.util.List
        static lambda$scanBlocks$2(section: cn.nukkit.level.format.ChunkSection): boolean
        lambda$scanBlocks$1(sectionY: int): cn.nukkit.level.format.ChunkSection
        lambda$scanBlocks$0(sectionY: int): boolean
        static log: org.apache.logging.log4j.Logger
        delayPaletteUpdates: boolean
        sections: cn.nukkit.level.format.ChunkSection[]
        sectionLength: int

    }
}

declare module "cn.nukkit.level.format.generic.BaseChunk" {
    declare const BaseChunk = cn.nukkit.level.format.generic.BaseChunk;
}

declare namespace cn.nukkit.level.format.generic {
    declare class BaseFullChunk extends java.lang.Object implements cn.nukkit.level.format.FullChunk, cn.nukkit.level.ChunkManager {
        public constructor(): void
        public clone(): cn.nukkit.level.format.generic.BaseFullChunk
        public setChunkPacket(packet: cn.nukkit.network.protocol.BatchPacket): void
        public getChunkPacket(): cn.nukkit.network.protocol.BatchPacket
        public backwardCompatibilityUpdate(level: cn.nukkit.level.Level): void
        public initChunk(): void
        public getIndex(): long
        public getX(): int
        public getZ(): int
        public setPosition(x: int, z: int): void
        public setX(x: int): void
        public setZ(z: int): void
        public getProvider(): cn.nukkit.level.format.LevelProvider
        public setProvider(provider: cn.nukkit.level.format.LevelProvider): void
        public getBiomeId(x: int, z: int): int
        public setBiomeId(x: int, z: int, biomeId: byte): void
        public getHeightMap(x: int, z: int): int
        public setHeightMap(x: int, z: int, value: int): void
        public recalculateHeightMap(): void
        public recalculateHeightMapColumn(x: int, z: int): int
        public getBlockExtraData(x: int, y: int, z: int): int
        public setBlockExtraData(x: int, y: int, z: int, data: int): void
        public populateSkyLight(): void
        public getHighestBlockAt(x: int, z: int): int
        public getHighestBlockAt(x: int, z: int, cache: boolean): int
        public addEntity(entity: cn.nukkit.entity.Entity): void
        public removeEntity(entity: cn.nukkit.entity.Entity): void
        public addBlockEntity(blockEntity: cn.nukkit.blockentity.BlockEntity): void
        public removeBlockEntity(blockEntity: cn.nukkit.blockentity.BlockEntity): void
        public getEntities(): java.util.Map<long, cn.nukkit.entity.Entity>
        public getBlockEntities(): java.util.Map<long, cn.nukkit.blockentity.BlockEntity>
        public getBlockExtraDataArray(): java.util.Map<int, int>
        public getTile(x: int, y: int, z: int): cn.nukkit.blockentity.BlockEntity
        public isLoaded(): boolean
        public load(): boolean
        public load(generate: boolean): boolean
        public unload(): boolean
        public unload(save: boolean): boolean
        public unload(save: boolean, safe: boolean): boolean
        public getBlockSkyLightArray(): byte[]
        public getBlockLightArray(): byte[]
        public getBiomeIdArray(): byte[]
        public getHeightMapArray(): byte[]
        public getChanges(): long
        public hasChanged(): boolean
        public setChanged(): void
        public setChanged(changed: boolean): void
        public toFastBinary(): byte[]
        public isLightPopulated(): boolean
        public setLightPopulated(): void
        public setLightPopulated(value: boolean): void
        public getBlockIdAt(x: int, y: int, z: int): int
        public getBlockIdAt(x: int, y: int, z: int, layer: int): int
        public setBlockFullIdAt(x: int, y: int, z: int, fullId: int): void
        public setBlockFullIdAt(x: int, y: int, z: int, layer: int, fullId: int): void
        public setBlockAtLayer(x: int, y: int, z: int, layer: int, blockId: int): boolean
        public setBlockAtLayer(x: int, y: int, z: int, layer: int, blockId: int, meta: int): boolean
        public setBlockIdAt(x: int, y: int, z: int, id: int): void
        public setBlockIdAt(x: int, y: int, z: int, layer: int, id: int): void
        public setBlockAt(x: int, y: int, z: int, id: int, data: int): void
        public getBlockDataAt(x: int, y: int, z: int): int
        public getBlockDataAt(x: int, y: int, z: int, layer: int): int
        public setBlockDataAt(x: int, y: int, z: int, data: int): void
        public setBlockDataAt(x: int, y: int, z: int, layer: int, data: int): void
        public getChunk(chunkX: int, chunkZ: int): cn.nukkit.level.format.generic.BaseFullChunk
        public setChunk(chunkX: int, chunkZ: int): void
        public setChunk(chunkX: int, chunkZ: int, chunk: cn.nukkit.level.format.generic.BaseFullChunk): void
        public getSeed(): long
        public compress(): boolean
        public scanBlocks(min: cn.nukkit.math.BlockVector3, max: cn.nukkit.math.BlockVector3, condition: java.util.function.BiPredicate<cn.nukkit.math.BlockVector3, cn.nukkit.blockstate.BlockState>): java.util.stream.Stream<cn.nukkit.block.Block>
        ensureY(y: int): int
        public clone(): java.lang.Object
        entities: java.util.Map<long, cn.nukkit.entity.Entity>
        tiles: java.util.Map<long, cn.nukkit.blockentity.BlockEntity>
        tileList: java.util.Map<int, cn.nukkit.blockentity.BlockEntity>
        biomes: byte[]
        blocks: byte[]
        data: byte[]
        skyLight: byte[]
        blockLight: byte[]
        heightMap: byte[]
        NBTtiles: java.util.List<cn.nukkit.nbt.tag.CompoundTag>
        NBTentities: java.util.List<cn.nukkit.nbt.tag.CompoundTag>
        extraData: java.util.Map<int, int>
        provider: cn.nukkit.level.format.LevelProvider
        providerClass: java.lang.Class<cn.nukkit.level.format.LevelProvider>
        x: int
        z: int
        hash: long
        changes: long
        isInit: boolean
        chunkPacket: cn.nukkit.network.protocol.BatchPacket

    }
}

declare module "cn.nukkit.level.format.generic.BaseFullChunk" {
    declare const BaseFullChunk = cn.nukkit.level.format.generic.BaseFullChunk;
}

declare namespace cn.nukkit.level.format.generic {
    declare class BaseLevelProvider$1 extends java.util.HashMap {
        constructor(this$0: cn.nukkit.level.format.generic.BaseLevelProvider): void
        this$0: cn.nukkit.level.format.generic.BaseLevelProvider

    }
}

declare module "cn.nukkit.level.format.generic.BaseLevelProvider$1" {
    declare const BaseLevelProvider$1 = cn.nukkit.level.format.generic.BaseLevelProvider$1;
}

declare namespace cn.nukkit.level.format.generic {
    declare class BaseLevelProvider extends java.lang.Object implements cn.nukkit.level.format.LevelProvider {
        public constructor(level: cn.nukkit.level.Level, path: string): void
        public constructor(level: cn.nukkit.level.Level, path: string, levelData: cn.nukkit.nbt.tag.CompoundTag, spawn: cn.nukkit.math.Vector3): void
        public loadChunk(var0: long, var1: int, var2: int, var3: boolean): cn.nukkit.level.format.generic.BaseFullChunk
        public size(): int
        public unloadChunks(): void
        public getGenerator(): string
        public getGeneratorOptions(): java.util.Map<string, java.lang.Object>
        public getLoadedChunks(): java.util.Map<long, cn.nukkit.level.format.generic.BaseFullChunk>
        public isChunkLoaded(X: int, Z: int): boolean
        public putChunk(index: long, var1: cn.nukkit.level.format.generic.BaseFullChunk): void
        public isChunkLoaded(hash: long): boolean
        public getRegion(x: int, z: int): cn.nukkit.level.format.generic.BaseRegionLoader
        static getRegionIndexX(chunkX: int): int
        static getRegionIndexZ(chunkZ: int): int
        public getPath(): string
        public getServer(): cn.nukkit.Server
        public getLevel(): cn.nukkit.level.Level
        public getName(): string
        public isRaining(): boolean
        public setRaining(raining: boolean): void
        public getRainTime(): int
        public setRainTime(rainTime: int): void
        public isThundering(): boolean
        public setThundering(thundering: boolean): void
        public getThunderTime(): int
        public setThunderTime(thunderTime: int): void
        public getCurrentTick(): long
        public setCurrentTick(currentTick: long): void
        public getTime(): long
        public setTime(value: long): void
        public getSeed(): long
        public setSeed(value: long): void
        public getSpawn(): cn.nukkit.math.Vector3
        public setSpawn(pos: cn.nukkit.math.Vector3): void
        public getGamerules(): cn.nukkit.level.GameRules
        public setGameRules(rules: cn.nukkit.level.GameRules): void
        public doGarbageCollection(): void
        public saveChunks(): void
        public getLevelData(): cn.nukkit.nbt.tag.CompoundTag
        public saveLevelData(): void
        public updateLevelName(name: string): void
        public loadChunk(chunkX: int, chunkZ: int): boolean
        public loadChunk(chunkX: int, chunkZ: int, create: boolean): boolean
        public unloadChunk(X: int, Z: int): boolean
        public unloadChunk(X: int, Z: int, safe: boolean): boolean
        public getChunk(chunkX: int, chunkZ: int): cn.nukkit.level.format.generic.BaseFullChunk
        public getLoadedChunk(chunkX: int, chunkZ: int): cn.nukkit.level.format.generic.BaseFullChunk
        public getLoadedChunk(hash: long): cn.nukkit.level.format.generic.BaseFullChunk
        public getChunk(chunkX: int, chunkZ: int, create: boolean): cn.nukkit.level.format.generic.BaseFullChunk
        public setChunk(chunkX: int, chunkZ: int, chunk: cn.nukkit.level.format.FullChunk): void
        public isChunkPopulated(chunkX: int, chunkZ: int): boolean
        public close(): void
        public isChunkGenerated(chunkX: int, chunkZ: int): boolean
        lambda$saveLevelData$0(file: java.io.File): void
        static log: org.apache.logging.log4j.Logger
        level: cn.nukkit.level.Level
        path: string
        levelData: cn.nukkit.nbt.tag.CompoundTag
        spawn: cn.nukkit.math.Vector3
        lastRegion: java.util.concurrent.atomic.AtomicReference<cn.nukkit.level.format.generic.BaseRegionLoader>
        regions: it.unimi.dsi.fastutil.longs.Long2ObjectMap<cn.nukkit.level.format.generic.BaseRegionLoader>
        chunks: it.unimi.dsi.fastutil.longs.Long2ObjectMap<cn.nukkit.level.format.generic.BaseFullChunk>
        lastChunk: java.util.concurrent.atomic.AtomicReference<cn.nukkit.level.format.generic.BaseFullChunk>

    }
}

declare module "cn.nukkit.level.format.generic.BaseLevelProvider" {
    declare const BaseLevelProvider = cn.nukkit.level.format.generic.BaseLevelProvider;
}

declare namespace cn.nukkit.level.format.anvil {
    declare class Anvil extends cn.nukkit.level.format.generic.BaseLevelProvider {
        public constructor(level: cn.nukkit.level.Level, path: string): void
        public static getProviderName(): string
        public static getProviderOrder(): byte
        public static usesChunkSection(): boolean
        public isOldAnvil(): boolean
        public static isValid(path: string): boolean
        public static generate(path: string, name: string, seed: long, var3: java.lang.Class<cn.nukkit.level.generator.Generator>): void
        public static generate(path: string, name: string, seed: long, var3: java.lang.Class<cn.nukkit.level.generator.Generator>, generator: java.util.Map<string, string>): void
        public getEmptyChunk(chunkX: int, chunkZ: int): cn.nukkit.level.format.anvil.Chunk
        public requestChunkTask(x: int, z: int): cn.nukkit.scheduler.AsyncTask
        public static serialize(chunk: cn.nukkit.level.format.generic.BaseChunk, callback: java.util.function.BiConsumer<cn.nukkit.utils.BinaryStream, int>, dimensionData: cn.nukkit.level.DimensionData): void
        static serializeEntities(chunk: cn.nukkit.level.format.generic.BaseChunk): byte[]
        static convert2DBiomesTo3D(chunk: cn.nukkit.level.format.generic.BaseFullChunk, sections: int): byte[]
        public doGarbageCollection(time: long): void
        public loadChunk(index: long, var1: int, chunkX: int, chunkZ: boolean): cn.nukkit.level.format.generic.BaseFullChunk
        public saveChunk(X: int, Z: int): void
        public saveChunk(x: int, z: int, chunk: cn.nukkit.level.format.FullChunk): void
        public static createChunkSection(y: int): cn.nukkit.level.format.anvil.ChunkSection
        loadRegion(x: int, z: int): cn.nukkit.level.format.generic.BaseRegionLoader
        public getMaximumLayer(): int
        public getEmptyChunk(var0: int, var1: int): cn.nukkit.level.format.generic.BaseFullChunk
        lambda$requestChunkTask$2(timestamp: long, var1: int, x: int, z: cn.nukkit.utils.BinaryStream, stream: int): void
        static lambda$generate$1(levelData: cn.nukkit.nbt.tag.CompoundTag, file: java.io.File): void
        static lambda$isValid$0(dir: java.io.File, name: string): boolean
        static log: org.apache.logging.log4j.Logger
        public static OLD_VERSION: int
        public static VERSION: int
        public static LOWER_PADDING_SIZE: int
        static PAD_256: byte[]
        isOldAnvil: boolean
        lastPosition: int

    }
}

declare module "cn.nukkit.level.format.anvil.Anvil" {
    declare const Anvil = cn.nukkit.level.format.anvil.Anvil;
}

declare namespace cn.nukkit.level.format.anvil {
    declare class ChunkSection extends java.lang.Object implements cn.nukkit.level.format.ChunkSection {
        constructor(y: int, layerStorage: cn.nukkit.level.format.anvil.LayerStorage, blockLight: byte[], skyLight: byte[], compressedLight: byte[], hasBlockLight: boolean, hasSkyLight: boolean): void
        public constructor(y: int): void
        public constructor(nbt: cn.nukkit.nbt.tag.CompoundTag): void
        loadStorage(layer: int, storageTag: cn.nukkit.nbt.tag.CompoundTag): void
        static loadState(index: int, blockId: int, composedData: int, hugeDataList: cn.nukkit.nbt.tag.ListTag<cn.nukkit.nbt.tag.ByteArrayTag>, hugeDataSize: int): cn.nukkit.blockstate.BlockState
        static loadHugeIntData(index: int, blockId: int, composedData: int, hugeDataList: cn.nukkit.nbt.tag.ListTag<cn.nukkit.nbt.tag.ByteArrayTag>, hugeDataSize: int): cn.nukkit.blockstate.BlockState
        static loadHugeLongData(index: int, blockId: int, composedData: int, hugeDataList: cn.nukkit.nbt.tag.ListTag<cn.nukkit.nbt.tag.ByteArrayTag>, hugeDataSize: int): cn.nukkit.blockstate.BlockState
        static loadHugeBigData(index: int, blockId: int, composedData: int, hugeDataList: cn.nukkit.nbt.tag.ListTag<cn.nukkit.nbt.tag.ByteArrayTag>, hugeDataSize: int): cn.nukkit.blockstate.BlockState
        static getStorageTagList(nbt: cn.nukkit.nbt.tag.CompoundTag, version: int): cn.nukkit.nbt.tag.ListTag<cn.nukkit.nbt.tag.CompoundTag>
        static composeBlockId(baseId: byte, extraId: byte): int
        static composeData(baseData: byte, extraData: byte): int
        static getAnvilIndex(x: int, y: int, z: int): int
        public getY(): int
        public getBlockId(x: int, y: int, z: int): int
        public getBlockId(x: int, y: int, z: int, layer: int): int
        public setBlockId(x: int, y: int, z: int, id: int): void
        public setBlockId(x: int, y: int, z: int, layer: int, id: int): void
        setLayerStorage(storage: cn.nukkit.level.format.anvil.LayerStorage): void
        public setFullBlockId(x: int, y: int, z: int, fullId: int): boolean
        public setFullBlockId(x: int, y: int, z: int, layer: int, fullId: int): boolean
        public getBlockData(x: int, y: int, z: int): int
        public getBlockData(x: int, y: int, z: int, layer: int): int
        public setBlockData(x: int, y: int, z: int, data: int): void
        public setBlockData(x: int, y: int, z: int, layer: int, data: int): void
        public getFullBlock(x: int, y: int, z: int): int
        public getBlockState(x: int, y: int, z: int, layer: int): cn.nukkit.blockstate.BlockState
        public getFullBlock(x: int, y: int, z: int, layer: int): int
        public setBlock(x: int, y: int, z: int, blockId: int): boolean
        public setBlockAtLayer(x: int, y: int, z: int, layer: int, blockId: int): boolean
        public getAndSetBlock(x: int, y: int, z: int, block: cn.nukkit.block.Block): cn.nukkit.block.Block
        public getAndSetBlock(x: int, y: int, z: int, layer: int, block: cn.nukkit.block.Block): cn.nukkit.block.Block
        public getAndSetBlockState(x: int, y: int, z: int, layer: int, state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState
        public setBlock(x: int, y: int, z: int, blockId: int, meta: int): boolean
        public setBlockAtLayer(x: int, y: int, z: int, layer: int, blockId: int, meta: int): boolean
        public setBlockStateAtLayer(x: int, y: int, z: int, layer: int, state: cn.nukkit.blockstate.BlockState): boolean
        public getBlockChangeStateAbove(x: int, y: int, z: int): int
        public delayPaletteUpdates(): void
        public getBlockSkyLight(x: int, y: int, z: int): int
        public setBlockSkyLight(x: int, y: int, z: int, level: int): void
        public getBlockLight(x: int, y: int, z: int): int
        public setBlockLight(x: int, y: int, z: int, level: int): void
        public getSkyLightArray(): byte[]
        inflate(): boolean
        public getLightArray(): byte[]
        public isEmpty(): boolean
        toXZY(raw: char[]): byte[]
        public writeTo(stream: cn.nukkit.utils.BinaryStream): void
        saveData(storage: cn.nukkit.level.format.anvil.util.BlockStorage, idsBase: byte[], idsExtra: byte[], dataBase: cn.nukkit.level.format.anvil.util.NibbleArray, dataExtra: cn.nukkit.level.format.anvil.util.NibbleArray): byte[]
        saveHugeData(hugeList: byte[], state: cn.nukkit.blockstate.BlockState, anvil: int, intData: int): void
        allocateBlob(hugeList: byte[], pos: int): byte[]
        public toNBT(): cn.nukkit.nbt.tag.CompoundTag
        public compressStorageLayers(): void
        public compress(): boolean
        public scanBlocks(provider: cn.nukkit.level.format.LevelProvider, offsetX: int, offsetZ: int, min: cn.nukkit.math.BlockVector3, max: cn.nukkit.math.BlockVector3, condition: java.util.function.BiPredicate<cn.nukkit.math.BlockVector3, cn.nukkit.blockstate.BlockState>): java.util.List<cn.nukkit.block.Block>
        public copy(): cn.nukkit.level.format.anvil.ChunkSection
        public getMaximumLayer(): int
        public getContentVersion(): int
        public setContentVersion(contentVersion: int): void
        public hasBlocks(): boolean
        public copy(): cn.nukkit.level.format.ChunkSection
        lambda$saveData$0(idsBase: byte[], idsExtra: byte[], dataBase: cn.nukkit.level.format.anvil.util.NibbleArray, dataExtra: cn.nukkit.level.format.anvil.util.NibbleArray, big: boolean, hugeList: java.util.List, huge: boolean, bx: int, by: int, bz: int, state: cn.nukkit.blockstate.BlockState): void
        static log: org.apache.logging.log4j.Logger
        public static STREAM_STORAGE_VERSION: int
        public static SAVE_STORAGE_VERSION: int
        static STORAGE_TAG_NAME: string
        static HUGE_TAG_NAME: string
        static BYTE_MASK: java.math.BigInteger
        y: int
        layerStorage: cn.nukkit.level.format.anvil.LayerStorage
        blockLight: byte[]
        skyLight: byte[]
        compressedLight: byte[]
        hasBlockLight: boolean
        hasSkyLight: boolean
        contentVersion: int

    }
}

declare module "cn.nukkit.level.format.anvil.ChunkSection" {
    declare const ChunkSection = cn.nukkit.level.format.anvil.ChunkSection;
}

declare namespace cn.nukkit.level.format.anvil {
    declare class SingleLayerStorage extends cn.nukkit.level.format.anvil.LayerStorage {
        public constructor(): void
        public constructor(storage: cn.nukkit.level.format.anvil.util.BlockStorage): void
        public hasBlocks(): boolean
        public clone(): cn.nukkit.level.format.anvil.SingleLayerStorage
        public getStorageOrEmpty(layer: int): cn.nukkit.level.format.anvil.util.BlockStorage
        public getOrSetStorage(setLayerStorage: java.util.function.Consumer<cn.nukkit.level.format.anvil.LayerStorage>, contentVersion: java.util.function.IntSupplier, layer: int): cn.nukkit.level.format.anvil.util.BlockStorage
        public getStorageOrNull(layer: int): cn.nukkit.level.format.anvil.util.BlockStorage
        public delayPaletteUpdates(): void
        public writeTo(stream: cn.nukkit.utils.BinaryStream): void
        public size(): int
        public compress(setLayerStorage: java.util.function.Consumer<cn.nukkit.level.format.anvil.LayerStorage>): void
        public clone(): cn.nukkit.level.format.anvil.LayerStorage
        public clone(): java.lang.Object
        storage: cn.nukkit.level.format.anvil.util.BlockStorage

    }
}

declare module "cn.nukkit.level.format.anvil.SingleLayerStorage" {
    declare const SingleLayerStorage = cn.nukkit.level.format.anvil.SingleLayerStorage;
}

declare namespace cn.nukkit.level.format.anvil.util {
    declare class ImmutableBlockStorage extends cn.nukkit.level.format.anvil.util.BlockStorage {
        constructor(states: cn.nukkit.blockstate.BlockState[], flags: byte, palette: cn.nukkit.level.util.PalettedBlockStorage, denyStates: java.util.BitSet): void
        setBlockState(index: int, state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState
        public delayPaletteUpdates(): void
        public recheckBlocks(): void
        public immutableCopy(): cn.nukkit.level.format.anvil.util.ImmutableBlockStorage
        public static EMPTY: cn.nukkit.level.format.anvil.util.ImmutableBlockStorage

    }
}

declare module "cn.nukkit.level.format.anvil.util.ImmutableBlockStorage" {
    declare const ImmutableBlockStorage = cn.nukkit.level.format.anvil.util.ImmutableBlockStorage;
}

declare namespace cn.nukkit.level.format.anvil.util {
    declare class NibbleArray extends java.lang.Object implements java.lang.Cloneable {
        public constructor(length: int): void
        public constructor(array: byte[]): void
        public get(index: int): byte
        public set(index: int, value: byte): void
        public fill(value: byte): void
        public copyFrom(bytes: byte[]): void
        public copyFrom(array: cn.nukkit.level.format.anvil.util.NibbleArray): void
        public getData(): byte[]
        public copy(): cn.nukkit.level.format.anvil.util.NibbleArray
        public static EMPTY_DATA_ARRAY: cn.nukkit.level.format.anvil.util.NibbleArray
        data: byte[]

    }
}

declare module "cn.nukkit.level.format.anvil.util.NibbleArray" {
    declare const NibbleArray = cn.nukkit.level.format.anvil.util.NibbleArray;
}

declare namespace cn.nukkit.level.format.anvil.util {
    declare class BlockStorage extends java.lang.Object {
        public constructor(): void
        constructor(states: cn.nukkit.blockstate.BlockState[], flags: byte, palette: cn.nukkit.level.util.PalettedBlockStorage, denyStates: java.util.BitSet): void
        static getIndex(x: int, y: int, z: int): int
        static checkArg(pos: int, arg: string): void
        public getBlockData(x: int, y: int, z: int): int
        public getBlockId(x: int, y: int, z: int): int
        public setBlockId(x: int, y: int, z: int, id: int): void
        public setBlockData(x: int, y: int, z: int, data: int): void
        public setBlock(x: int, y: int, z: int, id: int, data: int): void
        public getFullBlock(x: int, y: int, z: int): int
        public setFullBlock(x: int, y: int, z: int, value: int): void
        public getAndSetBlock(x: int, y: int, z: int, id: int, meta: int): cn.nukkit.blockstate.BlockState
        public getAndSetBlockState(x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState
        public setBlockState(x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): void
        public getAndSetFullBlock(x: int, y: int, z: int, value: int): int
        getAndSetFullBlock(index: int, value: int): int
        getFullBlock(index: int): int
        setFullBlock(index: int, value: int): void
        setBlockState(index: int, state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState
        public delayPaletteUpdates(): void
        public isPaletteUpdateDelayed(): boolean
        public getBlockState(x: int, y: int, z: int): cn.nukkit.blockstate.BlockState
        public recheckBlocks(): void
        updateFlags(index: int, previous: cn.nukkit.blockstate.BlockState, state: cn.nukkit.blockstate.BlockState): void
        border(index: int): void
        deny(index: int): void
        allow(index: int): void
        clearAllow(index: int): void
        clearDeny(index: int): void
        clearBorder(index: int): void
        computeFlags(newFlags: byte, states: cn.nukkit.blockstate.BlockState[]): byte
        public copy(): cn.nukkit.level.format.anvil.util.BlockStorage
        public immutableCopy(): cn.nukkit.level.format.anvil.util.ImmutableBlockStorage
        getFlag(flag: byte): boolean
        setFlag(flag: byte, value: boolean): void
        public hasBlockIds(): boolean
        public hasBlockIdExtras(): boolean
        public hasBlockDataExtras(): boolean
        public hasBlockDataBig(): boolean
        public hasBlockDataHuge(): boolean
        isPaletteUpdated(): boolean
        public writeTo(stream: cn.nukkit.utils.BinaryStream): void
        public iterateStates(consumer: cn.nukkit.utils.functional.BlockPositionDataConsumer<cn.nukkit.blockstate.BlockState>): void
        public getBlockChangeStateAbove(x: int, y: int, z: int): int
        static log: org.apache.logging.log4j.Logger
        public static EMPTY_ARRAY: cn.nukkit.level.format.anvil.util.BlockStorage[]
        static FLAG_HAS_ID: byte
        static FLAG_HAS_ID_EXTRA: byte
        static FLAG_HAS_DATA_EXTRA: byte
        static FLAG_HAS_DATA_BIG: byte
        static FLAG_HAS_DATA_HUGE: byte
        static FLAG_PALETTE_UPDATED: byte
        static FLAG_ENABLE_ID_EXTRA: byte
        static FLAG_ENABLE_DATA_EXTRA: byte
        static FLAG_ENABLE_DATA_BIG: byte
        static FLAG_ENABLE_DATA_HUGE: byte
        static FLAG_EVERYTHING_ENABLED: byte
        static BLOCK_ID_MASK: int
        static BLOCK_ID_EXTRA_MASK: int
        static BLOCK_ID_FULL: int
        public static SECTION_SIZE: int
        static EMPTY: cn.nukkit.blockstate.BlockState[]
        palette: cn.nukkit.level.util.PalettedBlockStorage
        states: cn.nukkit.blockstate.BlockState[]
        flags: byte
        denyStates: java.util.BitSet
        static $assertionsDisabled: boolean

    }
}

declare module "cn.nukkit.level.format.anvil.util.BlockStorage" {
    declare const BlockStorage = cn.nukkit.level.format.anvil.util.BlockStorage;
}

declare namespace cn.nukkit.level.format.anvil {
    declare class RegionLoader extends cn.nukkit.level.format.generic.BaseRegionLoader {
        public constructor(level: cn.nukkit.level.format.LevelProvider, regionX: int, regionZ: int): void
        isChunkGenerated(index: int): boolean
        public readChunk(x: int, z: int): cn.nukkit.level.format.anvil.Chunk
        unserializeChunk(data: byte[]): cn.nukkit.level.format.anvil.Chunk
        public chunkExists(x: int, z: int): boolean
        saveChunk(x: int, z: int, chunkData: byte[]): void
        public removeChunk(x: int, z: int): void
        public writeChunk(chunk: cn.nukkit.level.format.FullChunk): void
        static getChunkOffset(x: int, z: int): int
        public close(): void
        public doSlowCleanUp(): int
        loadLocationTable(): void
        writeLocationTable(): void
        cleanGarbage(): int
        writeLocationIndex(index: int): void
        createBlank(): void
        public getX(): int
        public getZ(): int
        unserializeChunk(var0: byte[]): cn.nukkit.level.format.generic.BaseFullChunk
        public readChunk(var0: int, var1: int): cn.nukkit.level.format.generic.BaseFullChunk
        static log: org.apache.logging.log4j.Logger
        static chunkUpdated: it.unimi.dsi.fastutil.longs.LongSet

    }
}

declare module "cn.nukkit.level.format.anvil.RegionLoader" {
    declare const RegionLoader = cn.nukkit.level.format.anvil.RegionLoader;
}

declare namespace cn.nukkit.level.format.anvil {
    declare class LayerStorage extends java.lang.Object implements java.lang.Cloneable {
        constructor(): void
        public hasBlocks(): boolean
        public clone(): cn.nukkit.level.format.anvil.LayerStorage
        public getStorageOrEmpty(layer: int): cn.nukkit.level.format.anvil.util.BlockStorage
        public getOrSetStorage(setLayerStorage: java.util.function.Consumer<cn.nukkit.level.format.anvil.LayerStorage>, contentVersion: java.util.function.IntSupplier, layer: int): cn.nukkit.level.format.anvil.util.BlockStorage
        public getStorageOrNull(layer: int): cn.nukkit.level.format.anvil.util.BlockStorage
        public delayPaletteUpdates(): void
        public writeTo(stream: cn.nukkit.utils.BinaryStream): void
        public size(): int
        public compress(setLayerStorage: java.util.function.Consumer<cn.nukkit.level.format.anvil.LayerStorage>): void
        createBlockStorage(contentVersion: int): cn.nukkit.level.format.anvil.util.BlockStorage
        public clone(): java.lang.Object
        public static EMPTY: cn.nukkit.level.format.anvil.LayerStorage

    }
}

declare module "cn.nukkit.level.format.anvil.LayerStorage" {
    declare const LayerStorage = cn.nukkit.level.format.anvil.LayerStorage;
}

declare namespace cn.nukkit.level.format.anvil {
    declare class Chunk extends cn.nukkit.level.format.generic.BaseChunk {
        public clone(): cn.nukkit.level.format.anvil.Chunk
        public constructor(level: cn.nukkit.level.format.LevelProvider): void
        public constructor(providerClass: java.lang.Class<cn.nukkit.level.format.LevelProvider>): void
        public constructor(providerClass: java.lang.Class<cn.nukkit.level.format.LevelProvider>, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public constructor(level: cn.nukkit.level.format.LevelProvider, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public isPopulated(): boolean
        public setPopulated(): void
        public setPopulated(value: boolean): void
        public isGenerated(): boolean
        public setGenerated(): void
        public setGenerated(value: boolean): void
        public getNBT(): cn.nukkit.nbt.tag.CompoundTag
        public static fromBinary(data: byte[]): cn.nukkit.level.format.anvil.Chunk
        public static fromBinary(data: byte[], provider: cn.nukkit.level.format.LevelProvider): cn.nukkit.level.format.anvil.Chunk
        public static fromFastBinary(data: byte[]): cn.nukkit.level.format.anvil.Chunk
        public static fromFastBinary(data: byte[], provider: cn.nukkit.level.format.LevelProvider): cn.nukkit.level.format.anvil.Chunk
        public toFastBinary(): byte[]
        public toBinary(): byte[]
        public getBlockSkyLight(x: int, y: int, z: int): int
        public getBlockLight(x: int, y: int, z: int): int
        public static getEmptyChunk(chunkX: int, chunkZ: int): cn.nukkit.level.format.anvil.Chunk
        public static getEmptyChunk(chunkX: int, chunkZ: int, provider: cn.nukkit.level.format.LevelProvider): cn.nukkit.level.format.anvil.Chunk
        public compress(): boolean
        public clone(): cn.nukkit.level.format.generic.BaseChunk
        public clone(): cn.nukkit.level.format.generic.BaseFullChunk
        public clone(): java.lang.Object
        static log: org.apache.logging.log4j.Logger
        inhabitedTime: long
        terrainPopulated: boolean
        terrainGenerated: boolean
        isNew384World: boolean

    }
}

declare module "cn.nukkit.level.format.anvil.Chunk" {
    declare const Chunk = cn.nukkit.level.format.anvil.Chunk;
}

declare namespace cn.nukkit.level.format.anvil {
    declare class MultiLayerStorage extends cn.nukkit.level.format.anvil.LayerStorage {
        public constructor(): void
        public constructor(storages: cn.nukkit.level.format.anvil.util.BlockStorage[]): void
        public compress(setLayerStorage: java.util.function.Consumer<cn.nukkit.level.format.anvil.LayerStorage>): void
        public size(): int
        public writeTo(stream: cn.nukkit.utils.BinaryStream): void
        public delayPaletteUpdates(): void
        public getOrSetStorage(setLayerStorage: java.util.function.Consumer<cn.nukkit.level.format.anvil.LayerStorage>, contentVersion: java.util.function.IntSupplier, layer: int): cn.nukkit.level.format.anvil.util.BlockStorage
        public getStorageOrEmpty(layer: int): cn.nukkit.level.format.anvil.util.BlockStorage
        public getStorageOrNull(layer: int): cn.nukkit.level.format.anvil.util.BlockStorage
        public hasBlocks(): boolean
        public clone(): cn.nukkit.level.format.anvil.MultiLayerStorage
        public clone(): cn.nukkit.level.format.anvil.LayerStorage
        public clone(): java.lang.Object
        storages: cn.nukkit.level.format.anvil.util.BlockStorage[]

    }
}

declare module "cn.nukkit.level.format.anvil.MultiLayerStorage" {
    declare const MultiLayerStorage = cn.nukkit.level.format.anvil.MultiLayerStorage;
}

declare namespace cn.nukkit.level.format.anvil.palette {
    declare class IntPalette extends java.lang.Object {
        public constructor(): void
        public add(key: int): void
        set(keys: int[]): void
        insert(val: int): int[]
        public getKey(index: int): int
        public getValue(key: int): int
        binarySearch0(fromIndex: int, toIndex: int, key: int): int
        public length(): int
        public clone(): cn.nukkit.level.format.anvil.palette.IntPalette
        public clone(): java.lang.Object
        keys: int[]
        lastIndex: int

    }
}

declare module "cn.nukkit.level.format.anvil.palette.IntPalette" {
    declare const IntPalette = cn.nukkit.level.format.anvil.palette.IntPalette;
}

declare namespace cn.nukkit.level.format.anvil.palette {
    declare class BitArray256 extends java.lang.Object {
        public constructor(bitsPerEntry: int): void
        public constructor(other: cn.nukkit.level.format.anvil.palette.BitArray256): void
        public setAt(index: int, value: int): void
        public getAt(index: int): int
        public fromRaw(arr: int[]): void
        public grow(newBitsPerEntry: int): cn.nukkit.level.format.anvil.palette.BitArray256
        public growSlow(bitsPerEntry: int): cn.nukkit.level.format.anvil.palette.BitArray256
        public toRaw(buffer: int[]): int[]
        public toRaw(): int[]
        public clone(): cn.nukkit.level.format.anvil.palette.BitArray256
        public clone(): java.lang.Object
        bitsPerEntry: int
        data: long[]

    }
}

declare module "cn.nukkit.level.format.anvil.palette.BitArray256" {
    declare const BitArray256 = cn.nukkit.level.format.anvil.palette.BitArray256;
}

declare namespace cn.nukkit.level.format.anvil.palette {
    declare class BlockDataPalette extends java.lang.Object implements java.lang.Cloneable {
        public constructor(): void
        public constructor(rawData: char[]): void
        getCachedRaw(): char[]
        public getRaw(): char[]
        getIndex(x: int, y: int, z: int): int
        public getBlockData(x: int, y: int, z: int): int
        public getBlockId(x: int, y: int, z: int): int
        public setBlockId(x: int, y: int, z: int, id: int): void
        public setBlockData(x: int, y: int, z: int, data: int): void
        public getFullBlock(x: int, y: int, z: int): int
        public setFullBlock(x: int, y: int, z: int, value: int): void
        public getAndSetFullBlock(x: int, y: int, z: int, value: int): int
        getAndSetFullBlock(index: int, value: char): int
        getFullBlock(index: int): int
        setFullBlock(index: int, value: char): void
        setPaletteFullBlock(index: int, value: char): boolean
        public compress(): boolean
        public clone(): cn.nukkit.level.format.anvil.palette.BlockDataPalette
        public clone(): java.lang.Object
        static BLOCK_SIZE: int
        rawData: char[]
        encodedData: cn.nukkit.level.format.anvil.palette.BitArray4096
        palette: cn.nukkit.level.format.anvil.palette.CharPalette

    }
}

declare module "cn.nukkit.level.format.anvil.palette.BlockDataPalette" {
    declare const BlockDataPalette = cn.nukkit.level.format.anvil.palette.BlockDataPalette;
}

declare namespace cn.nukkit.level.format.anvil.palette {
    declare class BytePalette extends java.lang.Object {
        public constructor(): void
        public add(key: byte): void
        set(keys: byte[]): void
        insert(val: byte): byte[]
        public getKey(index: int): byte
        public getValue(key: byte): byte
        binarySearch0(fromIndex: int, toIndex: int, key: byte): int
        static BYTE0: byte[]
        keys: byte[]
        lastIndex: byte

    }
}

declare module "cn.nukkit.level.format.anvil.palette.BytePalette" {
    declare const BytePalette = cn.nukkit.level.format.anvil.palette.BytePalette;
}

declare namespace cn.nukkit.level.format.anvil.palette {
    declare class BiomePalette extends java.lang.Object {
        constructor(clone: cn.nukkit.level.format.anvil.palette.BiomePalette): void
        public constructor(biomeColors: int[]): void
        public constructor(): void
        public get(x: int, z: int): int
        public get(index: int): int
        public set(x: int, z: int, value: int): void
        public set(index: int, value: int): void
        public toRaw(): int[]
        public getIndex(x: int, z: int): int
        public clone(): cn.nukkit.level.format.anvil.palette.BiomePalette
        public clone(): java.lang.Object
        biome: int
        encodedData: cn.nukkit.level.format.anvil.palette.BitArray256
        palette: cn.nukkit.level.format.anvil.palette.IntPalette

    }
}

declare module "cn.nukkit.level.format.anvil.palette.BiomePalette" {
    declare const BiomePalette = cn.nukkit.level.format.anvil.palette.BiomePalette;
}

declare namespace cn.nukkit.level.format.anvil.palette {
    declare class BitArray4096 extends java.lang.Object {
        public constructor(bitsPerEntry: int): void
        public setAt(index: int, value: int): void
        public getAt(index: int): int
        public fromRawSlow(arr: char[]): void
        public fromRaw(arr: char[]): void
        public grow(newBitsPerEntry: int): cn.nukkit.level.format.anvil.palette.BitArray4096
        public growSlow(bitsPerEntry: int): cn.nukkit.level.format.anvil.palette.BitArray4096
        public toRawSlow(): char[]
        public toRaw(): char[]
        toRaw(buffer: char[]): char[]
        bitsPerEntry: int
        maxSeqLocIndex: int
        maxEntryValue: int
        data: long[]

    }
}

declare module "cn.nukkit.level.format.anvil.palette.BitArray4096" {
    declare const BitArray4096 = cn.nukkit.level.format.anvil.palette.BitArray4096;
}

declare namespace cn.nukkit.level.format.anvil.palette {
    declare class CharPalette extends java.lang.Object {
        public constructor(): void
        public add(key: char): void
        set(keys: char[]): void
        insert(val: char): char[]
        public getKey(index: int): char
        public getValue(key: char): char
        binarySearch0(fromIndex: int, toIndex: int, key: char): int
        keys: char[]
        lastIndex: char

    }
}

declare module "cn.nukkit.level.format.anvil.palette.CharPalette" {
    declare const CharPalette = cn.nukkit.level.format.anvil.palette.CharPalette;
}

declare namespace cn.nukkit.level.format {
    declare interface FullChunk extends java.lang.Cloneable {
        public getX(): int
        public getZ(): int
        public setPosition(x: int, z: int): void
        public setX(var0: int): void
        public setZ(var0: int): void
        public getIndex(): long
        public getProvider(): cn.nukkit.level.format.LevelProvider
        public setProvider(var0: cn.nukkit.level.format.LevelProvider): void
        public getFullBlock(var0: int, var1: int, var2: int): int
        public getFullBlock(var0: int, var1: int, var2: int, var3: int): int
        public getBlockRuntimeId(x: int, y: int, z: int): int
        public getBlockRuntimeId(x: int, y: int, z: int, layer: int): int
        public getBlockState(x: int, y: int, z: int): cn.nukkit.blockstate.BlockState
        public getBlockState(x: int, y: int, z: int, layer: int): cn.nukkit.blockstate.BlockState
        public getAndSetBlock(var0: int, var1: int, var2: int, var3: cn.nukkit.block.Block): cn.nukkit.block.Block
        public getAndSetBlock(var0: int, var1: int, var2: int, var3: int, var4: cn.nukkit.block.Block): cn.nukkit.block.Block
        public getAndSetBlockState(var0: int, var1: int, var2: int, var3: int, var4: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState
        public getAndSetBlockState(x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState
        public setFullBlockId(x: int, y: int, z: int, fullId: int): boolean
        public setFullBlockId(x: int, y: int, z: int, layer: int, fullId: int): boolean
        public setBlock(var0: int, var1: int, var2: int, var3: int): boolean
        public setBlockAtLayer(var0: int, var1: int, var2: int, var3: int, var4: int): boolean
        public setBlockState(x: int, y: int, z: int, state: cn.nukkit.blockstate.BlockState): boolean
        public setBlockStateAtLayer(var0: int, var1: int, var2: int, var3: int, var4: cn.nukkit.blockstate.BlockState): boolean
        public setBlock(var0: int, var1: int, var2: int, var3: int, var4: int): boolean
        public setBlockAtLayer(var0: int, var1: int, var2: int, var3: int, var4: int, var5: int): boolean
        public getBlockId(var0: int, var1: int, var2: int): int
        public getBlockId(var0: int, var1: int, var2: int, var3: int): int
        public setBlockId(var0: int, var1: int, var2: int, var3: int): void
        public setBlockId(var0: int, var1: int, var2: int, var3: int, var4: int): void
        public getBlockData(var0: int, var1: int, var2: int): int
        public getBlockData(var0: int, var1: int, var2: int, var3: int): int
        public setBlockData(var0: int, var1: int, var2: int, var3: int): void
        public setBlockData(var0: int, var1: int, var2: int, var3: int, var4: int): void
        public getBlockExtraData(var0: int, var1: int, var2: int): int
        public setBlockExtraData(var0: int, var1: int, var2: int, var3: int): void
        public getBlockSkyLight(var0: int, var1: int, var2: int): int
        public setBlockSkyLight(var0: int, var1: int, var2: int, var3: int): void
        public getBlockLight(var0: int, var1: int, var2: int): int
        public setBlockLight(var0: int, var1: int, var2: int, var3: int): void
        public getHighestBlockAt(var0: int, var1: int): int
        public getHighestBlockAt(var0: int, var1: int, var2: boolean): int
        public getHeightMap(var0: int, var1: int): int
        public setHeightMap(var0: int, var1: int, var2: int): void
        public recalculateHeightMap(): void
        public recalculateHeightMapColumn(var0: int, var1: int): int
        public populateSkyLight(): void
        public getBiomeId(var0: int, var1: int): int
        public setBiomeId(var0: int, var1: int, var2: byte): void
        public setBiomeId(x: int, z: int, biomeId: int): void
        public setBiome(x: int, z: int, biome: cn.nukkit.level.biome.Biome): void
        public isLightPopulated(): boolean
        public setLightPopulated(): void
        public setLightPopulated(var0: boolean): void
        public isPopulated(): boolean
        public setPopulated(): void
        public setPopulated(var0: boolean): void
        public isGenerated(): boolean
        public setGenerated(): void
        public setGenerated(var0: boolean): void
        public addEntity(var0: cn.nukkit.entity.Entity): void
        public removeEntity(var0: cn.nukkit.entity.Entity): void
        public addBlockEntity(var0: cn.nukkit.blockentity.BlockEntity): void
        public removeBlockEntity(var0: cn.nukkit.blockentity.BlockEntity): void
        public getEntities(): java.util.Map<long, cn.nukkit.entity.Entity>
        public getBlockEntities(): java.util.Map<long, cn.nukkit.blockentity.BlockEntity>
        public getTile(var0: int, var1: int, var2: int): cn.nukkit.blockentity.BlockEntity
        public isLoaded(): boolean
        public load(): boolean
        public load(var0: boolean): boolean
        public unload(): boolean
        public unload(var0: boolean): boolean
        public unload(var0: boolean, var1: boolean): boolean
        public initChunk(): void
        public getBiomeIdArray(): byte[]
        public getHeightMapArray(): byte[]
        public getBlockExtraDataArray(): java.util.Map<int, int>
        public getBlockSkyLightArray(): byte[]
        public getBlockLightArray(): byte[]
        public toBinary(): byte[]
        public toFastBinary(): byte[]
        public hasChanged(): boolean
        public setChanged(): void
        public setChanged(var0: boolean): void
        public isBlockChangeAllowed(var0: int, var1: int, var2: int): boolean
        public findBorders(var0: int, var1: int): java.util.List<cn.nukkit.block.Block>
        public isBlockedByBorder(var0: int, var1: int): boolean
        public getChunkSectionCount(): int
        public isOverWorld(): boolean
        public isNether(): boolean
        public isTheEnd(): boolean

    }
}

declare module "cn.nukkit.level.format.FullChunk" {
    declare type FullChunk = cn.nukkit.level.format.FullChunk;
}

declare namespace cn.nukkit.level.terra.delegate {
    declare class PNXItemMeta extends java.lang.Record implements com.dfsek.terra.api.inventory.item.ItemMeta {
        public constructor(innerItem: cn.nukkit.item.Item): void
        public addEnchantment(enchantment: com.dfsek.terra.api.inventory.item.Enchantment, i: int): void
        public getEnchantments(): java.util.Map<com.dfsek.terra.api.inventory.item.Enchantment, int>
        public getHandle(): cn.nukkit.item.Item
        public toString(): string
        public hashCode(): int
        public equals(o: java.lang.Object): boolean
        public innerItem(): cn.nukkit.item.Item
        public getHandle(): java.lang.Object
        innerItem: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.level.terra.delegate.PNXItemMeta" {
    declare const PNXItemMeta = cn.nukkit.level.terra.delegate.PNXItemMeta;
}

declare namespace cn.nukkit.level.terra.delegate {
    declare class PNXEntityType extends java.lang.Record implements com.dfsek.terra.api.entity.EntityType {
        public constructor(entity: cn.nukkit.entity.Entity): void
        public getHandle(): cn.nukkit.entity.Entity
        public toString(): string
        public hashCode(): int
        public equals(o: java.lang.Object): boolean
        public entity(): cn.nukkit.entity.Entity
        public getHandle(): java.lang.Object
        entity: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.level.terra.delegate.PNXEntityType" {
    declare const PNXEntityType = cn.nukkit.level.terra.delegate.PNXEntityType;
}

declare namespace cn.nukkit.level.terra.delegate {
    declare class PNXItemDelegate extends java.lang.Record implements com.dfsek.terra.api.inventory.Item {
        public constructor(innerItem: cn.nukkit.item.Item): void
        public newItemStack(i: int): com.dfsek.terra.api.inventory.ItemStack
        public getMaxDurability(): double
        public getHandle(): cn.nukkit.item.Item
        public toString(): string
        public hashCode(): int
        public equals(o: java.lang.Object): boolean
        public innerItem(): cn.nukkit.item.Item
        public getHandle(): java.lang.Object
        innerItem: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.level.terra.delegate.PNXItemDelegate" {
    declare const PNXItemDelegate = cn.nukkit.level.terra.delegate.PNXItemDelegate;
}

declare namespace cn.nukkit.level.terra.delegate {
    declare class PNXBlockType extends java.lang.Record implements com.dfsek.terra.api.block.BlockType {
        public constructor(innerBlockState: cn.nukkit.blockstate.BlockState): void
        public getDefaultState(): com.dfsek.terra.api.block.state.BlockState
        public isSolid(): boolean
        public isWater(): boolean
        public getHandle(): cn.nukkit.blockstate.BlockState
        public toString(): string
        public hashCode(): int
        public equals(o: java.lang.Object): boolean
        public innerBlockState(): cn.nukkit.blockstate.BlockState
        public getHandle(): java.lang.Object
        innerBlockState: cn.nukkit.blockstate.BlockState

    }
}

declare module "cn.nukkit.level.terra.delegate.PNXBlockType" {
    declare const PNXBlockType = cn.nukkit.level.terra.delegate.PNXBlockType;
}

declare namespace cn.nukkit.level.terra.delegate {
    declare class PNXProtoChunk extends java.lang.Record implements com.dfsek.terra.api.world.chunk.generation.ProtoChunk {
        public constructor(chunk: cn.nukkit.level.format.generic.BaseFullChunk): void
        public getMaxHeight(): int
        public setBlock(i: int, i1: int, i2: int, blockState: com.dfsek.terra.api.block.state.BlockState): void
        public getBlock(i: int, i1: int, i2: int): com.dfsek.terra.api.block.state.BlockState
        public getHandle(): java.lang.Object
        public toString(): string
        public hashCode(): int
        public equals(o: java.lang.Object): boolean
        public chunk(): cn.nukkit.level.format.generic.BaseFullChunk
        chunk: cn.nukkit.level.format.generic.BaseFullChunk

    }
}

declare module "cn.nukkit.level.terra.delegate.PNXProtoChunk" {
    declare const PNXProtoChunk = cn.nukkit.level.terra.delegate.PNXProtoChunk;
}

declare namespace cn.nukkit.level.terra.delegate {
    declare class PNXEnchantmentDelegate extends java.lang.Record implements com.dfsek.terra.api.inventory.item.Enchantment {
        public constructor(innerEnchantment: cn.nukkit.item.enchantment.Enchantment): void
        public canEnchantItem(itemStack: com.dfsek.terra.api.inventory.ItemStack): boolean
        public conflictsWith(enchantment: com.dfsek.terra.api.inventory.item.Enchantment): boolean
        public getID(): string
        public getMaxLevel(): int
        public getHandle(): cn.nukkit.item.enchantment.Enchantment
        public toString(): string
        public hashCode(): int
        public equals(o: java.lang.Object): boolean
        public innerEnchantment(): cn.nukkit.item.enchantment.Enchantment
        public getHandle(): java.lang.Object
        innerEnchantment: cn.nukkit.item.enchantment.Enchantment

    }
}

declare module "cn.nukkit.level.terra.delegate.PNXEnchantmentDelegate" {
    declare const PNXEnchantmentDelegate = cn.nukkit.level.terra.delegate.PNXEnchantmentDelegate;
}

declare namespace cn.nukkit.level.terra.delegate {
    declare class PNXChunkDelegate extends java.lang.Record implements com.dfsek.terra.api.world.chunk.Chunk {
        public constructor(chunk: cn.nukkit.level.format.generic.BaseFullChunk, chunkManager: cn.nukkit.level.ChunkManager, chunkGenerator: com.dfsek.terra.api.world.chunk.generation.ChunkGenerator, configPack: com.dfsek.terra.api.config.ConfigPack, biomeProvider: com.dfsek.terra.api.world.biome.generation.BiomeProvider): void
        public setBlock(i: int, i1: int, i2: int, blockState: com.dfsek.terra.api.block.state.BlockState, b: boolean): void
        public setBlock(i: int, i1: int, i2: int, blockState: com.dfsek.terra.api.block.state.BlockState): void
        public getBlock(i: int, i1: int, i2: int): com.dfsek.terra.api.block.state.BlockState
        public getX(): int
        public getZ(): int
        public getWorld(): com.dfsek.terra.api.world.ServerWorld
        public getHandle(): java.lang.Object
        public toString(): string
        public hashCode(): int
        public equals(o: java.lang.Object): boolean
        public chunk(): cn.nukkit.level.format.generic.BaseFullChunk
        public chunkManager(): cn.nukkit.level.ChunkManager
        public chunkGenerator(): com.dfsek.terra.api.world.chunk.generation.ChunkGenerator
        public configPack(): com.dfsek.terra.api.config.ConfigPack
        public biomeProvider(): com.dfsek.terra.api.world.biome.generation.BiomeProvider
        chunk: cn.nukkit.level.format.generic.BaseFullChunk
        chunkManager: cn.nukkit.level.ChunkManager
        chunkGenerator: com.dfsek.terra.api.world.chunk.generation.ChunkGenerator
        configPack: com.dfsek.terra.api.config.ConfigPack
        biomeProvider: com.dfsek.terra.api.world.biome.generation.BiomeProvider

    }
}

declare module "cn.nukkit.level.terra.delegate.PNXChunkDelegate" {
    declare const PNXChunkDelegate = cn.nukkit.level.terra.delegate.PNXChunkDelegate;
}

declare namespace cn.nukkit.level.terra.delegate {
    declare class PNXProtoWorld extends java.lang.Record implements com.dfsek.terra.api.world.chunk.generation.ProtoWorld {
        public constructor(chunkManager: cn.nukkit.level.ChunkManager, chunkGenerator: com.dfsek.terra.api.world.chunk.generation.ChunkGenerator, configPack: com.dfsek.terra.api.config.ConfigPack, biomeProvider: com.dfsek.terra.api.world.biome.generation.BiomeProvider, centerChunkX: int, centerChunkZ: int): void
        public centerChunkX(): int
        public centerChunkZ(): int
        public getWorld(): com.dfsek.terra.api.world.ServerWorld
        public setBlockState(i: int, i1: int, i2: int, blockState: com.dfsek.terra.api.block.state.BlockState, b: boolean): void
        public spawnEntity(v: double, var1: double, v1: double, var3: com.dfsek.terra.api.entity.EntityType): com.dfsek.terra.api.entity.Entity
        public getBlockState(i: int, i1: int, i2: int): com.dfsek.terra.api.block.state.BlockState
        public getBlockEntity(i: int, i1: int, i2: int): com.dfsek.terra.api.block.entity.BlockEntity
        public getGenerator(): com.dfsek.terra.api.world.chunk.generation.ChunkGenerator
        public getBiomeProvider(): com.dfsek.terra.api.world.biome.generation.BiomeProvider
        public getPack(): com.dfsek.terra.api.config.ConfigPack
        public getSeed(): long
        public getMaxHeight(): int
        public getMinHeight(): int
        public getHandle(): cn.nukkit.level.ChunkManager
        public toString(): string
        public hashCode(): int
        public equals(o: java.lang.Object): boolean
        public chunkManager(): cn.nukkit.level.ChunkManager
        public chunkGenerator(): com.dfsek.terra.api.world.chunk.generation.ChunkGenerator
        public configPack(): com.dfsek.terra.api.config.ConfigPack
        public biomeProvider(): com.dfsek.terra.api.world.biome.generation.BiomeProvider
        public getHandle(): java.lang.Object
        chunkManager: cn.nukkit.level.ChunkManager
        chunkGenerator: com.dfsek.terra.api.world.chunk.generation.ChunkGenerator
        configPack: com.dfsek.terra.api.config.ConfigPack
        biomeProvider: com.dfsek.terra.api.world.biome.generation.BiomeProvider
        centerChunkX: int
        centerChunkZ: int

    }
}

declare module "cn.nukkit.level.terra.delegate.PNXProtoWorld" {
    declare const PNXProtoWorld = cn.nukkit.level.terra.delegate.PNXProtoWorld;
}

declare namespace cn.nukkit.level.terra.handles {
    declare class PNXWorldHandle$State extends java.lang.Object {
        public constructor(str: string): void
        public equals(obj: java.lang.Object): boolean
        public hashCode(): int
        public toString(): string
        static lambda$toString$0(ret: java.lang.StringBuilder, k: string, v: java.lang.Object): void
        public equalsIgnoreAttributes: boolean
        public equalsIgnoreWaterlogged: boolean
        identifier: string
        attributes: java.util.Map<string, java.lang.Object>

    }
}

declare module "cn.nukkit.level.terra.handles.PNXWorldHandle$State" {
    declare const PNXWorldHandle$State = cn.nukkit.level.terra.handles.PNXWorldHandle$State;
}

declare namespace cn.nukkit.level.terra.handles {
    declare class PNXWorldHandle extends java.lang.Object implements com.dfsek.terra.api.handle.WorldHandle {
        public constructor(): void
        public createBlockState(s: string): com.dfsek.terra.api.block.state.BlockState
        public air(): com.dfsek.terra.api.block.state.BlockState
        public getEntity(s: string): com.dfsek.terra.api.entity.EntityType
        static lambda$createBlockState$2(data: java.lang.StringBuilder, k: string, v: java.lang.Object): void
        static lambda$createBlockState$1(statesConverted: java.util.Map, k: string, v: java.lang.Object): void
        static lambda$static$0(k: string, v: java.lang.Object): void
        public static jeBlockMapping: java.util.Map<cn.nukkit.level.terra.handles.PNXWorldHandle$State, java.util.Map<string, java.lang.Object>>
        public static AIR: cn.nukkit.level.terra.delegate.PNXBlockStateDelegate
        public static err: int

    }
}

declare module "cn.nukkit.level.terra.handles.PNXWorldHandle" {
    declare const PNXWorldHandle = cn.nukkit.level.terra.handles.PNXWorldHandle;
}

declare namespace cn.nukkit.level {
    declare interface ChunkLoader {
        public getLoaderId(): int
        public isLoaderActive(): boolean
        public getPosition(): cn.nukkit.level.Position
        public getX(): double
        public getZ(): double
        public getLevel(): cn.nukkit.level.Level
        public onChunkChanged(var0: cn.nukkit.level.format.FullChunk): void
        public onChunkLoaded(var0: cn.nukkit.level.format.FullChunk): void
        public onChunkUnloaded(var0: cn.nukkit.level.format.FullChunk): void
        public onChunkPopulated(var0: cn.nukkit.level.format.FullChunk): void
        public onBlockChanged(var0: cn.nukkit.math.Vector3): void
        public static EMPTY_ARRAY: cn.nukkit.level.ChunkLoader[]

    }
}

declare module "cn.nukkit.level.ChunkLoader" {
    declare type ChunkLoader = cn.nukkit.level.ChunkLoader;
}

declare namespace cn.nukkit.level {
    declare class ListChunkManager extends java.lang.Object implements cn.nukkit.level.ChunkManager {
        public constructor(parent: cn.nukkit.level.ChunkManager): void
        public getBlockIdAt(x: int, y: int, z: int): int
        findBlockAt(x: int, y: int, z: int, layer: int): java.util.Optional<cn.nukkit.block.Block>
        public getBlockIdAt(x: int, y: int, z: int, layer: int): int
        public setBlockFullIdAt(x: int, y: int, z: int, fullId: int): void
        public setBlockFullIdAt(x: int, y: int, z: int, layer: int, fullId: int): void
        public setBlockIdAt(x: int, y: int, z: int, id: int): void
        public setBlockIdAt(x: int, y: int, z: int, layer: int, id: int): void
        public setBlockAt(x: int, y: int, z: int, id: int, data: int): void
        public setBlockAtLayer(x: int, y: int, z: int, layer: int, id: int, data: int): boolean
        public setBlockStateAt(x: int, y: int, z: int, layer: int, state: cn.nukkit.blockstate.BlockState): boolean
        public getBlockStateAt(x: int, y: int, z: int, layer: int): cn.nukkit.blockstate.BlockState
        public getBlockDataAt(x: int, y: int, z: int): int
        public getBlockDataAt(x: int, y: int, z: int, layer: int): int
        public setBlockDataAt(x: int, y: int, z: int, data: int): void
        public setBlockDataAt(x: int, y: int, z: int, layer: int, data: int): void
        public getChunk(chunkX: int, chunkZ: int): cn.nukkit.level.format.generic.BaseFullChunk
        public setChunk(chunkX: int, chunkZ: int): void
        public setChunk(chunkX: int, chunkZ: int, chunk: cn.nukkit.level.format.generic.BaseFullChunk): void
        public getSeed(): long
        public getBlocks(): java.util.List<cn.nukkit.block.Block>
        static lambda$setBlockDataAt$10(x: int, y: int, z: int, layer: int, block: cn.nukkit.block.Block): boolean
        lambda$getBlockDataAt$9(x: int, y: int, z: int, layer: int): int
        static lambda$getBlockDataAt$8(x: int, y: int, z: int, layer: int, block: cn.nukkit.block.Block): boolean
        lambda$getBlockStateAt$7(x: int, y: int, z: int, layer: int): cn.nukkit.blockstate.BlockState
        static lambda$setBlockStateAt$6(x: int, y: int, z: int, layer: int, block: cn.nukkit.block.Block): boolean
        static lambda$setBlockAtLayer$5(x: int, y: int, z: int, layer: int, block: cn.nukkit.block.Block): boolean
        static lambda$setBlockAt$4(x: int, y: int, z: int, block: cn.nukkit.block.Block): boolean
        static lambda$setBlockIdAt$3(x: int, y: int, z: int, layer: int, block: cn.nukkit.block.Block): boolean
        static lambda$setBlockFullIdAt$2(x: int, y: int, z: int, layer: int, block: cn.nukkit.block.Block): boolean
        lambda$getBlockIdAt$1(x: int, y: int, z: int, layer: int): int
        static lambda$findBlockAt$0(x: int, y: int, z: int, layer: int, block: cn.nukkit.block.Block): boolean
        parent: cn.nukkit.level.ChunkManager
        blocks: java.util.List<cn.nukkit.block.Block>

    }
}

declare module "cn.nukkit.level.ListChunkManager" {
    declare const ListChunkManager = cn.nukkit.level.ListChunkManager;
}

declare namespace cn.nukkit.network {
    declare class RakNetInterface$1 extends io.netty.util.concurrent.FastThreadLocal {
        constructor(this$0: cn.nukkit.network.RakNetInterface): void
        initialValue(): java.util.Set<cn.nukkit.network.RakNetInterface$NukkitRakNetSession>
        initialValue(): java.lang.Object
        this$0: cn.nukkit.network.RakNetInterface

    }
}

declare module "cn.nukkit.network.RakNetInterface$1" {
    declare const RakNetInterface$1 = cn.nukkit.network.RakNetInterface$1;
}

declare namespace cn.nukkit.network.rcon {
    declare class RCONServer extends java.lang.Thread {
        public constructor(address: string, port: int, password: string): void
        public receive(): cn.nukkit.network.rcon.RCONCommand
        public respond(channel: java.nio.channels.SocketChannel, id: int, response: string): void
        public close(): void
        public run(): void
        read(key: java.nio.channels.SelectionKey): void
        handle(channel: java.nio.channels.SocketChannel, packet: cn.nukkit.network.rcon.RCONPacket): void
        write(key: java.nio.channels.SelectionKey): void
        send(channel: java.nio.channels.SocketChannel, packet: cn.nukkit.network.rcon.RCONPacket): void
        static lambda$send$0(k: java.nio.channels.SocketChannel): java.util.List
        static log: org.apache.logging.log4j.Logger
        static SERVERDATA_AUTH: int
        static SERVERDATA_AUTH_RESPONSE: int
        static SERVERDATA_EXECCOMMAND: int
        static SERVERDATA_RESPONSE_VALUE: int
        running: boolean
        serverChannel: java.nio.channels.ServerSocketChannel
        selector: java.nio.channels.Selector
        password: string
        rconSessions: java.util.Set<java.nio.channels.SocketChannel>
        receiveQueue: java.util.List<cn.nukkit.network.rcon.RCONCommand>
        sendQueues: java.util.Map<java.nio.channels.SocketChannel, java.util.List<cn.nukkit.network.rcon.RCONPacket>>

    }
}

declare module "cn.nukkit.network.rcon.RCONServer" {
    declare const RCONServer = cn.nukkit.network.rcon.RCONServer;
}

declare namespace cn.nukkit.network {
    declare class CompressBatchedTask extends cn.nukkit.scheduler.AsyncTask {
        public constructor(data: byte[][], targets: java.util.List<java.net.InetSocketAddress>): void
        public constructor(data: byte[][], targets: java.util.List<java.net.InetSocketAddress>, level: int): void
        public constructor(data: byte[][], targets: java.util.List<java.net.InetSocketAddress>, level: int, channel: int): void
        public onRun(): void
        public onCompletion(server: cn.nukkit.Server): void
        public level: int
        public data: byte[][]
        public finalData: byte[]
        public channel: int
        public targets: java.util.List<java.net.InetSocketAddress>

    }
}

declare module "cn.nukkit.network.CompressBatchedTask" {
    declare const CompressBatchedTask = cn.nukkit.network.CompressBatchedTask;
}

declare namespace cn.nukkit.network {
    declare class RakNetInterface extends java.lang.Object implements com.nukkitx.network.raknet.RakNetServerListener, cn.nukkit.network.AdvancedSourceInterface {
        public constructor(server: cn.nukkit.Server): void
        public setNetwork(network: cn.nukkit.network.Network): void
        public process(): boolean
        public getNetworkLatency(player: cn.nukkit.Player): int
        public close(player: cn.nukkit.Player): void
        public close(player: cn.nukkit.Player, reason: string): void
        public shutdown(): void
        public emergencyShutdown(): void
        public blockAddress(address: java.net.InetAddress): void
        public blockAddress(address: java.net.InetAddress, timeout: int): void
        public unblockAddress(address: java.net.InetAddress): void
        public sendRawPacket(socketAddress: java.net.InetSocketAddress, payload: io.netty.buffer.ByteBuf): void
        public setName(name: string): void
        public putPacket(player: cn.nukkit.Player, packet: cn.nukkit.network.protocol.DataPacket): int
        public putPacket(player: cn.nukkit.Player, packet: cn.nukkit.network.protocol.DataPacket, needACK: boolean): int
        public putPacket(player: cn.nukkit.Player, packet: cn.nukkit.network.protocol.DataPacket, needACK: boolean, immediate: boolean): int
        public onConnectionRequest(inetSocketAddress: java.net.InetSocketAddress): boolean
        public onQuery(inetSocketAddress: java.net.InetSocketAddress): byte[]
        public onSessionCreation(session: com.nukkitx.network.raknet.RakNetServerSession): void
        public onUnhandledDatagram(ctx: io.netty.channel.ChannelHandlerContext, datagramPacket: io.netty.channel.socket.DatagramPacket): void
        public putResourcePacket(player: cn.nukkit.Player, packet: cn.nukkit.network.protocol.DataPacket): int
        lambda$onSessionCreation$3(nukkitSession: cn.nukkit.network.RakNetInterface$NukkitRakNetSession): void
        static lambda$emergencyShutdown$2(future: io.netty.util.concurrent.ScheduledFuture): void
        static lambda$shutdown$1(future: io.netty.util.concurrent.ScheduledFuture): void
        lambda$new$0(): void
        static log: org.apache.logging.log4j.Logger
        server: cn.nukkit.Server
        network: cn.nukkit.network.Network
        raknet: com.nukkitx.network.raknet.RakNetServer
        sessions: java.util.Map<java.net.InetSocketAddress, cn.nukkit.network.RakNetInterface$NukkitRakNetSession>
        sessionCreationQueue: java.util.Queue<cn.nukkit.network.RakNetInterface$NukkitRakNetSession>
        tickFutures: java.util.Set<short, float>
        sessionsToTick: io.netty.util.concurrent.FastThreadLocal<java.util.Set<cn.nukkit.network.RakNetInterface$NukkitRakNetSession>>
        advertisement: byte[]

    }
}

declare module "cn.nukkit.network.RakNetInterface" {
    declare const RakNetInterface = cn.nukkit.network.RakNetInterface;
}

declare namespace cn.nukkit.network {
    declare interface SourceInterface {
        public putPacket(var0: cn.nukkit.Player, var1: cn.nukkit.network.protocol.DataPacket): int
        public putPacket(var0: cn.nukkit.Player, var1: cn.nukkit.network.protocol.DataPacket, var2: boolean): int
        public putPacket(var0: cn.nukkit.Player, var1: cn.nukkit.network.protocol.DataPacket, var2: boolean, var3: boolean): int
        public getNetworkLatency(var0: cn.nukkit.Player): int
        public close(var0: cn.nukkit.Player): void
        public close(var0: cn.nukkit.Player, var1: string): void
        public setName(var0: string): void
        public process(): boolean
        public shutdown(): void
        public emergencyShutdown(): void
        public putResourcePacket(var0: cn.nukkit.Player, var1: cn.nukkit.network.protocol.DataPacket): int

    }
}

declare module "cn.nukkit.network.SourceInterface" {
    declare type SourceInterface = cn.nukkit.network.SourceInterface;
}

declare namespace cn.nukkit.network {
    declare class RakNetInterface$NukkitRakNetSession extends java.lang.Object implements com.nukkitx.network.raknet.RakNetSessionListener {
        public onSessionChangeState(rakNetState: com.nukkitx.network.raknet.RakNetState): void
        public onDisconnect(disconnectReason: com.nukkitx.network.util.DisconnectReason): void
        public onEncapsulated(packet: com.nukkitx.network.raknet.EncapsulatedPacket): void
        public onDirect(byteBuf: io.netty.buffer.ByteBuf): void
        disconnect(message: string): void
        sendOutbound(): void
        sendPackets(packets: java.util.Collection<cn.nukkit.network.protocol.DataPacket>): void
        sendPacket(payload: byte[]): void
        sendPacketImmediately(packet: cn.nukkit.network.protocol.DataPacket): void
        sendResourcePacket(packet: cn.nukkit.network.protocol.DataPacket): void
        public constructor(var0: cn.nukkit.network.RakNetInterface, raknet: com.nukkitx.network.raknet.RakNetServerSession): void
        raknet: com.nukkitx.network.raknet.RakNetServerSession
        inbound: java.util.Queue<cn.nukkit.network.protocol.DataPacket>
        outbound: java.util.Queue<cn.nukkit.network.protocol.DataPacket>
        disconnectReason: string
        player: cn.nukkit.Player
        this$0: cn.nukkit.network.RakNetInterface

    }
}

declare module "cn.nukkit.network.RakNetInterface$NukkitRakNetSession" {
    declare const RakNetInterface$NukkitRakNetSession = cn.nukkit.network.RakNetInterface$NukkitRakNetSession;
}

declare namespace cn.nukkit.network {
    declare class LittleEndianByteBufOutputStream extends io.netty.buffer.ByteBufOutputStream {
        public constructor(buffer: io.netty.buffer.ByteBuf): void
        public writeChar(v: int): void
        public writeDouble(v: double): void
        public writeFloat(v: float): void
        public writeShort(val: int): void
        public writeLong(val: long): void
        public writeInt(val: int): void
        public writeUTF(string: string): void
        buffer: io.netty.buffer.ByteBuf

    }
}

declare module "cn.nukkit.network.LittleEndianByteBufOutputStream" {
    declare const LittleEndianByteBufOutputStream = cn.nukkit.network.LittleEndianByteBufOutputStream;
}

declare namespace cn.nukkit.network.protocol {
    declare class EntityEventPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: int
        public static NONE: int
        public static JUMP: int
        public static HURT_ANIMATION: int
        public static DEATH_ANIMATION: int
        public static ARM_SWING: int
        public static ATTACK_STOP: int
        public static TAME_FAIL: int
        public static TAME_SUCCESS: int
        public static SHAKE_WET: int
        public static USE_ITEM: int
        public static EAT_GRASS_ANIMATION: int
        public static FISH_HOOK_BUBBLE: int
        public static FISH_HOOK_POSITION: int
        public static FISH_HOOK_HOOK: int
        public static FISH_HOOK_TEASE: int
        public static SQUID_INK_CLOUD: int
        public static ZOMBIE_VILLAGER_CURE: int
        public static AMBIENT_SOUND: int
        public static RESPAWN: int
        public static IRON_GOLEM_OFFER_FLOWER: int
        public static IRON_GOLEM_WITHDRAW_FLOWER: int
        public static LOVE_PARTICLES: int
        public static VILLAGER_ANGRY: int
        public static VILLAGER_HAPPY: int
        public static WITCH_SPELL_PARTICLES: int
        public static FIREWORK_EXPLOSION: int
        public static IN_LOVE_HEARTS: int
        public static SILVERFISH_SPAWN_ANIMATION: int
        public static GUARDIAN_ATTACK_ANIMATION: int
        public static WITCH_DRINK_POTION: int
        public static WITCH_THROW_POTION: int
        public static MINECART_TNT_PRIME_FUSE: int
        public static PRIME_CREEPER: int
        public static AIR_SUPPLY: int
        public static ENCHANT: int
        public static ELDER_GUARDIAN_CURSE: int
        public static AGENT_ARM_SWING: int
        public static ENDER_DRAGON_DEATH: int
        public static DUST_PARTICLES: int
        public static ARROW_SHAKE: int
        public static EATING_ITEM: int
        public static BABY_ANIMAL_FEED: int
        public static DEATH_SMOKE_CLOUD: int
        public static COMPLETE_TRADE: int
        public static REMOVE_LEASH: int
        public static CARAVAN: int
        public static CONSUME_TOTEM: int
        public static PLAYER_CHECK_TREASURE_HUNTER_ACHIEVEMENT: int
        public static ENTITY_SPAWN: int
        public static DRAGON_PUKE: int
        public static MERGE_ITEMS: int
        public static START_SWIMMING: int
        public static BALLOON_POP: int
        public static TREASURE_HUNT: int
        public static SUMMON_AGENT: int
        public static FINISHED_CHARGING_CROSSBOW: int
        public static LANDED_ON_GROUND: int
        public static ENTITY_GROW_UP: int
        public static VIBRATION_DETECTE: int
        public eid: long
        public event: int
        public data: int

    }
}

declare module "cn.nukkit.network.protocol.EntityEventPacket" {
    declare const EntityEventPacket = cn.nukkit.network.protocol.EntityEventPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class CompletedUsingItemPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public static ACTION_UNKNOWN: int
        public static ACTION_EQUIP_ARMOR: int
        public static ACTION_EAT: int
        public static ACTION_ATTACK: int
        public static ACTION_CONSUME: int
        public static ACTION_THROW: int
        public static ACTION_SHOOT: int
        public static ACTION_PLACE: int
        public static ACTION_FILL_BOTTLE: int
        public static ACTION_FILL_BUCKET: int
        public static ACTION_POUR_BUCKET: int
        public static ACTION_USE_TOOL: int
        public static ACTION_INTERACT: int
        public static ACTION_RETRIEVE: int
        public static ACTION_DYED: int
        public static ACTION_TRADED: int
        public itemId: int
        public action: int

    }
}

declare module "cn.nukkit.network.protocol.CompletedUsingItemPacket" {
    declare const CompletedUsingItemPacket = cn.nukkit.network.protocol.CompletedUsingItemPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ContainerClosePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public windowId: int
        public wasServerInitiated: boolean

    }
}

declare module "cn.nukkit.network.protocol.ContainerClosePacket" {
    declare const ContainerClosePacket = cn.nukkit.network.protocol.ContainerClosePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class BatchPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public trim(): void
        public static NETWORK_ID: byte
        public payload: byte[]

    }
}

declare module "cn.nukkit.network.protocol.BatchPacket" {
    declare const BatchPacket = cn.nukkit.network.protocol.BatchPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class EmotePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public runtimeId: long
        public emoteID: string
        public flags: byte

    }
}

declare module "cn.nukkit.network.protocol.EmotePacket" {
    declare const EmotePacket = cn.nukkit.network.protocol.EmotePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PlayStatusPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public static LOGIN_SUCCESS: int
        public static LOGIN_FAILED_CLIENT: int
        public static LOGIN_FAILED_SERVER: int
        public static PLAYER_SPAWN: int
        public static LOGIN_FAILED_INVALID_TENANT: int
        public static LOGIN_FAILED_VANILLA_EDU: int
        public static LOGIN_FAILED_EDU_VANILLA: int
        public static LOGIN_FAILED_SERVER_FULL: int
        public status: int

    }
}

declare module "cn.nukkit.network.protocol.PlayStatusPacket" {
    declare const PlayStatusPacket = cn.nukkit.network.protocol.PlayStatusPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class LevelSoundEventPacketV1 extends cn.nukkit.network.protocol.LevelSoundEventPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public sound: int
        public x: float
        public y: float
        public z: float
        public extraData: int
        public pitch: int
        public isBabyMob: boolean
        public isGlobal: boolean

    }
}

declare module "cn.nukkit.network.protocol.LevelSoundEventPacketV1" {
    declare const LevelSoundEventPacketV1 = cn.nukkit.network.protocol.LevelSoundEventPacketV1;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetScorePacket$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$scoreboard$data$ScorerType: int[]

    }
}

declare module "cn.nukkit.network.protocol.SetScorePacket$1" {
    declare const SetScorePacket$1 = cn.nukkit.network.protocol.SetScorePacket$1;
}

declare namespace cn.nukkit.network.protocol {
    declare class BlockEntityDataPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public x: int
        public y: int
        public z: int
        public namedTag: byte[]

    }
}

declare module "cn.nukkit.network.protocol.BlockEntityDataPacket" {
    declare const BlockEntityDataPacket = cn.nukkit.network.protocol.BlockEntityDataPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetPlayerGameTypePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public gamemode: int

    }
}

declare module "cn.nukkit.network.protocol.SetPlayerGameTypePacket" {
    declare const SetPlayerGameTypePacket = cn.nukkit.network.protocol.SetPlayerGameTypePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PositionTrackingDBClientRequestPacket extends cn.nukkit.network.protocol.DataPacket {
        public getAction(): cn.nukkit.network.protocol.PositionTrackingDBClientRequestPacket$Action
        public getTrackingId(): int
        public encode(): void
        public decode(): void
        public pid(): byte
        public toString(): string
        public constructor(): void
        public static NETWORK_ID: byte
        static ACTIONS: cn.nukkit.network.protocol.PositionTrackingDBClientRequestPacket$Action[]
        action: cn.nukkit.network.protocol.PositionTrackingDBClientRequestPacket$Action
        trackingId: int

    }
}

declare module "cn.nukkit.network.protocol.PositionTrackingDBClientRequestPacket" {
    declare const PositionTrackingDBClientRequestPacket = cn.nukkit.network.protocol.PositionTrackingDBClientRequestPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class MapInfoRequestPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public mapId: long

    }
}

declare module "cn.nukkit.network.protocol.MapInfoRequestPacket" {
    declare const MapInfoRequestPacket = cn.nukkit.network.protocol.MapInfoRequestPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ResourcePackClientResponsePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public static STATUS_REFUSED: byte
        public static STATUS_SEND_PACKS: byte
        public static STATUS_HAVE_ALL_PACKS: byte
        public static STATUS_COMPLETED: byte
        public responseStatus: byte
        public packEntries: cn.nukkit.network.protocol.ResourcePackClientResponsePacket$Entry[]

    }
}

declare module "cn.nukkit.network.protocol.ResourcePackClientResponsePacket" {
    declare const ResourcePackClientResponsePacket = cn.nukkit.network.protocol.ResourcePackClientResponsePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class AgentActionEventPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        requestId: string
        actionType: cn.nukkit.network.protocol.types.AgentActionType
        responseJson: string

    }
}

declare module "cn.nukkit.network.protocol.AgentActionEventPacket" {
    declare const AgentActionEventPacket = cn.nukkit.network.protocol.AgentActionEventPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetTitlePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public getTitleAction(): cn.nukkit.network.protocol.SetTitlePacket$TitleAction
        public setTitleAction(type: cn.nukkit.network.protocol.SetTitlePacket$TitleAction): void
        public getText(): string
        public setText(text: string): void
        public getFadeInTime(): int
        public setFadeInTime(fadeInTime: int): void
        public getStayTime(): int
        public setStayTime(stayTime: int): void
        public getFadeOutTime(): int
        public setFadeOutTime(fadeOutTime: int): void
        public getXuid(): string
        public setXuid(xuid: string): void
        public getPlatformOnlineId(): string
        public setPlatformOnlineId(platformOnlineId: string): void
        public toString(): string
        public static NETWORK_ID: byte
        static TITLE_ACTIONS: cn.nukkit.network.protocol.SetTitlePacket$TitleAction[]
        public static TYPE_CLEAR: int
        public static TYPE_RESET: int
        public static TYPE_TITLE: int
        public static TYPE_SUBTITLE: int
        public static TYPE_ACTION_BAR: int
        public static TYPE_ANIMATION_TIMES: int
        public static TYPE_TITLE_JSON: int
        public static TYPE_SUBTITLE_JSON: int
        public static TYPE_ACTIONBAR_JSON: int
        public type: int
        public text: string
        public fadeInTime: int
        public stayTime: int
        public fadeOutTime: int
        public xuid: string
        public platformOnlineId: string

    }
}

declare module "cn.nukkit.network.protocol.SetTitlePacket" {
    declare const SetTitlePacket = cn.nukkit.network.protocol.SetTitlePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class AvailableCommandsPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        lambda$encode$4(name: string, values: java.util.List): void
        lambda$encode$3(enums: java.util.List, postFixes: java.util.List, name: string, cmdData: cn.nukkit.command.data.CommandDataVersions): void
        lambda$encode$2(enumValues: java.util.List, indexWriter: java.util.function.ObjIntConsumer, cmdEnum: cn.nukkit.command.data.CommandEnum): void
        static lambda$encode$1(enumsSet: java.util.LinkedHashSet, enumValuesSet: java.util.LinkedHashSet, postFixesSet: java.util.LinkedHashSet, name: string, data: cn.nukkit.command.data.CommandDataVersions): void
        static lambda$static$0(s: cn.nukkit.utils.BinaryStream, v: int): void
        public static NETWORK_ID: byte
        static WRITE_BYTE: java.util.function.ObjIntConsumer<cn.nukkit.utils.BinaryStream>
        static WRITE_SHORT: java.util.function.ObjIntConsumer<cn.nukkit.utils.BinaryStream>
        static WRITE_INT: java.util.function.ObjIntConsumer<cn.nukkit.utils.BinaryStream>
        public static ARG_FLAG_VALID: int
        public static ARG_FLAG_ENUM: int
        public static ARG_FLAG_POSTFIX: int
        public static ARG_FLAG_SOFT_ENUM: int
        public static ARG_TYPE_INT: int
        public static ARG_TYPE_FLOAT: int
        public static ARG_TYPE_VALUE: int
        public static ARG_TYPE_WILDCARD_INT: int
        public static ARG_TYPE_OPERATOR: int
        public static ARG_TYPE_COMPARE_OPERATOR: int
        public static ARG_TYPE_TARGET: int
        public static ARG_TYPE_WILDCARD_TARGET: int
        public static ARG_TYPE_FILE_PATH: int
        public static ARG_TYPE_FULL_INTEGER_RANGE: int
        public static ARG_TYPE_EQUIPMENT_SLOT: int
        public static ARG_TYPE_STRING: int
        public static ARG_TYPE_BLOCK_POSITION: int
        public static ARG_TYPE_POSITION: int
        public static ARG_TYPE_MESSAGE: int
        public static ARG_TYPE_RAWTEXT: int
        public static ARG_TYPE_JSON: int
        public static ARG_TYPE_BLOCK_STATES: int
        public static ARG_TYPE_COMMAND: int
        public commands: java.util.Map<string, cn.nukkit.command.data.CommandDataVersions>
        public softEnums: java.util.Map<string, java.util.List<string>>

    }
}

declare module "cn.nukkit.network.protocol.AvailableCommandsPacket" {
    declare const AvailableCommandsPacket = cn.nukkit.network.protocol.AvailableCommandsPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class StructureBlockUpdatePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string

    }
}

declare module "cn.nukkit.network.protocol.StructureBlockUpdatePacket" {
    declare const StructureBlockUpdatePacket = cn.nukkit.network.protocol.StructureBlockUpdatePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class DisconnectPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public hideDisconnectionScreen: boolean
        public message: string

    }
}

declare module "cn.nukkit.network.protocol.DisconnectPacket" {
    declare const DisconnectPacket = cn.nukkit.network.protocol.DisconnectPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class CommandRequestPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public static TYPE_PLAYER: int
        public static TYPE_COMMAND_BLOCK: int
        public static TYPE_MINECART_COMMAND_BLOCK: int
        public static TYPE_DEV_CONSOLE: int
        public static TYPE_AUTOMATION_PLAYER: int
        public static TYPE_CLIENT_AUTOMATION: int
        public static TYPE_DEDICATED_SERVER: int
        public static TYPE_ENTITY: int
        public static TYPE_VIRTUAL: int
        public static TYPE_GAME_ARGUMENT: int
        public static TYPE_INTERNAL: int
        public command: string
        public data: cn.nukkit.network.protocol.types.CommandOriginData

    }
}

declare module "cn.nukkit.network.protocol.CommandRequestPacket" {
    declare const CommandRequestPacket = cn.nukkit.network.protocol.CommandRequestPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SimpleEventPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public unknown: short

    }
}

declare module "cn.nukkit.network.protocol.SimpleEventPacket" {
    declare const SimpleEventPacket = cn.nukkit.network.protocol.SimpleEventPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class LevelEventPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public static EVENT_SOUND_CLICK: int
        public static EVENT_SOUND_CLICK_FAIL: int
        public static EVENT_SOUND_SHOOT: int
        public static EVENT_SOUND_DOOR: int
        public static EVENT_SOUND_FIZZ: int
        public static EVENT_SOUND_TNT: int
        public static EVENT_SOUND_PLAY_RECORDING: int
        public static EVENT_SOUND_GHAST: int
        public static EVENT_SOUND_GHAST_SHOOT: int
        public static EVENT_SOUND_BLAZE_SHOOT: int
        public static EVENT_SOUND_DOOR_BUMP: int
        public static EVENT_SOUND_DOOR_CRASH: int
        public static EVENT_SOUND_ZOMBIE_INFECTED: int
        public static EVENT_SOUND_ZOMBIE_CONVERTED: int
        public static EVENT_SOUND_ENDERMAN_TELEPORT: int
        public static EVENT_SOUND_ANVIL_BREAK: int
        public static EVENT_SOUND_ANVIL_USE: int
        public static EVENT_SOUND_ANVIL_FALL: int
        public static EVENT_SOUND_ITEM_DROP: int
        public static EVENT_SOUND_ITEM_THROWN: int
        public static EVENT_SOUND_PORTAL: int
        public static EVENT_SOUND_ITEM_FRAME_ITEM_ADDED: int
        public static EVENT_SOUND_ITEM_FRAME_REMOVED: int
        public static EVENT_SOUND_ITEM_FRAME_PLACED: int
        public static EVENT_SOUND_ITEM_FRAME_ITEM_REMOVED: int
        public static EVENT_SOUND_ITEM_FRAME_ITEM_ROTATED: int
        public static EVENT_SOUND_CAMERA_TAKE_PICTURE: int
        public static EVENT_SOUND_EXPERIENCE_ORB: int
        public static EVENT_SOUND_TOTEM: int
        public static EVENT_SOUND_ARMOR_STAND_BREAK: int
        public static EVENT_SOUND_ARMOR_STAND_HIT: int
        public static EVENT_SOUND_ARMOR_STAND_FALL: int
        public static EVENT_SOUND_ARMOR_STAND_PLACE: int
        public static EVENT_SOUND_POINTED_DRIPSTONE_LAND: int
        public static EVENT_SOUND_DYE_USED: int
        public static EVENT_SOUND_INK_SACE_USED: int
        public static EVENT_GUARDIAN_CURSE: int
        public static EVENT_PARTICLE_DEATH_SMOKE: int
        public static EVENT_PARTICLE_BLOCK_FORCE_FIELD: int
        public static EVENT_PARTICLE_PROJECTILE_HIT: int
        public static EVENT_PARTICLE_DRAGON_EGG_TELEPORT: int
        public static EVENT_PARTICLE_CROP_EATEN: int
        public static EVENT_PARTICLE_CRIT: int
        public static EVENT_PARTICLE_ENDERMAN_TELEPORT: int
        public static EVENT_PARTICLE_PUNCH_BLOCK: int
        public static EVENT_PARTICLE_BUBBLES: int
        public static EVENT_PARTICLE_EVAPORATE: int
        public static EVENT_PARTICLE_DESTROY_ARMOR_STAND: int
        public static EVENT_PARTICLE_BREAKING_EGG: int
        public static EVENT_PARTICLE_DESTROY_EGG: int
        public static EVENT_PARTICLE_EVAPORATE_WATER: int
        public static EVENT_PARTICLE_DESTROY_BLOCK_NO_SOUND: int
        public static EVENT_PARTICLE_KNOCKBACK_ROAR: int
        public static EVENT_PARTICLE_TELEPORT_TRAIL: int
        public static EVENT_PARTICLE_POINT_CLOUD: int
        public static EVENT_PARTICLE_EXPLOSION: int
        public static EVENT_PARTICLE_BLOCK_EXPLOSION: int
        public static EVENT_PARTICLE_VIBRATION_SIGNAL: int
        public static EVENT_PARTICLE_DRIPSTONE_DRIP: int
        public static EVENT_PARTICLE_FIZZ_EFFECT: int
        public static EVENT_PARTICLE_WAX_ON: int
        public static EVENT_PARTICLE_WAX_OFF: int
        public static EVENT_PARTICLE_SCRAPE: int
        public static EVENT_PARTICLE_ELECTRIC_SPARK: int
        public static EVENT_PARTICLE_TURTLE_EGG: int
        public static EVENT_PARTICLE_SCULK_SHRIEK: int
        public static EVENT_PARTICLE_SCULK_CATALYST_BLOOM: int
        public static EVENT_PARTICLE_SCULK_CHARGE: int
        public static EVENT_PARTICLE_SCULK_CHARGE_POP: int
        public static EVENT_PARTICLE_SONIC_EXPLOSION: int
        public static EVENT_SOUND_BUTTON_CLICK: int
        public static EVENT_SOUND_EXPLODE: int
        public static EVENT_CAULDRON_DYE_ARMOR: int
        public static EVENT_CAULDRON_CLEAN_ARMOR: int
        public static EVENT_CAULDRON_FILL_POTION: int
        public static EVENT_CAULDRON_TAKE_POTION: int
        public static EVENT_SOUND_SPLASH: int
        public static EVENT_CAULDRON_TAKE_WATER: int
        public static EVENT_CAULDRON_ADD_DYE: int
        public static EVENT_CAULDRON_CLEAN_BANNER: int
        public static EVENT_CAULDRON_FLUSH: int
        public static EVENT_AGENT_SPAWN_EFFECT: int
        public static EVENT_CAULDRON_FILL_LAVA: int
        public static EVENT_CAULDRON_TAKE_LAVA: int
        public static EVENT_CAULDRON_FILL_POWDER_SNOW: int
        public static EVENT_CAULDRON_TAKE_POWDER_SNOW: int
        public static EVENT_PARTICLE_SHOOT: int
        public static EVENT_PARTICLE_DESTROY: int
        public static EVENT_PARTICLE_SPLASH: int
        public static EVENT_PARTICLE_EYE_DESPAWN: int
        public static EVENT_PARTICLE_SPAWN: int
        public static EVENT_PARTICLE_BONEMEAL: int
        public static EVENT_START_RAIN: int
        public static EVENT_START_THUNDER: int
        public static EVENT_STOP_RAIN: int
        public static EVENT_STOP_THUNDER: int
        public static EVENT_GLOBAL_PAUSE: int
        public static EVENT_SIM_TIME_STEP: int
        public static EVENT_SIM_TIME_SCALE: int
        public static EVENT_SOUND_CAULDRON: int
        public static EVENT_SOUND_CAULDRON_DYE_ARMOR: int
        public static EVENT_SOUND_CAULDRON_FILL_POTION: int
        public static EVENT_SOUND_CAULDRON_FILL_WATER: int
        public static EVENT_SOUND_CAULDRON_FILL_POWDER_SNOW: int
        public static EVENT_SOUND_CAULDRON_TAKE_POWDER_SNOW: int
        public static EVENT_BLOCK_START_BREAK: int
        public static EVENT_BLOCK_STOP_BREAK: int
        public static EVENT_BLOCK_UPDATE_BREAK: int
        public static EVENT_SET_DATA: int
        public static EVENT_PLAYERS_SLEEPING: int
        public static EVENT_SLEEPING_PLAYERS: int
        public static EVENT_JUMP_PREVENTED: int
        public static EVENT_ADD_PARTICLE_MASK: int
        public evid: int
        public x: float
        public y: float
        public z: float
        public data: int

    }
}

declare module "cn.nukkit.network.protocol.LevelEventPacket" {
    declare const LevelEventPacket = cn.nukkit.network.protocol.LevelEventPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PositionTrackingDBServerBroadcastPacket extends cn.nukkit.network.protocol.DataPacket {
        requireTag(): cn.nukkit.nbt.tag.CompoundTag
        public setAction(action: cn.nukkit.network.protocol.PositionTrackingDBServerBroadcastPacket$Action): void
        public setTrackingId(trackingId: int): void
        public getPosition(): cn.nukkit.math.BlockVector3
        public setPosition(position: cn.nukkit.math.BlockVector3): void
        public setPosition(position: cn.nukkit.math.Vector3): void
        public setPosition(x: int, y: int, z: int): void
        public getStatus(): int
        public setStatus(status: int): void
        public getVersion(): int
        public setVersion(status: int): void
        public getDimension(): int
        public setDimension(dimension: int): void
        public encode(): void
        public decode(): void
        public pid(): byte
        public clone(): cn.nukkit.network.protocol.PositionTrackingDBServerBroadcastPacket
        public toString(): string
        public constructor(): void
        public clone(): cn.nukkit.network.protocol.DataPacket
        public clone(): java.lang.Object
        public static NETWORK_ID: byte
        static ACTIONS: cn.nukkit.network.protocol.PositionTrackingDBServerBroadcastPacket$Action[]
        action: cn.nukkit.network.protocol.PositionTrackingDBServerBroadcastPacket$Action
        trackingId: int
        tag: cn.nukkit.nbt.tag.CompoundTag

    }
}

declare module "cn.nukkit.network.protocol.PositionTrackingDBServerBroadcastPacket" {
    declare const PositionTrackingDBServerBroadcastPacket = cn.nukkit.network.protocol.PositionTrackingDBServerBroadcastPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class AdventureSettingsPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public getFlag(flag: int): boolean
        public setFlag(flag: int, value: boolean): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public static PERMISSION_NORMAL: int
        public static PERMISSION_OPERATOR: int
        public static PERMISSION_HOST: int
        public static PERMISSION_AUTOMATION: int
        public static PERMISSION_ADMIN: int
        public static BITFLAG_SECOND_SET: int
        public static WORLD_IMMUTABLE: int
        public static NO_PVM: int
        public static NO_MVP: int
        public static SHOW_NAME_TAGS: int
        public static AUTO_JUMP: int
        public static ALLOW_FLIGHT: int
        public static NO_CLIP: int
        public static WORLD_BUILDER: int
        public static FLYING: int
        public static MUTED: int
        public static MINE: int
        public static DOORS_AND_SWITCHES: int
        public static OPEN_CONTAINERS: int
        public static ATTACK_PLAYERS: int
        public static ATTACK_MOBS: int
        public static OPERATOR: int
        public static TELEPORT: int
        public static BUILD: int
        public static DEFAULT_LEVEL_PERMISSIONS: int
        public flags: long
        public commandPermission: long
        public flags2: long
        public playerPermission: long
        public customFlags: long
        public entityUniqueId: long

    }
}

declare module "cn.nukkit.network.protocol.AdventureSettingsPacket" {
    declare const AdventureSettingsPacket = cn.nukkit.network.protocol.AdventureSettingsPacket;
}

declare namespace cn.nukkit.network.protocol.types {
    declare class CommandOriginData extends java.lang.Object {
        public constructor(type: cn.nukkit.network.protocol.types.CommandOriginData$Origin, uuid: java.util.UUID, requestId: string, varlong: long): void
        public getVarLong(): java.util.OptionalLong
        public toString(): string
        public type: cn.nukkit.network.protocol.types.CommandOriginData$Origin
        public uuid: java.util.UUID
        public requestId: string
        varlong: long

    }
}

declare module "cn.nukkit.network.protocol.types.CommandOriginData" {
    declare const CommandOriginData = cn.nukkit.network.protocol.types.CommandOriginData;
}

declare namespace cn.nukkit.network.protocol.types {
    declare class BlockChangeEntry extends java.lang.Record {
        public constructor(blockPos: cn.nukkit.math.BlockVector3, runtimeID: int, updateFlags: int, messageEntityID: long, var4: cn.nukkit.network.protocol.types.BlockChangeEntry$MessageType): void
        public toString(): string
        public hashCode(): int
        public equals(o: java.lang.Object): boolean
        public blockPos(): cn.nukkit.math.BlockVector3
        public runtimeID(): int
        public updateFlags(): int
        public messageEntityID(): long
        public messageType(): cn.nukkit.network.protocol.types.BlockChangeEntry$MessageType
        blockPos: cn.nukkit.math.BlockVector3
        runtimeID: int
        updateFlags: int
        messageEntityID: long
        messageType: cn.nukkit.network.protocol.types.BlockChangeEntry$MessageType

    }
}

declare module "cn.nukkit.network.protocol.types.BlockChangeEntry" {
    declare const BlockChangeEntry = cn.nukkit.network.protocol.types.BlockChangeEntry;
}

declare namespace cn.nukkit.network.protocol.types {
    declare class BlockChangeEntry$MessageType extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.types.BlockChangeEntry$MessageType[]
        public static valueOf(name: string): cn.nukkit.network.protocol.types.BlockChangeEntry$MessageType
        constructor(): void
        static $values(): cn.nukkit.network.protocol.types.BlockChangeEntry$MessageType[]
        public static NONE: cn.nukkit.network.protocol.types.BlockChangeEntry$MessageType
        public static CREATE: cn.nukkit.network.protocol.types.BlockChangeEntry$MessageType
        public static DESTROY: cn.nukkit.network.protocol.types.BlockChangeEntry$MessageType
        static $VALUES: cn.nukkit.network.protocol.types.BlockChangeEntry$MessageType[]

    }
}

declare module "cn.nukkit.network.protocol.types.BlockChangeEntry$MessageType" {
    declare const BlockChangeEntry$MessageType = cn.nukkit.network.protocol.types.BlockChangeEntry$MessageType;
}

declare namespace cn.nukkit.network.protocol.types {
    declare interface ContainerIds {
        public static NONE: int
        public static INVENTORY: int
        public static FIRST: int
        public static LAST: int
        public static OFFHAND: int
        public static ARMOR: int
        public static CREATIVE: int
        public static HOTBAR: int
        public static FIXED_INVENTORY: int
        public static UI: int

    }
}

declare module "cn.nukkit.network.protocol.types.ContainerIds" {
    declare type ContainerIds = cn.nukkit.network.protocol.types.ContainerIds;
}

declare namespace cn.nukkit.network.protocol.types {
    declare class NetworkInventoryAction extends java.lang.Object {
        public constructor(): void
        public read(packet: cn.nukkit.network.protocol.InventoryTransactionPacket): cn.nukkit.network.protocol.types.NetworkInventoryAction
        public write(packet: cn.nukkit.network.protocol.InventoryTransactionPacket): void
        public createInventoryAction(player: cn.nukkit.Player): cn.nukkit.inventory.transaction.action.InventoryAction
        public toString(): string
        static log: org.apache.logging.log4j.Logger
        public static EMPTY_ARRAY: cn.nukkit.network.protocol.types.NetworkInventoryAction[]
        public static SOURCE_CONTAINER: int
        public static SOURCE_WORLD: int
        public static SOURCE_CREATIVE: int
        public static SOURCE_TODO: int
        public static SOURCE_CRAFT_SLOT: int
        public static SOURCE_TYPE_CRAFTING_ADD_INGREDIENT: int
        public static SOURCE_TYPE_CRAFTING_REMOVE_INGREDIENT: int
        public static SOURCE_TYPE_CRAFTING_RESULT: int
        public static SOURCE_TYPE_CRAFTING_USE_INGREDIENT: int
        public static SOURCE_TYPE_ANVIL_INPUT: int
        public static SOURCE_TYPE_ANVIL_MATERIAL: int
        public static SOURCE_TYPE_ANVIL_RESULT: int
        public static SOURCE_TYPE_ANVIL_OUTPUT: int
        public static SOURCE_TYPE_ENCHANT_INPUT: int
        public static SOURCE_TYPE_ENCHANT_MATERIAL: int
        public static SOURCE_TYPE_ENCHANT_OUTPUT: int
        public static SOURCE_TYPE_TRADING_INPUT_1: int
        public static SOURCE_TYPE_TRADING_INPUT_2: int
        public static SOURCE_TYPE_TRADING_USE_INPUTS: int
        public static SOURCE_TYPE_TRADING_OUTPUT: int
        public static SOURCE_TYPE_BEACON: int
        public static SOURCE_TYPE_CONTAINER_DROP_CONTENTS: int
        public sourceType: int
        public windowId: int
        public unknown: long
        public inventorySlot: int
        public oldItem: cn.nukkit.item.Item
        public newItem: cn.nukkit.item.Item
        public stackNetworkId: int

    }
}

declare module "cn.nukkit.network.protocol.types.NetworkInventoryAction" {
    declare const NetworkInventoryAction = cn.nukkit.network.protocol.types.NetworkInventoryAction;
}

declare namespace cn.nukkit.network.protocol.types {
    declare class EntityLink extends java.lang.Object {
        public constructor(fromEntityUniquieId: long, var1: long, toEntityUniquieId: byte, var3: boolean, type: boolean): void
        public static EMPTY_ARRAY: cn.nukkit.network.protocol.types.EntityLink[]
        public static TYPE_REMOVE: byte
        public static TYPE_RIDER: byte
        public static TYPE_PASSENGER: byte
        public fromEntityUniquieId: long
        public toEntityUniquieId: long
        public type: byte
        public immediate: boolean
        public riderInitiated: boolean

    }
}

declare module "cn.nukkit.network.protocol.types.EntityLink" {
    declare const EntityLink = cn.nukkit.network.protocol.types.EntityLink;
}

declare namespace cn.nukkit.network.protocol {
    declare class CameraShakePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public intensity: float
        public duration: float
        public shakeType: cn.nukkit.network.protocol.CameraShakePacket$CameraShakeType
        public shakeAction: cn.nukkit.network.protocol.CameraShakePacket$CameraShakeAction

    }
}

declare module "cn.nukkit.network.protocol.CameraShakePacket" {
    declare const CameraShakePacket = cn.nukkit.network.protocol.CameraShakePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PlayerListPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public static TYPE_ADD: byte
        public static TYPE_REMOVE: byte
        public type: byte
        public entries: cn.nukkit.network.protocol.PlayerListPacket$Entry[]

    }
}

declare module "cn.nukkit.network.protocol.PlayerListPacket" {
    declare const PlayerListPacket = cn.nukkit.network.protocol.PlayerListPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SyncEntityPropertyPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public getData(): cn.nukkit.nbt.tag.CompoundTag
        public setData(data: cn.nukkit.nbt.tag.CompoundTag): void
        public static NETWORK_ID: byte
        data: cn.nukkit.nbt.tag.CompoundTag

    }
}

declare module "cn.nukkit.network.protocol.SyncEntityPropertyPacket" {
    declare const SyncEntityPropertyPacket = cn.nukkit.network.protocol.SyncEntityPropertyPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ServerSettingsRequestPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string

    }
}

declare module "cn.nukkit.network.protocol.ServerSettingsRequestPacket" {
    declare const ServerSettingsRequestPacket = cn.nukkit.network.protocol.ServerSettingsRequestPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class InventoryContentPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public clean(): cn.nukkit.network.protocol.DataPacket
        public decode(): void
        public encode(): void
        public clone(): cn.nukkit.network.protocol.InventoryContentPacket
        public toString(): string
        public clone(): cn.nukkit.network.protocol.DataPacket
        public clone(): java.lang.Object
        public static NETWORK_ID: byte
        public static SPECIAL_INVENTORY: int
        public static SPECIAL_OFFHAND: int
        public static SPECIAL_ARMOR: int
        public static SPECIAL_CREATIVE: int
        public static SPECIAL_HOTBAR: int
        public static SPECIAL_FIXED_INVENTORY: int
        public inventoryId: int
        public slots: cn.nukkit.item.Item[]

    }
}

declare module "cn.nukkit.network.protocol.InventoryContentPacket" {
    declare const InventoryContentPacket = cn.nukkit.network.protocol.InventoryContentPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetEntityDataPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public eid: long
        public metadata: cn.nukkit.entity.data.EntityMetadata
        public frame: long

    }
}

declare module "cn.nukkit.network.protocol.SetEntityDataPacket" {
    declare const SetEntityDataPacket = cn.nukkit.network.protocol.SetEntityDataPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PlayerArmorDamagePacket$PlayerArmorDamageFlag extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.PlayerArmorDamagePacket$PlayerArmorDamageFlag[]
        public static valueOf(name: string): cn.nukkit.network.protocol.PlayerArmorDamagePacket$PlayerArmorDamageFlag
        constructor(): void
        static $values(): cn.nukkit.network.protocol.PlayerArmorDamagePacket$PlayerArmorDamageFlag[]
        public static HELMET: cn.nukkit.network.protocol.PlayerArmorDamagePacket$PlayerArmorDamageFlag
        public static CHESTPLATE: cn.nukkit.network.protocol.PlayerArmorDamagePacket$PlayerArmorDamageFlag
        public static LEGGINGS: cn.nukkit.network.protocol.PlayerArmorDamagePacket$PlayerArmorDamageFlag
        public static BOOTS: cn.nukkit.network.protocol.PlayerArmorDamagePacket$PlayerArmorDamageFlag
        static $VALUES: cn.nukkit.network.protocol.PlayerArmorDamagePacket$PlayerArmorDamageFlag[]

    }
}

declare module "cn.nukkit.network.protocol.PlayerArmorDamagePacket$PlayerArmorDamageFlag" {
    declare const PlayerArmorDamagePacket$PlayerArmorDamageFlag = cn.nukkit.network.protocol.PlayerArmorDamagePacket$PlayerArmorDamageFlag;
}

declare namespace cn.nukkit.network.protocol {
    declare class InventoryTransactionPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public encode(): void
        public decode(): void
        public toString(): string
        public static TYPE_NORMAL: int
        public static TYPE_MISMATCH: int
        public static TYPE_USE_ITEM: int
        public static TYPE_USE_ITEM_ON_ENTITY: int
        public static TYPE_RELEASE_ITEM: int
        public static USE_ITEM_ACTION_CLICK_BLOCK: int
        public static USE_ITEM_ACTION_CLICK_AIR: int
        public static USE_ITEM_ACTION_BREAK_BLOCK: int
        public static RELEASE_ITEM_ACTION_RELEASE: int
        public static RELEASE_ITEM_ACTION_CONSUME: int
        public static USE_ITEM_ON_ENTITY_ACTION_INTERACT: int
        public static USE_ITEM_ON_ENTITY_ACTION_ATTACK: int
        public static ACTION_MAGIC_SLOT_DROP_ITEM: int
        public static ACTION_MAGIC_SLOT_PICKUP_ITEM: int
        public static ACTION_MAGIC_SLOT_CREATIVE_DELETE_ITEM: int
        public static ACTION_MAGIC_SLOT_CREATIVE_CREATE_ITEM: int
        public transactionType: int
        public actions: cn.nukkit.network.protocol.types.NetworkInventoryAction[]
        public transactionData: cn.nukkit.inventory.transaction.data.TransactionData
        public legacyRequestId: int
        public isCraftingPart: boolean
        public isEnchantingPart: boolean
        public isRepairItemPart: boolean

    }
}

declare module "cn.nukkit.network.protocol.InventoryTransactionPacket" {
    declare const InventoryTransactionPacket = cn.nukkit.network.protocol.InventoryTransactionPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetEntityMotionPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public eid: long
        public motionX: float
        public motionY: float
        public motionZ: float

    }
}

declare module "cn.nukkit.network.protocol.SetEntityMotionPacket" {
    declare const SetEntityMotionPacket = cn.nukkit.network.protocol.SetEntityMotionPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class NPCRequestPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public getRequestedEntityRuntimeId(): long
        public setRequestedEntityRuntimeId(entityRuntimeId: long): void
        public getRequestType(): cn.nukkit.network.protocol.NPCRequestPacket$RequestType
        public setRequestType(requestType: cn.nukkit.network.protocol.NPCRequestPacket$RequestType): void
        public getData(): string
        public setData(data: string): void
        public getSkinType(): int
        public setSkinType(skinType: int): void
        public getSceneName(): string
        public setSceneName(sceneName: string): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public entityRuntimeId: long
        public requestType: cn.nukkit.network.protocol.NPCRequestPacket$RequestType
        public data: string
        public skinType: int
        public sceneName: string

    }
}

declare module "cn.nukkit.network.protocol.NPCRequestPacket" {
    declare const NPCRequestPacket = cn.nukkit.network.protocol.NPCRequestPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ToastRequestPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public title: string
        public content: string

    }
}

declare module "cn.nukkit.network.protocol.ToastRequestPacket" {
    declare const ToastRequestPacket = cn.nukkit.network.protocol.ToastRequestPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class AddBehaviorTreePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public unknown: string

    }
}

declare module "cn.nukkit.network.protocol.AddBehaviorTreePacket" {
    declare const AddBehaviorTreePacket = cn.nukkit.network.protocol.AddBehaviorTreePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SpawnParticleEffectPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public dimensionId: int
        public uniqueEntityId: long
        public position: cn.nukkit.math.Vector3f
        public identifier: string
        molangVariablesJson: java.util.Optional<string>

    }
}

declare module "cn.nukkit.network.protocol.SpawnParticleEffectPacket" {
    declare const SpawnParticleEffectPacket = cn.nukkit.network.protocol.SpawnParticleEffectPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class BookEditPacket$Action extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.BookEditPacket$Action[]
        public static valueOf(name: string): cn.nukkit.network.protocol.BookEditPacket$Action
        constructor(): void
        static $values(): cn.nukkit.network.protocol.BookEditPacket$Action[]
        public static REPLACE_PAGE: cn.nukkit.network.protocol.BookEditPacket$Action
        public static ADD_PAGE: cn.nukkit.network.protocol.BookEditPacket$Action
        public static DELETE_PAGE: cn.nukkit.network.protocol.BookEditPacket$Action
        public static SWAP_PAGES: cn.nukkit.network.protocol.BookEditPacket$Action
        public static SIGN_BOOK: cn.nukkit.network.protocol.BookEditPacket$Action
        static $VALUES: cn.nukkit.network.protocol.BookEditPacket$Action[]

    }
}

declare module "cn.nukkit.network.protocol.BookEditPacket$Action" {
    declare const BookEditPacket$Action = cn.nukkit.network.protocol.BookEditPacket$Action;
}

declare namespace cn.nukkit.network.protocol {
    declare class CodeBuilderPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public isOpening: boolean
        public url: string

    }
}

declare module "cn.nukkit.network.protocol.CodeBuilderPacket" {
    declare const CodeBuilderPacket = cn.nukkit.network.protocol.CodeBuilderPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PlayerEnchantOptionsPacket$EnchantData extends java.lang.Object {
        public constructor(this$0: cn.nukkit.network.protocol.PlayerEnchantOptionsPacket, type: int, level: int): void
        public getType(): int
        public getLevel(): int
        public equals(o: java.lang.Object): boolean
        public hashCode(): int
        public toString(): string
        type: int
        level: int
        this$0: cn.nukkit.network.protocol.PlayerEnchantOptionsPacket

    }
}

declare module "cn.nukkit.network.protocol.PlayerEnchantOptionsPacket$EnchantData" {
    declare const PlayerEnchantOptionsPacket$EnchantData = cn.nukkit.network.protocol.PlayerEnchantOptionsPacket$EnchantData;
}

declare namespace cn.nukkit.network.protocol {
    declare class ChunkRadiusUpdatedPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public radius: int

    }
}

declare module "cn.nukkit.network.protocol.ChunkRadiusUpdatedPacket" {
    declare const ChunkRadiusUpdatedPacket = cn.nukkit.network.protocol.ChunkRadiusUpdatedPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ResourcePackStackPacket$ExperimentData extends java.lang.Object {
        public constructor(name: string, enabled: boolean): void
        public getName(): string
        public isEnabled(): boolean
        public equals(o: java.lang.Object): boolean
        public hashCode(): int
        public toString(): string
        name: string
        enabled: boolean

    }
}

declare module "cn.nukkit.network.protocol.ResourcePackStackPacket$ExperimentData" {
    declare const ResourcePackStackPacket$ExperimentData = cn.nukkit.network.protocol.ResourcePackStackPacket$ExperimentData;
}

declare namespace cn.nukkit.network.protocol {
    declare class SubClientLoginPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string

    }
}

declare module "cn.nukkit.network.protocol.SubClientLoginPacket" {
    declare const SubClientLoginPacket = cn.nukkit.network.protocol.SubClientLoginPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetDisplayObjectivePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public displaySlot: cn.nukkit.scoreboard.data.DisplaySlot
        public objectiveName: string
        public displayName: string
        public criteriaName: string
        public sortOrder: cn.nukkit.scoreboard.data.SortOrder

    }
}

declare module "cn.nukkit.network.protocol.SetDisplayObjectivePacket" {
    declare const SetDisplayObjectivePacket = cn.nukkit.network.protocol.SetDisplayObjectivePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class AddPlayerPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public uuid: java.util.UUID
        public username: string
        public entityUniqueId: long
        public entityRuntimeId: long
        public platformChatId: string
        public x: float
        public y: float
        public z: float
        public speedX: float
        public speedY: float
        public speedZ: float
        public pitch: float
        public yaw: float
        public item: cn.nukkit.item.Item
        public gameType: int
        public metadata: cn.nukkit.entity.data.EntityMetadata
        public deviceId: string
        public buildPlatform: int

    }
}

declare module "cn.nukkit.network.protocol.AddPlayerPacket" {
    declare const AddPlayerPacket = cn.nukkit.network.protocol.AddPlayerPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class BiomeDefinitionListPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        static TAG: byte[]
        public tag: byte[]

    }
}

declare module "cn.nukkit.network.protocol.BiomeDefinitionListPacket" {
    declare const BiomeDefinitionListPacket = cn.nukkit.network.protocol.BiomeDefinitionListPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class BookEditPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public action: cn.nukkit.network.protocol.BookEditPacket$Action
        public inventorySlot: int
        public pageNumber: int
        public secondaryPageNumber: int
        public text: string
        public photoName: string
        public title: string
        public author: string
        public xuid: string

    }
}

declare module "cn.nukkit.network.protocol.BookEditPacket" {
    declare const BookEditPacket = cn.nukkit.network.protocol.BookEditPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class AnimateEntityPacket extends cn.nukkit.network.protocol.DataPacket {
        public decode(): void
        public encode(): void
        public pid(): byte
        public setAnimation(animation: string): void
        public getAnimation(): string
        public setNextState(nextState: string): void
        public getNextState(): string
        public setStopExpression(stopExpression: string): void
        public getStopExpression(): string
        public setController(controller: string): void
        public getController(): string
        public setBlendOutTime(blendOutTime: float): void
        public getBlendOutTime(): float
        public setEntityRuntimeIds(entityRuntimeIds: java.util.List<long>): void
        public getEntityRuntimeIds(): java.util.List<long>
        public constructor(): void
        public static NETWORK_ID: byte
        animation: string
        nextState: string
        stopExpression: string
        controller: string
        blendOutTime: float
        entityRuntimeIds: java.util.List<long>

    }
}

declare module "cn.nukkit.network.protocol.AnimateEntityPacket" {
    declare const AnimateEntityPacket = cn.nukkit.network.protocol.AnimateEntityPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ServerSettingsResponsePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public formId: int
        public data: string

    }
}

declare module "cn.nukkit.network.protocol.ServerSettingsResponsePacket" {
    declare const ServerSettingsResponsePacket = cn.nukkit.network.protocol.ServerSettingsResponsePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class PlaySoundPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public name: string
        public x: int
        public y: int
        public z: int
        public volume: float
        public pitch: float

    }
}

declare module "cn.nukkit.network.protocol.PlaySoundPacket" {
    declare const PlaySoundPacket = cn.nukkit.network.protocol.PlaySoundPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class SetLocalPlayerAsInitializedPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public eid: long

    }
}

declare module "cn.nukkit.network.protocol.SetLocalPlayerAsInitializedPacket" {
    declare const SetLocalPlayerAsInitializedPacket = cn.nukkit.network.protocol.SetLocalPlayerAsInitializedPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class EntityPickRequestPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte

    }
}

declare module "cn.nukkit.network.protocol.EntityPickRequestPacket" {
    declare const EntityPickRequestPacket = cn.nukkit.network.protocol.EntityPickRequestPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class CraftingDataPacket$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$inventory$RecipeType: int[]

    }
}

declare module "cn.nukkit.network.protocol.CraftingDataPacket$1" {
    declare const CraftingDataPacket$1 = cn.nukkit.network.protocol.CraftingDataPacket$1;
}

declare namespace cn.nukkit.network.protocol {
    declare class ClientboundMapItemDataPacket$MapTrackedObject$Type extends java.lang.Enum {
        public static values(): cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapTrackedObject$Type[]
        public static valueOf(name: string): cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapTrackedObject$Type
        constructor(): void
        static $values(): cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapTrackedObject$Type[]
        public static ENTITY: cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapTrackedObject$Type
        public static BLOCK: cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapTrackedObject$Type
        static $VALUES: cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapTrackedObject$Type[]

    }
}

declare module "cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapTrackedObject$Type" {
    declare const ClientboundMapItemDataPacket$MapTrackedObject$Type = cn.nukkit.network.protocol.ClientboundMapItemDataPacket$MapTrackedObject$Type;
}

declare namespace cn.nukkit.network.protocol {
    declare class TakeItemEntityPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public entityId: long
        public target: long

    }
}

declare module "cn.nukkit.network.protocol.TakeItemEntityPacket" {
    declare const TakeItemEntityPacket = cn.nukkit.network.protocol.TakeItemEntityPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class InventorySlotPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public inventoryId: int
        public slot: int
        public item: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.network.protocol.InventorySlotPacket" {
    declare const InventorySlotPacket = cn.nukkit.network.protocol.InventorySlotPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ShowProfilePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string
        public static NETWORK_ID: byte
        public xuid: string

    }
}

declare module "cn.nukkit.network.protocol.ShowProfilePacket" {
    declare const ShowProfilePacket = cn.nukkit.network.protocol.ShowProfilePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ItemFrameDropItemPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        public pid(): byte
        public toString(): string
        public static NETWORK_ID: byte
        public x: int
        public y: int
        public z: int

    }
}

declare module "cn.nukkit.network.protocol.ItemFrameDropItemPacket" {
    declare const ItemFrameDropItemPacket = cn.nukkit.network.protocol.ItemFrameDropItemPacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ScriptMessagePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public _getChannel(): string
        public setChannel(channel: string): void
        public getMessage(): string
        public setMessage(message: string): void
        channel: string
        message: string

    }
}

declare module "cn.nukkit.network.protocol.ScriptMessagePacket" {
    declare const ScriptMessagePacket = cn.nukkit.network.protocol.ScriptMessagePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ClientToServerHandshakePacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public pid(): byte
        public decode(): void
        public encode(): void
        public toString(): string

    }
}

declare module "cn.nukkit.network.protocol.ClientToServerHandshakePacket" {
    declare const ClientToServerHandshakePacket = cn.nukkit.network.protocol.ClientToServerHandshakePacket;
}

declare namespace cn.nukkit.network.protocol {
    declare class ResourcePacksInfoPacket extends cn.nukkit.network.protocol.DataPacket {
        public constructor(): void
        public decode(): void
        public encode(): void
        encodePacks(packs: cn.nukkit.resourcepacks.ResourcePack[], behaviour: boolean): void
        public pid(): byte
        public isForcedToAccept(): boolean
        public setForcedToAccept(mustAccept: boolean): void
        public isScriptingEnabled(): boolean
        public setScriptingEnabled(scripting: boolean): void
        public getBehaviourPackEntries(): cn.nukkit.resourcepacks.ResourcePack[]
        public setBehaviourPackEntries(behaviourPackEntries: cn.nukkit.resourcepacks.ResourcePack[]): void
        public getResourcePackEntries(): cn.nukkit.resourcepacks.ResourcePack[]
        public setResourcePackEntries(resourcePackEntries: cn.nukkit.resourcepacks.ResourcePack[]): void
        public isForcingServerPacksEnabled(): boolean
        public setForcingServerPacksEnabled(forcingServerPacksEnabled: boolean): void
        public toString(): string
        public static NETWORK_ID: byte
        public mustAccept: boolean
        public scripting: boolean
        public forceServerPacks: boolean
        public behaviourPackEntries: cn.nukkit.resourcepacks.ResourcePack[]
        public resourcePackEntries: cn.nukkit.resourcepacks.ResourcePack[]

    }
}

declare module "cn.nukkit.network.protocol.ResourcePacksInfoPacket" {
    declare const ResourcePacksInfoPacket = cn.nukkit.network.protocol.ResourcePacksInfoPacket;
}

declare namespace cn.nukkit.potion {
    declare class InstantEffect extends cn.nukkit.potion.Effect {
        public constructor(id: int, name: string, r: int, g: int, b: int): void
        public constructor(id: int, name: string, r: int, g: int, b: int, isBad: boolean): void

    }
}

declare module "cn.nukkit.potion.InstantEffect" {
    declare const InstantEffect = cn.nukkit.potion.InstantEffect;
}

declare namespace cn.nukkit.potion {
    declare class Potion extends java.lang.Object implements java.lang.Cloneable {
        public static init(): void
        public static getPotion(id: int): cn.nukkit.potion.Potion
        public static getPotionByName(name: string): cn.nukkit.potion.Potion
        public constructor(id: int): void
        public constructor(id: int, level: int): void
        public constructor(id: int, level: int, splash: boolean): void
        public getEffect(): cn.nukkit.potion.Effect
        public getId(): int
        public getLevel(): int
        public isSplash(): boolean
        public setSplash(splash: boolean): cn.nukkit.potion.Potion
        public applyPotion(entity: cn.nukkit.entity.Entity): void
        public applyPotion(entity: cn.nukkit.entity.Entity, health: double): void
        public clone(): cn.nukkit.potion.Potion
        public static getEffect(potionType: int, isSplash: boolean): cn.nukkit.potion.Effect
        public static getLevel(potionType: int): int
        public static isInstant(potionType: int): boolean
        public static getApplySeconds(potionType: int, isSplash: boolean): int
        public getPotionTypeName(): string
        public getName(): string
        public getRomanLevel(): string
        static appendRoman(sb: java.lang.StringBuilder, num: int): void
        public equals(o: java.lang.Object): boolean
        canEqual(other: java.lang.Object): boolean
        public hashCode(): int
        public clone(): java.lang.Object
        public static NO_EFFECTS: int
        public static WATER: int
        public static MUNDANE: int
        public static MUNDANE_II: int
        public static THICK: int
        public static AWKWARD: int
        public static NIGHT_VISION: int
        public static NIGHT_VISION_LONG: int
        public static INVISIBLE: int
        public static INVISIBLE_LONG: int
        public static LEAPING: int
        public static LEAPING_LONG: int
        public static LEAPING_II: int
        public static FIRE_RESISTANCE: int
        public static FIRE_RESISTANCE_LONG: int
        public static SPEED: int
        public static SPEED_LONG: int
        public static SPEED_II: int
        public static SLOWNESS: int
        public static SLOWNESS_LONG: int
        public static WATER_BREATHING: int
        public static WATER_BREATHING_LONG: int
        public static INSTANT_HEALTH: int
        public static INSTANT_HEALTH_II: int
        public static HARMING: int
        public static HARMING_II: int
        public static POISON: int
        public static POISON_LONG: int
        public static POISON_II: int
        public static REGENERATION: int
        public static REGENERATION_LONG: int
        public static REGENERATION_II: int
        public static STRENGTH: int
        public static STRENGTH_LONG: int
        public static STRENGTH_II: int
        public static WEAKNESS: int
        public static WEAKNESS_LONG: int
        public static WITHER_II: int
        public static TURTLE_MASTER: int
        public static TURTLE_MASTER_LONG: int
        public static TURTLE_MASTER_II: int
        public static SLOW_FALLING: int
        public static SLOW_FALLING_LONG: int
        public static SLOWNESS_IV: int
        public static SLOWNESS_LONG_II: int
        static potions: cn.nukkit.potion.Potion[]
        id: int
        level: int
        splash: boolean

    }
}

declare module "cn.nukkit.potion.Potion" {
    declare const Potion = cn.nukkit.potion.Potion;
}

declare namespace cn.nukkit.resourcepacks {
    declare class ZippedResourcePack extends cn.nukkit.resourcepacks.AbstractResourcePack {
        public constructor(file: java.io.File): void
        public getPackSize(): int
        public getSha256(): byte[]
        public getPackChunk(off: int, len: int): byte[]
        static lambda$new$2(): java.lang.IllegalArgumentException
        static lambda$new$1(e: java.util.zip.ZipEntry): boolean
        static lambda$new$0(e: java.util.zip.ZipEntry): boolean
        static log: org.apache.logging.log4j.Logger
        file: java.io.File
        sha256: byte[]

    }
}

declare module "cn.nukkit.resourcepacks.ZippedResourcePack" {
    declare const ZippedResourcePack = cn.nukkit.resourcepacks.ZippedResourcePack;
}

declare namespace cn.nukkit.metadata {
    declare class LevelMetadataStore extends cn.nukkit.metadata.MetadataStore {
        public constructor(): void
        disambiguate(level: cn.nukkit.metadata.Metadatable, metadataKey: string): string

    }
}

declare module "cn.nukkit.metadata.LevelMetadataStore" {
    declare const LevelMetadataStore = cn.nukkit.metadata.LevelMetadataStore;
}

declare namespace cn.nukkit.metadata {
    declare class MetadataStore extends java.lang.Object {
        public constructor(): void
        public setMetadata(subject: java.lang.Object, metadataKey: string, newMetadataValue: cn.nukkit.metadata.MetadataValue): void
        public getMetadata(subject: java.lang.Object, metadataKey: string): java.util.List<cn.nukkit.metadata.MetadataValue>
        public hasMetadata(subject: java.lang.Object, metadataKey: string): boolean
        public removeMetadata(subject: java.lang.Object, metadataKey: string, owningPlugin: cn.nukkit.plugin.Plugin): void
        public invalidateAll(owningPlugin: cn.nukkit.plugin.Plugin): void
        disambiguate(var0: cn.nukkit.metadata.Metadatable, var1: string): string
        static lambda$setMetadata$0(k: string): java.util.Map
        metadataMap: java.util.Map<string, java.util.Map<cn.nukkit.plugin.Plugin, cn.nukkit.metadata.MetadataValue>>

    }
}

declare module "cn.nukkit.metadata.MetadataStore" {
    declare const MetadataStore = cn.nukkit.metadata.MetadataStore;
}

declare namespace cn.nukkit.event.blockstate {
    declare class BlockStateRepairFinishEvent extends cn.nukkit.event.blockstate.BlockStateRepairEvent {
        public constructor(allRepairs: java.util.List<cn.nukkit.blockstate.BlockStateRepair>, result: cn.nukkit.block.Block): void
        public getAllRepairs(): java.util.List<cn.nukkit.blockstate.BlockStateRepair>
        public getResult(): cn.nukkit.block.Block
        public setResult(result: cn.nukkit.block.Block): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        allRepairs: java.util.List<cn.nukkit.blockstate.BlockStateRepair>
        result: cn.nukkit.block.Block
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.blockstate.BlockStateRepairFinishEvent" {
    declare const BlockStateRepairFinishEvent = cn.nukkit.event.blockstate.BlockStateRepairFinishEvent;
}

declare namespace cn.nukkit.event.vehicle {
    declare class VehicleDestroyByEntityEvent extends cn.nukkit.event.vehicle.VehicleDestroyEvent implements cn.nukkit.event.Cancellable {
        public constructor(vehicle: cn.nukkit.entity.Entity, destroyer: cn.nukkit.entity.Entity): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        public getDestroyer(): cn.nukkit.entity.Entity
        static HANDLER_LIST: cn.nukkit.event.HandlerList
        destroyer: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.event.vehicle.VehicleDestroyByEntityEvent" {
    declare const VehicleDestroyByEntityEvent = cn.nukkit.event.vehicle.VehicleDestroyByEntityEvent;
}

declare namespace cn.nukkit.event.vehicle {
    declare class VehicleMoveEvent extends cn.nukkit.event.vehicle.VehicleEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(vehicle: cn.nukkit.entity.Entity, from: cn.nukkit.level.Location, to: cn.nukkit.level.Location): void
        public getFrom(): cn.nukkit.level.Location
        public getTo(): cn.nukkit.level.Location
        static handlers: cn.nukkit.event.HandlerList
        from: cn.nukkit.level.Location
        to: cn.nukkit.level.Location

    }
}

declare module "cn.nukkit.event.vehicle.VehicleMoveEvent" {
    declare const VehicleMoveEvent = cn.nukkit.event.vehicle.VehicleMoveEvent;
}

declare namespace cn.nukkit.event.vehicle {
    declare class VehicleUpdateEvent extends cn.nukkit.event.vehicle.VehicleEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(vehicle: cn.nukkit.entity.Entity): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.vehicle.VehicleUpdateEvent" {
    declare const VehicleUpdateEvent = cn.nukkit.event.vehicle.VehicleUpdateEvent;
}

declare namespace cn.nukkit.event.vehicle {
    declare class VehicleDamageEvent extends cn.nukkit.event.vehicle.VehicleEvent implements cn.nukkit.event.Cancellable {
        public constructor(vehicle: cn.nukkit.entity.item.EntityVehicle, damage: double): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        public getDamage(): double
        public setDamage(damage: double): void
        static handlers: cn.nukkit.event.HandlerList
        damage: double

    }
}

declare module "cn.nukkit.event.vehicle.VehicleDamageEvent" {
    declare const VehicleDamageEvent = cn.nukkit.event.vehicle.VehicleDamageEvent;
}

declare namespace cn.nukkit.event.vehicle {
    declare class EntityExitVehicleEvent extends cn.nukkit.event.vehicle.VehicleEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(riding: cn.nukkit.entity.Entity, vehicle: cn.nukkit.entity.Entity): void
        public getEntity(): cn.nukkit.entity.Entity
        public isPlayer(): boolean
        static handlers: cn.nukkit.event.HandlerList
        riding: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.event.vehicle.EntityExitVehicleEvent" {
    declare const EntityExitVehicleEvent = cn.nukkit.event.vehicle.EntityExitVehicleEvent;
}

declare namespace cn.nukkit.event.block {
    declare class DoorToggleEvent extends cn.nukkit.event.block.BlockUpdateEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, player: cn.nukkit.Player): void
        public setPlayer(player: cn.nukkit.Player): void
        public getPlayer(): cn.nukkit.Player
        static handlers: cn.nukkit.event.HandlerList
        player: cn.nukkit.Player

    }
}

declare module "cn.nukkit.event.block.DoorToggleEvent" {
    declare const DoorToggleEvent = cn.nukkit.event.block.DoorToggleEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockPistonEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(piston: cn.nukkit.block.BlockPistonBase, direction: cn.nukkit.math.BlockFace, blocks: java.util.List<cn.nukkit.block.Block>, destroyedBlocks: java.util.List<cn.nukkit.block.Block>, extending: boolean): void
        public getDirection(): cn.nukkit.math.BlockFace
        public getBlocks(): java.util.List<cn.nukkit.block.Block>
        public getDestroyedBlocks(): java.util.List<cn.nukkit.block.Block>
        public isExtending(): boolean
        public getBlock(): cn.nukkit.block.BlockPistonBase
        public getBlock(): cn.nukkit.block.Block
        static handlers: cn.nukkit.event.HandlerList
        direction: cn.nukkit.math.BlockFace
        blocks: java.util.List<cn.nukkit.block.Block>
        destroyedBlocks: java.util.List<cn.nukkit.block.Block>
        extending: boolean

    }
}

declare module "cn.nukkit.event.block.BlockPistonEvent" {
    declare const BlockPistonEvent = cn.nukkit.event.block.BlockPistonEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockIgniteEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, source: cn.nukkit.block.Block, entity: cn.nukkit.entity.Entity, cause: cn.nukkit.event.block.BlockIgniteEvent$BlockIgniteCause): void
        public getSource(): cn.nukkit.block.Block
        public getEntity(): cn.nukkit.entity.Entity
        public getCause(): cn.nukkit.event.block.BlockIgniteEvent$BlockIgniteCause
        static handlers: cn.nukkit.event.HandlerList
        source: cn.nukkit.block.Block
        entity: cn.nukkit.entity.Entity
        cause: cn.nukkit.event.block.BlockIgniteEvent$BlockIgniteCause

    }
}

declare module "cn.nukkit.event.block.BlockIgniteEvent" {
    declare const BlockIgniteEvent = cn.nukkit.event.block.BlockIgniteEvent;
}

declare namespace cn.nukkit.event.block {
    declare class ConduitDeactivateEvent extends cn.nukkit.event.block.BlockEvent {
        public constructor(block: cn.nukkit.block.Block): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.block.ConduitDeactivateEvent" {
    declare const ConduitDeactivateEvent = cn.nukkit.event.block.ConduitDeactivateEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockGrowEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, newState: cn.nukkit.block.Block): void
        public getNewState(): cn.nukkit.block.Block
        static handlers: cn.nukkit.event.HandlerList
        newState: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.event.block.BlockGrowEvent" {
    declare const BlockGrowEvent = cn.nukkit.event.block.BlockGrowEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockFadeEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, newState: cn.nukkit.block.Block): void
        public getNewState(): cn.nukkit.block.Block
        static handlers: cn.nukkit.event.HandlerList
        newState: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.event.block.BlockFadeEvent" {
    declare const BlockFadeEvent = cn.nukkit.event.block.BlockFadeEvent;
}

declare namespace cn.nukkit.event.block {
    declare class CauldronFilledByDrippingLiquidEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public constructor(cauldron: cn.nukkit.block.Block, liquid: cn.nukkit.blockproperty.value.CauldronLiquid, liquidLevelIncrement: int): void
        public getLiquid(): cn.nukkit.blockproperty.value.CauldronLiquid
        public setLiquid(liquid: cn.nukkit.blockproperty.value.CauldronLiquid): void
        public getLiquidLevelIncrement(): int
        public setLiquidLevelIncrement(liquidLevelIncrement: int): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        static handlers: cn.nukkit.event.HandlerList
        liquid: cn.nukkit.blockproperty.value.CauldronLiquid
        liquidLevelIncrement: int

    }
}

declare module "cn.nukkit.event.block.CauldronFilledByDrippingLiquidEvent" {
    declare const CauldronFilledByDrippingLiquidEvent = cn.nukkit.event.block.CauldronFilledByDrippingLiquidEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockFormEvent extends cn.nukkit.event.block.BlockGrowEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, newState: cn.nukkit.block.Block): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.block.BlockFormEvent" {
    declare const BlockFormEvent = cn.nukkit.event.block.BlockFormEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockHarvestEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public constructor(block: cn.nukkit.block.Block, newState: cn.nukkit.block.Block, drops: cn.nukkit.item.Item[]): void
        public getNewState(): cn.nukkit.block.Block
        public setNewState(newState: cn.nukkit.block.Block): void
        public getDrops(): cn.nukkit.item.Item[]
        public setDrops(drops: cn.nukkit.item.Item[]): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        static handlers: cn.nukkit.event.HandlerList
        newState: cn.nukkit.block.Block
        drops: cn.nukkit.item.Item[]

    }
}

declare module "cn.nukkit.event.block.BlockHarvestEvent" {
    declare const BlockHarvestEvent = cn.nukkit.event.block.BlockHarvestEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BellRingEvent$RingCause extends java.lang.Enum {
        public static values(): cn.nukkit.event.block.BellRingEvent$RingCause[]
        public static valueOf(name: string): cn.nukkit.event.block.BellRingEvent$RingCause
        constructor(): void
        static $values(): cn.nukkit.event.block.BellRingEvent$RingCause[]
        public static HUMAN_INTERACTION: cn.nukkit.event.block.BellRingEvent$RingCause
        public static REDSTONE: cn.nukkit.event.block.BellRingEvent$RingCause
        public static PROJECTILE: cn.nukkit.event.block.BellRingEvent$RingCause
        public static DROPPED_ITEM: cn.nukkit.event.block.BellRingEvent$RingCause
        public static UNKNOWN: cn.nukkit.event.block.BellRingEvent$RingCause
        static $VALUES: cn.nukkit.event.block.BellRingEvent$RingCause[]

    }
}

declare module "cn.nukkit.event.block.BellRingEvent$RingCause" {
    declare const BellRingEvent$RingCause = cn.nukkit.event.block.BellRingEvent$RingCause;
}

declare namespace cn.nukkit.event.block {
    declare class LecternPageChangeEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public constructor(player: cn.nukkit.Player, lectern: cn.nukkit.blockentity.BlockEntityLectern, newPage: int): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        public getLectern(): cn.nukkit.blockentity.BlockEntityLectern
        public getLeftPage(): int
        public getRightPage(): int
        public setLeftPage(newLeftPage: int): void
        public setRightPage(newRightPage: int): void
        public getNewRawPage(): int
        public setNewRawPage(newRawPage: int): void
        public getMaxPage(): int
        public getPlayer(): cn.nukkit.Player
        static handlers: cn.nukkit.event.HandlerList
        player: cn.nukkit.Player
        lectern: cn.nukkit.blockentity.BlockEntityLectern
        newRawPage: int

    }
}

declare module "cn.nukkit.event.block.LecternPageChangeEvent" {
    declare const LecternPageChangeEvent = cn.nukkit.event.block.LecternPageChangeEvent;
}

declare namespace cn.nukkit.event.block {
    declare class TurtleEggHatchEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public constructor(turtleEgg: cn.nukkit.block.BlockTurtleEgg, eggsHatching: int, newState: cn.nukkit.block.Block): void
        public recalculateNewState(): void
        public getNewState(): cn.nukkit.block.Block
        public setNewState(newState: cn.nukkit.block.Block): void
        public getBlock(): cn.nukkit.block.BlockTurtleEgg
        public getEggsHatching(): int
        public setEggsHatching(eggsHatching: int): void
        public isRecalculateOnFailure(): boolean
        public setRecalculateOnFailure(recalculateOnFailure: boolean): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        public getBlock(): cn.nukkit.block.Block
        static handlers: cn.nukkit.event.HandlerList
        eggsHatching: int
        newState: cn.nukkit.block.Block
        recalculateOnFailure: boolean

    }
}

declare module "cn.nukkit.event.block.TurtleEggHatchEvent" {
    declare const TurtleEggHatchEvent = cn.nukkit.event.block.TurtleEggHatchEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockBurnEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public constructor(block: cn.nukkit.block.Block): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.block.BlockBurnEvent" {
    declare const BlockBurnEvent = cn.nukkit.event.block.BlockBurnEvent;
}

declare namespace cn.nukkit.event.block {
    declare class ComposterEmptyEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public constructor(block: cn.nukkit.block.Block, player: cn.nukkit.Player, itemUsed: cn.nukkit.item.Item, drop: cn.nukkit.item.Item, newLevel: int): void
        public getPlayer(): cn.nukkit.Player
        public getDrop(): cn.nukkit.item.Item
        public setDrop(drop: cn.nukkit.item.Item): void
        public getItemUsed(): cn.nukkit.item.Item
        public setItemUsed(itemUsed: cn.nukkit.item.Item): void
        public getNewLevel(): int
        public setNewLevel(newLevel: int): void
        public getMotion(): cn.nukkit.math.Vector3
        public setMotion(motion: cn.nukkit.math.Vector3): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        static handlers: cn.nukkit.event.HandlerList
        player: cn.nukkit.Player
        drop: cn.nukkit.item.Item
        itemUsed: cn.nukkit.item.Item
        newLevel: int
        motion: cn.nukkit.math.Vector3

    }
}

declare module "cn.nukkit.event.block.ComposterEmptyEvent" {
    declare const ComposterEmptyEvent = cn.nukkit.event.block.ComposterEmptyEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockUpdateEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.block.BlockUpdateEvent" {
    declare const BlockUpdateEvent = cn.nukkit.event.block.BlockUpdateEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockEvent extends cn.nukkit.event.Event {
        public constructor(block: cn.nukkit.block.Block): void
        public getBlock(): cn.nukkit.block.Block
        block: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.event.block.BlockEvent" {
    declare const BlockEvent = cn.nukkit.event.block.BlockEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockExplosionPrimeEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, force: double): void
        public constructor(block: cn.nukkit.block.Block, force: double, var2: double): void
        public getForce(): double
        public setForce(force: double): void
        public isBlockBreaking(): boolean
        public setBlockBreaking(blockBreaking: boolean): void
        public isIncendiary(): boolean
        public setIncendiary(incendiary: boolean): void
        public getFireChance(): double
        public setFireChance(fireChance: double): void
        static handlers: cn.nukkit.event.HandlerList
        force: double
        blockBreaking: boolean
        fireChance: double

    }
}

declare module "cn.nukkit.event.block.BlockExplosionPrimeEvent" {
    declare const BlockExplosionPrimeEvent = cn.nukkit.event.block.BlockExplosionPrimeEvent;
}

declare namespace cn.nukkit.event.block {
    declare class BlockPistonChangeEvent extends cn.nukkit.event.block.BlockEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, oldPower: int, newPower: int): void
        public getOldPower(): int
        public getNewPower(): int
        static handlers: cn.nukkit.event.HandlerList
        oldPower: int
        newPower: int

    }
}

declare module "cn.nukkit.event.block.BlockPistonChangeEvent" {
    declare const BlockPistonChangeEvent = cn.nukkit.event.block.BlockPistonChangeEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class InventoryTransactionEvent extends cn.nukkit.event.Event implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(transaction: cn.nukkit.inventory.transaction.InventoryTransaction): void
        public getTransaction(): cn.nukkit.inventory.transaction.InventoryTransaction
        static handlers: cn.nukkit.event.HandlerList
        transaction: cn.nukkit.inventory.transaction.InventoryTransaction

    }
}

declare module "cn.nukkit.event.inventory.InventoryTransactionEvent" {
    declare const InventoryTransactionEvent = cn.nukkit.event.inventory.InventoryTransactionEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class FurnaceBurnEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(furnace: cn.nukkit.blockentity.BlockEntityFurnace, fuel: cn.nukkit.item.Item, burnTime: short): void
        public getFurnace(): cn.nukkit.blockentity.BlockEntityFurnace
        public getFuel(): cn.nukkit.item.Item
        public getBurnTime(): short
        public setBurnTime(burnTime: short): void
        public isBurning(): boolean
        public setBurning(burning: boolean): void
        static handlers: cn.nukkit.event.HandlerList
        furnace: cn.nukkit.blockentity.BlockEntityFurnace
        fuel: cn.nukkit.item.Item
        burnTime: short
        burning: boolean

    }
}

declare module "cn.nukkit.event.inventory.FurnaceBurnEvent" {
    declare const FurnaceBurnEvent = cn.nukkit.event.inventory.FurnaceBurnEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class InventoryCloseEvent extends cn.nukkit.event.inventory.InventoryEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(inventory: cn.nukkit.inventory.Inventory, who: cn.nukkit.Player): void
        public getPlayer(): cn.nukkit.Player
        static handlers: cn.nukkit.event.HandlerList
        who: cn.nukkit.Player

    }
}

declare module "cn.nukkit.event.inventory.InventoryCloseEvent" {
    declare const InventoryCloseEvent = cn.nukkit.event.inventory.InventoryCloseEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class InventoryMoveItemEvent$Action extends java.lang.Enum {
        public static values(): cn.nukkit.event.inventory.InventoryMoveItemEvent$Action[]
        public static valueOf(name: string): cn.nukkit.event.inventory.InventoryMoveItemEvent$Action
        constructor(): void
        static $values(): cn.nukkit.event.inventory.InventoryMoveItemEvent$Action[]
        public static SLOT_CHANGE: cn.nukkit.event.inventory.InventoryMoveItemEvent$Action
        public static PICKUP: cn.nukkit.event.inventory.InventoryMoveItemEvent$Action
        public static DROP: cn.nukkit.event.inventory.InventoryMoveItemEvent$Action
        public static DISPENSE: cn.nukkit.event.inventory.InventoryMoveItemEvent$Action
        static $VALUES: cn.nukkit.event.inventory.InventoryMoveItemEvent$Action[]

    }
}

declare module "cn.nukkit.event.inventory.InventoryMoveItemEvent$Action" {
    declare const InventoryMoveItemEvent$Action = cn.nukkit.event.inventory.InventoryMoveItemEvent$Action;
}

declare namespace cn.nukkit.event.inventory {
    declare class CraftItemEvent extends cn.nukkit.event.Event implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(transaction: cn.nukkit.inventory.transaction.CraftingTransaction): void
        public constructor(player: cn.nukkit.Player, input: cn.nukkit.item.Item[], recipe: cn.nukkit.inventory.Recipe): void
        public getTransaction(): cn.nukkit.inventory.transaction.CraftingTransaction
        public getInput(): cn.nukkit.item.Item[]
        public getRecipe(): cn.nukkit.inventory.Recipe
        public getPlayer(): cn.nukkit.Player
        static handlers: cn.nukkit.event.HandlerList
        input: cn.nukkit.item.Item[]
        recipe: cn.nukkit.inventory.Recipe
        player: cn.nukkit.Player
        transaction: cn.nukkit.inventory.transaction.CraftingTransaction

    }
}

declare module "cn.nukkit.event.inventory.CraftItemEvent" {
    declare const CraftItemEvent = cn.nukkit.event.inventory.CraftItemEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class PlayerTypingAnvilInventoryEvent extends cn.nukkit.event.inventory.InventoryEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, inventory: cn.nukkit.inventory.AnvilInventory, previousName: string, typedName: string): void
        public getInventory(): cn.nukkit.inventory.AnvilInventory
        public getPlayer(): cn.nukkit.Player
        public getTypedName(): string
        public getPreviousName(): string
        public toString(): string
        public getInventory(): cn.nukkit.inventory.Inventory
        static handlers: cn.nukkit.event.HandlerList
        player: cn.nukkit.Player
        previousName: string
        typedName: string

    }
}

declare module "cn.nukkit.event.inventory.PlayerTypingAnvilInventoryEvent" {
    declare const PlayerTypingAnvilInventoryEvent = cn.nukkit.event.inventory.PlayerTypingAnvilInventoryEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class InventoryEvent extends cn.nukkit.event.Event {
        public constructor(inventory: cn.nukkit.inventory.Inventory): void
        public getInventory(): cn.nukkit.inventory.Inventory
        public getViewers(): cn.nukkit.Player[]
        inventory: cn.nukkit.inventory.Inventory

    }
}

declare module "cn.nukkit.event.inventory.InventoryEvent" {
    declare const InventoryEvent = cn.nukkit.event.inventory.InventoryEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class BrewEvent extends cn.nukkit.event.inventory.InventoryEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(blockEntity: cn.nukkit.blockentity.BlockEntityBrewingStand): void
        public getBrewingStand(): cn.nukkit.blockentity.BlockEntityBrewingStand
        public getIngredient(): cn.nukkit.item.Item
        public getPotions(): cn.nukkit.item.Item[]
        public getPotion(index: int): cn.nukkit.item.Item
        public getFuel(): int
        static handlers: cn.nukkit.event.HandlerList
        brewingStand: cn.nukkit.blockentity.BlockEntityBrewingStand
        ingredient: cn.nukkit.item.Item
        potions: cn.nukkit.item.Item[]
        fuel: int

    }
}

declare module "cn.nukkit.event.inventory.BrewEvent" {
    declare const BrewEvent = cn.nukkit.event.inventory.BrewEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class InventoryClickEvent extends cn.nukkit.event.inventory.InventoryEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(who: cn.nukkit.Player, inventory: cn.nukkit.inventory.Inventory, slot: int, sourceItem: cn.nukkit.item.Item, heldItem: cn.nukkit.item.Item): void
        public getSlot(): int
        public getSourceItem(): cn.nukkit.item.Item
        public getHeldItem(): cn.nukkit.item.Item
        public getPlayer(): cn.nukkit.Player
        static handlers: cn.nukkit.event.HandlerList
        slot: int
        sourceItem: cn.nukkit.item.Item
        heldItem: cn.nukkit.item.Item
        player: cn.nukkit.Player

    }
}

declare module "cn.nukkit.event.inventory.InventoryClickEvent" {
    declare const InventoryClickEvent = cn.nukkit.event.inventory.InventoryClickEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class InventoryPickupTridentEvent extends cn.nukkit.event.inventory.InventoryEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(inventory: cn.nukkit.inventory.Inventory, trident: cn.nukkit.entity.projectile.EntityThrownTrident): void
        public getTrident(): cn.nukkit.entity.projectile.EntityThrownTrident
        static handlers: cn.nukkit.event.HandlerList
        trident: cn.nukkit.entity.projectile.EntityThrownTrident

    }
}

declare module "cn.nukkit.event.inventory.InventoryPickupTridentEvent" {
    declare const InventoryPickupTridentEvent = cn.nukkit.event.inventory.InventoryPickupTridentEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class InventoryOpenEvent extends cn.nukkit.event.inventory.InventoryEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(inventory: cn.nukkit.inventory.Inventory, who: cn.nukkit.Player): void
        public getPlayer(): cn.nukkit.Player
        static handlers: cn.nukkit.event.HandlerList
        who: cn.nukkit.Player

    }
}

declare module "cn.nukkit.event.inventory.InventoryOpenEvent" {
    declare const InventoryOpenEvent = cn.nukkit.event.inventory.InventoryOpenEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class InventoryPickupItemEvent extends cn.nukkit.event.inventory.InventoryEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(inventory: cn.nukkit.inventory.Inventory, item: cn.nukkit.entity.item.EntityItem): void
        public getItem(): cn.nukkit.entity.item.EntityItem
        static handlers: cn.nukkit.event.HandlerList
        item: cn.nukkit.entity.item.EntityItem

    }
}

declare module "cn.nukkit.event.inventory.InventoryPickupItemEvent" {
    declare const InventoryPickupItemEvent = cn.nukkit.event.inventory.InventoryPickupItemEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class InventoryMoveItemEvent extends cn.nukkit.event.inventory.InventoryEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(from: cn.nukkit.inventory.Inventory, targetInventory: cn.nukkit.inventory.Inventory, source: cn.nukkit.inventory.InventoryHolder, item: cn.nukkit.item.Item, action: cn.nukkit.event.inventory.InventoryMoveItemEvent$Action): void
        public getTargetInventory(): cn.nukkit.inventory.Inventory
        public getSource(): cn.nukkit.inventory.InventoryHolder
        public getItem(): cn.nukkit.item.Item
        public setItem(item: cn.nukkit.item.Item): void
        public getAction(): cn.nukkit.event.inventory.InventoryMoveItemEvent$Action
        static handlers: cn.nukkit.event.HandlerList
        targetInventory: cn.nukkit.inventory.Inventory
        source: cn.nukkit.inventory.InventoryHolder
        item: cn.nukkit.item.Item
        action: cn.nukkit.event.inventory.InventoryMoveItemEvent$Action

    }
}

declare module "cn.nukkit.event.inventory.InventoryMoveItemEvent" {
    declare const InventoryMoveItemEvent = cn.nukkit.event.inventory.InventoryMoveItemEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class RepairItemEvent extends cn.nukkit.event.inventory.InventoryEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(inventory: cn.nukkit.inventory.AnvilInventory, oldItem: cn.nukkit.item.Item, newItem: cn.nukkit.item.Item, materialItem: cn.nukkit.item.Item, cost: int, player: cn.nukkit.Player): void
        public getOldItem(): cn.nukkit.item.Item
        public getNewItem(): cn.nukkit.item.Item
        public getMaterialItem(): cn.nukkit.item.Item
        public getCost(): int
        public setCost(cost: int): void
        public getPlayer(): cn.nukkit.Player
        static handlers: cn.nukkit.event.HandlerList
        oldItem: cn.nukkit.item.Item
        newItem: cn.nukkit.item.Item
        materialItem: cn.nukkit.item.Item
        cost: int
        player: cn.nukkit.Player

    }
}

declare module "cn.nukkit.event.inventory.RepairItemEvent" {
    declare const RepairItemEvent = cn.nukkit.event.inventory.RepairItemEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class FurnaceSmeltEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(furnace: cn.nukkit.blockentity.BlockEntityFurnace, source: cn.nukkit.item.Item, result: cn.nukkit.item.Item): void
        public getFurnace(): cn.nukkit.blockentity.BlockEntityFurnace
        public getSource(): cn.nukkit.item.Item
        public getResult(): cn.nukkit.item.Item
        public setResult(result: cn.nukkit.item.Item): void
        static handlers: cn.nukkit.event.HandlerList
        furnace: cn.nukkit.blockentity.BlockEntityFurnace
        source: cn.nukkit.item.Item
        result: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.event.inventory.FurnaceSmeltEvent" {
    declare const FurnaceSmeltEvent = cn.nukkit.event.inventory.FurnaceSmeltEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class CampfireSmeltEvent extends cn.nukkit.event.block.BlockEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(campfire: cn.nukkit.blockentity.BlockEntityCampfire, source: cn.nukkit.item.Item, result: cn.nukkit.item.Item): void
        public getCampfire(): cn.nukkit.blockentity.BlockEntityCampfire
        public getSource(): cn.nukkit.item.Item
        public getResult(): cn.nukkit.item.Item
        public setResult(result: cn.nukkit.item.Item): void
        public getKeepItem(): boolean
        public setKeepItem(keepItem: boolean): void
        static handlers: cn.nukkit.event.HandlerList
        campfire: cn.nukkit.blockentity.BlockEntityCampfire
        source: cn.nukkit.item.Item
        result: cn.nukkit.item.Item
        keepItem: boolean

    }
}

declare module "cn.nukkit.event.inventory.CampfireSmeltEvent" {
    declare const CampfireSmeltEvent = cn.nukkit.event.inventory.CampfireSmeltEvent;
}

declare namespace cn.nukkit.event.inventory {
    declare class GrindstoneEvent extends cn.nukkit.event.inventory.InventoryEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(inventory: cn.nukkit.inventory.GrindstoneInventory, firstItem: cn.nukkit.item.Item, resultItem: cn.nukkit.item.Item, secondItem: cn.nukkit.item.Item, cost: int, player: cn.nukkit.Player): void
        public getFirstItem(): cn.nukkit.item.Item
        public getResultItem(): cn.nukkit.item.Item
        public getSecondItem(): cn.nukkit.item.Item
        public getExperienceDropped(): int
        public setExperienceDropped(experienceDropped: int): void
        public getPlayer(): cn.nukkit.Player
        static handlers: cn.nukkit.event.HandlerList
        firstItem: cn.nukkit.item.Item
        resultItem: cn.nukkit.item.Item
        secondItem: cn.nukkit.item.Item
        experienceDropped: int
        player: cn.nukkit.Player

    }
}

declare module "cn.nukkit.event.inventory.GrindstoneEvent" {
    declare const GrindstoneEvent = cn.nukkit.event.inventory.GrindstoneEvent;
}

declare namespace cn.nukkit.event {
    declare class EventPriority extends java.lang.Enum {
        public static values(): cn.nukkit.event.EventPriority[]
        public static valueOf(name: string): cn.nukkit.event.EventPriority
        constructor(var0: int): void
        public getSlot(): int
        static $values(): cn.nukkit.event.EventPriority[]
        public static LOWEST: cn.nukkit.event.EventPriority
        public static LOW: cn.nukkit.event.EventPriority
        public static NORMAL: cn.nukkit.event.EventPriority
        public static HIGH: cn.nukkit.event.EventPriority
        public static HIGHEST: cn.nukkit.event.EventPriority
        public static MONITOR: cn.nukkit.event.EventPriority
        slot: int
        static $VALUES: cn.nukkit.event.EventPriority[]

    }
}

declare module "cn.nukkit.event.EventPriority" {
    declare const EventPriority = cn.nukkit.event.EventPriority;
}

declare namespace cn.nukkit.event.level {
    declare class ChunkEvent extends cn.nukkit.event.level.LevelEvent {
        public constructor(chunk: cn.nukkit.level.format.FullChunk): void
        public getChunk(): cn.nukkit.level.format.FullChunk
        chunk: cn.nukkit.level.format.FullChunk

    }
}

declare module "cn.nukkit.event.level.ChunkEvent" {
    declare const ChunkEvent = cn.nukkit.event.level.ChunkEvent;
}

declare namespace cn.nukkit.event.level {
    declare class LevelUnloadEvent extends cn.nukkit.event.level.LevelEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(level: cn.nukkit.level.Level): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.level.LevelUnloadEvent" {
    declare const LevelUnloadEvent = cn.nukkit.event.level.LevelUnloadEvent;
}

declare namespace cn.nukkit.event.level {
    declare class StructureGrowEvent extends cn.nukkit.event.level.LevelEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(block: cn.nukkit.block.Block, blocks: java.util.List<cn.nukkit.block.Block>): void
        public getBlock(): cn.nukkit.block.Block
        public getBlockList(): java.util.List<cn.nukkit.block.Block>
        public setBlockList(blocks: java.util.List<cn.nukkit.block.Block>): void
        static handlers: cn.nukkit.event.HandlerList
        block: cn.nukkit.block.Block
        blocks: java.util.List<cn.nukkit.block.Block>

    }
}

declare module "cn.nukkit.event.level.StructureGrowEvent" {
    declare const StructureGrowEvent = cn.nukkit.event.level.StructureGrowEvent;
}

declare namespace cn.nukkit.event.level {
    declare class LevelEvent extends cn.nukkit.event.Event {
        public constructor(level: cn.nukkit.level.Level): void
        public getLevel(): cn.nukkit.level.Level
        level: cn.nukkit.level.Level

    }
}

declare module "cn.nukkit.event.level.LevelEvent" {
    declare const LevelEvent = cn.nukkit.event.level.LevelEvent;
}

declare namespace cn.nukkit.event.level {
    declare class ChunkLoadEvent extends cn.nukkit.event.level.ChunkEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(chunk: cn.nukkit.level.format.FullChunk, newChunk: boolean): void
        public isNewChunk(): boolean
        static handlers: cn.nukkit.event.HandlerList
        newChunk: boolean

    }
}

declare module "cn.nukkit.event.level.ChunkLoadEvent" {
    declare const ChunkLoadEvent = cn.nukkit.event.level.ChunkLoadEvent;
}

declare namespace cn.nukkit.event.level {
    declare class ThunderChangeEvent extends cn.nukkit.event.level.WeatherEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(level: cn.nukkit.level.Level, to: boolean): void
        public toThunderState(): boolean
        static handlers: cn.nukkit.event.HandlerList
        to: boolean

    }
}

declare module "cn.nukkit.event.level.ThunderChangeEvent" {
    declare const ThunderChangeEvent = cn.nukkit.event.level.ThunderChangeEvent;
}

declare namespace cn.nukkit.event.level {
    declare class ChunkUnloadEvent extends cn.nukkit.event.level.ChunkEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(chunk: cn.nukkit.level.format.FullChunk): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.level.ChunkUnloadEvent" {
    declare const ChunkUnloadEvent = cn.nukkit.event.level.ChunkUnloadEvent;
}

declare namespace cn.nukkit.event.level {
    declare class SpawnChangeEvent extends cn.nukkit.event.level.LevelEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(level: cn.nukkit.level.Level, previousSpawn: cn.nukkit.level.Position): void
        public getPreviousSpawn(): cn.nukkit.level.Position
        static handlers: cn.nukkit.event.HandlerList
        previousSpawn: cn.nukkit.level.Position

    }
}

declare module "cn.nukkit.event.level.SpawnChangeEvent" {
    declare const SpawnChangeEvent = cn.nukkit.event.level.SpawnChangeEvent;
}

declare namespace cn.nukkit.event.level {
    declare class LevelSaveEvent extends cn.nukkit.event.level.LevelEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(level: cn.nukkit.level.Level): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.level.LevelSaveEvent" {
    declare const LevelSaveEvent = cn.nukkit.event.level.LevelSaveEvent;
}

declare namespace cn.nukkit.event.level {
    declare class LevelLoadEvent extends cn.nukkit.event.level.LevelEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(level: cn.nukkit.level.Level): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.level.LevelLoadEvent" {
    declare const LevelLoadEvent = cn.nukkit.event.level.LevelLoadEvent;
}

declare namespace cn.nukkit.event.level {
    declare class LevelInitEvent extends cn.nukkit.event.level.LevelEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(level: cn.nukkit.level.Level): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.level.LevelInitEvent" {
    declare const LevelInitEvent = cn.nukkit.event.level.LevelInitEvent;
}

declare namespace cn.nukkit.event.level {
    declare class ChunkPopulateEvent extends cn.nukkit.event.level.ChunkEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(chunk: cn.nukkit.level.format.FullChunk): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.level.ChunkPopulateEvent" {
    declare const ChunkPopulateEvent = cn.nukkit.event.level.ChunkPopulateEvent;
}

declare namespace cn.nukkit.event.level {
    declare class WeatherChangeEvent extends cn.nukkit.event.level.WeatherEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(level: cn.nukkit.level.Level, to: boolean): void
        public toWeatherState(): boolean
        static handlers: cn.nukkit.event.HandlerList
        to: boolean

    }
}

declare module "cn.nukkit.event.level.WeatherChangeEvent" {
    declare const WeatherChangeEvent = cn.nukkit.event.level.WeatherChangeEvent;
}

declare namespace cn.nukkit.event.level {
    declare class WeatherEvent extends cn.nukkit.event.Event {
        public constructor(level: cn.nukkit.level.Level): void
        public getLevel(): cn.nukkit.level.Level
        level: cn.nukkit.level.Level

    }
}

declare module "cn.nukkit.event.level.WeatherEvent" {
    declare const WeatherEvent = cn.nukkit.event.level.WeatherEvent;
}

declare namespace cn.nukkit.event {
    declare class HandlerList extends java.lang.Object {
        public static bakeAll(): void
        public static unregisterAll(): void
        public static unregisterAll(plugin: cn.nukkit.plugin.Plugin): void
        public static unregisterAll(listener: cn.nukkit.event.Listener): void
        public constructor(): void
        public register(listener: cn.nukkit.plugin.RegisteredListener): void
        public registerAll(listeners: java.util.Collection<cn.nukkit.plugin.RegisteredListener>): void
        public unregister(listener: cn.nukkit.plugin.RegisteredListener): void
        public unregister(plugin: cn.nukkit.plugin.Plugin): void
        public unregister(listener: cn.nukkit.event.Listener): void
        public bake(): void
        public getRegisteredListeners(): cn.nukkit.plugin.RegisteredListener[]
        public static getRegisteredListeners(plugin: cn.nukkit.plugin.Plugin): java.util.ArrayList<cn.nukkit.plugin.RegisteredListener>
        public static getHandlerLists(): java.util.ArrayList<cn.nukkit.event.HandlerList>
        public isEmpty(): boolean
        handlers: cn.nukkit.plugin.RegisteredListener[]
        handlerslots: java.util.EnumMap<cn.nukkit.event.EventPriority, java.util.ArrayList<cn.nukkit.plugin.RegisteredListener>>
        static allLists: java.util.ArrayList<cn.nukkit.event.HandlerList>

    }
}

declare module "cn.nukkit.event.HandlerList" {
    declare const HandlerList = cn.nukkit.event.HandlerList;
}

declare namespace cn.nukkit.event.potion {
    declare class PotionEvent extends cn.nukkit.event.Event {
        public constructor(potion: cn.nukkit.potion.Potion): void
        public getPotion(): cn.nukkit.potion.Potion
        public setPotion(potion: cn.nukkit.potion.Potion): void
        potion: cn.nukkit.potion.Potion

    }
}

declare module "cn.nukkit.event.potion.PotionEvent" {
    declare const PotionEvent = cn.nukkit.event.potion.PotionEvent;
}

declare namespace cn.nukkit.event.potion {
    declare class PotionCollideEvent extends cn.nukkit.event.potion.PotionEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(potion: cn.nukkit.potion.Potion, thrownPotion: cn.nukkit.entity.item.EntityPotion): void
        public getThrownPotion(): cn.nukkit.entity.item.EntityPotion
        static handlers: cn.nukkit.event.HandlerList
        thrownPotion: cn.nukkit.entity.item.EntityPotion

    }
}

declare module "cn.nukkit.event.potion.PotionCollideEvent" {
    declare const PotionCollideEvent = cn.nukkit.event.potion.PotionCollideEvent;
}

declare namespace cn.nukkit.event.potion {
    declare class PotionApplyEvent extends cn.nukkit.event.potion.PotionEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(potion: cn.nukkit.potion.Potion, applyEffect: cn.nukkit.potion.Effect, entity: cn.nukkit.entity.Entity): void
        public getEntity(): cn.nukkit.entity.Entity
        public getApplyEffect(): cn.nukkit.potion.Effect
        public setApplyEffect(applyEffect: cn.nukkit.potion.Effect): void
        static handlers: cn.nukkit.event.HandlerList
        applyEffect: cn.nukkit.potion.Effect
        entity: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.event.potion.PotionApplyEvent" {
    declare const PotionApplyEvent = cn.nukkit.event.potion.PotionApplyEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerBucketEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public constructor(who: cn.nukkit.Player, blockClicked: cn.nukkit.block.Block, blockFace: cn.nukkit.math.BlockFace, liquid: cn.nukkit.block.Block, bucket: cn.nukkit.item.Item, itemInHand: cn.nukkit.item.Item): void
        public getBucket(): cn.nukkit.item.Item
        public getItem(): cn.nukkit.item.Item
        public setItem(item: cn.nukkit.item.Item): void
        public getBlockClicked(): cn.nukkit.block.Block
        public getBlockFace(): cn.nukkit.math.BlockFace
        blockClicked: cn.nukkit.block.Block
        blockFace: cn.nukkit.math.BlockFace
        liquid: cn.nukkit.block.Block
        bucket: cn.nukkit.item.Item
        item: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.event.player.PlayerBucketEvent" {
    declare const PlayerBucketEvent = cn.nukkit.event.player.PlayerBucketEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerItemConsumeEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, item: cn.nukkit.item.Item): void
        public getItem(): cn.nukkit.item.Item
        static handlers: cn.nukkit.event.HandlerList
        item: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.event.player.PlayerItemConsumeEvent" {
    declare const PlayerItemConsumeEvent = cn.nukkit.event.player.PlayerItemConsumeEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerEvent extends cn.nukkit.event.Event {
        public constructor(): void
        public getPlayer(): cn.nukkit.Player
        player: cn.nukkit.Player

    }
}

declare module "cn.nukkit.event.player.PlayerEvent" {
    declare const PlayerEvent = cn.nukkit.event.player.PlayerEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerTeleportEvent$TeleportCause extends java.lang.Enum {
        public static values(): cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause[]
        public static valueOf(name: string): cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause
        constructor(): void
        static $values(): cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause[]
        public static COMMAND: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause
        public static PLUGIN: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause
        public static NETHER_PORTAL: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause
        public static ENDER_PEARL: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause
        public static CHORUS_FRUIT: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause
        public static UNKNOWN: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause
        public static END_PORTAL: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause
        public static END_GATEWAY: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause
        static $VALUES: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause[]

    }
}

declare module "cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause" {
    declare const PlayerTeleportEvent$TeleportCause = cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerToggleSneakEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, isSneaking: boolean): void
        public isSneaking(): boolean
        static handlers: cn.nukkit.event.HandlerList
        isSneaking: boolean

    }
}

declare module "cn.nukkit.event.player.PlayerToggleSneakEvent" {
    declare const PlayerToggleSneakEvent = cn.nukkit.event.player.PlayerToggleSneakEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerGameModeChangeEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, newGameMode: int, newAdventureSettings: cn.nukkit.AdventureSettings): void
        public getNewGamemode(): int
        public getNewAdventureSettings(): cn.nukkit.AdventureSettings
        public setNewAdventureSettings(newAdventureSettings: cn.nukkit.AdventureSettings): void
        static handlers: cn.nukkit.event.HandlerList
        gamemode: int
        newAdventureSettings: cn.nukkit.AdventureSettings

    }
}

declare module "cn.nukkit.event.player.PlayerGameModeChangeEvent" {
    declare const PlayerGameModeChangeEvent = cn.nukkit.event.player.PlayerGameModeChangeEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerAsyncPreLoginEvent extends cn.nukkit.event.player.PlayerEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(name: string, uuid: java.util.UUID, address: string, port: int): void
        public constructor(name: string, uuid: java.util.UUID, chainData: cn.nukkit.utils.LoginChainData, skin: cn.nukkit.entity.data.Skin, address: string, port: int): void
        public getPlayer(): cn.nukkit.Player
        public getName(): string
        public getUuid(): java.util.UUID
        public getChainData(): cn.nukkit.utils.LoginChainData
        public getXuid(): string
        public getSkin(): cn.nukkit.entity.data.Skin
        public setSkin(skin: cn.nukkit.entity.data.Skin): void
        public getAddress(): string
        public getPort(): int
        public getLoginResult(): cn.nukkit.event.player.PlayerAsyncPreLoginEvent$LoginResult
        public setLoginResult(loginResult: cn.nukkit.event.player.PlayerAsyncPreLoginEvent$LoginResult): void
        public getKickMessage(): string
        public setKickMessage(kickMessage: string): void
        public scheduleSyncAction(action: java.util.function.Consumer<cn.nukkit.Server>): void
        public getScheduledActions(): java.util.List<java.util.function.Consumer<cn.nukkit.Server>>
        public allow(): void
        public disAllow(message: string): void
        static handlers: cn.nukkit.event.HandlerList
        name: string
        uuid: java.util.UUID
        chainData: cn.nukkit.utils.LoginChainData
        skin: cn.nukkit.entity.data.Skin
        address: string
        port: int
        loginResult: cn.nukkit.event.player.PlayerAsyncPreLoginEvent$LoginResult
        kickMessage: string
        scheduledActions: java.util.List<java.util.function.Consumer<cn.nukkit.Server>>

    }
}

declare module "cn.nukkit.event.player.PlayerAsyncPreLoginEvent" {
    declare const PlayerAsyncPreLoginEvent = cn.nukkit.event.player.PlayerAsyncPreLoginEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerFormRespondedEvent extends cn.nukkit.event.player.PlayerEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, formID: int, window: cn.nukkit.form.window.FormWindow): void
        public getFormID(): int
        public getWindow(): cn.nukkit.form.window.FormWindow
        public getResponse(): cn.nukkit.form.response.FormResponse
        public wasClosed(): boolean
        static handlers: cn.nukkit.event.HandlerList
        formID: int
        window: cn.nukkit.form.window.FormWindow
        closed: boolean

    }
}

declare module "cn.nukkit.event.player.PlayerFormRespondedEvent" {
    declare const PlayerFormRespondedEvent = cn.nukkit.event.player.PlayerFormRespondedEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerLoginEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, kickMessage: string): void
        public getKickMessage(): string
        public setKickMessage(kickMessage: string): void
        static handlers: cn.nukkit.event.HandlerList
        kickMessage: string

    }
}

declare module "cn.nukkit.event.player.PlayerLoginEvent" {
    declare const PlayerLoginEvent = cn.nukkit.event.player.PlayerLoginEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerKickEvent$Reason extends java.lang.Enum {
        public static values(): cn.nukkit.event.player.PlayerKickEvent$Reason[]
        public static valueOf(name: string): cn.nukkit.event.player.PlayerKickEvent$Reason
        constructor(): void
        public toString(): string
        static $values(): cn.nukkit.event.player.PlayerKickEvent$Reason[]
        public static NEW_CONNECTION: cn.nukkit.event.player.PlayerKickEvent$Reason
        public static KICKED_BY_ADMIN: cn.nukkit.event.player.PlayerKickEvent$Reason
        public static NOT_WHITELISTED: cn.nukkit.event.player.PlayerKickEvent$Reason
        public static IP_BANNED: cn.nukkit.event.player.PlayerKickEvent$Reason
        public static NAME_BANNED: cn.nukkit.event.player.PlayerKickEvent$Reason
        public static INVALID_PVE: cn.nukkit.event.player.PlayerKickEvent$Reason
        public static LOGIN_TIMEOUT: cn.nukkit.event.player.PlayerKickEvent$Reason
        public static SERVER_FULL: cn.nukkit.event.player.PlayerKickEvent$Reason
        public static FLYING_DISABLED: cn.nukkit.event.player.PlayerKickEvent$Reason
        public static INVALID_PVP: cn.nukkit.event.player.PlayerKickEvent$Reason
        public static UNKNOWN: cn.nukkit.event.player.PlayerKickEvent$Reason
        static $VALUES: cn.nukkit.event.player.PlayerKickEvent$Reason[]

    }
}

declare module "cn.nukkit.event.player.PlayerKickEvent$Reason" {
    declare const PlayerKickEvent$Reason = cn.nukkit.event.player.PlayerKickEvent$Reason;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerEditBookEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, oldBook: cn.nukkit.item.Item, newBook: cn.nukkit.item.Item, action: cn.nukkit.network.protocol.BookEditPacket$Action): void
        public getAction(): cn.nukkit.network.protocol.BookEditPacket$Action
        public getOldBook(): cn.nukkit.item.Item
        public getNewBook(): cn.nukkit.item.Item
        public setNewBook(book: cn.nukkit.item.Item): void
        static handlers: cn.nukkit.event.HandlerList
        oldBook: cn.nukkit.item.Item
        action: cn.nukkit.network.protocol.BookEditPacket$Action
        newBook: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.event.player.PlayerEditBookEvent" {
    declare const PlayerEditBookEvent = cn.nukkit.event.player.PlayerEditBookEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerAsyncPreLoginEvent$LoginResult extends java.lang.Enum {
        public static values(): cn.nukkit.event.player.PlayerAsyncPreLoginEvent$LoginResult[]
        public static valueOf(name: string): cn.nukkit.event.player.PlayerAsyncPreLoginEvent$LoginResult
        constructor(): void
        static $values(): cn.nukkit.event.player.PlayerAsyncPreLoginEvent$LoginResult[]
        public static SUCCESS: cn.nukkit.event.player.PlayerAsyncPreLoginEvent$LoginResult
        public static KICK: cn.nukkit.event.player.PlayerAsyncPreLoginEvent$LoginResult
        static $VALUES: cn.nukkit.event.player.PlayerAsyncPreLoginEvent$LoginResult[]

    }
}

declare module "cn.nukkit.event.player.PlayerAsyncPreLoginEvent$LoginResult" {
    declare const PlayerAsyncPreLoginEvent$LoginResult = cn.nukkit.event.player.PlayerAsyncPreLoginEvent$LoginResult;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerBedEnterEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, bed: cn.nukkit.block.Block): void
        public getBed(): cn.nukkit.block.Block
        static handlers: cn.nukkit.event.HandlerList
        bed: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.event.player.PlayerBedEnterEvent" {
    declare const PlayerBedEnterEvent = cn.nukkit.event.player.PlayerBedEnterEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerInteractEntityEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public constructor(player: cn.nukkit.Player, entity: cn.nukkit.entity.Entity, item: cn.nukkit.item.Item, clickedPos: cn.nukkit.math.Vector3): void
        public getEntity(): cn.nukkit.entity.Entity
        public getItem(): cn.nukkit.item.Item
        public getClickedPos(): cn.nukkit.math.Vector3
        public static getHandlers(): cn.nukkit.event.HandlerList
        static handlers: cn.nukkit.event.HandlerList
        entity: cn.nukkit.entity.Entity
        item: cn.nukkit.item.Item
        clickedPos: cn.nukkit.math.Vector3

    }
}

declare module "cn.nukkit.event.player.PlayerInteractEntityEvent" {
    declare const PlayerInteractEntityEvent = cn.nukkit.event.player.PlayerInteractEntityEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerToggleSpinAttackEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, isSpinAttacking: boolean): void
        public isSpinAttacking(): boolean
        static handlers: cn.nukkit.event.HandlerList
        isSpinAttacking: boolean

    }
}

declare module "cn.nukkit.event.player.PlayerToggleSpinAttackEvent" {
    declare const PlayerToggleSpinAttackEvent = cn.nukkit.event.player.PlayerToggleSpinAttackEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerFishEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, hook: cn.nukkit.entity.item.EntityFishingHook, loot: cn.nukkit.item.Item, experience: int, motion: cn.nukkit.math.Vector3): void
        public getHook(): cn.nukkit.entity.item.EntityFishingHook
        public getLoot(): cn.nukkit.item.Item
        public setLoot(loot: cn.nukkit.item.Item): void
        public getExperience(): int
        public setExperience(experience: int): void
        public getMotion(): cn.nukkit.math.Vector3
        public setMotion(motion: cn.nukkit.math.Vector3): void
        static handlers: cn.nukkit.event.HandlerList
        hook: cn.nukkit.entity.item.EntityFishingHook
        loot: cn.nukkit.item.Item
        experience: int
        motion: cn.nukkit.math.Vector3

    }
}

declare module "cn.nukkit.event.player.PlayerFishEvent" {
    declare const PlayerFishEvent = cn.nukkit.event.player.PlayerFishEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerInteractEvent$Action extends java.lang.Enum {
        public static values(): cn.nukkit.event.player.PlayerInteractEvent$Action[]
        public static valueOf(name: string): cn.nukkit.event.player.PlayerInteractEvent$Action
        constructor(): void
        static $values(): cn.nukkit.event.player.PlayerInteractEvent$Action[]
        public static LEFT_CLICK_BLOCK: cn.nukkit.event.player.PlayerInteractEvent$Action
        public static RIGHT_CLICK_BLOCK: cn.nukkit.event.player.PlayerInteractEvent$Action
        public static LEFT_CLICK_AIR: cn.nukkit.event.player.PlayerInteractEvent$Action
        public static RIGHT_CLICK_AIR: cn.nukkit.event.player.PlayerInteractEvent$Action
        public static PHYSICAL: cn.nukkit.event.player.PlayerInteractEvent$Action
        static $VALUES: cn.nukkit.event.player.PlayerInteractEvent$Action[]

    }
}

declare module "cn.nukkit.event.player.PlayerInteractEvent$Action" {
    declare const PlayerInteractEvent$Action = cn.nukkit.event.player.PlayerInteractEvent$Action;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerChangeSkinEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, skin: cn.nukkit.entity.data.Skin): void
        public getSkin(): cn.nukkit.entity.data.Skin
        static handlers: cn.nukkit.event.HandlerList
        skin: cn.nukkit.entity.data.Skin

    }
}

declare module "cn.nukkit.event.player.PlayerChangeSkinEvent" {
    declare const PlayerChangeSkinEvent = cn.nukkit.event.player.PlayerChangeSkinEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerBucketEmptyEvent extends cn.nukkit.event.player.PlayerBucketEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(who: cn.nukkit.Player, blockClicked: cn.nukkit.block.Block, blockFace: cn.nukkit.math.BlockFace, liquid: cn.nukkit.block.Block, bucket: cn.nukkit.item.Item, itemInHand: cn.nukkit.item.Item): void
        public getBlockFace(): cn.nukkit.math.BlockFace
        public getBlockClicked(): cn.nukkit.block.Block
        public setItem(var0: cn.nukkit.item.Item): void
        public getItem(): cn.nukkit.item.Item
        public getBucket(): cn.nukkit.item.Item
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.player.PlayerBucketEmptyEvent" {
    declare const PlayerBucketEmptyEvent = cn.nukkit.event.player.PlayerBucketEmptyEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerMoveEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, from: cn.nukkit.level.Location, to: cn.nukkit.level.Location): void
        public constructor(player: cn.nukkit.Player, from: cn.nukkit.level.Location, to: cn.nukkit.level.Location, resetBlocks: boolean): void
        public getFrom(): cn.nukkit.level.Location
        public setFrom(from: cn.nukkit.level.Location): void
        public getTo(): cn.nukkit.level.Location
        public setTo(to: cn.nukkit.level.Location): void
        public isResetBlocksAround(): boolean
        public setResetBlocksAround(value: boolean): void
        public setCancelled(): void
        static handlers: cn.nukkit.event.HandlerList
        from: cn.nukkit.level.Location
        to: cn.nukkit.level.Location
        resetBlocksAround: boolean

    }
}

declare module "cn.nukkit.event.player.PlayerMoveEvent" {
    declare const PlayerMoveEvent = cn.nukkit.event.player.PlayerMoveEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerAnimationEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, animatePacket: cn.nukkit.network.protocol.AnimatePacket): void
        public constructor(player: cn.nukkit.Player): void
        public constructor(player: cn.nukkit.Player, animation: cn.nukkit.network.protocol.AnimatePacket$Action): void
        public getAnimationType(): cn.nukkit.network.protocol.AnimatePacket$Action
        public getRowingTime(): float
        static handlers: cn.nukkit.event.HandlerList
        animationType: cn.nukkit.network.protocol.AnimatePacket$Action
        rowingTime: float

    }
}

declare module "cn.nukkit.event.player.PlayerAnimationEvent" {
    declare const PlayerAnimationEvent = cn.nukkit.event.player.PlayerAnimationEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerChunkRequestEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, chunkX: int, chunkZ: int): void
        public getChunkX(): int
        public getChunkZ(): int
        static handlers: cn.nukkit.event.HandlerList
        chunkX: int
        chunkZ: int

    }
}

declare module "cn.nukkit.event.player.PlayerChunkRequestEvent" {
    declare const PlayerChunkRequestEvent = cn.nukkit.event.player.PlayerChunkRequestEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerInteractEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, item: cn.nukkit.item.Item, block: cn.nukkit.math.Vector3, face: cn.nukkit.math.BlockFace): void
        public constructor(player: cn.nukkit.Player, item: cn.nukkit.item.Item, block: cn.nukkit.math.Vector3, face: cn.nukkit.math.BlockFace, action: cn.nukkit.event.player.PlayerInteractEvent$Action): void
        public getAction(): cn.nukkit.event.player.PlayerInteractEvent$Action
        public getItem(): cn.nukkit.item.Item
        public getBlock(): cn.nukkit.block.Block
        public getTouchVector(): cn.nukkit.math.Vector3
        public getFace(): cn.nukkit.math.BlockFace
        static handlers: cn.nukkit.event.HandlerList
        blockTouched: cn.nukkit.block.Block
        touchVector: cn.nukkit.math.Vector3
        blockFace: cn.nukkit.math.BlockFace
        item: cn.nukkit.item.Item
        action: cn.nukkit.event.player.PlayerInteractEvent$Action

    }
}

declare module "cn.nukkit.event.player.PlayerInteractEvent" {
    declare const PlayerInteractEvent = cn.nukkit.event.player.PlayerInteractEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerItemHeldEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, item: cn.nukkit.item.Item, hotbarSlot: int): void
        public getSlot(): int
        public getInventorySlot(): int
        public getItem(): cn.nukkit.item.Item
        static handlers: cn.nukkit.event.HandlerList
        item: cn.nukkit.item.Item
        hotbarSlot: int

    }
}

declare module "cn.nukkit.event.player.PlayerItemHeldEvent" {
    declare const PlayerItemHeldEvent = cn.nukkit.event.player.PlayerItemHeldEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerJumpEvent extends cn.nukkit.event.player.PlayerEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.player.PlayerJumpEvent" {
    declare const PlayerJumpEvent = cn.nukkit.event.player.PlayerJumpEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerMouseOverEntityEvent extends cn.nukkit.event.player.PlayerEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, entity: cn.nukkit.entity.Entity): void
        public getEntity(): cn.nukkit.entity.Entity
        static handlers: cn.nukkit.event.HandlerList
        entity: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.event.player.PlayerMouseOverEntityEvent" {
    declare const PlayerMouseOverEntityEvent = cn.nukkit.event.player.PlayerMouseOverEntityEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerChatEvent extends cn.nukkit.event.player.PlayerMessageEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, message: string): void
        public constructor(player: cn.nukkit.Player, message: string, format: string, recipients: java.util.Set<cn.nukkit.command.CommandSender>): void
        public setPlayer(player: cn.nukkit.Player): void
        public getFormat(): string
        public setFormat(format: string): void
        public getRecipients(): java.util.Set<cn.nukkit.command.CommandSender>
        public setRecipients(recipients: java.util.Set<cn.nukkit.command.CommandSender>): void
        static handlers: cn.nukkit.event.HandlerList
        format: string
        recipients: java.util.Set<cn.nukkit.command.CommandSender>

    }
}

declare module "cn.nukkit.event.player.PlayerChatEvent" {
    declare const PlayerChatEvent = cn.nukkit.event.player.PlayerChatEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerSettingsRespondedEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, formID: int, window: cn.nukkit.form.window.FormWindow): void
        public getFormID(): int
        public getWindow(): cn.nukkit.form.window.FormWindow
        public getResponse(): cn.nukkit.form.response.FormResponse
        public wasClosed(): boolean
        public setCancelled(): void
        static handlers: cn.nukkit.event.HandlerList
        formID: int
        window: cn.nukkit.form.window.FormWindow
        closed: boolean

    }
}

declare module "cn.nukkit.event.player.PlayerSettingsRespondedEvent" {
    declare const PlayerSettingsRespondedEvent = cn.nukkit.event.player.PlayerSettingsRespondedEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerDeathEvent extends cn.nukkit.event.entity.EntityDeathEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, drops: cn.nukkit.item.Item[], deathMessage: cn.nukkit.lang.TextContainer, experience: int): void
        public constructor(player: cn.nukkit.Player, drops: cn.nukkit.item.Item[], deathMessage: string, experience: int): void
        public getEntity(): cn.nukkit.Player
        public getDeathMessage(): cn.nukkit.lang.TextContainer
        public setDeathMessage(deathMessage: cn.nukkit.lang.TextContainer): void
        public setDeathMessage(deathMessage: string): void
        public getKeepInventory(): boolean
        public setKeepInventory(keepInventory: boolean): void
        public getKeepExperience(): boolean
        public setKeepExperience(keepExperience: boolean): void
        public getExperience(): int
        public setExperience(experience: int): void
        public getEntity(): cn.nukkit.entity.Entity
        static handlers: cn.nukkit.event.HandlerList
        deathMessage: cn.nukkit.lang.TextContainer
        keepInventory: boolean
        keepExperience: boolean
        experience: int

    }
}

declare module "cn.nukkit.event.player.PlayerDeathEvent" {
    declare const PlayerDeathEvent = cn.nukkit.event.player.PlayerDeathEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerKickEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, reason: string, quitMessage: string): void
        public constructor(player: cn.nukkit.Player, reason: string, quitMessage: cn.nukkit.lang.TextContainer): void
        public constructor(player: cn.nukkit.Player, reason: cn.nukkit.event.player.PlayerKickEvent$Reason, quitMessage: cn.nukkit.lang.TextContainer): void
        public constructor(player: cn.nukkit.Player, reason: cn.nukkit.event.player.PlayerKickEvent$Reason, quitMessage: string): void
        public constructor(player: cn.nukkit.Player, reason: cn.nukkit.event.player.PlayerKickEvent$Reason, reasonString: string, quitMessage: cn.nukkit.lang.TextContainer): void
        public getReason(): string
        public getReasonEnum(): cn.nukkit.event.player.PlayerKickEvent$Reason
        public getQuitMessage(): cn.nukkit.lang.TextContainer
        public setQuitMessage(quitMessage: cn.nukkit.lang.TextContainer): void
        public setQuitMessage(joinMessage: string): void
        static handlers: cn.nukkit.event.HandlerList
        quitMessage: cn.nukkit.lang.TextContainer
        reason: cn.nukkit.event.player.PlayerKickEvent$Reason
        reasonString: string

    }
}

declare module "cn.nukkit.event.player.PlayerKickEvent" {
    declare const PlayerKickEvent = cn.nukkit.event.player.PlayerKickEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerFreezeEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, speedFactor: float, baseSpeed: float): void
        public setBaseSpeed(baseSpeed: float): void
        public setSpeedFactor(speedFactor: float): void
        public getBaseSpeed(): float
        public getSpeedFactor(): float
        speedFactor: float
        baseSpeed: float
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.player.PlayerFreezeEvent" {
    declare const PlayerFreezeEvent = cn.nukkit.event.player.PlayerFreezeEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerServerSettingsRequestEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, settings: java.util.Map<int, cn.nukkit.form.window.FormWindow>): void
        public getSettings(): java.util.Map<int, cn.nukkit.form.window.FormWindow>
        public setSettings(settings: java.util.Map<int, cn.nukkit.form.window.FormWindow>): void
        public setSettings(id: int, window: cn.nukkit.form.window.FormWindow): void
        static handlers: cn.nukkit.event.HandlerList
        settings: java.util.Map<int, cn.nukkit.form.window.FormWindow>

    }
}

declare module "cn.nukkit.event.player.PlayerServerSettingsRequestEvent" {
    declare const PlayerServerSettingsRequestEvent = cn.nukkit.event.player.PlayerServerSettingsRequestEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerEatFoodEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, food: cn.nukkit.item.food.Food): void
        public getFood(): cn.nukkit.item.food.Food
        public setFood(food: cn.nukkit.item.food.Food): void
        static handlers: cn.nukkit.event.HandlerList
        food: cn.nukkit.item.food.Food

    }
}

declare module "cn.nukkit.event.player.PlayerEatFoodEvent" {
    declare const PlayerEatFoodEvent = cn.nukkit.event.player.PlayerEatFoodEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerAchievementAwardedEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, achievementId: string): void
        public getAchievement(): string
        static handlers: cn.nukkit.event.HandlerList
        achievement: string

    }
}

declare module "cn.nukkit.event.player.PlayerAchievementAwardedEvent" {
    declare const PlayerAchievementAwardedEvent = cn.nukkit.event.player.PlayerAchievementAwardedEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerToggleFlightEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, isFlying: boolean): void
        public isFlying(): boolean
        static handlers: cn.nukkit.event.HandlerList
        isFlying: boolean

    }
}

declare module "cn.nukkit.event.player.PlayerToggleFlightEvent" {
    declare const PlayerToggleFlightEvent = cn.nukkit.event.player.PlayerToggleFlightEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerToggleSprintEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, isSprinting: boolean): void
        public isSprinting(): boolean
        static handlers: cn.nukkit.event.HandlerList
        isSprinting: boolean

    }
}

declare module "cn.nukkit.event.player.PlayerToggleSprintEvent" {
    declare const PlayerToggleSprintEvent = cn.nukkit.event.player.PlayerToggleSprintEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerBucketFillEvent extends cn.nukkit.event.player.PlayerBucketEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(who: cn.nukkit.Player, blockClicked: cn.nukkit.block.Block, blockFace: cn.nukkit.math.BlockFace, liquid: cn.nukkit.block.Block, bucket: cn.nukkit.item.Item, itemInHand: cn.nukkit.item.Item): void
        public getBlockFace(): cn.nukkit.math.BlockFace
        public getBlockClicked(): cn.nukkit.block.Block
        public setItem(var0: cn.nukkit.item.Item): void
        public getItem(): cn.nukkit.item.Item
        public getBucket(): cn.nukkit.item.Item
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.player.PlayerBucketFillEvent" {
    declare const PlayerBucketFillEvent = cn.nukkit.event.player.PlayerBucketFillEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerRespawnEvent extends cn.nukkit.event.player.PlayerEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, position: cn.nukkit.level.Position): void
        public constructor(player: cn.nukkit.Player, position: cn.nukkit.level.Position, firstSpawn: boolean): void
        public getRespawnPosition(): cn.nukkit.level.Position
        public setRespawnPosition(position: cn.nukkit.level.Position): void
        public isFirstSpawn(): boolean
        public getRespawnBlockPosition(): cn.nukkit.level.Position
        public setRespawnBlockPosition(spawnBlock: cn.nukkit.level.Position): void
        public isRespawnBlockAvailable(): boolean
        public setRespawnBlockAvailable(spawnBlockAvailable: boolean): void
        public getOriginalRespawnPosition(): cn.nukkit.level.Position
        public setOriginalRespawnPosition(originalSpawnPosition: cn.nukkit.level.Position): void
        public isKeepRespawnBlockPosition(): boolean
        public setKeepRespawnBlockPosition(keepRespawnBlockPosition: boolean): void
        public isKeepRespawnPosition(): boolean
        public setKeepRespawnPosition(keepRespawnPosition: boolean): void
        public isSendInvalidRespawnBlockMessage(): boolean
        public setSendInvalidRespawnBlockMessage(sendInvalidRespawnBlockMessage: boolean): void
        public isConsumeCharge(): boolean
        public setConsumeCharge(consumeCharge: boolean): void
        static handlers: cn.nukkit.event.HandlerList
        position: cn.nukkit.level.Position
        spawnBlock: cn.nukkit.level.Position
        originalSpawnPosition: cn.nukkit.level.Position
        spawnBlockAvailable: boolean
        firstSpawn: boolean
        keepRespawnBlockPosition: boolean
        keepRespawnPosition: boolean
        sendInvalidRespawnBlockMessage: boolean
        consumeCharge: boolean

    }
}

declare module "cn.nukkit.event.player.PlayerRespawnEvent" {
    declare const PlayerRespawnEvent = cn.nukkit.event.player.PlayerRespawnEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerDialogRespondedEvent extends cn.nukkit.event.player.PlayerEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, dialog: cn.nukkit.dialog.window.FormWindowDialog, response: cn.nukkit.dialog.response.FormResponseDialog): void
        public getDialog(): cn.nukkit.dialog.window.FormWindowDialog
        public getResponse(): cn.nukkit.dialog.response.FormResponseDialog
        static handlers: cn.nukkit.event.HandlerList
        dialog: cn.nukkit.dialog.window.FormWindowDialog
        response: cn.nukkit.dialog.response.FormResponseDialog

    }
}

declare module "cn.nukkit.event.player.PlayerDialogRespondedEvent" {
    declare const PlayerDialogRespondedEvent = cn.nukkit.event.player.PlayerDialogRespondedEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerTeleportEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        constructor(player: cn.nukkit.Player): void
        public constructor(player: cn.nukkit.Player, from: cn.nukkit.level.Location, to: cn.nukkit.level.Location, cause: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause): void
        public constructor(player: cn.nukkit.Player, from: cn.nukkit.math.Vector3, to: cn.nukkit.math.Vector3, cause: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause): void
        public getFrom(): cn.nukkit.level.Location
        public getTo(): cn.nukkit.level.Location
        public getCause(): cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause
        vectorToLocation(baseLevel: cn.nukkit.level.Level, vector: cn.nukkit.math.Vector3): cn.nukkit.level.Location
        static handlers: cn.nukkit.event.HandlerList
        cause: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause
        from: cn.nukkit.level.Location
        to: cn.nukkit.level.Location

    }
}

declare module "cn.nukkit.event.player.PlayerTeleportEvent" {
    declare const PlayerTeleportEvent = cn.nukkit.event.player.PlayerTeleportEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerDropItemEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, drop: cn.nukkit.item.Item): void
        public getItem(): cn.nukkit.item.Item
        static handlers: cn.nukkit.event.HandlerList
        drop: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.event.player.PlayerDropItemEvent" {
    declare const PlayerDropItemEvent = cn.nukkit.event.player.PlayerDropItemEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerQuitEvent extends cn.nukkit.event.player.PlayerEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, quitMessage: cn.nukkit.lang.TextContainer, reason: string): void
        public constructor(player: cn.nukkit.Player, quitMessage: cn.nukkit.lang.TextContainer): void
        public constructor(player: cn.nukkit.Player, quitMessage: string, reason: string): void
        public constructor(player: cn.nukkit.Player, quitMessage: string): void
        public constructor(player: cn.nukkit.Player, quitMessage: string, autoSave: boolean, reason: string): void
        public constructor(player: cn.nukkit.Player, quitMessage: string, autoSave: boolean): void
        public constructor(player: cn.nukkit.Player, quitMessage: cn.nukkit.lang.TextContainer, autoSave: boolean): void
        public constructor(player: cn.nukkit.Player, quitMessage: cn.nukkit.lang.TextContainer, autoSave: boolean, reason: string): void
        public getQuitMessage(): cn.nukkit.lang.TextContainer
        public setQuitMessage(quitMessage: cn.nukkit.lang.TextContainer): void
        public setQuitMessage(quitMessage: string): void
        public getAutoSave(): boolean
        public setAutoSave(): void
        public setAutoSave(autoSave: boolean): void
        public getReason(): string
        static handlers: cn.nukkit.event.HandlerList
        quitMessage: cn.nukkit.lang.TextContainer
        autoSave: boolean
        reason: string

    }
}

declare module "cn.nukkit.event.player.PlayerQuitEvent" {
    declare const PlayerQuitEvent = cn.nukkit.event.player.PlayerQuitEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerPreLoginEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, kickMessage: string): void
        public setKickMessage(kickMessage: string): void
        public getKickMessage(): string
        static handlers: cn.nukkit.event.HandlerList
        kickMessage: string

    }
}

declare module "cn.nukkit.event.player.PlayerPreLoginEvent" {
    declare const PlayerPreLoginEvent = cn.nukkit.event.player.PlayerPreLoginEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerToggleSwimEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, isSwimming: boolean): void
        public isSwimming(): boolean
        static handlers: cn.nukkit.event.HandlerList
        isSwimming: boolean

    }
}

declare module "cn.nukkit.event.player.PlayerToggleSwimEvent" {
    declare const PlayerToggleSwimEvent = cn.nukkit.event.player.PlayerToggleSwimEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerShowCreditsEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.player.PlayerShowCreditsEvent" {
    declare const PlayerShowCreditsEvent = cn.nukkit.event.player.PlayerShowCreditsEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerBlockPickEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, blockClicked: cn.nukkit.block.Block, item: cn.nukkit.item.Item): void
        public getItem(): cn.nukkit.item.Item
        public setItem(item: cn.nukkit.item.Item): void
        public getBlockClicked(): cn.nukkit.block.Block
        static handlers: cn.nukkit.event.HandlerList
        blockClicked: cn.nukkit.block.Block
        item: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.event.player.PlayerBlockPickEvent" {
    declare const PlayerBlockPickEvent = cn.nukkit.event.player.PlayerBlockPickEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerFoodLevelChangeEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, foodLevel: int, foodSaturationLevel: float): void
        public getFoodLevel(): int
        public setFoodLevel(foodLevel: int): void
        public getFoodSaturationLevel(): float
        public setFoodSaturationLevel(foodSaturationLevel: float): void
        static handlers: cn.nukkit.event.HandlerList
        foodLevel: int
        foodSaturationLevel: float

    }
}

declare module "cn.nukkit.event.player.PlayerFoodLevelChangeEvent" {
    declare const PlayerFoodLevelChangeEvent = cn.nukkit.event.player.PlayerFoodLevelChangeEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerLocallyInitializedEvent extends cn.nukkit.event.player.PlayerEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.player.PlayerLocallyInitializedEvent" {
    declare const PlayerLocallyInitializedEvent = cn.nukkit.event.player.PlayerLocallyInitializedEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerMapInfoRequestEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public constructor(p: cn.nukkit.Player, item: cn.nukkit.item.Item): void
        public getMap(): cn.nukkit.item.Item
        public static getHandlers(): cn.nukkit.event.HandlerList
        static handlers: cn.nukkit.event.HandlerList
        item: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.event.player.PlayerMapInfoRequestEvent" {
    declare const PlayerMapInfoRequestEvent = cn.nukkit.event.player.PlayerMapInfoRequestEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerGlassBottleFillEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public constructor(player: cn.nukkit.Player, target: cn.nukkit.block.Block, item: cn.nukkit.item.Item): void
        public getItem(): cn.nukkit.item.Item
        public getBlock(): cn.nukkit.block.Block
        item: cn.nukkit.item.Item
        target: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.event.player.PlayerGlassBottleFillEvent" {
    declare const PlayerGlassBottleFillEvent = cn.nukkit.event.player.PlayerGlassBottleFillEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerCreationEvent extends cn.nukkit.event.Event {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(interfaz: cn.nukkit.network.SourceInterface, baseClass: java.lang.Class<cn.nukkit.Player>, playerClass: java.lang.Class<cn.nukkit.Player>, clientId: long, socketAddress: java.net.InetSocketAddress): void
        public getInterface(): cn.nukkit.network.SourceInterface
        public getAddress(): string
        public getPort(): int
        public getSocketAddress(): java.net.InetSocketAddress
        public getClientId(): long
        public getBaseClass(): java.lang.Class<cn.nukkit.Player>
        public setBaseClass(baseClass: java.lang.Class<cn.nukkit.Player>): void
        public getPlayerClass(): java.lang.Class<cn.nukkit.Player>
        public setPlayerClass(playerClass: java.lang.Class<cn.nukkit.Player>): void
        static handlers: cn.nukkit.event.HandlerList
        interfaz: cn.nukkit.network.SourceInterface
        clientId: long
        socketAddress: java.net.InetSocketAddress
        baseClass: java.lang.Class<cn.nukkit.Player>
        playerClass: java.lang.Class<cn.nukkit.Player>

    }
}

declare module "cn.nukkit.event.player.PlayerCreationEvent" {
    declare const PlayerCreationEvent = cn.nukkit.event.player.PlayerCreationEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerInvalidMoveEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, revert: boolean): void
        public isRevert(): boolean
        public setRevert(revert: boolean): void
        static handlers: cn.nukkit.event.HandlerList
        revert: boolean

    }
}

declare module "cn.nukkit.event.player.PlayerInvalidMoveEvent" {
    declare const PlayerInvalidMoveEvent = cn.nukkit.event.player.PlayerInvalidMoveEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerBedLeaveEvent extends cn.nukkit.event.player.PlayerEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, bed: cn.nukkit.block.Block): void
        public getBed(): cn.nukkit.block.Block
        static handlers: cn.nukkit.event.HandlerList
        bed: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.event.player.PlayerBedLeaveEvent" {
    declare const PlayerBedLeaveEvent = cn.nukkit.event.player.PlayerBedLeaveEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerToggleGlideEvent extends cn.nukkit.event.player.PlayerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(player: cn.nukkit.Player, isSneaking: boolean): void
        public isGliding(): boolean
        static handlers: cn.nukkit.event.HandlerList
        isGliding: boolean

    }
}

declare module "cn.nukkit.event.player.PlayerToggleGlideEvent" {
    declare const PlayerToggleGlideEvent = cn.nukkit.event.player.PlayerToggleGlideEvent;
}

declare namespace cn.nukkit.event.player {
    declare class PlayerMessageEvent extends cn.nukkit.event.player.PlayerEvent {
        public constructor(): void
        public getMessage(): string
        public setMessage(message: string): void
        message: string

    }
}

declare module "cn.nukkit.event.player.PlayerMessageEvent" {
    declare const PlayerMessageEvent = cn.nukkit.event.player.PlayerMessageEvent;
}

declare namespace cn.nukkit.event {
    declare interface Listener {

    }
}

declare module "cn.nukkit.event.Listener" {
    declare type Listener = cn.nukkit.event.Listener;
}

declare namespace cn.nukkit.event.server {
    declare class BatchPacketsEvent extends cn.nukkit.event.server.ServerEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(players: cn.nukkit.Player[], packets: cn.nukkit.network.protocol.DataPacket[], forceSync: boolean): void
        public getPlayers(): cn.nukkit.Player[]
        public getPackets(): cn.nukkit.network.protocol.DataPacket[]
        public isForceSync(): boolean
        static handlers: cn.nukkit.event.HandlerList
        players: cn.nukkit.Player[]
        packets: cn.nukkit.network.protocol.DataPacket[]
        forceSync: boolean

    }
}

declare module "cn.nukkit.event.server.BatchPacketsEvent" {
    declare const BatchPacketsEvent = cn.nukkit.event.server.BatchPacketsEvent;
}

declare namespace cn.nukkit.event.server {
    declare class ServerEvent extends cn.nukkit.event.Event {
        public constructor(): void

    }
}

declare module "cn.nukkit.event.server.ServerEvent" {
    declare const ServerEvent = cn.nukkit.event.server.ServerEvent;
}

declare namespace cn.nukkit.event.server {
    declare class QueryRegenerateEvent extends cn.nukkit.event.server.ServerEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(server: cn.nukkit.Server): void
        public constructor(server: cn.nukkit.Server, timeout: int): void
        public getTimeout(): int
        public setTimeout(timeout: int): void
        public getServerName(): string
        public setServerName(serverName: string): void
        public canListPlugins(): boolean
        public setListPlugins(listPlugins: boolean): void
        public getPlugins(): cn.nukkit.plugin.Plugin[]
        public setPlugins(plugins: cn.nukkit.plugin.Plugin[]): void
        public getPlayerList(): cn.nukkit.Player[]
        public setPlayerList(players: cn.nukkit.Player[]): void
        public getPlayerCount(): int
        public setPlayerCount(count: int): void
        public getMaxPlayerCount(): int
        public setMaxPlayerCount(count: int): void
        public getWorld(): string
        public setWorld(world: string): void
        public getExtraData(): java.util.Map<string, string>
        public setExtraData(extraData: java.util.Map<string, string>): void
        public getLongQuery(buffer: byte[]): byte[]
        public getShortQuery(buffer: byte[]): byte[]
        static handlers: cn.nukkit.event.HandlerList
        static GAME_ID: string
        timeout: int
        serverName: string
        listPlugins: boolean
        plugins: cn.nukkit.plugin.Plugin[]
        players: cn.nukkit.Player[]
        gameType: string
        version: string
        server_engine: string
        map: string
        numPlayers: int
        maxPlayers: int
        whitelist: string
        port: int
        ip: string
        extraData: java.util.Map<string, string>

    }
}

declare module "cn.nukkit.event.server.QueryRegenerateEvent" {
    declare const QueryRegenerateEvent = cn.nukkit.event.server.QueryRegenerateEvent;
}

declare namespace cn.nukkit.event {
    declare interface EventHandler extends java.lang.annotation.Annotation {
        public priority(): cn.nukkit.event.EventPriority
        public ignoreCancelled(): boolean

    }
}

declare module "cn.nukkit.event.EventHandler" {
    declare type EventHandler = cn.nukkit.event.EventHandler;
}

declare namespace cn.nukkit.event.plugin {
    declare class PluginEnableEvent extends cn.nukkit.event.plugin.PluginEvent {
        public constructor(plugin: cn.nukkit.plugin.Plugin): void

    }
}

declare module "cn.nukkit.event.plugin.PluginEnableEvent" {
    declare const PluginEnableEvent = cn.nukkit.event.plugin.PluginEnableEvent;
}

declare namespace cn.nukkit.event.plugin {
    declare class PluginEvent extends cn.nukkit.event.Event {
        public constructor(plugin: cn.nukkit.plugin.Plugin): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        public getPlugin(): cn.nukkit.plugin.Plugin
        static handlers: cn.nukkit.event.HandlerList
        plugin: cn.nukkit.plugin.Plugin

    }
}

declare module "cn.nukkit.event.plugin.PluginEvent" {
    declare const PluginEvent = cn.nukkit.event.plugin.PluginEvent;
}

declare namespace cn.nukkit.event.plugin {
    declare class PluginDisableEvent extends cn.nukkit.event.plugin.PluginEvent {
        public constructor(plugin: cn.nukkit.plugin.Plugin): void

    }
}

declare module "cn.nukkit.event.plugin.PluginDisableEvent" {
    declare const PluginDisableEvent = cn.nukkit.event.plugin.PluginDisableEvent;
}

declare namespace cn.nukkit.event.redstone {
    declare class RedstoneUpdateEvent extends cn.nukkit.event.block.BlockUpdateEvent {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(source: cn.nukkit.block.Block): void
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.redstone.RedstoneUpdateEvent" {
    declare const RedstoneUpdateEvent = cn.nukkit.event.redstone.RedstoneUpdateEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityLevelChangeEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity, originLevel: cn.nukkit.level.Level, targetLevel: cn.nukkit.level.Level): void
        public getOrigin(): cn.nukkit.level.Level
        public getTarget(): cn.nukkit.level.Level
        static handlers: cn.nukkit.event.HandlerList
        originLevel: cn.nukkit.level.Level
        targetLevel: cn.nukkit.level.Level

    }
}

declare module "cn.nukkit.event.entity.EntityLevelChangeEvent" {
    declare const EntityLevelChangeEvent = cn.nukkit.event.entity.EntityLevelChangeEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityEffectRemoveEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public constructor(entity: cn.nukkit.entity.Entity, effect: cn.nukkit.potion.Effect): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        public getRemoveEffect(): cn.nukkit.potion.Effect
        static handlers: cn.nukkit.event.HandlerList
        removeEffect: cn.nukkit.potion.Effect

    }
}

declare module "cn.nukkit.event.entity.EntityEffectRemoveEvent" {
    declare const EntityEffectRemoveEvent = cn.nukkit.event.entity.EntityEffectRemoveEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityCombustEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(combustee: cn.nukkit.entity.Entity, duration: int): void
        public getDuration(): int
        public setDuration(duration: int): void
        static handlers: cn.nukkit.event.HandlerList
        duration: int

    }
}

declare module "cn.nukkit.event.entity.EntityCombustEvent" {
    declare const EntityCombustEvent = cn.nukkit.event.entity.EntityCombustEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityVehicleExitEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity, vehicle: cn.nukkit.entity.Entity): void
        public getVehicle(): cn.nukkit.entity.Entity
        static handlers: cn.nukkit.event.HandlerList
        vehicle: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.event.entity.EntityVehicleExitEvent" {
    declare const EntityVehicleExitEvent = cn.nukkit.event.entity.EntityVehicleExitEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityDamageEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        static createDamageModifierMap(baseDamage: float): java.util.Map<cn.nukkit.event.entity.EntityDamageEvent$DamageModifier, float>
        public constructor(entity: cn.nukkit.entity.Entity, cause: cn.nukkit.event.entity.EntityDamageEvent$DamageCause, damage: float): void
        public constructor(entity: cn.nukkit.entity.Entity, cause: cn.nukkit.event.entity.EntityDamageEvent$DamageCause, modifiers: java.util.Map<cn.nukkit.event.entity.EntityDamageEvent$DamageModifier, float>): void
        public getCause(): cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public getOriginalDamage(): float
        public getOriginalDamage(type: cn.nukkit.event.entity.EntityDamageEvent$DamageModifier): float
        public getDamage(): float
        public getDamage(type: cn.nukkit.event.entity.EntityDamageEvent$DamageModifier): float
        public setDamage(damage: float): void
        public setDamage(damage: float, type: cn.nukkit.event.entity.EntityDamageEvent$DamageModifier): void
        public isApplicable(type: cn.nukkit.event.entity.EntityDamageEvent$DamageModifier): boolean
        public getFinalDamage(): float
        public getAttackCooldown(): int
        public setAttackCooldown(attackCooldown: int): void
        public getSideEffects(): cn.nukkit.item.enchantment.sideeffect.SideEffect[]
        public setSideEffects(sideEffects: cn.nukkit.item.enchantment.sideeffect.SideEffect[]): void
        public setSideEffects(sideEffects: java.util.Collection<cn.nukkit.item.enchantment.sideeffect.SideEffect>): void
        public addSideEffects(sideEffects: cn.nukkit.item.enchantment.sideeffect.SideEffect[]): void
        public addSideEffects(sideEffects: java.util.Collection<cn.nukkit.item.enchantment.sideeffect.SideEffect>): void
        public canBeReducedByArmor(): boolean
        static lambda$addSideEffects$2(x$0: int): cn.nukkit.item.enchantment.sideeffect.SideEffect[]
        static lambda$setSideEffects$1(x$0: int): cn.nukkit.item.enchantment.sideeffect.SideEffect[]
        static lambda$getSideEffects$0(x$0: int): cn.nukkit.item.enchantment.sideeffect.SideEffect[]
        static handlers: cn.nukkit.event.HandlerList
        attackCooldown: int
        cause: cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        modifiers: java.util.Map<cn.nukkit.event.entity.EntityDamageEvent$DamageModifier, float>
        originals: java.util.Map<cn.nukkit.event.entity.EntityDamageEvent$DamageModifier, float>
        sideEffects: cn.nukkit.item.enchantment.sideeffect.SideEffect[]

    }
}

declare module "cn.nukkit.event.entity.EntityDamageEvent" {
    declare const EntityDamageEvent = cn.nukkit.event.entity.EntityDamageEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class CreeperPowerEvent$PowerCause extends java.lang.Enum {
        public static values(): cn.nukkit.event.entity.CreeperPowerEvent$PowerCause[]
        public static valueOf(name: string): cn.nukkit.event.entity.CreeperPowerEvent$PowerCause
        constructor(): void
        static $values(): cn.nukkit.event.entity.CreeperPowerEvent$PowerCause[]
        public static LIGHTNING: cn.nukkit.event.entity.CreeperPowerEvent$PowerCause
        public static SET_ON: cn.nukkit.event.entity.CreeperPowerEvent$PowerCause
        public static SET_OFF: cn.nukkit.event.entity.CreeperPowerEvent$PowerCause
        static $VALUES: cn.nukkit.event.entity.CreeperPowerEvent$PowerCause[]

    }
}

declare module "cn.nukkit.event.entity.CreeperPowerEvent$PowerCause" {
    declare const CreeperPowerEvent$PowerCause = cn.nukkit.event.entity.CreeperPowerEvent$PowerCause;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityDamageEvent$DamageModifier extends java.lang.Enum {
        public static values(): cn.nukkit.event.entity.EntityDamageEvent$DamageModifier[]
        public static valueOf(name: string): cn.nukkit.event.entity.EntityDamageEvent$DamageModifier
        constructor(): void
        static $values(): cn.nukkit.event.entity.EntityDamageEvent$DamageModifier[]
        public static BASE: cn.nukkit.event.entity.EntityDamageEvent$DamageModifier
        public static ARMOR: cn.nukkit.event.entity.EntityDamageEvent$DamageModifier
        public static STRENGTH: cn.nukkit.event.entity.EntityDamageEvent$DamageModifier
        public static WEAKNESS: cn.nukkit.event.entity.EntityDamageEvent$DamageModifier
        public static RESISTANCE: cn.nukkit.event.entity.EntityDamageEvent$DamageModifier
        public static ABSORPTION: cn.nukkit.event.entity.EntityDamageEvent$DamageModifier
        public static ARMOR_ENCHANTMENTS: cn.nukkit.event.entity.EntityDamageEvent$DamageModifier
        static $VALUES: cn.nukkit.event.entity.EntityDamageEvent$DamageModifier[]

    }
}

declare module "cn.nukkit.event.entity.EntityDamageEvent$DamageModifier" {
    declare const EntityDamageEvent$DamageModifier = cn.nukkit.event.entity.EntityDamageEvent$DamageModifier;
}

declare namespace cn.nukkit.event.entity {
    declare class CreeperPowerEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(creeper: cn.nukkit.entity.mob.EntityCreeper, bolt: cn.nukkit.entity.weather.EntityLightningStrike, cause: cn.nukkit.event.entity.CreeperPowerEvent$PowerCause): void
        public constructor(creeper: cn.nukkit.entity.mob.EntityCreeper, cause: cn.nukkit.event.entity.CreeperPowerEvent$PowerCause): void
        public getEntity(): cn.nukkit.entity.mob.EntityCreeper
        public getLightning(): cn.nukkit.entity.weather.EntityLightningStrike
        public getCause(): cn.nukkit.event.entity.CreeperPowerEvent$PowerCause
        public getEntity(): cn.nukkit.entity.Entity
        static handlers: cn.nukkit.event.HandlerList
        cause: cn.nukkit.event.entity.CreeperPowerEvent$PowerCause
        bolt: cn.nukkit.entity.weather.EntityLightningStrike

    }
}

declare module "cn.nukkit.event.entity.CreeperPowerEvent" {
    declare const CreeperPowerEvent = cn.nukkit.event.entity.CreeperPowerEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityInteractEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity, block: cn.nukkit.block.Block): void
        public getBlock(): cn.nukkit.block.Block
        static handlers: cn.nukkit.event.HandlerList
        block: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.event.entity.EntityInteractEvent" {
    declare const EntityInteractEvent = cn.nukkit.event.entity.EntityInteractEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityMotionEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity, motion: cn.nukkit.math.Vector3): void
        public getVector(): cn.nukkit.math.Vector3
        public getMotion(): cn.nukkit.math.Vector3
        static handlers: cn.nukkit.event.HandlerList
        motion: cn.nukkit.math.Vector3

    }
}

declare module "cn.nukkit.event.entity.EntityMotionEvent" {
    declare const EntityMotionEvent = cn.nukkit.event.entity.EntityMotionEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityBlockChangeEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity, from: cn.nukkit.block.Block, to: cn.nukkit.block.Block): void
        public getFrom(): cn.nukkit.block.Block
        public getTo(): cn.nukkit.block.Block
        static handlers: cn.nukkit.event.HandlerList
        from: cn.nukkit.block.Block
        to: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.event.entity.EntityBlockChangeEvent" {
    declare const EntityBlockChangeEvent = cn.nukkit.event.entity.EntityBlockChangeEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntitySpawnEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity): void
        public getPosition(): cn.nukkit.level.Position
        public getType(): int
        public isCreature(): boolean
        public isHuman(): boolean
        public isProjectile(): boolean
        public isVehicle(): boolean
        public isItem(): boolean
        static handlers: cn.nukkit.event.HandlerList
        entityType: int

    }
}

declare module "cn.nukkit.event.entity.EntitySpawnEvent" {
    declare const EntitySpawnEvent = cn.nukkit.event.entity.EntitySpawnEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class ExplosionPrimeEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity, force: double): void
        public getForce(): double
        public setForce(force: double): void
        public isBlockBreaking(): boolean
        public setBlockBreaking(affectsBlocks: boolean): void
        static handlers: cn.nukkit.event.HandlerList
        force: double
        blockBreaking: boolean

    }
}

declare module "cn.nukkit.event.entity.ExplosionPrimeEvent" {
    declare const ExplosionPrimeEvent = cn.nukkit.event.entity.ExplosionPrimeEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityCombustByEntityEvent extends cn.nukkit.event.entity.EntityCombustEvent {
        public constructor(combuster: cn.nukkit.entity.Entity, combustee: cn.nukkit.entity.Entity, duration: int): void
        public getCombuster(): cn.nukkit.entity.Entity
        combuster: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.event.entity.EntityCombustByEntityEvent" {
    declare const EntityCombustByEntityEvent = cn.nukkit.event.entity.EntityCombustByEntityEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityExplosionPrimeEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity, force: double): void
        public getForce(): double
        public setForce(force: double): void
        public isBlockBreaking(): boolean
        public setBlockBreaking(blockBreaking: boolean): void
        public isIncendiary(): boolean
        public setIncendiary(incendiary: boolean): void
        public getFireChance(): double
        public setFireChance(fireChance: double): void
        static handlers: cn.nukkit.event.HandlerList
        force: double
        blockBreaking: boolean
        fireChance: double

    }
}

declare module "cn.nukkit.event.entity.EntityExplosionPrimeEvent" {
    declare const EntityExplosionPrimeEvent = cn.nukkit.event.entity.EntityExplosionPrimeEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityDamageEvent$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$event$entity$EntityDamageEvent$DamageCause: int[]

    }
}

declare module "cn.nukkit.event.entity.EntityDamageEvent$1" {
    declare const EntityDamageEvent$1 = cn.nukkit.event.entity.EntityDamageEvent$1;
}

declare namespace cn.nukkit.event.entity {
    declare class CreatureSpawnEvent extends cn.nukkit.event.Event implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(networkId: int, position: cn.nukkit.level.Position, nbt: cn.nukkit.nbt.tag.CompoundTag, reason: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason): void
        public constructor(networkId: int, position: cn.nukkit.level.Position, reason: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason): void
        public getReason(): cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        public getEntityNetworkId(): int
        public getCompoundTag(): cn.nukkit.nbt.tag.CompoundTag
        public getPosition(): cn.nukkit.level.Position
        static handlers: cn.nukkit.event.HandlerList
        reason: cn.nukkit.event.entity.CreatureSpawnEvent$SpawnReason
        entityNetworkId: int
        position: cn.nukkit.level.Position
        compoundTag: cn.nukkit.nbt.tag.CompoundTag

    }
}

declare module "cn.nukkit.event.entity.CreatureSpawnEvent" {
    declare const CreatureSpawnEvent = cn.nukkit.event.entity.CreatureSpawnEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityFallEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity, blockFallOn: cn.nukkit.block.Block, fallDistance: float): void
        public getBlockFallOn(): cn.nukkit.block.Block
        public getFallDistance(): float
        public setFallDistance(distance: float): void
        static handlers: cn.nukkit.event.HandlerList
        blockFallOn: cn.nukkit.block.Block
        fallDistance: float

    }
}

declare module "cn.nukkit.event.entity.EntityFallEvent" {
    declare const EntityFallEvent = cn.nukkit.event.entity.EntityFallEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class ProjectileLaunchEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.projectile.EntityProjectile): void
        public getEntity(): cn.nukkit.entity.projectile.EntityProjectile
        public getEntity(): cn.nukkit.entity.Entity
        static handlers: cn.nukkit.event.HandlerList

    }
}

declare module "cn.nukkit.event.entity.ProjectileLaunchEvent" {
    declare const ProjectileLaunchEvent = cn.nukkit.event.entity.ProjectileLaunchEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityEffectUpdateEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public constructor(entity: cn.nukkit.entity.Entity, oldEffect: cn.nukkit.potion.Effect, newEffect: cn.nukkit.potion.Effect): void
        public static getHandlers(): cn.nukkit.event.HandlerList
        public getOldEffect(): cn.nukkit.potion.Effect
        public getNewEffect(): cn.nukkit.potion.Effect
        static handlers: cn.nukkit.event.HandlerList
        oldEffect: cn.nukkit.potion.Effect
        newEffect: cn.nukkit.potion.Effect

    }
}

declare module "cn.nukkit.event.entity.EntityEffectUpdateEvent" {
    declare const EntityEffectUpdateEvent = cn.nukkit.event.entity.EntityEffectUpdateEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityMoveByPistonEvent extends cn.nukkit.event.entity.EntityMotionEvent implements cn.nukkit.event.Cancellable {
        public constructor(entity: cn.nukkit.entity.Entity, pos: cn.nukkit.math.Vector3): void

    }
}

declare module "cn.nukkit.event.entity.EntityMoveByPistonEvent" {
    declare const EntityMoveByPistonEvent = cn.nukkit.event.entity.EntityMoveByPistonEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityPortalEnterEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity, type: cn.nukkit.event.entity.EntityPortalEnterEvent$PortalType): void
        public getPortalType(): cn.nukkit.event.entity.EntityPortalEnterEvent$PortalType
        static handlers: cn.nukkit.event.HandlerList
        type: cn.nukkit.event.entity.EntityPortalEnterEvent$PortalType

    }
}

declare module "cn.nukkit.event.entity.EntityPortalEnterEvent" {
    declare const EntityPortalEnterEvent = cn.nukkit.event.entity.EntityPortalEnterEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityArmorChangeEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity, oldItem: cn.nukkit.item.Item, newItem: cn.nukkit.item.Item, slot: int): void
        public getSlot(): int
        public getNewItem(): cn.nukkit.item.Item
        public setNewItem(newItem: cn.nukkit.item.Item): void
        public getOldItem(): cn.nukkit.item.Item
        static handlers: cn.nukkit.event.HandlerList
        oldItem: cn.nukkit.item.Item
        newItem: cn.nukkit.item.Item
        slot: int

    }
}

declare module "cn.nukkit.event.entity.EntityArmorChangeEvent" {
    declare const EntityArmorChangeEvent = cn.nukkit.event.entity.EntityArmorChangeEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityDamageByBlockEvent extends cn.nukkit.event.entity.EntityDamageEvent {
        public constructor(damager: cn.nukkit.block.Block, entity: cn.nukkit.entity.Entity, cause: cn.nukkit.event.entity.EntityDamageEvent$DamageCause, damage: float): void
        public getDamager(): cn.nukkit.block.Block
        damager: cn.nukkit.block.Block

    }
}

declare module "cn.nukkit.event.entity.EntityDamageByBlockEvent" {
    declare const EntityDamageByBlockEvent = cn.nukkit.event.entity.EntityDamageByBlockEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityInventoryChangeEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity, oldItem: cn.nukkit.item.Item, newItem: cn.nukkit.item.Item, slot: int): void
        public getSlot(): int
        public getNewItem(): cn.nukkit.item.Item
        public setNewItem(newItem: cn.nukkit.item.Item): void
        public getOldItem(): cn.nukkit.item.Item
        static handlers: cn.nukkit.event.HandlerList
        oldItem: cn.nukkit.item.Item
        newItem: cn.nukkit.item.Item
        slot: int

    }
}

declare module "cn.nukkit.event.entity.EntityInventoryChangeEvent" {
    declare const EntityInventoryChangeEvent = cn.nukkit.event.entity.EntityInventoryChangeEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class ProjectileHitEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.projectile.EntityProjectile): void
        public constructor(entity: cn.nukkit.entity.projectile.EntityProjectile, movingObjectPosition: cn.nukkit.level.MovingObjectPosition): void
        public getMovingObjectPosition(): cn.nukkit.level.MovingObjectPosition
        public setMovingObjectPosition(movingObjectPosition: cn.nukkit.level.MovingObjectPosition): void
        static handlers: cn.nukkit.event.HandlerList
        movingObjectPosition: cn.nukkit.level.MovingObjectPosition

    }
}

declare module "cn.nukkit.event.entity.ProjectileHitEvent" {
    declare const ProjectileHitEvent = cn.nukkit.event.entity.ProjectileHitEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityDamageBlockedEvent extends cn.nukkit.event.entity.EntityEvent implements cn.nukkit.event.Cancellable {
        public static getHandlers(): cn.nukkit.event.HandlerList
        public constructor(entity: cn.nukkit.entity.Entity, damage: cn.nukkit.event.entity.EntityDamageEvent, knockBack: boolean, animation: boolean): void
        public getCause(): cn.nukkit.event.entity.EntityDamageEvent$DamageCause
        public getAttacker(): cn.nukkit.entity.Entity
        public getDamage(): cn.nukkit.event.entity.EntityDamageEvent
        public getKnockBackAttacker(): boolean
        public getAnimation(): boolean
        static handlers: cn.nukkit.event.HandlerList
        damage: cn.nukkit.event.entity.EntityDamageEvent
        knockBackAttacker: boolean
        animation: boolean

    }
}

declare module "cn.nukkit.event.entity.EntityDamageBlockedEvent" {
    declare const EntityDamageBlockedEvent = cn.nukkit.event.entity.EntityDamageBlockedEvent;
}

declare namespace cn.nukkit.event.entity {
    declare class EntityPortalEnterEvent$PortalType extends java.lang.Enum {
        public static values(): cn.nukkit.event.entity.EntityPortalEnterEvent$PortalType[]
        public static valueOf(name: string): cn.nukkit.event.entity.EntityPortalEnterEvent$PortalType
        constructor(): void
        static $values(): cn.nukkit.event.entity.EntityPortalEnterEvent$PortalType[]
        public static NETHER: cn.nukkit.event.entity.EntityPortalEnterEvent$PortalType
        public static END: cn.nukkit.event.entity.EntityPortalEnterEvent$PortalType
        static $VALUES: cn.nukkit.event.entity.EntityPortalEnterEvent$PortalType[]

    }
}

declare module "cn.nukkit.event.entity.EntityPortalEnterEvent$PortalType" {
    declare const EntityPortalEnterEvent$PortalType = cn.nukkit.event.entity.EntityPortalEnterEvent$PortalType;
}

declare namespace cn.nukkit.console {
    declare class NukkitConsoleCompleter extends java.lang.Object implements org.jline.reader.Completer {
        public complete(lineReader: org.jline.reader.LineReader, parsedLine: org.jline.reader.ParsedLine, candidates: java.util.List<org.jline.reader.Candidate>): void
        addCandidates(commandConsumer: java.util.function.Consumer<string>): void
        public constructor(server: cn.nukkit.Server): void
        static lambda$complete$1(names: java.util.SortedSet, p: cn.nukkit.Player): void
        static lambda$complete$0(candidates: java.util.List, s: string): void
        server: cn.nukkit.Server

    }
}

declare module "cn.nukkit.console.NukkitConsoleCompleter" {
    declare const NukkitConsoleCompleter = cn.nukkit.console.NukkitConsoleCompleter;
}

declare namespace cn.nukkit.positiontracking {
    declare class PositionTrackingService extends java.lang.Object implements java.io.Closeable {
        public constructor(folder: java.io.File): void
        hasTrackingDevice(player: cn.nukkit.Player, inventory: cn.nukkit.inventory.Inventory, trackingHandler: int): boolean
        isTrackingDevice(player: cn.nukkit.Player, item: cn.nukkit.item.Item, trackingHandler: int): boolean
        public hasTrackingDevice(player: cn.nukkit.Player, trackingHandler: int): boolean
        sendTrackingUpdate(player: cn.nukkit.Player, trackingHandler: int, pos: cn.nukkit.positiontracking.PositionTracking): void
        sendTrackingDestroy(player: cn.nukkit.Player, trackingHandler: int): void
        public startTracking(player: cn.nukkit.Player, trackingHandler: int, validate: boolean): cn.nukkit.positiontracking.PositionTracking
        destroyPacket(trackingHandler: int): cn.nukkit.network.protocol.PositionTrackingDBServerBroadcastPacket
        public stopTracking(player: cn.nukkit.Player): boolean
        public stopTracking(player: cn.nukkit.Player, trackingHandler: int): boolean
        public isTracking(player: cn.nukkit.Player, trackingHandler: int, validate: boolean): boolean
        public forceRecheckAllPlayers(): void
        inventories(player: cn.nukkit.Player): java.lang.Iterable<cn.nukkit.inventory.Inventory>
        detectNeededUpdates(player: cn.nukkit.Player): void
        public forceRecheck(player: cn.nukkit.Player): void
        findStorageForHandler(handler: int): int
        loadStorage(startIndex: int): cn.nukkit.positiontracking.PositionTrackingStorage
        getStorageForHandler(trackingHandler: int): cn.nukkit.positiontracking.PositionTrackingStorage
        public addOrReusePosition(position: cn.nukkit.positiontracking.NamedPosition): int
        public addNewPosition(position: cn.nukkit.positiontracking.NamedPosition): int
        public addNewPosition(position: cn.nukkit.positiontracking.NamedPosition, enabled: boolean): int
        public findTrackingHandler(position: cn.nukkit.positiontracking.NamedPosition): java.util.OptionalInt
        public invalidateHandler(trackingHandler: int): boolean
        handlerDisabled(trackingHandler: int): void
        handlerEnabled(trackingHandler: int): void
        public getPosition(trackingHandle: int): cn.nukkit.positiontracking.PositionTracking
        public getPosition(trackingHandle: int, onlyEnabled: boolean): cn.nukkit.positiontracking.PositionTracking
        public isEnabled(trackingHandler: int): boolean
        public setEnabled(trackingHandler: int, enabled: boolean): boolean
        public hasPosition(trackingHandler: int): boolean
        public hasPosition(trackingHandler: int, onlyEnabled: boolean): boolean
        public findTrackingHandlers(pos: cn.nukkit.positiontracking.NamedPosition): it.unimi.dsi.fastutil.ints.IntList
        public findTrackingHandlers(pos: cn.nukkit.positiontracking.NamedPosition, onlyEnabled: boolean): it.unimi.dsi.fastutil.ints.IntList
        public findTrackingHandlers(pos: cn.nukkit.positiontracking.NamedPosition, onlyEnabled: boolean, limit: int): it.unimi.dsi.fastutil.ints.IntList
        public close(): void
        finalize(): void
        checkClosed(): void
        lambda$forceRecheck$15(player: cn.nukkit.Player, handler: int): void
        lambda$forceRecheck$14(player: cn.nukkit.Player, toRemove: it.unimi.dsi.fastutil.ints.IntList, trackingHandler: int): void
        lambda$inventories$13(player: cn.nukkit.Player): java.util.Iterator
        lambda$forceRecheckAllPlayers$12(player: cn.nukkit.Player, list: it.unimi.dsi.fastutil.ints.IntList): void
        lambda$forceRecheckAllPlayers$11(player: cn.nukkit.Player, handler: int): void
        lambda$forceRecheckAllPlayers$10(player: cn.nukkit.Player, toRemove: java.util.Map, trackingHandler: int): void
        static lambda$forceRecheckAllPlayers$9(p: cn.nukkit.Player): it.unimi.dsi.fastutil.ints.IntList
        static lambda$forceRecheckAllPlayers$8(p: cn.nukkit.Player): boolean
        static lambda$stopTracking$7(x$0: int): cn.nukkit.network.protocol.DataPacket[]
        static lambda$stopTracking$6(handlers: it.unimi.dsi.fastutil.ints.IntSet): java.util.stream.IntStream
        static lambda$startTracking$5(s: cn.nukkit.positiontracking.PositionTrackingStorage): it.unimi.dsi.fastutil.ints.IntSet
        static lambda$startTracking$4(p: cn.nukkit.Player): java.util.Map
        lambda$new$3(emptyRef: java.lang.ref.WeakReference, startIndex: int): void
        static lambda$new$2(name: string): int
        static lambda$new$1(folder: java.io.File): java.io.FileNotFoundException
        static lambda$static$0(dir: java.io.File, name: string): boolean
        static log: org.apache.logging.log4j.Logger
        static FILENAME_PATTERN: java.util.regex.Pattern
        static FILENAME_FILTER: java.io.FilenameFilter
        storage: java.util.TreeMap<int, java.lang.ref.WeakReference<cn.nukkit.positiontracking.PositionTrackingStorage>>
        closed: java.util.concurrent.atomic.AtomicBoolean
        folder: java.io.File
        tracking: java.util.Map<cn.nukkit.Player, java.util.Map<cn.nukkit.positiontracking.PositionTrackingStorage, it.unimi.dsi.fastutil.ints.IntSet>>

    }
}

declare module "cn.nukkit.positiontracking.PositionTrackingService" {
    declare const PositionTrackingService = cn.nukkit.positiontracking.PositionTrackingService;
}

declare namespace cn.nukkit.positiontracking {
    declare class NamedPosition extends cn.nukkit.math.Vector3 {
        public constructor(): void
        public constructor(x: double): void
        public constructor(x: double, var1: double): void
        public constructor(x: double, var1: double, y: double): void
        public getLevelName(): string
        public matchesNamedPosition(position: cn.nukkit.positiontracking.NamedPosition): boolean
        public clone(): cn.nukkit.positiontracking.NamedPosition
        public clone(): cn.nukkit.math.Vector3
        public clone(): java.lang.Object

    }
}

declare module "cn.nukkit.positiontracking.NamedPosition" {
    declare const NamedPosition = cn.nukkit.positiontracking.NamedPosition;
}

declare namespace cn.nukkit.plugin {
    declare interface EventExecutor {
        public execute(var0: cn.nukkit.event.Listener, var1: cn.nukkit.event.Event): void

    }
}

declare module "cn.nukkit.plugin.EventExecutor" {
    declare type EventExecutor = cn.nukkit.plugin.EventExecutor;
}

declare namespace cn.nukkit.plugin {
    declare interface Library {
        public getGroupId(): string
        public getArtifactId(): string
        public getVersion(): string

    }
}

declare module "cn.nukkit.plugin.Library" {
    declare type Library = cn.nukkit.plugin.Library;
}

declare namespace cn.nukkit.plugin {
    declare interface PluginLoader {
        public loadPlugin(var0: string): cn.nukkit.plugin.Plugin
        public loadPlugin(var0: java.io.File): cn.nukkit.plugin.Plugin
        public getPluginDescription(var0: string): cn.nukkit.plugin.PluginDescription
        public getPluginDescription(var0: java.io.File): cn.nukkit.plugin.PluginDescription
        public getPluginFilters(): java.util.regex.Pattern[]
        public enablePlugin(var0: cn.nukkit.plugin.Plugin): void
        public disablePlugin(var0: cn.nukkit.plugin.Plugin): void

    }
}

declare module "cn.nukkit.plugin.PluginLoader" {
    declare type PluginLoader = cn.nukkit.plugin.PluginLoader;
}

declare namespace cn.nukkit.plugin.service {
    declare class RegisteredServiceProvider extends java.lang.Object implements java.lang.Comparable {
        constructor(service: java.lang.Class<any>, provider: cn.nukkit.plugin.service.ServicePriority, priority: cn.nukkit.plugin.Plugin): void
        public getService(): java.lang.Class<any>
        public getPlugin(): cn.nukkit.plugin.Plugin
        public getProvider(): any
        public getPriority(): cn.nukkit.plugin.service.ServicePriority
        public equals(o: java.lang.Object): boolean
        public hashCode(): int
        public compareTo(other: cn.nukkit.plugin.service.RegisteredServiceProvider<any>): int
        public compareTo(var0: java.lang.Object): int
        plugin: cn.nukkit.plugin.Plugin
        priority: cn.nukkit.plugin.service.ServicePriority
        service: java.lang.Class<any>
        provider: any

    }
}

declare module "cn.nukkit.plugin.service.RegisteredServiceProvider" {
    declare const RegisteredServiceProvider = cn.nukkit.plugin.service.RegisteredServiceProvider;
}

declare namespace cn.nukkit.plugin.service {
    declare class ServicePriority extends java.lang.Enum {
        public static values(): cn.nukkit.plugin.service.ServicePriority[]
        public static valueOf(name: string): cn.nukkit.plugin.service.ServicePriority
        constructor(): void
        static $values(): cn.nukkit.plugin.service.ServicePriority[]
        public static LOWEST: cn.nukkit.plugin.service.ServicePriority
        public static LOWER: cn.nukkit.plugin.service.ServicePriority
        public static NORMAL: cn.nukkit.plugin.service.ServicePriority
        public static HIGHER: cn.nukkit.plugin.service.ServicePriority
        public static HIGHEST: cn.nukkit.plugin.service.ServicePriority
        static $VALUES: cn.nukkit.plugin.service.ServicePriority[]

    }
}

declare module "cn.nukkit.plugin.service.ServicePriority" {
    declare const ServicePriority = cn.nukkit.plugin.service.ServicePriority;
}

declare namespace cn.nukkit.plugin.service {
    declare interface ServiceManager {
        public register(var0: java.lang.Object, var1: java.lang.Class<any>, var2: cn.nukkit.plugin.Plugin, var3: cn.nukkit.plugin.service.ServicePriority): boolean
        public cancel(var0: cn.nukkit.plugin.Plugin): java.util.List<short>
        public cancel(var0: java.lang.Object, var1: java.lang.Class<any>): cn.nukkit.plugin.service.RegisteredServiceProvider<any>
        public getProvider(var0: java.lang.Object, var1: java.lang.Class<any>): cn.nukkit.plugin.service.RegisteredServiceProvider<any>
        public getKnownService(): java.util.List<char>
        public getRegistrations(var0: cn.nukkit.plugin.Plugin): java.util.List<short>
        public getRegistrations(var0: java.lang.Object, var1: java.lang.Class<any>): java.util.List<cn.nukkit.plugin.service.RegisteredServiceProvider<any>>
        public isProvidedFor(var0: java.lang.Object, var1: java.lang.Class<any>): boolean

    }
}

declare module "cn.nukkit.plugin.service.ServiceManager" {
    declare type ServiceManager = cn.nukkit.plugin.service.ServiceManager;
}

declare namespace cn.nukkit.plugin {
    declare class PluginLoadOrder extends java.lang.Enum {
        public static values(): cn.nukkit.plugin.PluginLoadOrder[]
        public static valueOf(name: string): cn.nukkit.plugin.PluginLoadOrder
        constructor(): void
        static $values(): cn.nukkit.plugin.PluginLoadOrder[]
        public static STARTUP: cn.nukkit.plugin.PluginLoadOrder
        public static POSTWORLD: cn.nukkit.plugin.PluginLoadOrder
        static $VALUES: cn.nukkit.plugin.PluginLoadOrder[]

    }
}

declare module "cn.nukkit.plugin.PluginLoadOrder" {
    declare const PluginLoadOrder = cn.nukkit.plugin.PluginLoadOrder;
}

declare namespace cn.nukkit.plugin {
    declare class LibraryLoadException extends java.lang.RuntimeException {
        public constructor(library: cn.nukkit.plugin.Library): void

    }
}

declare module "cn.nukkit.plugin.LibraryLoadException" {
    declare const LibraryLoadException = cn.nukkit.plugin.LibraryLoadException;
}

declare namespace cn.nukkit.plugin {
    declare class CommonJSPlugin extends java.lang.Object implements cn.nukkit.plugin.Plugin, cn.nukkit.event.Listener {
        public constructor(): void
        public init(jsPluginLoader: cn.nukkit.plugin.JSPluginLoader, pluginDir: java.io.File, pluginDescription: cn.nukkit.plugin.PluginDescription): void
        public onCommand(sender: cn.nukkit.command.CommandSender, command: cn.nukkit.command.Command, label: string, args: string[]): boolean
        public onLoad(): void
        public onEnable(): void
        public isEnabled(): boolean
        public onDisable(): void
        public isDisabled(): boolean
        public getDataFolder(): java.io.File
        public getDescription(): cn.nukkit.plugin.PluginDescription
        public getResource(filename: string): java.io.InputStream
        public saveResource(filename: string): boolean
        public saveResource(filename: string, replace: boolean): boolean
        public saveResource(filename: string, outputName: string, replace: boolean): boolean
        public getConfig(): cn.nukkit.utils.Config
        public saveConfig(): void
        public saveDefaultConfig(): void
        public reloadConfig(): void
        public getServer(): cn.nukkit.Server
        public getName(): string
        public getLogger(): cn.nukkit.plugin.PluginLogger
        public getPluginLoader(): cn.nukkit.plugin.PluginLoader
        public isInitialized(): boolean
        public getJsContext(): org.graalvm.polyglot.Context
        public getJsExports(): org.graalvm.polyglot.Value
        public getFileSystem(): cn.nukkit.plugin.js.ESMFileSystem
        static lambda$init$0(className: string): boolean
        public static jsPluginIdMap: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap<cn.nukkit.plugin.CommonJSPlugin>
        public static jsExternalMap: java.util.concurrent.ConcurrentHashMap<string, cn.nukkit.plugin.js.JSExternal>
        public static globalMaxId: int
        pluginName: string
        pluginDir: java.io.File
        mainJSFile: java.io.File
        server: cn.nukkit.Server
        isEnabled: boolean
        initialized: boolean
        description: cn.nukkit.plugin.PluginDescription
        jsPluginLoader: cn.nukkit.plugin.JSPluginLoader
        logger: cn.nukkit.plugin.PluginLogger
        fileSystem: cn.nukkit.plugin.js.ESMFileSystem
        jsContext: org.graalvm.polyglot.Context
        jsExports: org.graalvm.polyglot.Value
        public usedFeatures: java.util.LinkedHashMap<string, cn.nukkit.plugin.js.JSFeature>
        public id: int

    }
}

declare module "cn.nukkit.plugin.CommonJSPlugin" {
    declare const CommonJSPlugin = cn.nukkit.plugin.CommonJSPlugin;
}

declare namespace cn.nukkit.plugin.js {
    declare class JSSafeObject extends java.lang.Object {
        public constructor(jsContext: org.graalvm.polyglot.Context, object: java.lang.Object, lockTimeout: long): void
        public atomicUse(): java.lang.Object
        public use(): java.lang.Object
        public getTimeout(): long
        public setTimeout(timeout: long): cn.nukkit.plugin.js.JSSafeObject
        public endUse(): void
        lambda$use$0(): java.lang.Object
        jsContext: org.graalvm.polyglot.Context
        lock: java.util.concurrent.locks.ReentrantLock
        object: java.lang.Object
        public timeout: long

    }
}

declare module "cn.nukkit.plugin.js.JSSafeObject" {
    declare const JSSafeObject = cn.nukkit.plugin.js.JSSafeObject;
}

declare namespace cn.nukkit.plugin.js.external {
    declare class ExternalObject extends cn.nukkit.plugin.js.JSExternal implements org.graalvm.polyglot.proxy.ProxyObject {
        public constructor(sourceContext: org.graalvm.polyglot.Context, value: org.graalvm.polyglot.Value): void
        public getMember(key: string): java.lang.Object
        public getMemberKeys(): java.lang.Object
        public hasMember(key: string): boolean
        public putMember(key: string, value: org.graalvm.polyglot.Value): void
        public removeMember(key: string): boolean

    }
}

declare module "cn.nukkit.plugin.js.external.ExternalObject" {
    declare const ExternalObject = cn.nukkit.plugin.js.external.ExternalObject;
}

declare namespace cn.nukkit.plugin.js {
    declare class JSConcurrentManager$JPromise extends java.lang.Object implements cn.nukkit.plugin.js.JSConcurrentManager$Thenable, cn.nukkit.plugin.js.JSConcurrentManager$Executable {
        public constructor(context: org.graalvm.polyglot.Context, javaFuture: char, var2: float): void
        public then(onResolve: org.graalvm.polyglot.Value, onReject: org.graalvm.polyglot.Value): void
        public then(onResolve: org.graalvm.polyglot.Value): void
        public onPromiseCreation(onResolve: org.graalvm.polyglot.Value, onReject: org.graalvm.polyglot.Value): void
        public waitAndGet(): java.lang.Object
        public waitAndGet(timeOut: long): java.lang.Object
        public join(): java.lang.Object
        lambda$onPromiseCreation$2(onResolve: org.graalvm.polyglot.Value, onReject: org.graalvm.polyglot.Value, result: java.lang.Object, ex: java.lang.Throwable): void
        lambda$then$1(onResolve: org.graalvm.polyglot.Value, result: java.lang.Object, ex: java.lang.Throwable): void
        lambda$then$0(onResolve: org.graalvm.polyglot.Value, onReject: org.graalvm.polyglot.Value, result: java.lang.Object, ex: java.lang.Throwable): void
        context: org.graalvm.polyglot.Context
        javaFuture: char

    }
}

declare module "cn.nukkit.plugin.js.JSConcurrentManager$JPromise" {
    declare const JSConcurrentManager$JPromise = cn.nukkit.plugin.js.JSConcurrentManager$JPromise;
}

declare namespace cn.nukkit.plugin.js {
    declare class JSExternal$ReferenceNotAliveException extends java.lang.RuntimeException {
        public constructor(message: string): void

    }
}

declare module "cn.nukkit.plugin.js.JSExternal$ReferenceNotAliveException" {
    declare const JSExternal$ReferenceNotAliveException = cn.nukkit.plugin.js.JSExternal$ReferenceNotAliveException;
}

declare namespace cn.nukkit.plugin.js {
    declare interface JSConcurrentManager$Executable {
        public onPromiseCreation(var0: org.graalvm.polyglot.Value, var1: org.graalvm.polyglot.Value): void

    }
}

declare module "cn.nukkit.plugin.js.JSConcurrentManager$Executable" {
    declare type JSConcurrentManager$Executable = cn.nukkit.plugin.js.JSConcurrentManager$Executable;
}

declare namespace cn.nukkit.plugin.js {
    declare class JSEventManager$CommandBuilder extends java.lang.Object {
        public constructor(jsPlugin: cn.nukkit.plugin.CommonJSPlugin): void
        public getCommandName(): string
        public setCommandName(commandName: string): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public getDescription(): string
        public setDescription(description: string): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public getUsageMessage(): string
        public setUsageMessage(usageMessage: string): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public getAlias(): string[]
        public setAlias(alias: string[]): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addAlias(alias: string[]): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public getPermission(): string
        public setPermission(permission: string): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public getPermissionMessage(): string
        public setPermissionMessage(permissionMessage: string): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public getCommandParameters(): java.util.Map<string, cn.nukkit.command.data.CommandParameter[]>
        public setCommandParameters(commandParameters: java.util.Map<string, cn.nukkit.command.data.CommandParameter[]>): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public getCallback(): org.graalvm.polyglot.Value
        public setCallback(callback: org.graalvm.polyglot.Value): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public createCommandPattern(patternName: string): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public createDefaultPattern(): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addTypeParameter(name: string, optional: boolean, commandParamType: cn.nukkit.command.data.CommandParamType): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addIntParameter(name: string, optional: boolean): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addFloatParameter(name: string, optional: boolean): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addValueParameter(name: string, optional: boolean): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addWildcardIntParameter(name: string, optional: boolean): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addTargetParameter(name: string, optional: boolean): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addWildcardTargetParameter(name: string, optional: boolean): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addStringParameter(name: string, optional: boolean): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addBlockPositionParameter(name: string, optional: boolean): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addPositionParameter(name: string, optional: boolean): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addMessageParameter(name: string, optional: boolean): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addTextParameter(name: string, optional: boolean): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addJsonParameter(name: string, optional: boolean): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addSubCommandParameter(name: string, optional: boolean): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addFilePathParameter(name: string, optional: boolean): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addOperatorParameter(name: string, optional: boolean): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public addEnumParameter(name: string, optional: boolean, enumValues: string[]): cn.nukkit.plugin.js.JSEventManager$CommandBuilder
        public register(): boolean
        jsPlugin: cn.nukkit.plugin.CommonJSPlugin
        commandName: string
        description: string
        usageMessage: string
        alias: string[]
        permission: string
        permissionMessage: string
        commandParameters: java.util.Map<string, cn.nukkit.command.data.CommandParameter[]>
        callback: org.graalvm.polyglot.Value
        currentCommandPatternId: string
        currentCommandParameterList: java.util.List<cn.nukkit.command.data.CommandParameter>

    }
}

declare module "cn.nukkit.plugin.js.JSEventManager$CommandBuilder" {
    declare const JSEventManager$CommandBuilder = cn.nukkit.plugin.js.JSEventManager$CommandBuilder;
}

declare namespace cn.nukkit.plugin.js {
    declare class JSJob extends java.lang.Object implements java.lang.AutoCloseable {
        public constructor(sourceContext: org.graalvm.polyglot.Context, fileSystem: cn.nukkit.plugin.js.ESMFileSystem, jobSourcePath: string): void
        public init(): void
        public start(): void
        public work(args: java.lang.Object[]): cn.nukkit.plugin.js.JSConcurrentManager$JPromise
        public close(): void
        lambda$work$1(args: java.lang.Object[]): java.lang.Object
        static lambda$init$0(className: string): boolean
        sourceContext: org.graalvm.polyglot.Context
        fileSystem: cn.nukkit.plugin.js.ESMFileSystem
        jobSourcePath: string
        jobContext: org.graalvm.polyglot.Context
        sourceReader: java.io.Reader
        sourcePath: java.nio.file.Path
        jobMainFunc: org.graalvm.polyglot.Value

    }
}

declare module "cn.nukkit.plugin.js.JSJob" {
    declare const JSJob = cn.nukkit.plugin.js.JSJob;
}

declare namespace cn.nukkit.plugin.js.feature.ws {
    declare class WsClientBuilder extends java.lang.Object implements org.graalvm.polyglot.proxy.ProxyObject {
        public constructor(sourceContext: org.graalvm.polyglot.Context): void
        public getMember(key: string): java.lang.Object
        public getMemberKeys(): java.lang.Object
        public hasMember(key: string): boolean
        public putMember(key: string, value: org.graalvm.polyglot.Value): void
        lambda$getMember$11(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$getMember$10(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$getMember$9(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$getMember$8(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$getMember$7(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$getMember$6(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$getMember$5(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$getMember$4(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$getMember$3(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$getMember$2(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$getMember$1(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$getMember$0(arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        sourceContext: org.graalvm.polyglot.Context
        webSocketBuilder: java.net.http.WebSocket$Builder
        uri: java.net.URI
        onOpenHandler: org.graalvm.polyglot.Value
        onErrorHandler: org.graalvm.polyglot.Value
        onBinaryHandler: org.graalvm.polyglot.Value
        onCloseHandler: org.graalvm.polyglot.Value
        onPingHandler: org.graalvm.polyglot.Value
        onPongHandler: org.graalvm.polyglot.Value
        onTextHandler: org.graalvm.polyglot.Value
        public static memberKeys: java.util.List<string>

    }
}

declare module "cn.nukkit.plugin.js.feature.ws.WsClientBuilder" {
    declare const WsClientBuilder = cn.nukkit.plugin.js.feature.ws.WsClientBuilder;
}

declare namespace cn.nukkit.plugin.js.feature.ws {
    declare class WsClientBuilder$1 extends java.lang.Object implements java.net.http.WebSocket$Listener {
        constructor(this$0: cn.nukkit.plugin.js.feature.ws.WsClientBuilder): void
        public onOpen(webSocket: java.net.http.WebSocket): void
        public onText(webSocket: java.net.http.WebSocket, data: java.lang.CharSequence, last: boolean, var3: char): short
        public onBinary(webSocket: java.net.http.WebSocket, data: java.nio.ByteBuffer, last: boolean, var3: char): short
        public onPing(webSocket: java.net.http.WebSocket, message: java.nio.ByteBuffer, var2: char): short
        public onPong(webSocket: java.net.http.WebSocket, message: java.nio.ByteBuffer, var2: char): short
        public onClose(webSocket: java.net.http.WebSocket, statusCode: int, reason: string, var3: char): short
        public onError(webSocket: java.net.http.WebSocket, error: java.lang.Throwable): void
        this$0: cn.nukkit.plugin.js.feature.ws.WsClientBuilder

    }
}

declare module "cn.nukkit.plugin.js.feature.ws.WsClientBuilder$1" {
    declare const WsClientBuilder$1 = cn.nukkit.plugin.js.feature.ws.WsClientBuilder$1;
}

declare namespace cn.nukkit.plugin.js.feature {
    declare class WsClientFeature extends java.lang.Object implements cn.nukkit.plugin.js.JSFeature {
        public constructor(): void
        public getName(): string
        public availableModuleNames(): java.util.Collection<string>
        public generateModule(moduleName: string, context: org.graalvm.polyglot.Context): java.util.Map<string, org.graalvm.polyglot.proxy.Proxy>

    }
}

declare module "cn.nukkit.plugin.js.feature.WsClientFeature" {
    declare const WsClientFeature = cn.nukkit.plugin.js.feature.WsClientFeature;
}

declare namespace cn.nukkit.plugin.js.feature {
    declare class TestFeature extends java.lang.Object implements cn.nukkit.plugin.js.JSFeature {
        public constructor(): void
        public getName(): string
        public availableModuleNames(): java.util.Collection<string>
        public generateModule(moduleName: string, context: org.graalvm.polyglot.Context): java.util.Map<string, org.graalvm.polyglot.proxy.Proxy>
        static lambda$generateModule$0(arguments: org.graalvm.polyglot.Value[]): java.lang.Object

    }
}

declare module "cn.nukkit.plugin.js.feature.TestFeature" {
    declare const TestFeature = cn.nukkit.plugin.js.feature.TestFeature;
}

declare namespace cn.nukkit.plugin.js {
    declare class JSProxyLogger extends java.lang.Object implements org.graalvm.polyglot.proxy.ProxyObject {
        public constructor(logger: cn.nukkit.plugin.PluginLogger): void
        joinValues(values: org.graalvm.polyglot.Value[]): string
        public getMember(key: string): java.lang.Object
        public getMemberKeys(): java.lang.Object
        public hasMember(key: string): boolean
        public putMember(key: string, value: org.graalvm.polyglot.Value): void
        lambda$new$3(logger: cn.nukkit.plugin.PluginLogger, arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$new$2(logger: cn.nukkit.plugin.PluginLogger, arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$new$1(logger: cn.nukkit.plugin.PluginLogger, arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        lambda$new$0(logger: cn.nukkit.plugin.PluginLogger, arguments: org.graalvm.polyglot.Value[]): java.lang.Object
        static NULL: org.graalvm.polyglot.Value
        log: org.graalvm.polyglot.proxy.ProxyExecutable
        warn: org.graalvm.polyglot.proxy.ProxyExecutable
        debug: org.graalvm.polyglot.proxy.ProxyExecutable
        error: org.graalvm.polyglot.proxy.ProxyExecutable

    }
}

declare module "cn.nukkit.plugin.js.JSProxyLogger" {
    declare const JSProxyLogger = cn.nukkit.plugin.js.JSProxyLogger;
}

declare namespace cn.nukkit.plugin.js {
    declare class ESMJavaExporter extends java.lang.Object {
        public constructor(): void
        public static exportJava(clazz: char): string

    }
}

declare module "cn.nukkit.plugin.js.ESMJavaExporter" {
    declare const ESMJavaExporter = cn.nukkit.plugin.js.ESMJavaExporter;
}

declare namespace cn.nukkit.plugin {
    declare class PowerNukkitPlugin extends cn.nukkit.plugin.PluginBase {
        public static getInstance(): cn.nukkit.plugin.PowerNukkitPlugin
        public constructor(): void
        static INSTANCE: cn.nukkit.plugin.PowerNukkitPlugin

    }
}

declare module "cn.nukkit.plugin.PowerNukkitPlugin" {
    declare const PowerNukkitPlugin = cn.nukkit.plugin.PowerNukkitPlugin;
}

declare namespace cn.nukkit.plugin {
    declare class PluginLogger extends java.lang.Object implements cn.nukkit.utils.Logger {
        public constructor(context: cn.nukkit.plugin.Plugin): void
        public emergency(message: string): void
        public alert(message: string): void
        public critical(message: string): void
        public error(message: string): void
        public warning(message: string): void
        public notice(message: string): void
        public info(message: string): void
        public debug(message: string): void
        toApacheLevel(level: cn.nukkit.utils.LogLevel): org.apache.logging.log4j.Level
        public log(level: cn.nukkit.utils.LogLevel, message: string): void
        public emergency(message: string, t: java.lang.Throwable): void
        public alert(message: string, t: java.lang.Throwable): void
        public critical(message: string, t: java.lang.Throwable): void
        public error(message: string, t: java.lang.Throwable): void
        public warning(message: string, t: java.lang.Throwable): void
        public notice(message: string, t: java.lang.Throwable): void
        public info(message: string, t: java.lang.Throwable): void
        public debug(message: string, t: java.lang.Throwable): void
        public log(level: cn.nukkit.utils.LogLevel, message: string, t: java.lang.Throwable): void
        pluginName: string
        log: org.apache.logging.log4j.Logger

    }
}

declare module "cn.nukkit.plugin.PluginLogger" {
    declare const PluginLogger = cn.nukkit.plugin.PluginLogger;
}

declare namespace cn.nukkit.plugin {
    declare class PluginBase extends java.lang.Object implements cn.nukkit.plugin.Plugin {
        public constructor(): void
        public onLoad(): void
        public onEnable(): void
        public onDisable(): void
        public isEnabled(): boolean
        public setEnabled(): void
        public setEnabled(value: boolean): void
        public isDisabled(): boolean
        public getDataFolder(): java.io.File
        public getDescription(): cn.nukkit.plugin.PluginDescription
        public init(loader: cn.nukkit.plugin.PluginLoader, server: cn.nukkit.Server, description: cn.nukkit.plugin.PluginDescription, dataFolder: java.io.File, file: java.io.File): void
        public getLogger(): cn.nukkit.plugin.PluginLogger
        public isInitialized(): boolean
        public getCommand(name: string): cn.nukkit.command.PluginIdentifiableCommand
        public getPluginCommand(name: string): char
        public onCommand(sender: cn.nukkit.command.CommandSender, command: cn.nukkit.command.Command, label: string, args: string[]): boolean
        public getResource(filename: string): java.io.InputStream
        public saveResource(filename: string): boolean
        public saveResource(filename: string, replace: boolean): boolean
        public saveResource(filename: string, outputName: string, replace: boolean): boolean
        public getConfig(): cn.nukkit.utils.Config
        public saveConfig(): void
        public saveDefaultConfig(): void
        public reloadConfig(): void
        public getServer(): cn.nukkit.Server
        public getName(): string
        public getFullName(): string
        getFile(): java.io.File
        public getPluginLoader(): cn.nukkit.plugin.PluginLoader
        static log: org.apache.logging.log4j.Logger
        loader: cn.nukkit.plugin.PluginLoader
        server: cn.nukkit.Server
        isEnabled: boolean
        initialized: boolean
        description: cn.nukkit.plugin.PluginDescription
        dataFolder: java.io.File
        config: cn.nukkit.utils.Config
        configFile: java.io.File
        file: java.io.File
        logger: cn.nukkit.plugin.PluginLogger

    }
}

declare module "cn.nukkit.plugin.PluginBase" {
    declare const PluginBase = cn.nukkit.plugin.PluginBase;
}

declare namespace cn.nukkit.plugin {
    declare class PluginManager extends java.lang.Object {
        public constructor(server: cn.nukkit.Server, commandMap: cn.nukkit.command.SimpleCommandMap): void
        public getPlugin(name: string): cn.nukkit.plugin.Plugin
        public registerInterface(loaderClass: java.lang.Class<cn.nukkit.plugin.PluginLoader>): boolean
        public loadPowerNukkitPlugins(): void
        public getPlugins(): java.util.Map<string, cn.nukkit.plugin.Plugin>
        public loadPlugin(path: string): cn.nukkit.plugin.Plugin
        public loadPlugin(file: java.io.File): cn.nukkit.plugin.Plugin
        public loadPlugin(path: string, loaders: java.util.Map<string, cn.nukkit.plugin.PluginLoader>): cn.nukkit.plugin.Plugin
        public loadPlugin(file: java.io.File, loaders: java.util.Map<string, cn.nukkit.plugin.PluginLoader>): cn.nukkit.plugin.Plugin
        public loadPlugins(dictionary: string): java.util.Map<string, cn.nukkit.plugin.Plugin>
        public loadPlugins(dictionary: java.io.File): java.util.Map<string, cn.nukkit.plugin.Plugin>
        public loadPlugins(dictionary: string, newLoaders: java.util.List<string>): java.util.Map<string, cn.nukkit.plugin.Plugin>
        public loadPlugins(dictionary: java.io.File, newLoaders: java.util.List<string>): java.util.Map<string, cn.nukkit.plugin.Plugin>
        public loadPlugins(dictionary: java.io.File, newLoaders: java.util.List<string>, includeDir: boolean): java.util.Map<string, cn.nukkit.plugin.Plugin>
        public getPermission(name: string): cn.nukkit.permission.Permission
        public addPermission(permission: cn.nukkit.permission.Permission): boolean
        public removePermission(name: string): void
        public removePermission(permission: cn.nukkit.permission.Permission): void
        public getDefaultPermissions(op: boolean): java.util.Map<string, cn.nukkit.permission.Permission>
        public recalculatePermissionDefaults(permission: cn.nukkit.permission.Permission): void
        calculatePermissionDefault(permission: cn.nukkit.permission.Permission): void
        dirtyPermissibles(op: boolean): void
        public subscribeToPermission(permission: string, permissible: cn.nukkit.permission.Permissible): void
        public unsubscribeFromPermission(permission: string, permissible: cn.nukkit.permission.Permissible): void
        public getPermissionSubscriptions(permission: string): java.util.Set<cn.nukkit.permission.Permissible>
        public subscribeToDefaultPerms(op: boolean, permissible: cn.nukkit.permission.Permissible): void
        public unsubscribeFromDefaultPerms(op: boolean, permissible: cn.nukkit.permission.Permissible): void
        public getDefaultPermSubscriptions(op: boolean): java.util.Set<cn.nukkit.permission.Permissible>
        public getPermissions(): java.util.Map<string, cn.nukkit.permission.Permission>
        public isPluginEnabled(plugin: cn.nukkit.plugin.Plugin): boolean
        public enablePlugin(plugin: cn.nukkit.plugin.Plugin): void
        parseYamlCommands(plugin: cn.nukkit.plugin.Plugin): java.util.List<cn.nukkit.command.PluginCommand>
        public disablePlugins(): void
        public disablePlugin(plugin: cn.nukkit.plugin.Plugin): void
        public clearPlugins(): void
        public callEvent(event: cn.nukkit.event.Event): void
        public registerEvents(listener: cn.nukkit.event.Listener, plugin: cn.nukkit.plugin.Plugin): void
        public registerEvent(event: java.lang.Class<cn.nukkit.event.Event>, listener: cn.nukkit.event.Listener, priority: cn.nukkit.event.EventPriority, executor: cn.nukkit.plugin.EventExecutor, plugin: cn.nukkit.plugin.Plugin): void
        public registerEvent(event: java.lang.Class<cn.nukkit.event.Event>, listener: cn.nukkit.event.Listener, priority: cn.nukkit.event.EventPriority, executor: cn.nukkit.plugin.EventExecutor, plugin: cn.nukkit.plugin.Plugin, ignoreCancelled: boolean): void
        getEventListeners(type: java.lang.Class<cn.nukkit.event.Event>): cn.nukkit.event.HandlerList
        getRegistrationClass(clazz: java.lang.Class<cn.nukkit.event.Event>): java.lang.Class<cn.nukkit.event.Event>
        static lambda$callEvent$2(eventName: string, cb: cn.nukkit.blockentity.BlockEntityCommandBlock, k: string, v: string): void
        lambda$loadPlugins$1(loadedPlugins: java.util.Map, dependency: string): boolean
        static lambda$loadPlugins$0(loader: cn.nukkit.plugin.PluginLoader, dir: java.io.File, name: string): boolean
        static log: org.apache.logging.log4j.Logger
        server: cn.nukkit.Server
        commandMap: cn.nukkit.command.SimpleCommandMap
        plugins: java.util.Map<string, cn.nukkit.plugin.Plugin>
        permissions: java.util.Map<string, cn.nukkit.permission.Permission>
        defaultPerms: java.util.Map<string, cn.nukkit.permission.Permission>
        defaultPermsOp: java.util.Map<string, cn.nukkit.permission.Permission>
        permSubs: java.util.Map<string, java.util.Set<cn.nukkit.permission.Permissible>>
        defSubs: java.util.Set<cn.nukkit.permission.Permissible>
        defSubsOp: java.util.Set<cn.nukkit.permission.Permissible>
        fileAssociations: java.util.Map<string, cn.nukkit.plugin.PluginLoader>

    }
}

declare module "cn.nukkit.plugin.PluginManager" {
    declare const PluginManager = cn.nukkit.plugin.PluginManager;
}

declare namespace cn.nukkit.plugin {
    declare class LibraryLoader$1 extends java.lang.Object implements cn.nukkit.plugin.Library {
        constructor(): void
        public getGroupId(): string
        public getArtifactId(): string
        public getVersion(): string
        val$split: string[]

    }
}

declare module "cn.nukkit.plugin.LibraryLoader$1" {
    declare const LibraryLoader$1 = cn.nukkit.plugin.LibraryLoader$1;
}

declare namespace cn.nukkit.plugin {
    declare class JavaPluginLoader extends java.lang.Object implements cn.nukkit.plugin.PluginLoader {
        public constructor(server: cn.nukkit.Server): void
        public loadPlugin(file: java.io.File): cn.nukkit.plugin.Plugin
        public loadPlugin(filename: string): cn.nukkit.plugin.Plugin
        public getPluginDescription(file: java.io.File): cn.nukkit.plugin.PluginDescription
        public getPluginDescription(filename: string): cn.nukkit.plugin.PluginDescription
        public getPluginFilters(): java.util.regex.Pattern[]
        initPlugin(plugin: cn.nukkit.plugin.PluginBase, description: cn.nukkit.plugin.PluginDescription, dataFolder: java.io.File, file: java.io.File): void
        public enablePlugin(plugin: cn.nukkit.plugin.Plugin): void
        public disablePlugin(plugin: cn.nukkit.plugin.Plugin): void
        getClassByName(name: string): char
        setClass(name: string, clazz: char): void
        removeClass(name: string): void
        static log: org.apache.logging.log4j.Logger
        server: cn.nukkit.Server
        classes: java.util.Map<string, java.lang.Class>
        classLoaders: java.util.Map<string, cn.nukkit.plugin.PluginClassLoader>

    }
}

declare module "cn.nukkit.plugin.JavaPluginLoader" {
    declare const JavaPluginLoader = cn.nukkit.plugin.JavaPluginLoader;
}

declare namespace cn.nukkit.plugin {
    declare class MethodEventExecutor extends java.lang.Object implements cn.nukkit.plugin.EventExecutor {
        public constructor(method: java.lang.reflect.Method): void
        public execute(listener: cn.nukkit.event.Listener, event: cn.nukkit.event.Event): void
        public getMethod(): java.lang.reflect.Method
        public static compile(plugin: cn.nukkit.plugin.Plugin, listenerClass: java.lang.Class<cn.nukkit.event.Listener>, method: java.lang.reflect.Method): cn.nukkit.plugin.EventExecutor
        public static compile(classLoader: java.lang.ClassLoader, listenerClass: java.lang.Class<cn.nukkit.event.Listener>, method: java.lang.reflect.Method): cn.nukkit.plugin.EventExecutor
        static loadClass(loader: java.lang.ClassLoader, b: byte[]): char
        static log: org.apache.logging.log4j.Logger
        public static compileTime: java.util.concurrent.atomic.AtomicInteger
        method: java.lang.reflect.Method
        static defineClassMethodRef: java.lang.ref.WeakReference<java.lang.reflect.Method>

    }
}

declare module "cn.nukkit.plugin.MethodEventExecutor" {
    declare const MethodEventExecutor = cn.nukkit.plugin.MethodEventExecutor;
}

declare namespace cn.nukkit.plugin {
    declare class PluginDescription extends java.lang.Object {
        public constructor(yamlMap: java.util.Map<string, java.lang.Object>): void
        public constructor(yamlString: string): void
        loadMap(plugin: java.util.Map<string, java.lang.Object>): void
        public getFullName(): string
        public getCompatibleAPIs(): java.util.List<string>
        public getAuthors(): java.util.List<string>
        public getPrefix(): string
        public getCommands(): java.util.Map<string, java.lang.Object>
        public getDepend(): java.util.List<string>
        public getDescription(): string
        public getLoadBefore(): java.util.List<string>
        public getMain(): string
        public getName(): string
        public getOrder(): cn.nukkit.plugin.PluginLoadOrder
        public getPermissions(): java.util.List<cn.nukkit.permission.Permission>
        public getSoftDepend(): java.util.List<string>
        public getVersion(): string
        public getWebsite(): string
        public getFeatures(): java.util.List<string>
        name: string
        main: string
        api: java.util.List<string>
        depend: java.util.List<string>
        softDepend: java.util.List<string>
        loadBefore: java.util.List<string>
        version: string
        commands: java.util.Map<string, java.lang.Object>
        description: string
        authors: java.util.List<string>
        website: string
        prefix: string
        order: cn.nukkit.plugin.PluginLoadOrder
        permissions: java.util.List<cn.nukkit.permission.Permission>
        features: java.util.List<string>

    }
}

declare module "cn.nukkit.plugin.PluginDescription" {
    declare const PluginDescription = cn.nukkit.plugin.PluginDescription;
}

declare namespace cn.nukkit.plugin {
    declare class RegisteredListener extends java.lang.Object {
        public constructor(listener: cn.nukkit.event.Listener, executor: cn.nukkit.plugin.EventExecutor, priority: cn.nukkit.event.EventPriority, plugin: cn.nukkit.plugin.Plugin, ignoreCancelled: boolean, timing: co.aikar.timings.Timing): void
        public getListener(): cn.nukkit.event.Listener
        public getPlugin(): cn.nukkit.plugin.Plugin
        public getPriority(): cn.nukkit.event.EventPriority
        public callEvent(event: cn.nukkit.event.Event): void
        public isIgnoringCancelled(): boolean
        public static EMPTY_ARRAY: cn.nukkit.plugin.RegisteredListener[]
        listener: cn.nukkit.event.Listener
        priority: cn.nukkit.event.EventPriority
        plugin: cn.nukkit.plugin.Plugin
        executor: cn.nukkit.plugin.EventExecutor
        ignoreCancelled: boolean
        timing: co.aikar.timings.Timing

    }
}

declare module "cn.nukkit.plugin.RegisteredListener" {
    declare const RegisteredListener = cn.nukkit.plugin.RegisteredListener;
}

declare namespace cn.nukkit.plugin {
    declare class PluginLogger$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$utils$LogLevel: int[]

    }
}

declare module "cn.nukkit.plugin.PluginLogger$1" {
    declare const PluginLogger$1 = cn.nukkit.plugin.PluginLogger$1;
}

declare namespace cn.nukkit.plugin {
    declare class JSPluginLoader extends java.lang.Object implements cn.nukkit.plugin.PluginLoader {
        public constructor(server: cn.nukkit.Server): void
        public loadPlugin(filename: string): cn.nukkit.plugin.Plugin
        public loadPlugin(file: java.io.File): cn.nukkit.plugin.Plugin
        public getPluginDescription(filename: string): cn.nukkit.plugin.PluginDescription
        public getPluginDescription(file: java.io.File): cn.nukkit.plugin.PluginDescription
        public getPluginFilters(): java.util.regex.Pattern[]
        public enablePlugin(plugin: cn.nukkit.plugin.Plugin): void
        public disablePlugin(plugin: cn.nukkit.plugin.Plugin): void
        static log: org.apache.logging.log4j.Logger
        public server: cn.nukkit.Server

    }
}

declare module "cn.nukkit.plugin.JSPluginLoader" {
    declare const JSPluginLoader = cn.nukkit.plugin.JSPluginLoader;
}

declare namespace cn.nukkit {
    declare class Achievement extends java.lang.Object {
        public static broadcast(player: cn.nukkit.Player, achievementId: string): boolean
        public static add(name: string, achievement: cn.nukkit.Achievement): boolean
        public constructor(message: string, requires: string[]): void
        public getMessage(): string
        public broadcast(player: cn.nukkit.Player): void
        public static achievements: java.util.HashMap<string, cn.nukkit.Achievement>
        public message: string
        public requires: string[]

    }
}

declare module "cn.nukkit.Achievement" {
    declare const Achievement = cn.nukkit.Achievement;
}

declare namespace cn.nukkit.timings {
    declare class JsonUtil extends java.lang.Object {
        public constructor(): void
        public static toArray(objects: java.lang.Object[]): com.google.gson.JsonArray
        public static toObject(object: java.lang.Object): com.google.gson.JsonObject
        public static mapToObject(collection: java.lang.Object, mapper: java.lang.Iterable<any>, object: java.util.function.Function<cn.nukkit.timings.JsonUtil$JSONPair>): com.google.gson.JsonObject
        public static mapToArray(elements: java.lang.Object, mapper: java.util.function.Function<java.lang.Object>): com.google.gson.JsonArray
        public static mapToArray(collection: java.lang.Object, mapper: java.lang.Iterable<any>, array: java.util.function.Function<java.lang.Object>): com.google.gson.JsonArray
        static GSON: com.google.gson.Gson

    }
}

declare module "cn.nukkit.timings.JsonUtil" {
    declare const JsonUtil = cn.nukkit.timings.JsonUtil;
}

declare namespace cn.nukkit.timings {
    declare class JsonUtil$JSONPair extends java.lang.Object {
        public constructor(key: string, value: java.lang.Object): void
        public constructor(key: int, value: java.lang.Object): void
        public key: string
        public value: java.lang.Object

    }
}

declare module "cn.nukkit.timings.JsonUtil$JSONPair" {
    declare const JsonUtil$JSONPair = cn.nukkit.timings.JsonUtil$JSONPair;
}

declare namespace cn.nukkit.timings {
    declare class LevelTimings extends java.lang.Object {
        public constructor(level: cn.nukkit.level.Level): void
        public doChunkUnload: co.aikar.timings.Timing
        public doTickPending: co.aikar.timings.Timing
        public doChunkGC: co.aikar.timings.Timing
        public doTick: co.aikar.timings.Timing
        public tickChunks: co.aikar.timings.Timing
        public entityTick: co.aikar.timings.Timing
        public blockEntityTick: co.aikar.timings.Timing
        public syncChunkSendTimer: co.aikar.timings.Timing
        public syncChunkSendPrepareTimer: co.aikar.timings.Timing
        public syncChunkLoadTimer: co.aikar.timings.Timing
        public syncChunkLoadDataTimer: co.aikar.timings.Timing
        public syncChunkLoadEntitiesTimer: co.aikar.timings.Timing
        public syncChunkLoadBlockEntitiesTimer: co.aikar.timings.Timing

    }
}

declare module "cn.nukkit.timings.LevelTimings" {
    declare const LevelTimings = cn.nukkit.timings.LevelTimings;
}

declare namespace cn.nukkit {
    declare class AdventureSettings$Type extends java.lang.Enum {
        public static values(): cn.nukkit.AdventureSettings$Type[]
        public static valueOf(name: string): cn.nukkit.AdventureSettings$Type
        constructor(var0: int, var1: boolean): void
        public getId(): int
        public getDefaultValue(): boolean
        static $values(): cn.nukkit.AdventureSettings$Type[]
        public static WORLD_IMMUTABLE: cn.nukkit.AdventureSettings$Type
        public static NO_PVM: cn.nukkit.AdventureSettings$Type
        public static NO_MVP: cn.nukkit.AdventureSettings$Type
        public static SHOW_NAME_TAGS: cn.nukkit.AdventureSettings$Type
        public static AUTO_JUMP: cn.nukkit.AdventureSettings$Type
        public static ALLOW_FLIGHT: cn.nukkit.AdventureSettings$Type
        public static NO_CLIP: cn.nukkit.AdventureSettings$Type
        public static WORLD_BUILDER: cn.nukkit.AdventureSettings$Type
        public static FLYING: cn.nukkit.AdventureSettings$Type
        public static MUTED: cn.nukkit.AdventureSettings$Type
        public static MINE: cn.nukkit.AdventureSettings$Type
        public static DOORS_AND_SWITCHED: cn.nukkit.AdventureSettings$Type
        public static OPEN_CONTAINERS: cn.nukkit.AdventureSettings$Type
        public static ATTACK_PLAYERS: cn.nukkit.AdventureSettings$Type
        public static ATTACK_MOBS: cn.nukkit.AdventureSettings$Type
        public static OPERATOR: cn.nukkit.AdventureSettings$Type
        public static TELEPORT: cn.nukkit.AdventureSettings$Type
        public static BUILD: cn.nukkit.AdventureSettings$Type
        public static DEFAULT_LEVEL_PERMISSIONS: cn.nukkit.AdventureSettings$Type
        id: int
        defaultValue: boolean
        static $VALUES: cn.nukkit.AdventureSettings$Type[]

    }
}

declare module "cn.nukkit.AdventureSettings$Type" {
    declare const AdventureSettings$Type = cn.nukkit.AdventureSettings$Type;
}

declare namespace cn.nukkit {
    declare class Server$3 extends cn.nukkit.scheduler.Task {
        constructor(this$0: cn.nukkit.Server): void
        public onRun(currentTick: int): void
        this$0: cn.nukkit.Server

    }
}

declare module "cn.nukkit.Server$3" {
    declare const Server$3 = cn.nukkit.Server$3;
}

declare namespace cn.nukkit {
    declare class PlayerFood extends java.lang.Object {
        public constructor(player: cn.nukkit.Player, foodLevel: int, foodSaturationLevel: float): void
        public getPlayer(): cn.nukkit.Player
        public getLevel(): int
        public getMaxLevel(): int
        public setLevel(foodLevel: int): void
        public setLevel(foodLevel: int, saturationLevel: float): void
        public getFoodSaturationLevel(): float
        public setFoodSaturationLevel(fsl: float): void
        public useHunger(): void
        public useHunger(amount: int): void
        public addFoodLevel(food: cn.nukkit.item.food.Food): void
        public addFoodLevel(foodLevel: int, fsl: float): void
        public sendFoodLevel(): void
        public reset(): void
        public sendFoodLevel(foodLevel: int): void
        public update(tickDiff: int): void
        public updateFoodExpLevel(use: double): void
        public setFoodLevel(foodLevel: int): void
        public setFoodLevel(foodLevel: int, saturationLevel: float): void
        foodLevel: int
        maxFoodLevel: int
        foodSaturationLevel: float
        foodTickTimer: int
        foodExpLevel: double
        player: cn.nukkit.Player

    }
}

declare module "cn.nukkit.PlayerFood" {
    declare const PlayerFood = cn.nukkit.PlayerFood;
}

declare namespace cn.nukkit.nbt.tag {
    declare class FloatTag extends cn.nukkit.nbt.tag.NumberTag {
        public getData(): float
        public setData(data: float): void
        public constructor(name: string): void
        public constructor(name: string, data: float): void
        write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void
        load(dis: cn.nukkit.nbt.stream.NBTInputStream): void
        public parseValue(): float
        public getId(): byte
        public toString(): string
        public toSnbt(): string
        public copy(): cn.nukkit.nbt.tag.Tag
        public equals(obj: java.lang.Object): boolean
        public setData(var0: java.lang.Number): void
        public getData(): java.lang.Number
        public parseValue(): java.lang.Object
        public data: float

    }
}

declare module "cn.nukkit.nbt.tag.FloatTag" {
    declare const FloatTag = cn.nukkit.nbt.tag.FloatTag;
}

declare namespace cn.nukkit.nbt.tag {
    declare class ShortTag extends cn.nukkit.nbt.tag.NumberTag {
        public getData(): int
        public setData(data: int): void
        public constructor(name: string): void
        public constructor(name: string, data: int): void
        write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void
        load(dis: cn.nukkit.nbt.stream.NBTInputStream): void
        public parseValue(): int
        public getId(): byte
        public toString(): string
        public toSnbt(): string
        public copy(): cn.nukkit.nbt.tag.Tag
        public equals(obj: java.lang.Object): boolean
        public setData(var0: java.lang.Number): void
        public getData(): java.lang.Number
        public parseValue(): java.lang.Object
        public data: int

    }
}

declare module "cn.nukkit.nbt.tag.ShortTag" {
    declare const ShortTag = cn.nukkit.nbt.tag.ShortTag;
}

declare namespace cn.nukkit.nbt.tag {
    declare class StringTag extends cn.nukkit.nbt.tag.Tag {
        public constructor(name: string): void
        public constructor(name: string, data: string): void
        write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void
        load(dis: cn.nukkit.nbt.stream.NBTInputStream): void
        public parseValue(): string
        public getId(): byte
        public toString(): string
        public toSnbt(): string
        public copy(): cn.nukkit.nbt.tag.Tag
        public equals(obj: java.lang.Object): boolean
        public hashCode(): int
        public parseValue(): java.lang.Object
        public data: string

    }
}

declare module "cn.nukkit.nbt.tag.StringTag" {
    declare const StringTag = cn.nukkit.nbt.tag.StringTag;
}

declare namespace cn.nukkit.nbt.tag {
    declare class DoubleTag extends cn.nukkit.nbt.tag.NumberTag {
        public getData(): double
        public setData(data: double): void
        public constructor(name: string): void
        public constructor(name: string, data: double): void
        write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void
        load(dis: cn.nukkit.nbt.stream.NBTInputStream): void
        public parseValue(): double
        public getId(): byte
        public toString(): string
        public toSnbt(): string
        public copy(): cn.nukkit.nbt.tag.Tag
        public equals(obj: java.lang.Object): boolean
        public setData(var0: java.lang.Number): void
        public getData(): java.lang.Number
        public parseValue(): java.lang.Object
        public data: double

    }
}

declare module "cn.nukkit.nbt.tag.DoubleTag" {
    declare const DoubleTag = cn.nukkit.nbt.tag.DoubleTag;
}

declare namespace cn.nukkit.nbt.tag {
    declare class ByteTag extends cn.nukkit.nbt.tag.NumberTag {
        public getData(): int
        public setData(data: int): void
        public constructor(name: string): void
        public constructor(name: string, data: int): void
        write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void
        load(dis: cn.nukkit.nbt.stream.NBTInputStream): void
        public getId(): byte
        public parseValue(): int
        public toString(): string
        public toSnbt(): string
        public equals(obj: java.lang.Object): boolean
        public copy(): cn.nukkit.nbt.tag.Tag
        public setData(var0: java.lang.Number): void
        public getData(): java.lang.Number
        public parseValue(): java.lang.Object
        public data: int

    }
}

declare module "cn.nukkit.nbt.tag.ByteTag" {
    declare const ByteTag = cn.nukkit.nbt.tag.ByteTag;
}

declare namespace cn.nukkit.nbt.tag {
    declare class IntTag extends cn.nukkit.nbt.tag.NumberTag {
        public getData(): int
        public setData(data: int): void
        public constructor(name: string): void
        public constructor(name: string, data: int): void
        write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void
        load(dis: cn.nukkit.nbt.stream.NBTInputStream): void
        public parseValue(): int
        public getId(): byte
        public toString(): string
        public toSnbt(): string
        public copy(): cn.nukkit.nbt.tag.Tag
        public equals(obj: java.lang.Object): boolean
        public setData(var0: java.lang.Number): void
        public getData(): java.lang.Number
        public parseValue(): java.lang.Object
        public data: int

    }
}

declare module "cn.nukkit.nbt.tag.IntTag" {
    declare const IntTag = cn.nukkit.nbt.tag.IntTag;
}

declare namespace cn.nukkit.nbt.tag {
    declare class CompoundTag extends cn.nukkit.nbt.tag.Tag implements java.lang.Cloneable {
        public constructor(): void
        public constructor(name: string): void
        public constructor(tags: java.util.Map<string, cn.nukkit.nbt.tag.Tag>): void
        public constructor(name: string, tags: java.util.Map<string, cn.nukkit.nbt.tag.Tag>): void
        public write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void
        public load(dis: cn.nukkit.nbt.stream.NBTInputStream): void
        public getAllTags(): java.util.Collection<cn.nukkit.nbt.tag.Tag>
        public getId(): byte
        public put(name: string, tag: cn.nukkit.nbt.tag.Tag): cn.nukkit.nbt.tag.CompoundTag
        public putByte(name: string, value: int): cn.nukkit.nbt.tag.CompoundTag
        public putShort(name: string, value: int): cn.nukkit.nbt.tag.CompoundTag
        public putInt(name: string, value: int): cn.nukkit.nbt.tag.CompoundTag
        public putLong(name: string, value: long): cn.nukkit.nbt.tag.CompoundTag
        public putFloat(name: string, value: float): cn.nukkit.nbt.tag.CompoundTag
        public putDouble(name: string, value: double): cn.nukkit.nbt.tag.CompoundTag
        public putString(name: string, value: string): cn.nukkit.nbt.tag.CompoundTag
        public putByteArray(name: string, value: byte[]): cn.nukkit.nbt.tag.CompoundTag
        public putIntArray(name: string, value: int[]): cn.nukkit.nbt.tag.CompoundTag
        public putList(listTag: cn.nukkit.nbt.tag.ListTag<cn.nukkit.nbt.tag.Tag>): cn.nukkit.nbt.tag.CompoundTag
        public putCompound(name: string, value: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.nbt.tag.CompoundTag
        public putBoolean(string: string, val: boolean): cn.nukkit.nbt.tag.CompoundTag
        public get(name: string): cn.nukkit.nbt.tag.Tag
        public contains(name: string): boolean
        public containsCompound(name: string): boolean
        public containsString(name: string): boolean
        public containsIntArray(name: string): boolean
        public containsByteArray(name: string): boolean
        public containsNumber(name: string): boolean
        public containsList(name: string): boolean
        public containsList(name: string, type: byte): boolean
        public containsByte(name: string): boolean
        public containsShort(name: string): boolean
        public containsInt(name: string): boolean
        public containsDouble(name: string): boolean
        public containsFloat(name: string): boolean
        public remove(name: string): cn.nukkit.nbt.tag.CompoundTag
        public removeAndGet(name: cn.nukkit.nbt.tag.Tag): string
        public getByte(name: string): int
        public getShort(name: string): int
        public getInt(name: string): int
        public getLong(name: string): long
        public getFloat(name: string): float
        public getDouble(name: string): double
        public getString(name: string): string
        public getByteArray(name: string): byte[]
        public getIntArray(name: string): int[]
        public getCompound(name: string): cn.nukkit.nbt.tag.CompoundTag
        public getList(name: string): cn.nukkit.nbt.tag.ListTag<cn.nukkit.nbt.tag.Tag>
        public getList(name: cn.nukkit.nbt.tag.Tag, type: string, var2: java.lang.Class<any>): cn.nukkit.nbt.tag.ListTag<any>
        public getTags(): java.util.Map<string, cn.nukkit.nbt.tag.Tag>
        public parseValue(): java.util.Map<string, java.lang.Object>
        public getBoolean(name: string): boolean
        public toString(): string
        public toSnbt(): string
        public print(prefix: string, out: java.io.PrintStream): void
        public isEmpty(): boolean
        public copy(): cn.nukkit.nbt.tag.CompoundTag
        public equals(obj: java.lang.Object): boolean
        public hashCode(): int
        public exist(name: string): boolean
        public clone(): cn.nukkit.nbt.tag.CompoundTag
        public parseValue(): java.lang.Object
        public copy(): cn.nukkit.nbt.tag.Tag
        public clone(): java.lang.Object
        static lambda$clone$2(nbt: cn.nukkit.nbt.tag.CompoundTag, key: string, value: cn.nukkit.nbt.tag.Tag): void
        static lambda$toSnbt$1(joiner: java.util.StringJoiner, key: string, tag: cn.nukkit.nbt.tag.Tag): void
        static lambda$toString$0(joiner: java.util.StringJoiner, key: string, tag: cn.nukkit.nbt.tag.Tag): void
        tags: java.util.Map<string, cn.nukkit.nbt.tag.Tag>

    }
}

declare module "cn.nukkit.nbt.tag.CompoundTag" {
    declare const CompoundTag = cn.nukkit.nbt.tag.CompoundTag;
}

declare namespace cn.nukkit.nbt.tag {
    declare class Tag extends java.lang.Object {
        write(var0: cn.nukkit.nbt.stream.NBTOutputStream): void
        load(var0: cn.nukkit.nbt.stream.NBTInputStream): void
        public toString(): string
        public toSnbt(): string
        public getId(): byte
        constructor(name: string): void
        public equals(obj: java.lang.Object): boolean
        public hashCode(): int
        public print(out: java.io.PrintStream): void
        public print(prefix: string, out: java.io.PrintStream): void
        public setName(name: string): cn.nukkit.nbt.tag.Tag
        public getName(): string
        public static readNamedTag(dis: cn.nukkit.nbt.stream.NBTInputStream): cn.nukkit.nbt.tag.Tag
        public static writeNamedTag(tag: cn.nukkit.nbt.tag.Tag, dos: cn.nukkit.nbt.stream.NBTOutputStream): void
        public static writeNamedTag(tag: cn.nukkit.nbt.tag.Tag, name: string, dos: cn.nukkit.nbt.stream.NBTOutputStream): void
        public static newTag(type: byte, name: string): cn.nukkit.nbt.tag.Tag
        public static getTagName(type: byte): string
        public copy(): cn.nukkit.nbt.tag.Tag
        public parseValue(): java.lang.Object
        public static TAG_End: byte
        public static TAG_Byte: byte
        public static TAG_Short: byte
        public static TAG_Int: byte
        public static TAG_Long: byte
        public static TAG_Float: byte
        public static TAG_Double: byte
        public static TAG_Byte_Array: byte
        public static TAG_String: byte
        public static TAG_List: byte
        public static TAG_Compound: byte
        public static TAG_Int_Array: byte
        name: string

    }
}

declare module "cn.nukkit.nbt.tag.Tag" {
    declare const Tag = cn.nukkit.nbt.tag.Tag;
}

declare namespace cn.nukkit.nbt.stream {
    declare class PGZIPThreadLocal extends java.lang.ThreadLocal {
        public constructor(parent: cn.nukkit.nbt.stream.PGZIPOutputStream): void
        initialValue(): cn.nukkit.nbt.stream.PGZIPState
        initialValue(): java.lang.Object
        parent: cn.nukkit.nbt.stream.PGZIPOutputStream

    }
}

declare module "cn.nukkit.nbt.stream.PGZIPThreadLocal" {
    declare const PGZIPThreadLocal = cn.nukkit.nbt.stream.PGZIPThreadLocal;
}

declare namespace cn.nukkit.nbt.stream {
    declare class PGZIPBlock extends java.lang.Object implements java.util.concurrent.Callable {
        public constructor(parent: cn.nukkit.nbt.stream.PGZIPOutputStream): void
        public call(): byte[]
        public toString(): string
        public call(): java.lang.Object
        STATE: java.lang.ThreadLocal<cn.nukkit.nbt.stream.PGZIPState>
        public static SIZE: int
        in: byte[]
        in_length: int

    }
}

declare module "cn.nukkit.nbt.stream.PGZIPBlock" {
    declare const PGZIPBlock = cn.nukkit.nbt.stream.PGZIPBlock;
}

declare namespace cn.nukkit.nbt.stream {
    declare class BufferedRandomAccessFile extends java.io.RandomAccessFile {
        public constructor(file: java.io.File, mode: string): void
        public constructor(file: java.io.File, mode: string, size: int): void
        public constructor(name: string, mode: string): void
        public constructor(name: string, mode: string, size: int): void
        init(size: int): void
        public close(): void
        public flush(): void
        flushBuffer(): void
        fillBuffer(): int
        public seek(pos: long): void
        public seekUnsafe(pos: long): void
        public getFilePointer(): long
        public length(): long
        public read(): int
        public read1(): byte
        public read(b: byte[]): int
        public read(b: byte[], off: int, len: int): int
        public readCurrent(): byte
        public writeCurrent(b: byte): void
        public write(b: int): void
        public write(b: byte[]): void
        public write(b: byte[], off: int, len: int): void
        writeAtMost(b: byte[], off: int, len: int): int
        static LogBuffSz_: int
        public static BuffSz_: int
        static BuffMask_: long
        dirty_: boolean
        closed_: boolean
        curr_: long
        lo_: long
        hi_: long
        buff_: byte[]
        maxHi_: long
        hitEOF_: boolean
        diskPos_: long

    }
}

declare module "cn.nukkit.nbt.stream.BufferedRandomAccessFile" {
    declare const BufferedRandomAccessFile = cn.nukkit.nbt.stream.BufferedRandomAccessFile;
}

declare namespace cn.nukkit.nbt.stream {
    declare class PGZIPOutputStream extends java.io.FilterOutputStream {
        public static getSharedThreadPool(): java.util.concurrent.ExecutorService
        newDeflater(): java.util.zip.Deflater
        public setStrategy(strategy: int): void
        public setLevel(level: int): void
        static newDeflaterOutputStream(out: java.io.OutputStream, deflater: java.util.zip.Deflater): java.util.zip.DeflaterOutputStream
        public constructor(out: java.io.OutputStream, executor: java.util.concurrent.ExecutorService, nthreads: int): void
        public constructor(out: java.io.OutputStream, nthreads: int): void
        public constructor(out: java.io.OutputStream): void
        writeHeader(): void
        public write(b: int): void
        public write(b: byte[]): void
        public write(b: byte[], off: int, len: int): void
        submit(): void
        tryEmit(): void
        emitUntil(taskCountAllowed: int): void
        public flush(): void
        public finish(): void
        public close(): void
        static EXECUTOR: java.util.concurrent.ExecutorService
        static GZIP_MAGIC: int
        blockSizes: it.unimi.dsi.fastutil.ints.IntList
        level: int
        strategy: int
        executor: java.util.concurrent.ExecutorService
        nthreads: int
        crc: java.util.zip.CRC32
        emitQueue: java.util.concurrent.BlockingQueue<float, byte[]>
        block: cn.nukkit.nbt.stream.PGZIPBlock
        bytesWritten: int

    }
}

declare module "cn.nukkit.nbt.stream.PGZIPOutputStream" {
    declare const PGZIPOutputStream = cn.nukkit.nbt.stream.PGZIPOutputStream;
}

declare namespace cn.nukkit.nbt.stream {
    declare class NBTOutputStream extends java.lang.Object implements java.io.DataOutput, java.lang.AutoCloseable {
        public constructor(stream: java.io.OutputStream): void
        public constructor(stream: java.io.OutputStream, endianness: java.nio.ByteOrder): void
        public constructor(stream: java.io.OutputStream, endianness: java.nio.ByteOrder, network: boolean): void
        public getEndianness(): java.nio.ByteOrder
        public isNetwork(): boolean
        public write(bytes: byte[]): void
        public write(b: byte[], off: int, len: int): void
        public write(b: int): void
        public writeBoolean(v: boolean): void
        public writeByte(v: int): void
        public writeShort(v: int): void
        public writeChar(v: int): void
        public writeInt(v: int): void
        public writeLong(v: long): void
        public writeFloat(v: float): void
        public writeDouble(v: double): void
        public writeBytes(s: string): void
        public writeChars(s: string): void
        public writeUTF(s: string): void
        public close(): void
        stream: java.io.DataOutputStream
        endianness: java.nio.ByteOrder
        network: boolean

    }
}

declare module "cn.nukkit.nbt.stream.NBTOutputStream" {
    declare const NBTOutputStream = cn.nukkit.nbt.stream.NBTOutputStream;
}

declare namespace cn.nukkit.nbt.stream {
    declare class PGZIPState extends java.lang.Object {
        public constructor(parent: cn.nukkit.nbt.stream.PGZIPOutputStream): void
        str: java.util.zip.DeflaterOutputStream
        buf: java.io.ByteArrayOutputStream
        def: java.util.zip.Deflater

    }
}

declare module "cn.nukkit.nbt.stream.PGZIPState" {
    declare const PGZIPState = cn.nukkit.nbt.stream.PGZIPState;
}

declare namespace cn.nukkit.nbt.stream {
    declare class NBTInputStream extends java.lang.Object implements java.io.DataInput, java.lang.AutoCloseable {
        public constructor(stream: java.io.InputStream): void
        public constructor(stream: java.io.InputStream, endianness: java.nio.ByteOrder): void
        public constructor(stream: java.io.InputStream, endianness: java.nio.ByteOrder, network: boolean): void
        public getEndianness(): java.nio.ByteOrder
        public isNetwork(): boolean
        public readFully(b: byte[]): void
        public readFully(b: byte[], off: int, len: int): void
        public skipBytes(n: int): int
        public readBoolean(): boolean
        public readByte(): byte
        public readUnsignedByte(): int
        public readShort(): short
        public readUnsignedShort(): int
        public readChar(): char
        public readInt(): int
        public readLong(): long
        public readFloat(): float
        public readDouble(): double
        public readLine(): string
        public readUTF(): string
        public available(): int
        public close(): void
        stream: java.io.DataInputStream
        endianness: java.nio.ByteOrder
        network: boolean

    }
}

declare module "cn.nukkit.nbt.stream.NBTInputStream" {
    declare const NBTInputStream = cn.nukkit.nbt.stream.NBTInputStream;
}

declare namespace cn.nukkit.scoreboard {
    declare class Scoreboard extends java.lang.Object {
        public constructor(objectiveName: string, displayName: string, criteriaName: string, sortOrder: cn.nukkit.scoreboard.data.SortOrder, manager: cn.nukkit.scoreboard.interfaces.AbstractScoreboardManager): void
        public constructor(lines: java.util.Map<cn.nukkit.scoreboard.interfaces.Scorer, cn.nukkit.scoreboard.Scoreboard$ScoreboardLine>, objectiveName: string, displayName: string, criteriaName: string, sortOrder: cn.nukkit.scoreboard.data.SortOrder, manager: cn.nukkit.scoreboard.interfaces.AbstractScoreboardManager): void
        public addLine(scorer: cn.nukkit.scoreboard.interfaces.Scorer, score: int): boolean
        public removeLine(scorer: cn.nukkit.scoreboard.interfaces.Scorer): boolean
        public getLine(scorer: cn.nukkit.scoreboard.interfaces.Scorer): cn.nukkit.scoreboard.Scoreboard$ScoreboardLine
        public containLine(scorer: cn.nukkit.scoreboard.interfaces.Scorer): boolean
        public getLines(): java.util.Map<cn.nukkit.scoreboard.interfaces.Scorer, cn.nukkit.scoreboard.Scoreboard$ScoreboardLine>
        public getObjectiveName(): string
        public getDisplayName(): string
        public getCriteriaName(): string
        public getSortOrder(): cn.nukkit.scoreboard.data.SortOrder
        public getManager(): cn.nukkit.scoreboard.interfaces.AbstractScoreboardManager
        public setSortOrder(sortOrder: cn.nukkit.scoreboard.data.SortOrder): void
        static lambda$removeLine$2(packet: cn.nukkit.network.protocol.SetScorePacket, player: cn.nukkit.Player): void
        static lambda$addLine$1(packet: cn.nukkit.network.protocol.SetScorePacket, player: cn.nukkit.Player): void
        static lambda$new$0(scorer: cn.nukkit.scoreboard.interfaces.Scorer, line: cn.nukkit.scoreboard.Scoreboard$ScoreboardLine): void
        lines: java.util.Map<cn.nukkit.scoreboard.interfaces.Scorer, cn.nukkit.scoreboard.Scoreboard$ScoreboardLine>
        objectiveName: string
        displayName: string
        criteriaName: string
        sortOrder: cn.nukkit.scoreboard.data.SortOrder
        manager: cn.nukkit.scoreboard.interfaces.AbstractScoreboardManager
        static scoreboardId: int

    }
}

declare module "cn.nukkit.scoreboard.Scoreboard" {
    declare const Scoreboard = cn.nukkit.scoreboard.Scoreboard;
}

declare namespace cn.nukkit.scoreboard.data {
    declare class DisplaySlot extends java.lang.Enum {
        public static values(): cn.nukkit.scoreboard.data.DisplaySlot[]
        public static valueOf(name: string): cn.nukkit.scoreboard.data.DisplaySlot
        constructor(var0: string): void
        public getSlotName(): string
        static $values(): cn.nukkit.scoreboard.data.DisplaySlot[]
        public static SIDEBAR: cn.nukkit.scoreboard.data.DisplaySlot
        public static LIST: cn.nukkit.scoreboard.data.DisplaySlot
        public static BELOW_NAME: cn.nukkit.scoreboard.data.DisplaySlot
        slotName: string
        static $VALUES: cn.nukkit.scoreboard.data.DisplaySlot[]

    }
}

declare module "cn.nukkit.scoreboard.data.DisplaySlot" {
    declare const DisplaySlot = cn.nukkit.scoreboard.data.DisplaySlot;
}

declare namespace cn.nukkit.scoreboard.data {
    declare class SortOrder extends java.lang.Enum {
        public static values(): cn.nukkit.scoreboard.data.SortOrder[]
        public static valueOf(name: string): cn.nukkit.scoreboard.data.SortOrder
        constructor(): void
        static $values(): cn.nukkit.scoreboard.data.SortOrder[]
        public static ASCENDING: cn.nukkit.scoreboard.data.SortOrder
        public static DESCENDING: cn.nukkit.scoreboard.data.SortOrder
        static $VALUES: cn.nukkit.scoreboard.data.SortOrder[]

    }
}

declare module "cn.nukkit.scoreboard.data.SortOrder" {
    declare const SortOrder = cn.nukkit.scoreboard.data.SortOrder;
}

declare namespace cn.nukkit.scoreboard.data {
    declare class ScorerType extends java.lang.Enum {
        public static values(): cn.nukkit.scoreboard.data.ScorerType[]
        public static valueOf(name: string): cn.nukkit.scoreboard.data.ScorerType
        constructor(): void
        static $values(): cn.nukkit.scoreboard.data.ScorerType[]
        public static INVALID: cn.nukkit.scoreboard.data.ScorerType
        public static PLAYER: cn.nukkit.scoreboard.data.ScorerType
        public static ENTITY: cn.nukkit.scoreboard.data.ScorerType
        public static FAKE: cn.nukkit.scoreboard.data.ScorerType
        static $VALUES: cn.nukkit.scoreboard.data.ScorerType[]

    }
}

declare module "cn.nukkit.scoreboard.data.ScorerType" {
    declare const ScorerType = cn.nukkit.scoreboard.data.ScorerType;
}

declare namespace cn.nukkit.scoreboard.scorer {
    declare class FakeScorer extends java.lang.Object implements cn.nukkit.scoreboard.interfaces.Scorer {
        public constructor(fakeName: string): void
        public getScorerType(): cn.nukkit.scoreboard.data.ScorerType
        public hashCode(): int
        public equals(obj: java.lang.Object): boolean
        public getName(): string
        public getFakeName(): string
        fakeName: string

    }
}

declare module "cn.nukkit.scoreboard.scorer.FakeScorer" {
    declare const FakeScorer = cn.nukkit.scoreboard.scorer.FakeScorer;
}

declare namespace cn.nukkit.scoreboard.scorer {
    declare class PlayerScorer extends java.lang.Object implements cn.nukkit.scoreboard.interfaces.Scorer {
        public constructor(uuid: java.util.UUID): void
        public constructor(uuid: string): void
        public constructor(player: cn.nukkit.Player): void
        public getPlayer(): cn.nukkit.Player
        public isOnline(): boolean
        public getScorerType(): cn.nukkit.scoreboard.data.ScorerType
        public hashCode(): int
        public equals(obj: java.lang.Object): boolean
        public getName(): string
        public getUuid(): java.util.UUID
        uuid: java.util.UUID

    }
}

declare module "cn.nukkit.scoreboard.scorer.PlayerScorer" {
    declare const PlayerScorer = cn.nukkit.scoreboard.scorer.PlayerScorer;
}

declare namespace cn.nukkit.scoreboard.scorer {
    declare class EntityScorer extends java.lang.Object implements cn.nukkit.scoreboard.interfaces.Scorer {
        public constructor(uuid: java.util.UUID): void
        public constructor(entity: cn.nukkit.entity.Entity): void
        public getScorerType(): cn.nukkit.scoreboard.data.ScorerType
        public hashCode(): int
        public equals(obj: java.lang.Object): boolean
        public getName(): string
        public getEntityUuid(): java.util.UUID
        entityUuid: java.util.UUID

    }
}

declare module "cn.nukkit.scoreboard.scorer.EntityScorer" {
    declare const EntityScorer = cn.nukkit.scoreboard.scorer.EntityScorer;
}

declare namespace cn.nukkit.scoreboard.storage {
    declare class JSONScoreboardStorage extends java.lang.Object implements cn.nukkit.scoreboard.interfaces.ScoreboardStorage {
        public constructor(path: string): void
        public saveScoreboard(scoreboard: cn.nukkit.scoreboard.Scoreboard): void
        public saveScoreboard(scoreboards: cn.nukkit.scoreboard.Scoreboard[]): void
        public saveDisplay(display: java.util.Map<cn.nukkit.scoreboard.data.DisplaySlot, string>): void
        public readScoreboard(manager: cn.nukkit.scoreboard.interfaces.AbstractScoreboardManager): java.util.Map<string, cn.nukkit.scoreboard.Scoreboard>
        public readScoreboard(name: string, manager: cn.nukkit.scoreboard.interfaces.AbstractScoreboardManager): cn.nukkit.scoreboard.Scoreboard
        public readDisplay(): java.util.Map<cn.nukkit.scoreboard.data.DisplaySlot, string>
        public removeScoreboard(name: string): void
        public containScoreboard(name: string): boolean
        serializeToMap(scoreboard: cn.nukkit.scoreboard.Scoreboard): java.util.Map<string, java.lang.Object>
        deserializeFromMap(map: java.util.Map<string, java.lang.Object>, manager: cn.nukkit.scoreboard.interfaces.AbstractScoreboardManager): cn.nukkit.scoreboard.Scoreboard
        public getFilePath(): java.nio.file.Path
        public getJson(): cn.nukkit.utils.Config
        filePath: java.nio.file.Path
        json: cn.nukkit.utils.Config

    }
}

declare module "cn.nukkit.scoreboard.storage.JSONScoreboardStorage" {
    declare const JSONScoreboardStorage = cn.nukkit.scoreboard.storage.JSONScoreboardStorage;
}

declare namespace cn.nukkit.scoreboard.storage {
    declare class JSONScoreboardStorage$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$scoreboard$data$ScorerType: int[]

    }
}

declare module "cn.nukkit.scoreboard.storage.JSONScoreboardStorage$1" {
    declare const JSONScoreboardStorage$1 = cn.nukkit.scoreboard.storage.JSONScoreboardStorage$1;
}

declare namespace cn.nukkit.scoreboard {
    declare class Scoreboard$ScoreboardLine extends java.lang.Object {
        constructor(this$0: cn.nukkit.scoreboard.Scoreboard, scorer: cn.nukkit.scoreboard.interfaces.Scorer, score: int, scoreboardId: int): void
        public setScore(score: int): boolean
        public addScore(score: int): boolean
        public removeScore(score: int): boolean
        public toScoreInfo(): cn.nukkit.network.protocol.SetScorePacket$ScoreInfo
        public toRemovedScoreInfo(): cn.nukkit.network.protocol.SetScorePacket$ScoreInfo
        callEvent(newValue: int, oldValue: int): cn.nukkit.event.command.ScoreboardScoreChangeEvent
        public getScorer(): cn.nukkit.scoreboard.interfaces.Scorer
        public getScore(): int
        public getScoreboardId(): int
        static lambda$setScore$0(packet: cn.nukkit.network.protocol.SetScorePacket, player: cn.nukkit.Player): void
        scorer: cn.nukkit.scoreboard.interfaces.Scorer
        score: int
        scoreboardId: int
        this$0: cn.nukkit.scoreboard.Scoreboard

    }
}

declare module "cn.nukkit.scoreboard.Scoreboard$ScoreboardLine" {
    declare const Scoreboard$ScoreboardLine = cn.nukkit.scoreboard.Scoreboard$ScoreboardLine;
}

declare namespace cn.nukkit.scoreboard {
    declare class ScoreboardManager extends cn.nukkit.scoreboard.interfaces.AbstractScoreboardManager {
        public constructor(storage: cn.nukkit.scoreboard.interfaces.ScoreboardStorage): void
        public addScoreboard(scoreboard: cn.nukkit.scoreboard.Scoreboard): boolean
        public removeScoreboard(name: string): boolean
        public setDisplay(slot: cn.nukkit.scoreboard.data.DisplaySlot, name: string): void
        public removeDisplay(slot: cn.nukkit.scoreboard.data.DisplaySlot): void
        public onPlayerJoin(player: cn.nukkit.Player): void
        public onPlayerQuit(player: cn.nukkit.Player): void
        sendDisplayToAll(slot: cn.nukkit.scoreboard.data.DisplaySlot): void
        sendDisplayTo(slot: cn.nukkit.scoreboard.data.DisplaySlot, player: cn.nukkit.Player): void
        sendAllDisplayToAll(): void
        sendAllDisplayTo(player: cn.nukkit.Player): void
        hideOfflinePlayerScore(player: cn.nukkit.Player): void
        lambda$sendAllDisplayToAll$4(player: cn.nukkit.Player): void
        lambda$sendDisplayToAll$3(slot: cn.nukkit.scoreboard.data.DisplaySlot, player: cn.nukkit.Player): void
        static lambda$removeDisplay$2(slot: cn.nukkit.scoreboard.data.DisplaySlot, player: cn.nukkit.Player): void
        lambda$setDisplay$1(name: string, slot: cn.nukkit.scoreboard.data.DisplaySlot, player: cn.nukkit.Player): void
        static lambda$removeScoreboard$0(line: cn.nukkit.scoreboard.Scoreboard$ScoreboardLine): cn.nukkit.network.protocol.SetScorePacket$ScoreInfo

    }
}

declare module "cn.nukkit.scoreboard.ScoreboardManager" {
    declare const ScoreboardManager = cn.nukkit.scoreboard.ScoreboardManager;
}

declare namespace cn.nukkit.scoreboard.interfaces {
    declare interface ScoreboardStorage {
        public saveScoreboard(var0: cn.nukkit.scoreboard.Scoreboard): void
        public saveScoreboard(var0: cn.nukkit.scoreboard.Scoreboard[]): void
        public saveDisplay(var0: java.util.Map<cn.nukkit.scoreboard.data.DisplaySlot, string>): void
        public readScoreboard(var0: cn.nukkit.scoreboard.interfaces.AbstractScoreboardManager): java.util.Map<string, cn.nukkit.scoreboard.Scoreboard>
        public readScoreboard(var0: string, var1: cn.nukkit.scoreboard.interfaces.AbstractScoreboardManager): cn.nukkit.scoreboard.Scoreboard
        public readDisplay(): java.util.Map<cn.nukkit.scoreboard.data.DisplaySlot, string>
        public removeScoreboard(var0: string): void
        public containScoreboard(var0: string): boolean

    }
}

declare module "cn.nukkit.scoreboard.interfaces.ScoreboardStorage" {
    declare type ScoreboardStorage = cn.nukkit.scoreboard.interfaces.ScoreboardStorage;
}

declare namespace cn.nukkit.scoreboard.interfaces {
    declare class AbstractScoreboardManager extends java.lang.Object {
        public constructor(storage: cn.nukkit.scoreboard.interfaces.ScoreboardStorage): void
        public getStorage(): cn.nukkit.scoreboard.interfaces.ScoreboardStorage
        public addScoreboard(var0: cn.nukkit.scoreboard.Scoreboard): boolean
        public removeScoreboard(var0: string): boolean
        public getScoreboards(): java.util.Map<string, cn.nukkit.scoreboard.Scoreboard>
        public getScoreboard(name: string): cn.nukkit.scoreboard.Scoreboard
        public hasScoreboard(name: string): boolean
        public setDisplay(var0: cn.nukkit.scoreboard.data.DisplaySlot, var1: string): void
        public removeDisplay(var0: cn.nukkit.scoreboard.data.DisplaySlot): void
        public getDisplays(): java.util.Map<cn.nukkit.scoreboard.data.DisplaySlot, string>
        public getDisplay(slot: cn.nukkit.scoreboard.data.DisplaySlot): string
        public getDisplaySlot(name: string): cn.nukkit.scoreboard.data.DisplaySlot
        public isScoreboardOnDisplay(name: string): boolean
        public isScoreboardOnDisplaySlot(name: string, slot: cn.nukkit.scoreboard.data.DisplaySlot): boolean
        public hasScoreboardOnDisplaySlot(slot: cn.nukkit.scoreboard.data.DisplaySlot): boolean
        public onPlayerJoin(var0: cn.nukkit.Player): void
        public onPlayerQuit(var0: cn.nukkit.Player): void
        public updateAllScoreTag(): void
        public updateScoreTag(player: cn.nukkit.Player): void
        public isReading(): boolean
        static lambda$updateAllScoreTag$0(player: cn.nukkit.Player): void
        scoreboards: java.util.Map<string, cn.nukkit.scoreboard.Scoreboard>
        display: java.util.Map<cn.nukkit.scoreboard.data.DisplaySlot, string>
        storage: cn.nukkit.scoreboard.interfaces.ScoreboardStorage
        reading: boolean

    }
}

declare module "cn.nukkit.scoreboard.interfaces.AbstractScoreboardManager" {
    declare const AbstractScoreboardManager = cn.nukkit.scoreboard.interfaces.AbstractScoreboardManager;
}

declare namespace cn.nukkit.entity.data {
    declare class EntityData extends java.lang.Object {
        constructor(id: int): void
        public getType(): int
        public getData(): any
        public setData(): void
        public getId(): int
        public setId(id: int): cn.nukkit.entity.data.EntityData
        public equals(obj: java.lang.Object): boolean
        readFlags(offset: int, flags: long): java.util.SortedSet<string>
        public toString(): string
        static lambda$static$9(it: java.lang.reflect.Field): void
        static lambda$static$8(it: java.lang.reflect.Field): boolean
        static lambda$static$7(it: java.lang.reflect.Field): boolean
        static lambda$static$6(it: java.lang.reflect.Field): boolean
        static lambda$static$5(it: java.lang.reflect.Field): void
        static lambda$static$4(it: java.lang.reflect.Field): boolean
        static lambda$static$3(it: java.lang.reflect.Field): boolean
        static lambda$static$2(it: java.lang.reflect.Field): boolean
        static lambda$static$1(it: java.lang.reflect.Field): boolean
        static lambda$static$0(it: java.lang.reflect.Field): boolean
        static KNOWN_ENTITY_DATA: it.unimi.dsi.fastutil.ints.Int2ObjectMap<string>
        static KNOWN_ENTITY_FLAGS: it.unimi.dsi.fastutil.ints.Int2ObjectMap<string>
        id: int

    }
}

declare module "cn.nukkit.entity.data.EntityData" {
    declare const EntityData = cn.nukkit.entity.data.EntityData;
}

declare namespace cn.nukkit.entity.data {
    declare class StringEntityData extends cn.nukkit.entity.data.EntityData {
        public constructor(id: int, data: string): void
        public getData(): string
        public setData(data: string): void
        public getType(): int
        public setData(var0: java.lang.Object): void
        public getData(): java.lang.Object
        public data: string

    }
}

declare module "cn.nukkit.entity.data.StringEntityData" {
    declare const StringEntityData = cn.nukkit.entity.data.StringEntityData;
}

declare namespace cn.nukkit.entity.data {
    declare class IntEntityData extends cn.nukkit.entity.data.EntityData {
        public constructor(id: int, data: int): void
        public getData(): int
        public setData(data: int): void
        public getType(): int
        public toString(): string
        public setData(var0: java.lang.Object): void
        public getData(): java.lang.Object
        public data: int

    }
}

declare module "cn.nukkit.entity.data.IntEntityData" {
    declare const IntEntityData = cn.nukkit.entity.data.IntEntityData;
}

declare namespace cn.nukkit.entity.data {
    declare class IntPositionEntityData extends cn.nukkit.entity.data.EntityData {
        public constructor(id: int, x: int, y: int, z: int): void
        public constructor(id: int, pos: cn.nukkit.math.Vector3): void
        public getData(): cn.nukkit.math.BlockVector3
        public setData(data: cn.nukkit.math.BlockVector3): void
        public getType(): int
        public toString(): string
        public setData(var0: java.lang.Object): void
        public getData(): java.lang.Object
        public x: int
        public y: int
        public z: int

    }
}

declare module "cn.nukkit.entity.data.IntPositionEntityData" {
    declare const IntPositionEntityData = cn.nukkit.entity.data.IntPositionEntityData;
}

declare namespace cn.nukkit.entity.data {
    declare class LongEntityData extends cn.nukkit.entity.data.EntityData {
        public constructor(id: int, data: long): void
        public getData(): long
        public setData(data: long): void
        public getType(): int
        public toString(): string
        public setData(var0: java.lang.Object): void
        public getData(): java.lang.Object
        public data: long

    }
}

declare module "cn.nukkit.entity.data.LongEntityData" {
    declare const LongEntityData = cn.nukkit.entity.data.LongEntityData;
}

declare namespace cn.nukkit.entity.data {
    declare class FloatEntityData extends cn.nukkit.entity.data.EntityData {
        public constructor(id: int, data: float): void
        public getData(): float
        public setData(data: float): void
        public getType(): int
        public toString(): string
        public setData(var0: java.lang.Object): void
        public getData(): java.lang.Object
        public data: float

    }
}

declare module "cn.nukkit.entity.data.FloatEntityData" {
    declare const FloatEntityData = cn.nukkit.entity.data.FloatEntityData;
}

declare namespace cn.nukkit.entity.data {
    declare class NBTEntityData extends cn.nukkit.entity.data.EntityData {
        public constructor(id: int, tag: cn.nukkit.nbt.tag.CompoundTag): void
        public getData(): cn.nukkit.nbt.tag.CompoundTag
        public setData(tag: cn.nukkit.nbt.tag.CompoundTag): void
        public getType(): int
        public toString(): string
        public setData(var0: java.lang.Object): void
        public getData(): java.lang.Object
        public tag: cn.nukkit.nbt.tag.CompoundTag

    }
}

declare module "cn.nukkit.entity.data.NBTEntityData" {
    declare const NBTEntityData = cn.nukkit.entity.data.NBTEntityData;
}

declare namespace cn.nukkit.entity.data {
    declare class ByteEntityData extends cn.nukkit.entity.data.EntityData {
        public constructor(id: int, data: int): void
        public getData(): int
        public setData(data: int): void
        public getType(): int
        public toString(): string
        public setData(var0: java.lang.Object): void
        public getData(): java.lang.Object
        public data: int

    }
}

declare module "cn.nukkit.entity.data.ByteEntityData" {
    declare const ByteEntityData = cn.nukkit.entity.data.ByteEntityData;
}

declare namespace cn.nukkit.entity.data {
    declare class Vector3fEntityData extends cn.nukkit.entity.data.EntityData {
        public constructor(id: int, x: float, y: float, z: float): void
        public constructor(id: int, pos: cn.nukkit.math.Vector3f): void
        public getData(): cn.nukkit.math.Vector3f
        public setData(data: cn.nukkit.math.Vector3f): void
        public getType(): int
        public toString(): string
        public setData(var0: java.lang.Object): void
        public getData(): java.lang.Object
        public x: float
        public y: float
        public z: float

    }
}

declare module "cn.nukkit.entity.data.Vector3fEntityData" {
    declare const Vector3fEntityData = cn.nukkit.entity.data.Vector3fEntityData;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityShulker extends cn.nukkit.entity.mob.EntityMob {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityShulker" {
    declare const EntityShulker = cn.nukkit.entity.mob.EntityShulker;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityZombieVillagerV1 extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntitySmite {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isUndead(): boolean
        public onUpdate(currentTick: int): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityZombieVillagerV1" {
    declare const EntityZombieVillagerV1 = cn.nukkit.entity.mob.EntityZombieVillagerV1;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityCreeper extends cn.nukkit.entity.mob.EntityMob {
        public getNetworkId(): int
        public getWidth(): float
        public getHeight(): float
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public isPowered(): boolean
        public setPowered(bolt: cn.nukkit.entity.weather.EntityLightningStrike): void
        public setPowered(powered: boolean): void
        public onStruckByLightning(entity: cn.nukkit.entity.Entity): void
        initEntity(): void
        public getOriginalName(): string
        public getDrops(): cn.nukkit.item.Item[]
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int
        public static DATA_SWELL_DIRECTION: int
        public static DATA_SWELL: int
        public static DATA_SWELL_OLD: int
        public static DATA_POWERED: int

    }
}

declare module "cn.nukkit.entity.mob.EntityCreeper" {
    declare const EntityCreeper = cn.nukkit.entity.mob.EntityCreeper;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntitySnowGolem extends cn.nukkit.entity.mob.EntityMob {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getOriginalName(): string
        public getWidth(): float
        public getHeight(): float
        initEntity(): void
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntitySnowGolem" {
    declare const EntitySnowGolem = cn.nukkit.entity.mob.EntitySnowGolem;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityHusk extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntitySmite {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isUndead(): boolean
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityHusk" {
    declare const EntityHusk = cn.nukkit.entity.mob.EntityHusk;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityZoglin extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntityAgeable {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isUndead(): boolean
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public isBaby(): boolean
        public setBaby(baby: boolean): void
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityZoglin" {
    declare const EntityZoglin = cn.nukkit.entity.mob.EntityZoglin;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityEvoker extends cn.nukkit.entity.mob.EntityMob {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityEvoker" {
    declare const EntityEvoker = cn.nukkit.entity.mob.EntityEvoker;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityRavager extends cn.nukkit.entity.mob.EntityMob {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        initEntity(): void
        public getHeight(): float
        public getWidth(): float
        public getOriginalName(): string
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityRavager" {
    declare const EntityRavager = cn.nukkit.entity.mob.EntityRavager;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityStray extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntitySmite {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public getDrops(): cn.nukkit.item.Item[]
        public isUndead(): boolean
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityStray" {
    declare const EntityStray = cn.nukkit.entity.mob.EntityStray;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityWitherSkeleton extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntitySmite {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isUndead(): boolean
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityWitherSkeleton" {
    declare const EntityWitherSkeleton = cn.nukkit.entity.mob.EntityWitherSkeleton;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityPiglinBrute extends cn.nukkit.entity.mob.EntityMob {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityPiglinBrute" {
    declare const EntityPiglinBrute = cn.nukkit.entity.mob.EntityPiglinBrute;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityGuardian extends cn.nukkit.entity.mob.EntityMob {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public initEntity(): void
        public getOriginalName(): string
        public getWidth(): float
        public getHeight(): float
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityGuardian" {
    declare const EntityGuardian = cn.nukkit.entity.mob.EntityGuardian;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityMob extends cn.nukkit.entity.EntityPhysical implements cn.nukkit.inventory.EntityInventoryHolder {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public spawnToAll(): void
        public spawnTo(player: cn.nukkit.Player): void
        public saveNBT(): void
        public getInventory(): cn.nukkit.inventory.Inventory
        public canEquipByDispenser(): boolean
        public getEquipmentInventory(): cn.nukkit.inventory.EntityEquipmentInventory
        public getArmorInventory(): cn.nukkit.inventory.EntityArmorInventory
        static TAG_MAINHAND: string
        static TAG_OFFHAND: string
        static TAG_ARMOR: string
        equipmentInventory: cn.nukkit.inventory.EntityEquipmentInventory
        armorInventory: cn.nukkit.inventory.EntityArmorInventory

    }
}

declare module "cn.nukkit.entity.mob.EntityMob" {
    declare const EntityMob = cn.nukkit.entity.mob.EntityMob;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityWither extends cn.nukkit.entity.mob.EntityMob implements cn.nukkit.entity.EntitySmite {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getWidth(): float
        public getHeight(): float
        initEntity(): void
        public getOriginalName(): string
        public isUndead(): boolean
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public isBoss(): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityWither" {
    declare const EntityWither = cn.nukkit.entity.mob.EntityWither;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityVindicator extends cn.nukkit.entity.mob.EntityMob {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public getDrops(): cn.nukkit.item.Item[]
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityVindicator" {
    declare const EntityVindicator = cn.nukkit.entity.mob.EntityVindicator;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityVex extends cn.nukkit.entity.mob.EntityMob {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityVex" {
    declare const EntityVex = cn.nukkit.entity.mob.EntityVex;
}

declare namespace cn.nukkit.entity.mob {
    declare class EntityBlaze extends cn.nukkit.entity.mob.EntityMob {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.mob.EntityBlaze" {
    declare const EntityBlaze = cn.nukkit.entity.mob.EntityBlaze;
}

declare namespace cn.nukkit.entity {
    declare interface EntityNameable {
        public setNameTag(var0: string): void
        public getNameTag(): string
        public setNameTagVisible(var0: boolean): void
        public isNameTagVisible(): boolean
        public isPersistent(): boolean
        public setPersistent(var0: boolean): void
        public onInteract(player: cn.nukkit.Player, item: cn.nukkit.item.Item, clickedPos: cn.nukkit.math.Vector3): boolean
        public playerApplyNameTag(player: cn.nukkit.Player, item: cn.nukkit.item.Item): boolean
        public playerApplyNameTag(player: cn.nukkit.Player, item: cn.nukkit.item.Item, consume: boolean): boolean
        public applyNameTag(item: cn.nukkit.item.Item): boolean

    }
}

declare module "cn.nukkit.entity.EntityNameable" {
    declare type EntityNameable = cn.nukkit.entity.EntityNameable;
}

declare namespace cn.nukkit.entity.weather {
    declare interface EntityWeather {

    }
}

declare module "cn.nukkit.entity.weather.EntityWeather" {
    declare type EntityWeather = cn.nukkit.entity.weather.EntityWeather;
}

declare namespace cn.nukkit.entity {
    declare interface EntityRideable {
        public mountEntity(var0: cn.nukkit.entity.Entity): boolean
        public dismountEntity(var0: cn.nukkit.entity.Entity): boolean

    }
}

declare module "cn.nukkit.entity.EntityRideable" {
    declare type EntityRideable = cn.nukkit.entity.EntityRideable;
}

declare namespace cn.nukkit.entity {
    declare interface EntityAsyncPrepare {
        public asyncPrepare(var0: int): void

    }
}

declare module "cn.nukkit.entity.EntityAsyncPrepare" {
    declare type EntityAsyncPrepare = cn.nukkit.entity.EntityAsyncPrepare;
}

declare namespace cn.nukkit.entity {
    declare interface EntityInteractable {
        public getInteractButtonText(var0: cn.nukkit.Player): string
        public canDoInteraction(): boolean

    }
}

declare module "cn.nukkit.entity.EntityInteractable" {
    declare type EntityInteractable = cn.nukkit.entity.EntityInteractable;
}

declare namespace cn.nukkit.entity {
    declare interface EntityExplosive {
        public explode(): void

    }
}

declare module "cn.nukkit.entity.EntityExplosive" {
    declare type EntityExplosive = cn.nukkit.entity.EntityExplosive;
}

declare namespace cn.nukkit.entity {
    declare class EntityHuman extends cn.nukkit.entity.EntityHumanType {
        public getWidth(): float
        public getLength(): float
        public getHeight(): float
        public getSwimmingHeight(): float
        public getEyeHeight(): float
        getBaseOffset(): float
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getSkin(): cn.nukkit.entity.data.Skin
        public getUniqueId(): java.util.UUID
        public getRawUniqueId(): byte[]
        public setSkin(skin: cn.nukkit.entity.data.Skin): void
        initEntity(): void
        public getOriginalName(): string
        public getName(): string
        public saveNBT(): void
        public addMovement(x: double, var1: double, y: double, var3: double, z: double, var5: double): void
        public spawnTo(player: cn.nukkit.Player): void
        public despawnFrom(player: cn.nukkit.Player): void
        public close(): void
        onBlock(entity: cn.nukkit.entity.Entity, animate: boolean): void
        static lambda$saveNBT$1(s: string): cn.nukkit.nbt.tag.StringTag
        static lambda$initEntity$0(stringTag: cn.nukkit.nbt.tag.StringTag): string
        public static DATA_PLAYER_FLAG_SLEEP: int
        public static DATA_PLAYER_FLAG_DEAD: int
        public static DATA_PLAYER_FLAGS: int
        public static DATA_PLAYER_BED_POSITION: int
        public static DATA_PLAYER_BUTTON_TEXT: int
        uuid: java.util.UUID
        rawUUID: byte[]
        skin: cn.nukkit.entity.data.Skin

    }
}

declare module "cn.nukkit.entity.EntityHuman" {
    declare const EntityHuman = cn.nukkit.entity.EntityHuman;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityBoat$1 extends java.lang.Object implements cn.nukkit.math.AxisAlignedBB$BBConsumer {
        constructor(): void
        public accept(x: int, y: int, z: int): void
        public get(): double
        public get(): java.lang.Object
        diffY: double
        val$maxY: double
        this$0: cn.nukkit.entity.item.EntityBoat

    }
}

declare module "cn.nukkit.entity.item.EntityBoat$1" {
    declare const EntityBoat$1 = cn.nukkit.entity.item.EntityBoat$1;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityPotionLingering extends cn.nukkit.entity.item.EntityPotion {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, shootingEntity: cn.nukkit.entity.Entity): void
        initEntity(): void
        splash(collidedWith: cn.nukkit.entity.Entity): void
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.item.EntityPotionLingering" {
    declare const EntityPotionLingering = cn.nukkit.entity.item.EntityPotionLingering;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityArmorStand$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$event$entity$EntityDamageEvent$DamageCause: int[]

    }
}

declare module "cn.nukkit.entity.item.EntityArmorStand$1" {
    declare const EntityArmorStand$1 = cn.nukkit.entity.item.EntityArmorStand$1;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityMinecartChest extends cn.nukkit.entity.item.EntityMinecartAbstract implements cn.nukkit.inventory.InventoryHolder {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getOriginalName(): string
        public getType(): cn.nukkit.utils.MinecartType
        public isRideable(): boolean
        public getNetworkId(): int
        public dropItem(): void
        public mountEntity(entity: cn.nukkit.entity.Entity, mode: byte): boolean
        public onInteract(player: cn.nukkit.Player, item: cn.nukkit.item.Item, clickedPos: cn.nukkit.math.Vector3): boolean
        public getInventory(): cn.nukkit.inventory.MinecartChestInventory
        public initEntity(): void
        public saveNBT(): void
        public getInventory(): cn.nukkit.inventory.Inventory
        public static NETWORK_ID: int
        inventory: cn.nukkit.inventory.MinecartChestInventory

    }
}

declare module "cn.nukkit.entity.item.EntityMinecartChest" {
    declare const EntityMinecartChest = cn.nukkit.entity.item.EntityMinecartChest;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityPotion extends cn.nukkit.entity.projectile.EntityProjectile {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, shootingEntity: cn.nukkit.entity.Entity): void
        initEntity(): void
        public getNetworkId(): int
        public getWidth(): float
        public getLength(): float
        public getHeight(): float
        getGravity(): float
        getDrag(): float
        public onCollideWithEntity(entity: cn.nukkit.entity.Entity): void
        splash(collidedWith: cn.nukkit.entity.Entity): void
        public onUpdate(currentTick: int): boolean
        public getOriginalName(): string
        public static NETWORK_ID: int
        public static DATA_POTION_ID: int
        public potionId: int

    }
}

declare module "cn.nukkit.entity.item.EntityPotion" {
    declare const EntityPotion = cn.nukkit.entity.item.EntityPotion;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityFishingHook extends cn.nukkit.entity.projectile.EntityProjectile {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, shootingEntity: cn.nukkit.entity.Entity): void
        public getNetworkId(): int
        public getWidth(): float
        public getLength(): float
        public getHeight(): float
        public getGravity(): float
        public getDrag(): float
        public canCollide(): boolean
        public onUpdate(currentTick: int): boolean
        public getWaterHeight(): int
        public fishBites(): void
        public spawnFish(): void
        public attractFish(): boolean
        public reelLine(): void
        createAddEntityPacket(): cn.nukkit.network.protocol.DataPacket
        public onCollideWithEntity(entity: cn.nukkit.entity.Entity): void
        public checkLure(): void
        public setTarget(eid: long): void
        public getOriginalName(): string
        public static NETWORK_ID: int
        public waitChance: int
        public waitTimer: int
        public attracted: boolean
        public attractTimer: int
        public caught: boolean
        public caughtTimer: int
        public canCollide: boolean
        public fish: cn.nukkit.math.Vector3
        public rod: cn.nukkit.item.Item

    }
}

declare module "cn.nukkit.entity.item.EntityFishingHook" {
    declare const EntityFishingHook = cn.nukkit.entity.item.EntityFishingHook;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityVehicle extends cn.nukkit.entity.Entity implements cn.nukkit.entity.EntityRideable, cn.nukkit.entity.EntityInteractable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getRollingAmplitude(): int
        public setRollingAmplitude(time: int): void
        public getRollingDirection(): int
        public setRollingDirection(direction: int): void
        public getDamage(): int
        public setDamage(damage: int): void
        public getInteractButtonText(player: cn.nukkit.Player): string
        public canDoInteraction(): boolean
        public onUpdate(currentTick: int): boolean
        performHurtAnimation(): boolean
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        rollingDirection: boolean

    }
}

declare module "cn.nukkit.entity.item.EntityVehicle" {
    declare const EntityVehicle = cn.nukkit.entity.item.EntityVehicle;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityPainting$Motive extends java.lang.Enum {
        public static values(): cn.nukkit.entity.item.EntityPainting$Motive[]
        public static valueOf(name: string): cn.nukkit.entity.item.EntityPainting$Motive
        constructor(var0: string, var1: int, title: int): void
        static $values(): cn.nukkit.entity.item.EntityPainting$Motive[]
        public static KEBAB: cn.nukkit.entity.item.EntityPainting$Motive
        public static AZTEC: cn.nukkit.entity.item.EntityPainting$Motive
        public static ALBAN: cn.nukkit.entity.item.EntityPainting$Motive
        public static AZTEC2: cn.nukkit.entity.item.EntityPainting$Motive
        public static BOMB: cn.nukkit.entity.item.EntityPainting$Motive
        public static PLANT: cn.nukkit.entity.item.EntityPainting$Motive
        public static WASTELAND: cn.nukkit.entity.item.EntityPainting$Motive
        public static WANDERER: cn.nukkit.entity.item.EntityPainting$Motive
        public static GRAHAM: cn.nukkit.entity.item.EntityPainting$Motive
        public static POOL: cn.nukkit.entity.item.EntityPainting$Motive
        public static COURBET: cn.nukkit.entity.item.EntityPainting$Motive
        public static SUNSET: cn.nukkit.entity.item.EntityPainting$Motive
        public static SEA: cn.nukkit.entity.item.EntityPainting$Motive
        public static CREEBET: cn.nukkit.entity.item.EntityPainting$Motive
        public static MATCH: cn.nukkit.entity.item.EntityPainting$Motive
        public static BUST: cn.nukkit.entity.item.EntityPainting$Motive
        public static STAGE: cn.nukkit.entity.item.EntityPainting$Motive
        public static VOID: cn.nukkit.entity.item.EntityPainting$Motive
        public static SKULL_AND_ROSES: cn.nukkit.entity.item.EntityPainting$Motive
        public static WITHER: cn.nukkit.entity.item.EntityPainting$Motive
        public static FIGHTERS: cn.nukkit.entity.item.EntityPainting$Motive
        public static SKELETON: cn.nukkit.entity.item.EntityPainting$Motive
        public static DONKEY_KONG: cn.nukkit.entity.item.EntityPainting$Motive
        public static POINTER: cn.nukkit.entity.item.EntityPainting$Motive
        public static PIG_SCENE: cn.nukkit.entity.item.EntityPainting$Motive
        public static BURNING_SKULL: cn.nukkit.entity.item.EntityPainting$Motive
        public title: string
        public width: int
        public height: int
        static BY_NAME: java.util.Map<string, cn.nukkit.entity.item.EntityPainting$Motive>
        static $VALUES: cn.nukkit.entity.item.EntityPainting$Motive[]

    }
}

declare module "cn.nukkit.entity.item.EntityPainting$Motive" {
    declare const EntityPainting$Motive = cn.nukkit.entity.item.EntityPainting$Motive;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityElytraFirework extends cn.nukkit.entity.item.EntityFirework {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, player: cn.nukkit.Player): void
        public onUpdate(currentTick: int): boolean
        public setFollowingPlayer(followingPlayer: cn.nukkit.Player): void
        public getFollowingPlayer(): cn.nukkit.Player
        followingPlayer: cn.nukkit.Player
        static RANDOM: java.util.Random
        fireworkAge: int
        lifetime: int

    }
}

declare module "cn.nukkit.entity.item.EntityElytraFirework" {
    declare const EntityElytraFirework = cn.nukkit.entity.item.EntityElytraFirework;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityCrossbowFirework extends cn.nukkit.entity.item.EntityFirework {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public onUpdate(currentTick: int): boolean
        static RANDOM: java.util.Random
        fireworkAge: int
        lifetime: int

    }
}

declare module "cn.nukkit.entity.item.EntityCrossbowFirework" {
    declare const EntityCrossbowFirework = cn.nukkit.entity.item.EntityCrossbowFirework;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityAreaEffectCloud extends cn.nukkit.entity.Entity {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getWaitTime(): int
        public setWaitTime(waitTime: int): void
        public setWaitTime(waitTime: int, send: boolean): void
        public getPotionId(): int
        public setPotionId(potionId: int): void
        public setPotionId(potionId: int, send: boolean): void
        public recalculatePotionColor(): void
        public recalculatePotionColor(send: boolean): void
        public getPotionColor(): int
        public setPotionColor(alpha: int, red: int, green: int, blue: int, send: boolean): void
        public setPotionColor(argp: int): void
        public setPotionColor(argp: int, send: boolean): void
        public getPickupCount(): int
        public setPickupCount(pickupCount: int): void
        public setPickupCount(pickupCount: int, send: boolean): void
        public getRadiusChangeOnPickup(): float
        public setRadiusChangeOnPickup(radiusChangeOnPickup: float): void
        public setRadiusChangeOnPickup(radiusChangeOnPickup: float, send: boolean): void
        public getRadiusPerTick(): float
        public setRadiusPerTick(radiusPerTick: float): void
        public setRadiusPerTick(radiusPerTick: float, send: boolean): void
        public getSpawnTime(): long
        public setSpawnTime(spawnTime: long): void
        public setSpawnTime(spawnTime: long, var1: boolean): void
        public getDuration(): int
        public setDuration(duration: int): void
        public setDuration(duration: int, send: boolean): void
        public getRadius(): float
        public setRadius(radius: float): void
        public setRadius(radius: float, send: boolean): void
        public getParticleId(): int
        public setParticleId(particleId: int): void
        public setParticleId(particleId: int, send: boolean): void
        initEntity(): void
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        public saveNBT(): void
        public onUpdate(currentTick: int): boolean
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean
        public getHeight(): float
        public getWidth(): float
        public getLength(): float
        getGravity(): float
        getDrag(): float
        public getNetworkId(): int
        public getOriginalName(): string
        public static NETWORK_ID: int
        reapplicationDelay: int
        durationOnUse: int
        initialRadius: float
        radiusOnUse: float
        nextApply: int
        public cloudEffects: java.util.List<cn.nukkit.potion.Effect>
        lastAge: int

    }
}

declare module "cn.nukkit.entity.item.EntityAreaEffectCloud" {
    declare const EntityAreaEffectCloud = cn.nukkit.entity.item.EntityAreaEffectCloud;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityXPOrb extends cn.nukkit.entity.Entity {
        public getNetworkId(): int
        public getWidth(): float
        public getLength(): float
        public getHeight(): float
        getGravity(): float
        getDrag(): float
        public canCollide(): boolean
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        public onUpdate(currentTick: int): boolean
        public saveNBT(): void
        public getExp(): int
        public setExp(exp: int): void
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean
        public getPickupDelay(): int
        public setPickupDelay(pickupDelay: int): void
        public static getMaxOrbSize(amount: int): int
        public static splitIntoOrbSizes(amount: int): java.util.List<int>
        public getOriginalName(): string
        public static NETWORK_ID: int
        public static ORB_SPLIT_SIZES: int[]
        age: int
        pickupDelay: int
        exp: int
        public closestPlayer: cn.nukkit.Player

    }
}

declare module "cn.nukkit.entity.item.EntityXPOrb" {
    declare const EntityXPOrb = cn.nukkit.entity.item.EntityXPOrb;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityArmorStand extends cn.nukkit.entity.Entity implements cn.nukkit.inventory.EntityInventoryHolder, cn.nukkit.entity.EntityInteractable, cn.nukkit.entity.EntityNameable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        static getArmorSlot(armorItem: cn.nukkit.item.ItemArmor): int
        static getArmorSlot(armorItem: cn.nukkit.item.customitem.ItemCustomArmor): int
        public getNetworkId(): int
        public getHeight(): float
        public getWidth(): float
        getGravity(): float
        initEntity(): void
        public isPersistent(): boolean
        public setPersistent(persistent: boolean): void
        public onInteract(player: cn.nukkit.Player, item: cn.nukkit.item.Item, clickedPos: cn.nukkit.math.Vector3): boolean
        tryChangeEquipment(player: cn.nukkit.Player, handItem: cn.nukkit.item.Item, slot: int, isArmorSlot: boolean): boolean
        getPose(): int
        setPose(pose: int): void
        public saveNBT(): void
        public spawnTo(player: cn.nukkit.Player): void
        public spawnToAll(): void
        public fall(fallDistance: float): void
        public kill(): void
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        public getOriginalName(): string
        public entityBaseTick(tickDiff: int): boolean
        public getArmorInventory(): cn.nukkit.inventory.EntityArmorInventory
        public getEquipmentInventory(): cn.nukkit.inventory.EntityEquipmentInventory
        public getInventory(): cn.nukkit.inventory.EntityArmorInventory
        public onUpdate(currentTick: int): boolean
        getDrag(): float
        public getInteractButtonText(player: cn.nukkit.Player): string
        public canDoInteraction(): boolean
        public canEquipByDispenser(): boolean
        public getInventory(): cn.nukkit.inventory.Inventory
        lambda$kill$1(items: cn.nukkit.item.Item): void
        static lambda$setPose$0(setEntityDataPacket: cn.nukkit.network.protocol.SetEntityDataPacket, all: cn.nukkit.Player): void
        public static NETWORK_ID: int
        static TAG_MAINHAND: string
        static TAG_POSE_INDEX: string
        static TAG_OFFHAND: string
        static TAG_ARMOR: string
        equipmentInventory: cn.nukkit.inventory.EntityEquipmentInventory
        armorInventory: cn.nukkit.inventory.EntityArmorInventory

    }
}

declare module "cn.nukkit.entity.item.EntityArmorStand" {
    declare const EntityArmorStand = cn.nukkit.entity.item.EntityArmorStand;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityMinecartAbstract$1 extends java.lang.Object {
        static $SwitchMap$cn$nukkit$utils$Rail$Orientation: int[]

    }
}

declare module "cn.nukkit.entity.item.EntityMinecartAbstract$1" {
    declare const EntityMinecartAbstract$1 = cn.nukkit.entity.item.EntityMinecartAbstract$1;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityItem extends cn.nukkit.entity.Entity {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getWidth(): float
        public getLength(): float
        public getHeight(): float
        public getGravity(): float
        public getDrag(): float
        getBaseOffset(): float
        public canCollide(): boolean
        initEntity(): void
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        public onUpdate(currentTick: int): boolean
        public setOnFire(seconds: int): void
        public saveNBT(): void
        public getOriginalName(): string
        public getName(): string
        public getItem(): cn.nukkit.item.Item
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean
        public getPickupDelay(): int
        public setPickupDelay(pickupDelay: int): void
        public getOwner(): string
        public setOwner(owner: string): void
        public getThrower(): string
        public setThrower(thrower: string): void
        public createAddEntityPacket(): cn.nukkit.network.protocol.DataPacket
        public doesTriggerPressurePlate(): boolean
        public static NETWORK_ID: int
        owner: string
        thrower: string
        item: cn.nukkit.item.Item
        pickupDelay: int

    }
}

declare module "cn.nukkit.entity.item.EntityItem" {
    declare const EntityItem = cn.nukkit.entity.item.EntityItem;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityExpBottle extends cn.nukkit.entity.projectile.EntityProjectile {
        public getNetworkId(): int
        public getWidth(): float
        public getLength(): float
        public getHeight(): float
        getGravity(): float
        getDrag(): float
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, shootingEntity: cn.nukkit.entity.Entity): void
        public onUpdate(currentTick: int): boolean
        public onCollideWithEntity(entity: cn.nukkit.entity.Entity): void
        public dropXp(): void
        addHitEffect(): void
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.item.EntityExpBottle" {
    declare const EntityExpBottle = cn.nukkit.entity.item.EntityExpBottle;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityMinecartTNT extends cn.nukkit.entity.item.EntityMinecartAbstract implements cn.nukkit.entity.EntityExplosive {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public isRideable(): boolean
        public initEntity(): void
        public onUpdate(currentTick: int): boolean
        public activate(x: int, y: int, z: int, flag: boolean): void
        public explode(): void
        public explode(square: double): void
        public dropItem(): void
        public getOriginalName(): string
        public getType(): cn.nukkit.utils.MinecartType
        public getNetworkId(): int
        public saveNBT(): void
        public onInteract(player: cn.nukkit.Player, item: cn.nukkit.item.Item, clickedPos: cn.nukkit.math.Vector3): boolean
        public mountEntity(entity: cn.nukkit.entity.Entity, mode: byte): boolean
        public static NETWORK_ID: int
        fuse: int

    }
}

declare module "cn.nukkit.entity.item.EntityMinecartTNT" {
    declare const EntityMinecartTNT = cn.nukkit.entity.item.EntityMinecartTNT;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityEndCrystal extends cn.nukkit.entity.Entity implements cn.nukkit.entity.EntityExplosive {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public saveNBT(): void
        public getHeight(): float
        public getWidth(): float
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        public explode(): void
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean
        public showBase(): boolean
        public setShowBase(value: boolean): void
        public getBeamTarget(): cn.nukkit.math.Vector3
        public setBeamTarget(beamTarget: cn.nukkit.math.Vector3): void
        public getOriginalName(): string
        public static NETWORK_ID: int
        detonated: boolean

    }
}

declare module "cn.nukkit.entity.item.EntityEndCrystal" {
    declare const EntityEndCrystal = cn.nukkit.entity.item.EntityEndCrystal;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityFallingBlock extends cn.nukkit.entity.Entity {
        public getWidth(): float
        public getLength(): float
        public getHeight(): float
        getGravity(): float
        getDrag(): float
        getBaseOffset(): float
        public canCollide(): boolean
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        public onUpdate(currentTick: int): boolean
        public getBlock(): int
        public getDamage(): int
        public getNetworkId(): int
        public saveNBT(): void
        public canBeMovedByCurrents(): boolean
        public resetFallDistance(): void
        public getOriginalName(): string
        public static NETWORK_ID: int
        blockId: int
        damage: int
        breakOnLava: boolean
        breakOnGround: boolean

    }
}

declare module "cn.nukkit.entity.item.EntityFallingBlock" {
    declare const EntityFallingBlock = cn.nukkit.entity.item.EntityFallingBlock;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityPainting extends cn.nukkit.entity.EntityHanging {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public static getMotive(name: string): cn.nukkit.entity.item.EntityPainting$Motive
        public getWidth(): float
        public getLength(): float
        public getHeight(): float
        public getNetworkId(): int
        initEntity(): void
        public createAddEntityPacket(): cn.nukkit.network.protocol.DataPacket
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        public saveNBT(): void
        public onPushByPiston(piston: cn.nukkit.blockentity.BlockEntityPistonArm): void
        public getArt(): cn.nukkit.entity.item.EntityPainting$Motive
        public getMotive(): cn.nukkit.entity.item.EntityPainting$Motive
        public getOriginalName(): string
        public static NETWORK_ID: int
        public static motives: cn.nukkit.entity.item.EntityPainting$Motive[]
        motive: cn.nukkit.entity.item.EntityPainting$Motive
        width: float
        length: float
        height: float

    }
}

declare module "cn.nukkit.entity.item.EntityPainting" {
    declare const EntityPainting = cn.nukkit.entity.item.EntityPainting;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityMinecartEmpty extends cn.nukkit.entity.item.EntityMinecartAbstract {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getOriginalName(): string
        public getType(): cn.nukkit.utils.MinecartType
        public getInteractButtonText(player: cn.nukkit.Player): string
        public isRideable(): boolean
        activate(x: int, y: int, z: int, flag: boolean): void
        public onUpdate(currentTick: int): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.item.EntityMinecartEmpty" {
    declare const EntityMinecartEmpty = cn.nukkit.entity.item.EntityMinecartEmpty;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityMinecartAbstract extends cn.nukkit.entity.item.EntityVehicle {
        public getType(): cn.nukkit.utils.MinecartType
        public isRideable(): boolean
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getHeight(): float
        public getWidth(): float
        getDrag(): float
        public getBaseOffset(): float
        public canDoInteraction(): boolean
        public initEntity(): void
        public onUpdate(currentTick: int): boolean
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        public dropItem(): void
        public kill(): void
        public close(): void
        public onInteract(p: cn.nukkit.Player, item: cn.nukkit.item.Item, clickedPos: cn.nukkit.math.Vector3): boolean
        public applyEntityCollision(entity: cn.nukkit.entity.Entity): void
        public saveNBT(): void
        public getMaxSpeed(): double
        activate(x: int, y: int, z: int, flag: boolean): void
        setFalling(): void
        processMovement(dx: int, dy: int, dz: int, block: cn.nukkit.block.BlockRail): void
        applyDrag(): void
        getNextRail(dx: double, var1: double, dy: double): cn.nukkit.math.Vector3
        public setCurrentSpeed(speed: double): void
        prepareDataProperty(): void
        saveEntityData(): void
        public setDisplayBlock(block: cn.nukkit.block.Block): boolean
        public setDisplayBlock(block: cn.nukkit.block.Block, update: boolean): boolean
        public getDisplayBlock(): cn.nukkit.block.Block
        public setDisplayBlockOffset(offset: int): void
        public getDisplayBlockOffset(): int
        public isSlowWhenEmpty(): boolean
        public setSlowWhenEmpty(slow: boolean): void
        public getFlyingVelocityMod(): cn.nukkit.math.Vector3
        public setFlyingVelocityMod(flying: cn.nukkit.math.Vector3): void
        public getDerailedVelocityMod(): cn.nukkit.math.Vector3
        public setDerailedVelocityMod(derailed: cn.nukkit.math.Vector3): void
        public setMaximumSpeed(speed: double): void
        static matrix: int[][][]
        currentSpeed: double
        blockInside: cn.nukkit.block.Block
        slowWhenEmpty: boolean
        derailedX: double
        derailedY: double
        derailedZ: double
        flyingX: double
        flyingY: double
        flyingZ: double
        maxSpeed: double
        devs: boolean
        hasUpdated: boolean

    }
}

declare module "cn.nukkit.entity.item.EntityMinecartAbstract" {
    declare const EntityMinecartAbstract = cn.nukkit.entity.item.EntityMinecartAbstract;
}

declare namespace cn.nukkit.entity.item {
    declare class EntityFirework extends cn.nukkit.entity.Entity {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public onUpdate(currentTick: int): boolean
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        public setFirework(item: cn.nukkit.item.Item): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public static NETWORK_ID: int
        fireworkAge: int
        lifetime: int
        firework: cn.nukkit.item.Item
        hadCollision: boolean

    }
}

declare module "cn.nukkit.entity.item.EntityFirework" {
    declare const EntityFirework = cn.nukkit.entity.item.EntityFirework;
}

declare namespace cn.nukkit.entity {
    declare class Attribute extends java.lang.Object implements java.lang.Cloneable {
        constructor(id: int, name: string, minValue: float, maxValue: float, defaultValue: float, shouldSend: boolean): void
        public static init(): void
        public static addAttribute(id: int, name: string, minValue: float, maxValue: float, defaultValue: float): cn.nukkit.entity.Attribute
        public static addAttribute(id: int, name: string, minValue: float, maxValue: float, defaultValue: float, shouldSend: boolean): cn.nukkit.entity.Attribute
        public static getAttribute(id: int): cn.nukkit.entity.Attribute
        public static getAttributeByName(name: string): cn.nukkit.entity.Attribute
        public getMinValue(): float
        public setMinValue(minValue: float): cn.nukkit.entity.Attribute
        public getMaxValue(): float
        public setMaxValue(maxValue: float): cn.nukkit.entity.Attribute
        public getDefaultValue(): float
        public setDefaultValue(defaultValue: float): cn.nukkit.entity.Attribute
        public getValue(): float
        public setValue(value: float): cn.nukkit.entity.Attribute
        public setValue(value: float, fit: boolean): cn.nukkit.entity.Attribute
        public getName(): string
        public getId(): int
        public isSyncable(): boolean
        public clone(): cn.nukkit.entity.Attribute
        public toString(): string
        public clone(): java.lang.Object
        public static EMPTY_ARRAY: cn.nukkit.entity.Attribute[]
        public static ABSORPTION: int
        public static SATURATION: int
        public static EXHAUSTION: int
        public static KNOCKBACK_RESISTANCE: int
        public static MAX_HEALTH: int
        public static MOVEMENT_SPEED: int
        public static FOLLOW_RANGE: int
        public static MAX_HUNGER: int
        public static FOOD: int
        public static ATTACK_DAMAGE: int
        public static EXPERIENCE_LEVEL: int
        public static EXPERIENCE: int
        public static LUCK: int
        static attributes: java.util.Map<int, cn.nukkit.entity.Attribute>
        minValue: float
        maxValue: float
        defaultValue: float
        currentValue: float
        name: string
        shouldSend: boolean
        id: int

    }
}

declare module "cn.nukkit.entity.Attribute" {
    declare const Attribute = cn.nukkit.entity.Attribute;
}

declare namespace cn.nukkit.entity {
    declare interface EntityDamageable {

    }
}

declare module "cn.nukkit.entity.EntityDamageable" {
    declare type EntityDamageable = cn.nukkit.entity.EntityDamageable;
}

declare namespace cn.nukkit.entity {
    declare class Entity$3 extends cn.nukkit.scheduler.Task {
        constructor(this$0: cn.nukkit.entity.Entity, var1: cn.nukkit.level.Position): void
        public onRun(currentTick: int): void
        val$newPos: cn.nukkit.level.Position
        this$0: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.entity.Entity$3" {
    declare const Entity$3 = cn.nukkit.entity.Entity$3;
}

declare namespace cn.nukkit.entity {
    declare class Entity$1 extends cn.nukkit.scheduler.Task {
        constructor(this$0: cn.nukkit.entity.Entity, var1: cn.nukkit.level.Position, var2: cn.nukkit.level.Position): void
        public onRun(currentTick: int): void
        val$finalPos: cn.nukkit.level.Position
        val$newPos: cn.nukkit.level.Position
        this$0: cn.nukkit.entity.Entity

    }
}

declare module "cn.nukkit.entity.Entity$1" {
    declare const Entity$1 = cn.nukkit.entity.Entity$1;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityBat extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityBat" {
    declare const EntityBat = cn.nukkit.entity.passive.EntityBat;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityOcelot extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public getNetworkId(): int
        public initEntity(): void
        public isBreedingItem(item: cn.nukkit.item.Item): boolean
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityOcelot" {
    declare const EntityOcelot = cn.nukkit.entity.passive.EntityOcelot;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityTurtle extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getOriginalName(): string
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public setBreedingAge(ticks: int): void
        public setHomePos(pos: cn.nukkit.math.Vector3): void
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityTurtle" {
    declare const EntityTurtle = cn.nukkit.entity.passive.EntityTurtle;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityStrider extends cn.nukkit.entity.passive.EntityAnimal {
        public getNetworkId(): int
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityStrider" {
    declare const EntityStrider = cn.nukkit.entity.passive.EntityStrider;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityRabbit extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public getDrops(): cn.nukkit.item.Item[]
        public getNetworkId(): int
        initEntity(): void
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityRabbit" {
    declare const EntityRabbit = cn.nukkit.entity.passive.EntityRabbit;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityPufferfish extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getOriginalName(): string
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityPufferfish" {
    declare const EntityPufferfish = cn.nukkit.entity.passive.EntityPufferfish;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityParrot extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getOriginalName(): string
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public getDrops(): cn.nukkit.item.Item[]
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityParrot" {
    declare const EntityParrot = cn.nukkit.entity.passive.EntityParrot;
}

declare namespace cn.nukkit.entity.passive {
    declare interface EntityNPC {

    }
}

declare module "cn.nukkit.entity.passive.EntityNPC" {
    declare type EntityNPC = cn.nukkit.entity.passive.EntityNPC;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityCow extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public getDrops(): cn.nukkit.item.Item[]
        public getNetworkId(): int
        initEntity(): void
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityCow" {
    declare const EntityCow = cn.nukkit.entity.passive.EntityCow;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityDolphin extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getOriginalName(): string
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public getDrops(): cn.nukkit.item.Item[]
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityDolphin" {
    declare const EntityDolphin = cn.nukkit.entity.passive.EntityDolphin;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntitySheep extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getWidth(): float
        public getHeight(): float
        public getOriginalName(): string
        public getNetworkId(): int
        public initEntity(): void
        public saveNBT(): void
        public onInteract(player: cn.nukkit.Player, item: cn.nukkit.item.Item, clickedPos: cn.nukkit.math.Vector3): boolean
        public shear(): boolean
        public getDrops(): cn.nukkit.item.Item[]
        public setColor(color: int): void
        public getColor(): int
        randomColor(): int
        public static NETWORK_ID: int
        public sheared: boolean
        public color: int

    }
}

declare module "cn.nukkit.entity.passive.EntitySheep" {
    declare const EntitySheep = cn.nukkit.entity.passive.EntitySheep;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityCat extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public getOriginalName(): string
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityCat" {
    declare const EntityCat = cn.nukkit.entity.passive.EntityCat;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityNPCEntity extends cn.nukkit.entity.EntityLiving implements cn.nukkit.entity.passive.EntityNPC, cn.nukkit.entity.EntityInteractable {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getWidth(): float
        public getHeight(): float
        public canDoInteraction(): boolean
        public getInteractButtonText(player: cn.nukkit.Player): string
        public getOriginalName(): string
        public initEntity(): void
        public saveNBT(): void
        public onInteract(player: cn.nukkit.Player, item: cn.nukkit.item.Item, clickedPos: cn.nukkit.math.Vector3): boolean
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        public setVariant(variant: int): void
        public getVariant(): int
        public getDialog(): cn.nukkit.dialog.window.FormWindowDialog
        lambda$initEntity$0(player: cn.nukkit.Player, response: cn.nukkit.dialog.response.FormResponseDialog): void
        public static NETWORK_ID: int
        public static KEY_DIALOG_TITLE: string
        public static KEY_DIALOG_CONTENT: string
        public static KEY_DIALOG_SKINDATA: string
        public static KEY_DIALOG_BUTTONS: string
        dialog: cn.nukkit.dialog.window.FormWindowDialog
        variant: int

    }
}

declare module "cn.nukkit.entity.passive.EntityNPCEntity" {
    declare const EntityNPCEntity = cn.nukkit.entity.passive.EntityNPCEntity;
}

declare namespace cn.nukkit.entity.passive {
    declare class EntityTropicalFish extends cn.nukkit.entity.passive.EntityAnimal {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public getNetworkId(): int
        public getOriginalName(): string
        public getWidth(): float
        public getHeight(): float
        public initEntity(): void
        public static NETWORK_ID: int

    }
}

declare module "cn.nukkit.entity.passive.EntityTropicalFish" {
    declare const EntityTropicalFish = cn.nukkit.entity.passive.EntityTropicalFish;
}

declare namespace cn.nukkit.entity {
    declare class EntityPhysical extends cn.nukkit.entity.EntityCreature implements cn.nukkit.entity.EntityAsyncPrepare {
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public asyncPrepare(currentTick: int): void
        public onUpdate(currentTick: int): boolean
        public canBeMovedByCurrents(): boolean
        public updateMovement(): void
        public addTmpMoveMotion(tmpMotion: cn.nukkit.math.Vector3): void
        public addTmpMoveMotionXZ(tmpMotion: cn.nukkit.math.Vector3): void
        handleGravity(): void
        handleFrictionMovement(): void
        handleLiquidMovement(): void
        addPreviousLiquidMovement(): void
        handleFloatingMovement(): void
        handleCollideMovement(currentTick: int): void
        onCollide(currentTick: int, collidingEntities: java.util.List<cn.nukkit.entity.Entity>): boolean
        getLiquidMovementSpeed(liquid: cn.nukkit.block.BlockLiquid): float
        public getFootHeight(): float
        calculateOffsetBoundingBox(): void
        public getOffsetBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public resetFallDistance(): void
        public getGravity(): float
        public getFallingTick(): int
        static lambda$handleCollideMovement$1(selfAABB: cn.nukkit.math.AxisAlignedBB, dxPositives: it.unimi.dsi.fastutil.doubles.DoubleArrayList, dxNegatives: it.unimi.dsi.fastutil.doubles.DoubleArrayList, dzPositives: it.unimi.dsi.fastutil.doubles.DoubleArrayList, dzNegatives: it.unimi.dsi.fastutil.doubles.DoubleArrayList, each: cn.nukkit.entity.Entity): void
        static lambda$handleLiquidMovement$0(block: cn.nukkit.block.Block): boolean
        public static PRECISION: float
        fallingTick: int
        offsetBoundingBox: cn.nukkit.math.AxisAlignedBB
        needsCollisionDamage: boolean
        needsRecalcMovement: boolean
        previousCollideMotion: cn.nukkit.math.Vector3
        previousCurrentMotion: cn.nukkit.math.Vector3

    }
}

declare module "cn.nukkit.entity.EntityPhysical" {
    declare const EntityPhysical = cn.nukkit.entity.EntityPhysical;
}

declare namespace cn.nukkit.entity.projectile {
    declare class EntityProjectile extends cn.nukkit.entity.Entity {
        getDamage(): double
        getBaseDamage(): double
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, shootingEntity: cn.nukkit.entity.Entity): void
        public getResultDamage(entity: cn.nukkit.entity.Entity): int
        public getResultDamage(): int
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        public onCollideWithEntity(entity: cn.nukkit.entity.Entity): void
        afterCollisionWithEntity(entity: cn.nukkit.entity.Entity): void
        initEntity(): void
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean
        public saveNBT(): void
        updateMotion(): void
        public onUpdate(currentTick: int): boolean
        public updateRotation(): void
        public inaccurate(modifier: float): void
        onCollideWithBlock(position: cn.nukkit.level.Position, motion: cn.nukkit.math.Vector3): void
        onCollideWithBlock(position: cn.nukkit.level.Position, motion: cn.nukkit.math.Vector3, collisionBlock: cn.nukkit.block.Block): boolean
        addHitEffect(): void
        public hasAge(): boolean
        public setAge(hasAge: boolean): void
        public setHasAge(hasAge: boolean): void
        public getHasAge(): boolean
        public static DATA_SHOOTER_ID: int
        public static PICKUP_NONE: int
        public static PICKUP_ANY: int
        public static PICKUP_CREATIVE: int
        public shootingEntity: cn.nukkit.entity.Entity
        noAge: boolean
        public hadCollision: boolean
        public closeOnCollide: boolean
        damage: double

    }
}

declare module "cn.nukkit.entity.projectile.EntityProjectile" {
    declare const EntityProjectile = cn.nukkit.entity.projectile.EntityProjectile;
}

declare namespace cn.nukkit.entity.projectile {
    declare class EntityThrownTrident extends cn.nukkit.entity.projectile.EntityProjectile {
        public getNetworkId(): int
        public getWidth(): float
        public getLength(): float
        public getHeight(): float
        public getGravity(): float
        public getDrag(): float
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, shootingEntity: cn.nukkit.entity.Entity): void
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, shootingEntity: cn.nukkit.entity.Entity, critical: boolean): void
        public getOriginalName(): string
        initEntity(): void
        public saveNBT(): void
        public getItem(): cn.nukkit.item.Item
        public setItem(item: cn.nukkit.item.Item): void
        public setCritical(): void
        public setCritical(value: boolean): void
        public isCritical(): boolean
        public getResultDamage(): int
        getBaseDamage(): double
        public onUpdate(currentTick: int): boolean
        public spawnTo(player: cn.nukkit.Player): void
        public onCollideWithEntity(entity: cn.nukkit.entity.Entity): void
        public create(type: java.lang.Object, source: cn.nukkit.level.Position, args: java.lang.Object[]): cn.nukkit.entity.Entity
        public getPickupMode(): int
        public setPickupMode(pickupMode: int): void
        onCollideWithBlock(position: cn.nukkit.level.Position, motion: cn.nukkit.math.Vector3): void
        public getCollisionPos(): cn.nukkit.math.Vector3
        public setCollisionPos(collisionPos: cn.nukkit.math.Vector3): void
        public getStuckToBlockPos(): cn.nukkit.math.BlockVector3
        public setStuckToBlockPos(stuckToBlockPos: cn.nukkit.math.BlockVector3): void
        public getFavoredSlot(): int
        public setFavoredSlot(favoredSlot: int): void
        public isCreative(): boolean
        public setCreative(isCreative: boolean): void
        public isPlayer(): boolean
        public setPlayer(player: boolean): void
        public getLoyaltyLevel(): int
        public setLoyaltyLevel(loyaltyLevel: int): void
        public hasChanneling(): boolean
        public setChanneling(hasChanneling: boolean): void
        public getRiptideLevel(): int
        public setRiptideLevel(riptideLevel: int): void
        public getImpalingLevel(): int
        public setImpalingLevel(impalingLevel: int): void
        public getTridentRope(): boolean
        public setTridentRope(tridentRope: boolean): void
        public canReturnToShooter(): boolean
        public static NETWORK_ID: int
        static TAG_PICKUP: string
        static TAG_TRIDENT: string
        static TAG_FAVORED_SLOT: string
        static TAG_CREATIVE: string
        static TAG_PLAYER: string
        static NAME_TRIDENT: string
        trident: cn.nukkit.item.Item
        collisionPos: cn.nukkit.math.Vector3
        stuckToBlockPos: cn.nukkit.math.BlockVector3
        favoredSlot: int
        player: boolean
        loyaltyLevel: int
        hasChanneling: boolean
        riptideLevel: int
        impalingLevel: int
        gravity: float
        drag: float
        static defaultCollisionPos: cn.nukkit.math.Vector3
        static defaultStuckToBlockPos: cn.nukkit.math.BlockVector3
        pickupMode: int
        public alreadyCollided: boolean

    }
}

declare module "cn.nukkit.entity.projectile.EntityThrownTrident" {
    declare const EntityThrownTrident = cn.nukkit.entity.projectile.EntityThrownTrident;
}

declare namespace co.aikar.timings {
    declare class FullServerTickTiming extends co.aikar.timings.Timing {
        constructor(): void
        public startTiming(): co.aikar.timings.Timing
        public stopTiming(): void
        isViolated(): boolean
        static IDENTIFIER: co.aikar.timings.TimingIdentifier
        minuteData: co.aikar.timings.TimingData
        avgFreeMemory: double
        avgUsedMemory: double

    }
}

declare module "co.aikar.timings.FullServerTickTiming" {
    declare const FullServerTickTiming = co.aikar.timings.FullServerTickTiming;
}

declare namespace cn.nukkit.block {
    declare class Block extends cn.nukkit.level.Position implements cn.nukkit.metadata.Metadatable, java.lang.Cloneable, cn.nukkit.math.AxisAlignedBB, cn.nukkit.block.BlockID, cn.nukkit.blockstate.IMutableBlockState {
        public static isInitializing(): boolean
        public static init(): void
        public static get(id: int): cn.nukkit.block.Block
        public static get(id: int, meta: int): cn.nukkit.block.Block
        public static get(id: int, meta: int, pos: cn.nukkit.level.Position): cn.nukkit.block.Block
        public static get(id: int, meta: int, pos: cn.nukkit.level.Position, layer: int): cn.nukkit.block.Block
        public static get(id: int, data: int): cn.nukkit.block.Block
        public static get(fullId: int, level: cn.nukkit.level.Level, x: int, y: int, z: int): cn.nukkit.block.Block
        public static get(fullId: int, level: cn.nukkit.level.Level, x: int, y: int, z: int, layer: int): cn.nukkit.block.Block
        public static get(id: int, meta: int, level: cn.nukkit.level.Level, x: int, y: int, z: int): cn.nukkit.block.Block
        public static get(id: int, meta: int, level: cn.nukkit.level.Level, x: int, y: int, z: int, layer: int): cn.nukkit.block.Block
        public static isSolid(blockId: int): boolean
        public static diffusesSkyLight(blockId: int): boolean
        public static getHardness(blockId: int): double
        public static getLightLevel(blockId: int): int
        public static getLightFilter(blockId: int): int
        public static isTransparent(blockId: int): boolean
        public static registerBlockImplementation(blockId: int, blockClass: java.lang.Class<cn.nukkit.block.Block>, persistenceName: string, receivesRandomTick: boolean): void
        constructor(): void
        getMutableState(): cn.nukkit.blockstate.MutableBlockState
        public place(item: cn.nukkit.item.Item, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var5: double, fy: double, var7: cn.nukkit.Player): boolean
        public canHarvestWithHand(): boolean
        public isBreakable(item: cn.nukkit.item.Item): boolean
        public tickRate(): int
        public onBreak(item: cn.nukkit.item.Item): boolean
        public onUpdate(type: int): int
        public onTouch(player: cn.nukkit.Player, action: cn.nukkit.event.player.PlayerInteractEvent$Action): int
        public onNeighborChange(side: cn.nukkit.math.BlockFace): void
        public onActivate(item: cn.nukkit.item.Item): boolean
        public onActivate(item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public afterRemoval(newBlock: cn.nukkit.block.Block, update: boolean): void
        public isSoulSpeedCompatible(): boolean
        public getHardness(): double
        public getResistance(): double
        public getBurnChance(): int
        public getBurnAbility(): int
        public getToolType(): int
        public getFrictionFactor(): double
        public getLightLevel(): int
        public canBePlaced(): boolean
        public canBeReplaced(): boolean
        public isTransparent(): boolean
        public isSolid(): boolean
        public isSolid(side: cn.nukkit.math.BlockFace): boolean
        public diffusesSkyLight(): boolean
        public canBeFlowedInto(): boolean
        public getWaterloggingLevel(): int
        public canWaterloggingFlowInto(): boolean
        public canBeActivated(): boolean
        public hasEntityCollision(): boolean
        public canPassThrough(): boolean
        public canBePushed(): boolean
        public canBePulled(): boolean
        public breaksWhenMoved(): boolean
        public sticksToPiston(): boolean
        public hasComparatorInputOverride(): boolean
        public getComparatorInputOverride(): int
        public canHarvest(item: cn.nukkit.item.Item): boolean
        public getToolTier(): int
        public canBeClimbed(): boolean
        public getColor(): cn.nukkit.utils.BlockColor
        public getName(): string
        public getId(): int
        public getItemId(): int
        public getFullId(): int
        public getProperties(): cn.nukkit.blockproperty.BlockProperties
        public getCurrentState(): cn.nukkit.blockstate.BlockState
        public getRuntimeId(): int
        public addVelocityToEntity(entity: cn.nukkit.entity.Entity, vector: cn.nukkit.math.Vector3): void
        public getDamage(): int
        public setDamage(meta: int): void
        public setDamage(meta: int): void
        public position(v: cn.nukkit.level.Position): void
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[]
        toolBreakTimeBonus0(item: cn.nukkit.item.Item): double
        static toolBreakTimeBonus0(toolType: int, toolTier: int, blockId: int): double
        static speedBonusByEfficiencyLore0(efficiencyLoreLevel: int): double
        static speedRateByHasteLore0(hasteLoreLevel: int): double
        static toolType0(item: cn.nukkit.item.Item, blockId: int): int
        static correctTool0(blockToolType: int, item: cn.nukkit.item.Item, blockId: int): boolean
        static breakTime0(blockHardness: double, var1: boolean, correctTool: boolean, canHarvestWithHand: int, blockId: int, toolType: int, toolTier: int, efficiencyLoreLevel: int, hasteEffectLevel: boolean, insideOfWaterWithoutAquaAffinity: boolean): double
        public calculateBreakTime(item: cn.nukkit.item.Item): double
        public calculateBreakTime(item: cn.nukkit.item.Item, player: cn.nukkit.Player): double
        public getBreakTime(item: cn.nukkit.item.Item, player: cn.nukkit.Player): double
        public getBreakTime(item: cn.nukkit.item.Item): double
        public canBeBrokenWith(item: cn.nukkit.item.Item): boolean
        public getSide(face: cn.nukkit.math.BlockFace): cn.nukkit.block.Block
        public getSide(face: cn.nukkit.math.BlockFace, step: int): cn.nukkit.block.Block
        public getSideAtLayer(layer: int, face: cn.nukkit.math.BlockFace): cn.nukkit.block.Block
        public getSideAtLayer(layer: int, face: cn.nukkit.math.BlockFace, step: int): cn.nukkit.block.Block
        public up(): cn.nukkit.block.Block
        public up(step: int): cn.nukkit.block.Block
        public up(step: int, layer: int): cn.nukkit.block.Block
        public down(): cn.nukkit.block.Block
        public down(step: int): cn.nukkit.block.Block
        public down(step: int, layer: int): cn.nukkit.block.Block
        public north(): cn.nukkit.block.Block
        public north(step: int): cn.nukkit.block.Block
        public north(step: int, layer: int): cn.nukkit.block.Block
        public south(): cn.nukkit.block.Block
        public south(step: int): cn.nukkit.block.Block
        public south(step: int, layer: int): cn.nukkit.block.Block
        public east(): cn.nukkit.block.Block
        public east(step: int): cn.nukkit.block.Block
        public east(step: int, layer: int): cn.nukkit.block.Block
        public west(): cn.nukkit.block.Block
        public west(step: int): cn.nukkit.block.Block
        public west(step: int, layer: int): cn.nukkit.block.Block
        public toString(): string
        public collidesWithBB(bb: cn.nukkit.math.AxisAlignedBB): boolean
        public collidesWithBB(bb: cn.nukkit.math.AxisAlignedBB, collisionBB: boolean): boolean
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void
        public onEntityFallOn(entity: cn.nukkit.entity.Entity, fallDistance: float): void
        public useDefaultFallDamage(): boolean
        public getBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public getMinX(): double
        public getMinY(): double
        public getMinZ(): double
        public getMaxX(): double
        public getMaxY(): double
        public getMaxZ(): double
        recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public calculateIntercept(pos1: cn.nukkit.math.Vector3, pos2: cn.nukkit.math.Vector3): cn.nukkit.level.MovingObjectPosition
        public getSaveId(): string
        public setMetadata(metadataKey: string, newMetadataValue: cn.nukkit.metadata.MetadataValue): void
        public getMetadata(metadataKey: string): java.util.List<cn.nukkit.metadata.MetadataValue>
        public hasMetadata(metadataKey: string): boolean
        public removeMetadata(metadataKey: string, owningPlugin: cn.nukkit.plugin.Plugin): void
        public clone(): cn.nukkit.block.Block
        public getWeakPower(face: cn.nukkit.math.BlockFace): int
        public getStrongPower(side: cn.nukkit.math.BlockFace): int
        public isPowerSource(): boolean
        public getLocationHash(): string
        public getDropExp(): int
        public isNormalBlock(): boolean
        public isSimpleBlock(): boolean
        public isSideFull(face: cn.nukkit.math.BlockFace): boolean
        public isFullBlock(): boolean
        public static equals(b1: cn.nukkit.block.Block, b2: cn.nukkit.block.Block): boolean
        public static equals(b1: cn.nukkit.block.Block, b2: cn.nukkit.block.Block, checkDamage: boolean): boolean
        public toItem(): cn.nukkit.item.Item
        public isLavaResistant(): boolean
        public asItemBlock(): cn.nukkit.item.ItemBlock
        public canSilkTouch(): boolean
        public mustSilkTouch(vector: cn.nukkit.math.Vector3, layer: int, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public mustDrop(vector: cn.nukkit.math.Vector3, layer: int, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item, player: cn.nukkit.Player): boolean
        public firstInLayers(condition: java.util.function.Predicate<cn.nukkit.block.Block>): java.util.Optional<cn.nukkit.block.Block>
        public firstInLayers(startingLayer: int, condition: java.util.function.Predicate<cn.nukkit.block.Block>): java.util.Optional<cn.nukkit.block.Block>
        public setState(state: cn.nukkit.blockstate.IBlockState): void
        public forState(state: cn.nukkit.blockstate.IBlockState): cn.nukkit.block.Block
        public setDataStorage(storage: java.lang.Number): void
        public setDataStorageFromInt(storage: int): void
        public setDataStorage(storage: java.lang.Number, repair: boolean, callback: java.util.function.Consumer<cn.nukkit.blockstate.BlockStateRepair>): boolean
        public setDataStorageFromInt(storage: int, repair: boolean, callback: java.util.function.Consumer<cn.nukkit.blockstate.BlockStateRepair>): boolean
        public setPropertyValue(propertyName: string, value: java.io.Serializable): void
        public setBooleanValue(propertyName: string, value: boolean): void
        public setIntValue(propertyName: string, value: int): void
        public getBlockId(): int
        public getDataStorage(): java.lang.Number
        public getLegacyDamage(): int
        public getBigDamage(): int
        public getSignedBigDamage(): int
        public getHugeDamage(): java.math.BigInteger
        public getPropertyValue(propertyName: string): java.io.Serializable
        public getIntValue(propertyName: string): int
        public getBooleanValue(propertyName: string): boolean
        public getPersistenceValue(propertyName: string): string
        public getExactIntStorage(): int
        public isBreakable(vector: cn.nukkit.math.Vector3, layer: int, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item, player: cn.nukkit.Player, setBlockDestroy: boolean): boolean
        public isBlockChangeAllowed(): boolean
        public isBlockChangeAllowed(player: cn.nukkit.Player): boolean
        public getLightFilter(): int
        public canRandomTick(): boolean
        public onProjectileHit(projectile: cn.nukkit.entity.Entity, position: cn.nukkit.level.Position, motion: cn.nukkit.math.Vector3): boolean
        public getBlock(): cn.nukkit.block.Block
        public isDefaultState(): boolean
        public getItemMaxStackSize(): int
        public isGettingPower(): boolean
        public cloneTo(pos: cn.nukkit.level.Position): void
        public equalsBlock(obj: java.lang.Object): boolean
        public clone(): cn.nukkit.level.Position
        public getSide(var0: cn.nukkit.math.BlockFace, var1: int): cn.nukkit.level.Position
        public getSide(var0: cn.nukkit.math.BlockFace): cn.nukkit.level.Position
        public clone(): cn.nukkit.positiontracking.NamedPosition
        public clone(): cn.nukkit.math.Vector3
        public west(var0: int): cn.nukkit.math.Vector3
        public west(): cn.nukkit.math.Vector3
        public east(var0: int): cn.nukkit.math.Vector3
        public east(): cn.nukkit.math.Vector3
        public south(var0: int): cn.nukkit.math.Vector3
        public south(): cn.nukkit.math.Vector3
        public north(var0: int): cn.nukkit.math.Vector3
        public north(): cn.nukkit.math.Vector3
        public down(var0: int): cn.nukkit.math.Vector3
        public down(): cn.nukkit.math.Vector3
        public up(var0: int): cn.nukkit.math.Vector3
        public up(): cn.nukkit.math.Vector3
        public getSide(var0: cn.nukkit.math.BlockFace, var1: int): cn.nukkit.math.Vector3
        public getSide(var0: cn.nukkit.math.BlockFace): cn.nukkit.math.Vector3
        public clone(): java.lang.Object
        public clone(): cn.nukkit.math.AxisAlignedBB
        public forState(var0: cn.nukkit.blockstate.IBlockState): cn.nukkit.blockstate.IMutableBlockState
        static lambda$getBreakTime$2(l: int): boolean
        static lambda$getBreakTime$1(e: cn.nukkit.potion.Effect): int
        static lambda$calculateBreakTime$0(l: int): boolean
        static log: org.apache.logging.log4j.Logger
        public static EMPTY_ARRAY: cn.nukkit.block.Block[]
        public static MAX_BLOCK_ID: int
        public static DATA_BITS: int
        public static DATA_SIZE: int
        public static DATA_MASK: int
        public static list: java.lang.Class<cn.nukkit.block.Block>[]
        public static fullList: cn.nukkit.block.Block[]
        public static light: int[]
        public static lightFilter: int[]
        public static solid: boolean[]
        public static hardness: double[]
        public static transparent: boolean[]
        static diffusesSkyLight: boolean[]
        public static hasMeta: boolean[]
        static initializing: boolean
        mutableState: cn.nukkit.blockstate.MutableBlockState
        public layer: int

    }
}

declare module "cn.nukkit.block.Block" {
    declare const Block = cn.nukkit.block.Block;
}

declare namespace cn.nukkit.item {
    declare class Item extends java.lang.Object implements java.lang.Cloneable, cn.nukkit.block.BlockID, cn.nukkit.item.ItemID {
        public constructor(id: int): void
        public constructor(id: int, meta: int): void
        public constructor(id: int, meta: int, count: int): void
        public constructor(id: int, meta: int, count: int, name: string): void
        public hasMeta(): boolean
        public canBeActivated(): boolean
        public static init(): void
        public static rebuildItemList(): java.util.List<string>
        public static getItemList(): java.util.List<string>
        static initCreativeItems(): void
        static loadCreativeItemEntry(data: java.util.Map<string, java.lang.Object>): cn.nukkit.item.Item
        public static registerCustomItem(c: java.lang.Class<cn.nukkit.item.customitem.ItemCustom>): void
        public static deleteCustomItem(namespaceId: string): void
        public static getCustomItems(): java.util.HashMap<string, java.lang.Class<cn.nukkit.item.Item>>
        public static clearCreativeItems(): void
        public static getCreativeItems(): java.util.ArrayList<cn.nukkit.item.Item>
        public static addCreativeItem(item: cn.nukkit.item.Item): void
        public static removeCreativeItem(item: cn.nukkit.item.Item): void
        public static isCreativeItem(item: cn.nukkit.item.Item): boolean
        public static getCreativeItem(index: int): cn.nukkit.item.Item
        public static getCreativeItemIndex(item: cn.nukkit.item.Item): int
        public static getBlock(id: int): cn.nukkit.item.Item
        public static getBlock(id: int, meta: int): cn.nukkit.item.Item
        public static getBlock(id: int, meta: int, count: int): cn.nukkit.item.Item
        public static getBlock(id: int, meta: int, count: int, tags: byte[]): cn.nukkit.item.Item
        public static get(id: int): cn.nukkit.item.Item
        public static get(id: int, meta: int): cn.nukkit.item.Item
        public static get(id: int, meta: int, count: int): cn.nukkit.item.Item
        public static get(id: int, meta: int, count: int, tags: byte[]): cn.nukkit.item.Item
        public static fromString(str: string): cn.nukkit.item.Item
        public static fromJson(data: java.util.Map<string, java.lang.Object>): cn.nukkit.item.Item
        static fromJson(data: java.util.Map<string, java.lang.Object>, ignoreNegativeItemId: boolean): cn.nukkit.item.Item
        public static fromJsonNetworkId(data: java.util.Map<string, java.lang.Object>): cn.nukkit.item.Item
        public static fromStringMultiple(str: string): cn.nukkit.item.Item[]
        public setCompoundTag(tag: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.item.Item
        public setCompoundTag(tags: byte[]): cn.nukkit.item.Item
        public getCompoundTag(): byte[]
        public hasCompoundTag(): boolean
        public hasCustomCompoundTag(): boolean
        public getCustomCompoundTag(): byte[]
        public hasCustomBlockData(): boolean
        public clearCustomBlockData(): cn.nukkit.item.Item
        public setCustomBlockData(compoundTag: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.item.Item
        public getCustomBlockData(): cn.nukkit.nbt.tag.CompoundTag
        public applyEnchantments(): boolean
        public hasEnchantments(): boolean
        public getEnchantmentLevel(id: int): int
        public getEnchantment(id: int): cn.nukkit.item.enchantment.Enchantment
        public getEnchantment(id: short): cn.nukkit.item.enchantment.Enchantment
        public addEnchantment(enchantments: cn.nukkit.item.enchantment.Enchantment[]): void
        public getEnchantments(): cn.nukkit.item.enchantment.Enchantment[]
        public hasEnchantment(id: int): boolean
        public getAttackSideEffects(attacker: cn.nukkit.entity.Entity, entity: cn.nukkit.entity.Entity): cn.nukkit.item.enchantment.sideeffect.SideEffect[]
        public getRepairCost(): int
        public setRepairCost(cost: int): cn.nukkit.item.Item
        public hasCustomName(): boolean
        public getCustomName(): string
        public setCustomName(name: string): cn.nukkit.item.Item
        public clearCustomName(): cn.nukkit.item.Item
        public getLore(): string[]
        public setLore(lines: string[]): cn.nukkit.item.Item
        public getNamedTagEntry(name: string): cn.nukkit.nbt.tag.Tag
        public getNamedTag(): cn.nukkit.nbt.tag.CompoundTag
        public getOrCreateNamedTag(): cn.nukkit.nbt.tag.CompoundTag
        public setNamedTag(tag: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.item.Item
        public clearNamedTag(): cn.nukkit.item.Item
        public static parseCompoundTag(tag: byte[]): cn.nukkit.nbt.tag.CompoundTag
        public writeCompoundTag(tag: cn.nukkit.nbt.tag.CompoundTag): byte[]
        public getCount(): int
        public setCount(count: int): void
        public isNull(): boolean
        public getName(): string
        public canBePlaced(): boolean
        public getBlock(): cn.nukkit.block.Block
        public getBlockUnsafe(): cn.nukkit.block.Block
        public getId(): int
        public getNetworkFullId(): int
        public getNamespaceId(): string
        public getBlockId(): int
        public getDamage(): int
        public setDamage(meta: int): void
        public createFuzzyCraftingRecipe(): cn.nukkit.item.Item
        public getMaxStackSize(): int
        public getFuelTime(): java.lang.Short
        public useOn(entity: cn.nukkit.entity.Entity): boolean
        public useOn(block: cn.nukkit.block.Block): boolean
        public isTool(): boolean
        public getMaxDurability(): int
        public getTier(): int
        public isPickaxe(): boolean
        public isAxe(): boolean
        public isSword(): boolean
        public isShovel(): boolean
        public isHoe(): boolean
        public isShears(): boolean
        public isArmor(): boolean
        public isHelmet(): boolean
        public isChestplate(): boolean
        public isLeggings(): boolean
        public isBoots(): boolean
        public getEnchantAbility(): int
        public getAttackDamage(): int
        public getArmorPoints(): int
        public getToughness(): int
        public isUnbreakable(): boolean
        public isLavaResistant(): boolean
        public onUse(player: cn.nukkit.Player, ticksUsed: int): boolean
        public onRelease(player: cn.nukkit.Player, ticksUsed: int): boolean
        public toString(): string
        public getDestroySpeed(block: cn.nukkit.block.Block, player: cn.nukkit.Player): int
        public onActivate(level: cn.nukkit.level.Level, player: cn.nukkit.Player, block: cn.nukkit.block.Block, target: cn.nukkit.block.Block, face: cn.nukkit.math.BlockFace, fx: double, var6: double, fy: double): boolean
        public decrement(amount: int): cn.nukkit.item.Item
        public increment(amount: int): cn.nukkit.item.Item
        public isFertilizer(): boolean
        public onClickAir(player: cn.nukkit.Player, directionVector: cn.nukkit.math.Vector3): boolean
        public equals(item: java.lang.Object): boolean
        public equals(item: cn.nukkit.item.Item, checkDamage: boolean): boolean
        public equals(item: cn.nukkit.item.Item, checkDamage: boolean, checkCompound: boolean): boolean
        public equalsExact(other: cn.nukkit.item.Item): boolean
        public equalsIgnoringEnchantmentOrder(item: cn.nukkit.item.Item, checkDamage: boolean): boolean
        public deepEquals(item: cn.nukkit.item.Item): boolean
        public deepEquals(item: cn.nukkit.item.Item, checkDamage: boolean): boolean
        public deepEquals(item: cn.nukkit.item.Item, checkDamage: boolean, checkCompound: boolean): boolean
        public clone(): cn.nukkit.item.Item
        public getNetworkId(): int
        public addCanPlaceOn(block: cn.nukkit.block.Block): void
        public addCanPlaceOn(blocks: cn.nukkit.block.Block[]): void
        public setCanPlaceOn(blocks: cn.nukkit.block.Block[]): void
        public getCanPlaceOn(): cn.nukkit.nbt.tag.ListTag<cn.nukkit.nbt.tag.StringTag>
        public addCanDestroy(block: cn.nukkit.block.Block): void
        public addCanDestroy(blocks: cn.nukkit.block.Block[]): void
        public setCanDestroy(blocks: cn.nukkit.block.Block[]): void
        public getCanDestroy(): cn.nukkit.nbt.tag.ListTag<cn.nukkit.nbt.tag.StringTag>
        public setItemLockMode(mode: cn.nukkit.item.Item$ItemLockMode): void
        public getItemLockMode(): cn.nukkit.item.Item$ItemLockMode
        public setKeepOnDeath(keepOnDeath: boolean): void
        public keepOnDeath(): boolean
        public readItemJsonComponents(components: cn.nukkit.item.Item$ItemJsonComponents): void
        public clone(): java.lang.Object
        static lambda$readItemJsonComponents$14(str: string): cn.nukkit.block.Block
        static lambda$readItemJsonComponents$13(str: string): cn.nukkit.block.Block
        static lambda$getAttackSideEffects$12(x$0: int): cn.nukkit.item.enchantment.sideeffect.SideEffect[]
        static lambda$getAttackSideEffects$11(attacker: cn.nukkit.entity.Entity, entity: cn.nukkit.entity.Entity, enchantment: cn.nukkit.item.enchantment.Enchantment): java.util.stream.Stream
        static lambda$rebuildItemList$10(name: string): string
        static lambda$static$9(e1: int, e2: int): int
        static lambda$static$8(field: java.lang.reflect.Field): int
        static lambda$static$7(field: java.lang.reflect.Field): string
        static lambda$static$6(field: java.lang.reflect.Field): boolean
        static lambda$static$5(field: java.lang.reflect.Field): boolean
        static lambda$static$4(e1: int, e2: int): int
        static lambda$static$3(field: java.lang.reflect.Field): int
        static lambda$static$2(field: java.lang.reflect.Field): string
        static lambda$static$1(field: java.lang.reflect.Field): boolean
        static lambda$static$0(field: java.lang.reflect.Field): boolean
        static log: org.apache.logging.log4j.Logger
        public static EMPTY_ARRAY: cn.nukkit.item.Item[]
        static ITEM_STRING_PATTERN: java.util.regex.Pattern
        static UNKNOWN_STR: string
        public static list: java.lang.Class[]
        static itemIds: java.util.Map<string, int>
        static blockIds: java.util.Map<string, int>
        static CUSTOM_ITEMS: java.util.HashMap<string, java.lang.Class<cn.nukkit.item.Item>>
        block: cn.nukkit.block.Block
        id: int
        meta: int
        hasMeta: boolean
        tags: byte[]
        cachedNBT: cn.nukkit.nbt.tag.CompoundTag
        public count: int
        durability: int
        name: string
        static itemList: java.util.List<string>
        static creative: java.util.ArrayList<cn.nukkit.item.Item>

    }
}

declare module "cn.nukkit.item.Item" {
    declare const Item = cn.nukkit.item.Item;
}

declare namespace cn.nukkit.item {
    declare class MinecraftItemID extends java.lang.Enum {
        public static values(): cn.nukkit.item.MinecraftItemID[]
        public static valueOf(name: string): cn.nukkit.item.MinecraftItemID
        public static getByNamespaceId(namespacedId: string): cn.nukkit.item.MinecraftItemID
        constructor(var0: string, var1: string, namespacedId: string[]): void
        constructor(): void
        constructor(var0: boolean): void
        constructor(var0: boolean, var1: boolean): void
        constructor(var0: boolean, var1: boolean, blockForm: boolean): void
        constructor(var0: string, var1: string): void
        constructor(var0: string, var1: string, namespacedId: boolean): void
        constructor(var0: string, var1: string, namespacedId: boolean, itemFormNamespaceId: boolean): void
        public get(amount: int): cn.nukkit.item.Item
        public get(amount: int, compoundTag: byte[]): cn.nukkit.item.Item
        public getItemFormNamespaceId(): string
        public getNamespacedId(): string
        public isTechnical(): boolean
        public isEducationEdition(): boolean
        public getAliases(): string[]
        static lambda$static$2(entry: java.util.AbstractMap$SimpleEntry): string
        static lambda$static$1(id: cn.nukkit.item.MinecraftItemID): java.util.stream.Stream
        static lambda$static$0(id: cn.nukkit.item.MinecraftItemID, ns: string): java.util.AbstractMap$SimpleEntry
        static $values(): cn.nukkit.item.MinecraftItemID[]
        public static UNKNOWN: cn.nukkit.item.MinecraftItemID
        public static QUARTZ_BRICKS: cn.nukkit.item.MinecraftItemID
        public static CRACKED_NETHER_BRICKS: cn.nukkit.item.MinecraftItemID
        public static CHISELED_NETHER_BRICKS: cn.nukkit.item.MinecraftItemID
        public static STRIPPED_WARPED_HYPHAE: cn.nukkit.item.MinecraftItemID
        public static STRIPPED_CRIMSON_HYPHAE: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_HYPHAE: cn.nukkit.item.MinecraftItemID
        public static WARPED_HYPHAE: cn.nukkit.item.MinecraftItemID
        public static POLISHED_BLACKSTONE_WALL: cn.nukkit.item.MinecraftItemID
        public static POLISHED_BLACKSTONE_BUTTON: cn.nukkit.item.MinecraftItemID
        public static POLISHED_BLACKSTONE_PRESSURE_PLATE: cn.nukkit.item.MinecraftItemID
        public static POLISHED_BLACKSTONE_DOUBLE_SLAB: cn.nukkit.item.MinecraftItemID
        public static POLISHED_BLACKSTONE_SLAB: cn.nukkit.item.MinecraftItemID
        public static POLISHED_BLACKSTONE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static POLISHED_BLACKSTONE: cn.nukkit.item.MinecraftItemID
        public static SOUL_CAMPFIRE_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static CRYING_OBSIDIAN: cn.nukkit.item.MinecraftItemID
        public static NETHER_GOLD_ORE: cn.nukkit.item.MinecraftItemID
        public static TWISTING_VINES: cn.nukkit.item.MinecraftItemID
        public static CHAIN_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static POLISHED_BLACKSTONE_BRICK_DOUBLE_SLAB: cn.nukkit.item.MinecraftItemID
        public static POLISHED_BLACKSTONE_BRICK_SLAB: cn.nukkit.item.MinecraftItemID
        public static BLACKSTONE_DOUBLE_SLAB: cn.nukkit.item.MinecraftItemID
        public static BLACKSTONE_SLAB: cn.nukkit.item.MinecraftItemID
        public static GILDED_BLACKSTONE: cn.nukkit.item.MinecraftItemID
        public static CRACKED_POLISHED_BLACKSTONE_BRICKS: cn.nukkit.item.MinecraftItemID
        public static CHISELED_POLISHED_BLACKSTONE: cn.nukkit.item.MinecraftItemID
        public static POLISHED_BLACKSTONE_BRICK_WALL: cn.nukkit.item.MinecraftItemID
        public static BLACKSTONE_WALL: cn.nukkit.item.MinecraftItemID
        public static BLACKSTONE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static POLISHED_BLACKSTONE_BRICK_STAIRS: cn.nukkit.item.MinecraftItemID
        public static POLISHED_BLACKSTONE_BRICKS: cn.nukkit.item.MinecraftItemID
        public static BLACKSTONE: cn.nukkit.item.MinecraftItemID
        public static RESPAWN_ANCHOR: cn.nukkit.item.MinecraftItemID
        public static ANCIENT_DEBRIS: cn.nukkit.item.MinecraftItemID
        public static NETHERITE_BLOCK: cn.nukkit.item.MinecraftItemID
        public static SOUL_LANTERN: cn.nukkit.item.MinecraftItemID
        public static SOUL_TORCH: cn.nukkit.item.MinecraftItemID
        public static WARPED_DOUBLE_SLAB: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_DOUBLE_SLAB: cn.nukkit.item.MinecraftItemID
        public static WARPED_SLAB: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_SLAB: cn.nukkit.item.MinecraftItemID
        public static WARPED_PRESSURE_PLATE: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_PRESSURE_PLATE: cn.nukkit.item.MinecraftItemID
        public static WARPED_BUTTON: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_BUTTON: cn.nukkit.item.MinecraftItemID
        public static WARPED_FENCE_GATE: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_FENCE_GATE: cn.nukkit.item.MinecraftItemID
        public static WARPED_FENCE: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_FENCE: cn.nukkit.item.MinecraftItemID
        public static WARPED_STAIRS: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_STAIRS: cn.nukkit.item.MinecraftItemID
        public static WARPED_WALL_SIGN: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_WALL_SIGN: cn.nukkit.item.MinecraftItemID
        public static WARPED_STANDING_SIGN: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_STANDING_SIGN: cn.nukkit.item.MinecraftItemID
        public static WARPED_TRAPDOOR: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_TRAPDOOR: cn.nukkit.item.MinecraftItemID
        public static WARPED_DOOR_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_DOOR_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static WARPED_PLANKS: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_PLANKS: cn.nukkit.item.MinecraftItemID
        public static STRIPPED_WARPED_STEM: cn.nukkit.item.MinecraftItemID
        public static STRIPPED_CRIMSON_STEM: cn.nukkit.item.MinecraftItemID
        public static TARGET: cn.nukkit.item.MinecraftItemID
        public static NETHER_SPROUTS_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static SOUL_FIRE: cn.nukkit.item.MinecraftItemID
        public static SOUL_SOIL: cn.nukkit.item.MinecraftItemID
        public static POLISHED_BASALT: cn.nukkit.item.MinecraftItemID
        public static BASALT: cn.nukkit.item.MinecraftItemID
        public static WARPED_NYLIUM: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_NYLIUM: cn.nukkit.item.MinecraftItemID
        public static WEEPING_VINES: cn.nukkit.item.MinecraftItemID
        public static SHROOMLIGHT: cn.nukkit.item.MinecraftItemID
        public static WARPED_FUNGUS: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_FUNGUS: cn.nukkit.item.MinecraftItemID
        public static WARPED_WART_BLOCK: cn.nukkit.item.MinecraftItemID
        public static WARPED_STEM: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_STEM: cn.nukkit.item.MinecraftItemID
        public static WARPED_ROOTS: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_ROOTS: cn.nukkit.item.MinecraftItemID
        public static LODESTONE: cn.nukkit.item.MinecraftItemID
        public static HONEYCOMB_BLOCK: cn.nukkit.item.MinecraftItemID
        public static HONEY_BLOCK: cn.nukkit.item.MinecraftItemID
        public static BEEHIVE: cn.nukkit.item.MinecraftItemID
        public static BEE_NEST: cn.nukkit.item.MinecraftItemID
        public static WITHER_ROSE: cn.nukkit.item.MinecraftItemID
        public static LIGHT_BLOCK: cn.nukkit.item.MinecraftItemID
        public static LIT_BLAST_FURNACE: cn.nukkit.item.MinecraftItemID
        public static COMPOSTER: cn.nukkit.item.MinecraftItemID
        public static WOOD: cn.nukkit.item.MinecraftItemID
        public static JIGSAW: cn.nukkit.item.MinecraftItemID
        public static LAVA_CAULDRON: cn.nukkit.item.MinecraftItemID
        public static CAMPFIRE_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static LANTERN: cn.nukkit.item.MinecraftItemID
        public static SWEET_BERRY_BUSH: cn.nukkit.item.MinecraftItemID
        public static BELL: cn.nukkit.item.MinecraftItemID
        public static LOOM: cn.nukkit.item.MinecraftItemID
        public static BARREL: cn.nukkit.item.MinecraftItemID
        public static SMITHING_TABLE: cn.nukkit.item.MinecraftItemID
        public static FLETCHING_TABLE: cn.nukkit.item.MinecraftItemID
        public static CARTOGRAPHY_TABLE: cn.nukkit.item.MinecraftItemID
        public static LIT_SMOKER: cn.nukkit.item.MinecraftItemID
        public static SMOKER: cn.nukkit.item.MinecraftItemID
        public static STONECUTTER_BLOCK: cn.nukkit.item.MinecraftItemID
        public static BLAST_FURNACE: cn.nukkit.item.MinecraftItemID
        public static GRINDSTONE: cn.nukkit.item.MinecraftItemID
        public static LECTERN: cn.nukkit.item.MinecraftItemID
        public static DARKOAK_WALL_SIGN: cn.nukkit.item.MinecraftItemID
        public static DARKOAK_STANDING_SIGN: cn.nukkit.item.MinecraftItemID
        public static ACACIA_WALL_SIGN: cn.nukkit.item.MinecraftItemID
        public static ACACIA_STANDING_SIGN: cn.nukkit.item.MinecraftItemID
        public static JUNGLE_WALL_SIGN: cn.nukkit.item.MinecraftItemID
        public static JUNGLE_STANDING_SIGN: cn.nukkit.item.MinecraftItemID
        public static BIRCH_WALL_SIGN: cn.nukkit.item.MinecraftItemID
        public static BIRCH_STANDING_SIGN: cn.nukkit.item.MinecraftItemID
        public static SMOOTH_QUARTZ_STAIRS: cn.nukkit.item.MinecraftItemID
        public static RED_NETHER_BRICK_STAIRS: cn.nukkit.item.MinecraftItemID
        public static SMOOTH_STONE: cn.nukkit.item.MinecraftItemID
        public static SPRUCE_WALL_SIGN: cn.nukkit.item.MinecraftItemID
        public static SPRUCE_STANDING_SIGN: cn.nukkit.item.MinecraftItemID
        public static NORMAL_STONE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static MOSSY_COBBLESTONE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static END_BRICK_STAIRS: cn.nukkit.item.MinecraftItemID
        public static SMOOTH_SANDSTONE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static SMOOTH_RED_SANDSTONE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static MOSSY_STONE_BRICK_STAIRS: cn.nukkit.item.MinecraftItemID
        public static POLISHED_ANDESITE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static POLISHED_DIORITE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static POLISHED_GRANITE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static ANDESITE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static DIORITE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static GRANITE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static REAL_DOUBLE_STONE_SLAB4: cn.nukkit.item.MinecraftItemID
        public static REAL_DOUBLE_STONE_SLAB3: cn.nukkit.item.MinecraftItemID
        public static DOUBLE_STONE_SLAB4: cn.nukkit.item.MinecraftItemID
        public static SCAFFOLDING: cn.nukkit.item.MinecraftItemID
        public static BAMBOO_SAPLING: cn.nukkit.item.MinecraftItemID
        public static BAMBOO: cn.nukkit.item.MinecraftItemID
        public static DOUBLE_STONE_SLAB3: cn.nukkit.item.MinecraftItemID
        public static BARRIER: cn.nukkit.item.MinecraftItemID
        public static BUBBLE_COLUMN: cn.nukkit.item.MinecraftItemID
        public static TURTLE_EGG: cn.nukkit.item.MinecraftItemID
        public static AIR: cn.nukkit.item.MinecraftItemID
        public static CONDUIT: cn.nukkit.item.MinecraftItemID
        public static SEA_PICKLE: cn.nukkit.item.MinecraftItemID
        public static CARVED_PUMPKIN: cn.nukkit.item.MinecraftItemID
        public static SPRUCE_PRESSURE_PLATE: cn.nukkit.item.MinecraftItemID
        public static JUNGLE_PRESSURE_PLATE: cn.nukkit.item.MinecraftItemID
        public static DARK_OAK_PRESSURE_PLATE: cn.nukkit.item.MinecraftItemID
        public static BIRCH_PRESSURE_PLATE: cn.nukkit.item.MinecraftItemID
        public static ACACIA_PRESSURE_PLATE: cn.nukkit.item.MinecraftItemID
        public static SPRUCE_TRAPDOOR: cn.nukkit.item.MinecraftItemID
        public static JUNGLE_TRAPDOOR: cn.nukkit.item.MinecraftItemID
        public static DARK_OAK_TRAPDOOR: cn.nukkit.item.MinecraftItemID
        public static BIRCH_TRAPDOOR: cn.nukkit.item.MinecraftItemID
        public static ACACIA_TRAPDOOR: cn.nukkit.item.MinecraftItemID
        public static SPRUCE_BUTTON: cn.nukkit.item.MinecraftItemID
        public static JUNGLE_BUTTON: cn.nukkit.item.MinecraftItemID
        public static DARK_OAK_BUTTON: cn.nukkit.item.MinecraftItemID
        public static BIRCH_BUTTON: cn.nukkit.item.MinecraftItemID
        public static ACACIA_BUTTON: cn.nukkit.item.MinecraftItemID
        public static DRIED_KELP_BLOCK: cn.nukkit.item.MinecraftItemID
        public static KELP_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static CORAL_FAN_HANG3: cn.nukkit.item.MinecraftItemID
        public static CORAL_FAN_HANG2: cn.nukkit.item.MinecraftItemID
        public static CORAL_FAN_HANG: cn.nukkit.item.MinecraftItemID
        public static CORAL_FAN_DEAD: cn.nukkit.item.MinecraftItemID
        public static CORAL_FAN: cn.nukkit.item.MinecraftItemID
        public static CORAL_BLOCK: cn.nukkit.item.MinecraftItemID
        public static CORAL: cn.nukkit.item.MinecraftItemID
        public static SEAGRASS: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_118: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_117: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_116: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_115: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_114: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_113: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_112: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_111: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_110: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_109: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_108: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_107: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_106: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_105: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_104: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_103: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_102: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_101: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_100: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_99: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_98: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_97: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_96: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_95: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_94: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_93: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_92: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_91: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_90: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_89: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_88: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_87: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_86: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_85: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_84: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_83: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_82: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_81: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_80: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_79: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_78: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_77: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_76: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_75: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_74: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_73: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_72: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_71: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_70: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_69: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_68: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_67: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_66: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_65: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_64: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_63: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_62: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_61: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_60: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_59: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_58: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_57: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_56: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_55: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_54: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_53: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_52: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_51: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_50: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_49: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_48: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_47: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_46: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_45: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_44: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_43: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_42: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_41: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_40: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_39: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_38: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_37: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_36: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_35: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_34: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_33: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_32: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_31: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_30: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_29: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_28: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_27: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_26: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_25: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_24: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_23: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_22: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_21: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_20: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_19: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_18: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_17: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_16: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_15: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_14: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_13: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_12: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_11: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_10: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_9: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_8: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_7: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_6: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_5: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_4: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_3: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_2: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_1: cn.nukkit.item.MinecraftItemID
        public static BLUE_ICE: cn.nukkit.item.MinecraftItemID
        public static STRIPPED_OAK_LOG: cn.nukkit.item.MinecraftItemID
        public static STRIPPED_DARK_OAK_LOG: cn.nukkit.item.MinecraftItemID
        public static STRIPPED_ACACIA_LOG: cn.nukkit.item.MinecraftItemID
        public static STRIPPED_JUNGLE_LOG: cn.nukkit.item.MinecraftItemID
        public static STRIPPED_BIRCH_LOG: cn.nukkit.item.MinecraftItemID
        public static STRIPPED_SPRUCE_LOG: cn.nukkit.item.MinecraftItemID
        public static PRISMARINE_BRICKS_STAIRS: cn.nukkit.item.MinecraftItemID
        public static DARK_PRISMARINE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static PRISMARINE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static STONE: cn.nukkit.item.MinecraftItemID
        public static GRASS: cn.nukkit.item.MinecraftItemID
        public static DIRT: cn.nukkit.item.MinecraftItemID
        public static COBBLESTONE: cn.nukkit.item.MinecraftItemID
        public static PLANKS: cn.nukkit.item.MinecraftItemID
        public static SAPLING: cn.nukkit.item.MinecraftItemID
        public static BEDROCK: cn.nukkit.item.MinecraftItemID
        public static FLOWING_WATER: cn.nukkit.item.MinecraftItemID
        public static WATER: cn.nukkit.item.MinecraftItemID
        public static FLOWING_LAVA: cn.nukkit.item.MinecraftItemID
        public static LAVA: cn.nukkit.item.MinecraftItemID
        public static SAND: cn.nukkit.item.MinecraftItemID
        public static GRAVEL: cn.nukkit.item.MinecraftItemID
        public static GOLD_ORE: cn.nukkit.item.MinecraftItemID
        public static IRON_ORE: cn.nukkit.item.MinecraftItemID
        public static COAL_ORE: cn.nukkit.item.MinecraftItemID
        public static LOG: cn.nukkit.item.MinecraftItemID
        public static LEAVES: cn.nukkit.item.MinecraftItemID
        public static SPONGE: cn.nukkit.item.MinecraftItemID
        public static GLASS: cn.nukkit.item.MinecraftItemID
        public static LAPIS_ORE: cn.nukkit.item.MinecraftItemID
        public static LAPIS_BLOCK: cn.nukkit.item.MinecraftItemID
        public static DISPENSER: cn.nukkit.item.MinecraftItemID
        public static SANDSTONE: cn.nukkit.item.MinecraftItemID
        public static NOTEBLOCK: cn.nukkit.item.MinecraftItemID
        public static BED_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static GOLDEN_RAIL: cn.nukkit.item.MinecraftItemID
        public static DETECTOR_RAIL: cn.nukkit.item.MinecraftItemID
        public static STICKY_PISTON: cn.nukkit.item.MinecraftItemID
        public static WEB: cn.nukkit.item.MinecraftItemID
        public static TALLGRASS: cn.nukkit.item.MinecraftItemID
        public static DEADBUSH: cn.nukkit.item.MinecraftItemID
        public static PISTON: cn.nukkit.item.MinecraftItemID
        public static WOOL: cn.nukkit.item.MinecraftItemID
        public static ELEMENT_0: cn.nukkit.item.MinecraftItemID
        public static YELLOW_FLOWER: cn.nukkit.item.MinecraftItemID
        public static RED_FLOWER: cn.nukkit.item.MinecraftItemID
        public static BROWN_MUSHROOM: cn.nukkit.item.MinecraftItemID
        public static RED_MUSHROOM: cn.nukkit.item.MinecraftItemID
        public static GOLD_BLOCK: cn.nukkit.item.MinecraftItemID
        public static IRON_BLOCK: cn.nukkit.item.MinecraftItemID
        public static REAL_DOUBLE_STONE_SLAB: cn.nukkit.item.MinecraftItemID
        public static DOUBLE_STONE_SLAB: cn.nukkit.item.MinecraftItemID
        public static BRICK_BLOCK: cn.nukkit.item.MinecraftItemID
        public static TNT: cn.nukkit.item.MinecraftItemID
        public static BOOKSHELF: cn.nukkit.item.MinecraftItemID
        public static MOSSY_COBBLESTONE: cn.nukkit.item.MinecraftItemID
        public static OBSIDIAN: cn.nukkit.item.MinecraftItemID
        public static TORCH: cn.nukkit.item.MinecraftItemID
        public static FIRE: cn.nukkit.item.MinecraftItemID
        public static MOB_SPAWNER: cn.nukkit.item.MinecraftItemID
        public static OAK_STAIRS: cn.nukkit.item.MinecraftItemID
        public static CHEST: cn.nukkit.item.MinecraftItemID
        public static REDSTONE_WIRE: cn.nukkit.item.MinecraftItemID
        public static DIAMOND_ORE: cn.nukkit.item.MinecraftItemID
        public static DIAMOND_BLOCK: cn.nukkit.item.MinecraftItemID
        public static CRAFTING_TABLE: cn.nukkit.item.MinecraftItemID
        public static WHEAT_BLOCK: cn.nukkit.item.MinecraftItemID
        public static FARMLAND: cn.nukkit.item.MinecraftItemID
        public static FURNACE: cn.nukkit.item.MinecraftItemID
        public static LIT_FURNACE: cn.nukkit.item.MinecraftItemID
        public static STANDING_SIGN: cn.nukkit.item.MinecraftItemID
        public static WOODEN_DOOR_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static LADDER: cn.nukkit.item.MinecraftItemID
        public static RAIL: cn.nukkit.item.MinecraftItemID
        public static STONE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static WALL_SIGN: cn.nukkit.item.MinecraftItemID
        public static LEVER: cn.nukkit.item.MinecraftItemID
        public static STONE_PRESSURE_PLATE: cn.nukkit.item.MinecraftItemID
        public static IRON_DOOR_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static WOODEN_PRESSURE_PLATE: cn.nukkit.item.MinecraftItemID
        public static REDSTONE_ORE: cn.nukkit.item.MinecraftItemID
        public static LIT_REDSTONE_ORE: cn.nukkit.item.MinecraftItemID
        public static UNLIT_REDSTONE_TORCH: cn.nukkit.item.MinecraftItemID
        public static REDSTONE_TORCH: cn.nukkit.item.MinecraftItemID
        public static STONE_BUTTON: cn.nukkit.item.MinecraftItemID
        public static SNOW_LAYER: cn.nukkit.item.MinecraftItemID
        public static ICE: cn.nukkit.item.MinecraftItemID
        public static SNOW: cn.nukkit.item.MinecraftItemID
        public static CACTUS: cn.nukkit.item.MinecraftItemID
        public static CLAY: cn.nukkit.item.MinecraftItemID
        public static REEDS: cn.nukkit.item.MinecraftItemID
        public static JUKEBOX: cn.nukkit.item.MinecraftItemID
        public static FENCE: cn.nukkit.item.MinecraftItemID
        public static PUMPKIN: cn.nukkit.item.MinecraftItemID
        public static NETHERRACK: cn.nukkit.item.MinecraftItemID
        public static SOUL_SAND: cn.nukkit.item.MinecraftItemID
        public static GLOWSTONE: cn.nukkit.item.MinecraftItemID
        public static PORTAL: cn.nukkit.item.MinecraftItemID
        public static LIT_PUMPKIN: cn.nukkit.item.MinecraftItemID
        public static CAKE_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static UNPOWERED_REPEATER: cn.nukkit.item.MinecraftItemID
        public static POWERED_REPEATER: cn.nukkit.item.MinecraftItemID
        public static INVISIBLEBEDROCK: cn.nukkit.item.MinecraftItemID
        public static TRAPDOOR: cn.nukkit.item.MinecraftItemID
        public static MONSTER_EGG: cn.nukkit.item.MinecraftItemID
        public static STONEBRICK: cn.nukkit.item.MinecraftItemID
        public static BROWN_MUSHROOM_BLOCK: cn.nukkit.item.MinecraftItemID
        public static RED_MUSHROOM_BLOCK: cn.nukkit.item.MinecraftItemID
        public static IRON_BARS: cn.nukkit.item.MinecraftItemID
        public static GLASS_PANE: cn.nukkit.item.MinecraftItemID
        public static MELON_BLOCK: cn.nukkit.item.MinecraftItemID
        public static PUMPKIN_STEM: cn.nukkit.item.MinecraftItemID
        public static MELON_STEM: cn.nukkit.item.MinecraftItemID
        public static VINE: cn.nukkit.item.MinecraftItemID
        public static FENCE_GATE: cn.nukkit.item.MinecraftItemID
        public static BRICK_STAIRS: cn.nukkit.item.MinecraftItemID
        public static STONE_BRICK_STAIRS: cn.nukkit.item.MinecraftItemID
        public static MYCELIUM: cn.nukkit.item.MinecraftItemID
        public static WATERLILY: cn.nukkit.item.MinecraftItemID
        public static NETHER_BRICK: cn.nukkit.item.MinecraftItemID
        public static NETHER_BRICK_FENCE: cn.nukkit.item.MinecraftItemID
        public static NETHER_BRICK_STAIRS: cn.nukkit.item.MinecraftItemID
        public static NETHER_WART_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static ENCHANTING_TABLE: cn.nukkit.item.MinecraftItemID
        public static BREWINGSTANDBLOCK: cn.nukkit.item.MinecraftItemID
        public static CAULDRON_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static END_PORTAL: cn.nukkit.item.MinecraftItemID
        public static END_PORTAL_FRAME: cn.nukkit.item.MinecraftItemID
        public static END_STONE: cn.nukkit.item.MinecraftItemID
        public static DRAGON_EGG: cn.nukkit.item.MinecraftItemID
        public static REDSTONE_LAMP: cn.nukkit.item.MinecraftItemID
        public static LIT_REDSTONE_LAMP: cn.nukkit.item.MinecraftItemID
        public static DROPPER: cn.nukkit.item.MinecraftItemID
        public static ACTIVATOR_RAIL: cn.nukkit.item.MinecraftItemID
        public static COCOA: cn.nukkit.item.MinecraftItemID
        public static SANDSTONE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static EMERALD_ORE: cn.nukkit.item.MinecraftItemID
        public static ENDER_CHEST: cn.nukkit.item.MinecraftItemID
        public static TRIPWIRE_HOOK: cn.nukkit.item.MinecraftItemID
        public static TRIPWIRE: cn.nukkit.item.MinecraftItemID
        public static EMERALD_BLOCK: cn.nukkit.item.MinecraftItemID
        public static SPRUCE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static BIRCH_STAIRS: cn.nukkit.item.MinecraftItemID
        public static JUNGLE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static COMMAND_BLOCK: cn.nukkit.item.MinecraftItemID
        public static BEACON: cn.nukkit.item.MinecraftItemID
        public static COBBLESTONE_WALL: cn.nukkit.item.MinecraftItemID
        public static FLOWER_POT_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static CARROTS: cn.nukkit.item.MinecraftItemID
        public static POTATOES: cn.nukkit.item.MinecraftItemID
        public static WOODEN_BUTTON: cn.nukkit.item.MinecraftItemID
        public static SKULL_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static ANVIL: cn.nukkit.item.MinecraftItemID
        public static TRAPPED_CHEST: cn.nukkit.item.MinecraftItemID
        public static LIGHT_WEIGHTED_PRESSURE_PLATE: cn.nukkit.item.MinecraftItemID
        public static HEAVY_WEIGHTED_PRESSURE_PLATE: cn.nukkit.item.MinecraftItemID
        public static UNPOWERED_COMPARATOR: cn.nukkit.item.MinecraftItemID
        public static POWERED_COMPARATOR: cn.nukkit.item.MinecraftItemID
        public static DAYLIGHT_DETECTOR: cn.nukkit.item.MinecraftItemID
        public static REDSTONE_BLOCK: cn.nukkit.item.MinecraftItemID
        public static QUARTZ_ORE: cn.nukkit.item.MinecraftItemID
        public static HOPPER_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static QUARTZ_BLOCK: cn.nukkit.item.MinecraftItemID
        public static QUARTZ_STAIRS: cn.nukkit.item.MinecraftItemID
        public static DOUBLE_WOODEN_SLAB: cn.nukkit.item.MinecraftItemID
        public static WOODEN_SLAB: cn.nukkit.item.MinecraftItemID
        public static STAINED_HARDENED_CLAY: cn.nukkit.item.MinecraftItemID
        public static STAINED_GLASS_PANE: cn.nukkit.item.MinecraftItemID
        public static LEAVES2: cn.nukkit.item.MinecraftItemID
        public static LOG2: cn.nukkit.item.MinecraftItemID
        public static ACACIA_STAIRS: cn.nukkit.item.MinecraftItemID
        public static DARK_OAK_STAIRS: cn.nukkit.item.MinecraftItemID
        public static SLIME: cn.nukkit.item.MinecraftItemID
        public static GLOW_STICK: cn.nukkit.item.MinecraftItemID
        public static IRON_TRAPDOOR: cn.nukkit.item.MinecraftItemID
        public static PRISMARINE: cn.nukkit.item.MinecraftItemID
        public static SEALANTERN: cn.nukkit.item.MinecraftItemID
        public static HAY_BLOCK: cn.nukkit.item.MinecraftItemID
        public static CARPET: cn.nukkit.item.MinecraftItemID
        public static HARDENED_CLAY: cn.nukkit.item.MinecraftItemID
        public static COAL_BLOCK: cn.nukkit.item.MinecraftItemID
        public static PACKED_ICE: cn.nukkit.item.MinecraftItemID
        public static DOUBLE_PLANT: cn.nukkit.item.MinecraftItemID
        public static STANDING_BANNER: cn.nukkit.item.MinecraftItemID
        public static WALL_BANNER: cn.nukkit.item.MinecraftItemID
        public static DAYLIGHT_DETECTOR_INVERTED: cn.nukkit.item.MinecraftItemID
        public static RED_SANDSTONE: cn.nukkit.item.MinecraftItemID
        public static RED_SANDSTONE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static REAL_DOUBLE_STONE_SLAB2: cn.nukkit.item.MinecraftItemID
        public static DOUBLE_STONE_SLAB2: cn.nukkit.item.MinecraftItemID
        public static SPRUCE_FENCE_GATE: cn.nukkit.item.MinecraftItemID
        public static BIRCH_FENCE_GATE: cn.nukkit.item.MinecraftItemID
        public static JUNGLE_FENCE_GATE: cn.nukkit.item.MinecraftItemID
        public static DARK_OAK_FENCE_GATE: cn.nukkit.item.MinecraftItemID
        public static ACACIA_FENCE_GATE: cn.nukkit.item.MinecraftItemID
        public static REPEATING_COMMAND_BLOCK: cn.nukkit.item.MinecraftItemID
        public static CHAIN_COMMAND_BLOCK: cn.nukkit.item.MinecraftItemID
        public static HARD_GLASS_PANE: cn.nukkit.item.MinecraftItemID
        public static HARD_STAINED_GLASS_PANE: cn.nukkit.item.MinecraftItemID
        public static CHEMICAL_HEAT: cn.nukkit.item.MinecraftItemID
        public static SPRUCE_DOOR_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static BIRCH_DOOR_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static JUNGLE_DOOR_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static ACACIA_DOOR_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static DARK_OAK_DOOR_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static GRASS_PATH: cn.nukkit.item.MinecraftItemID
        public static FRAME_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static CHORUS_FLOWER: cn.nukkit.item.MinecraftItemID
        public static PURPUR_BLOCK: cn.nukkit.item.MinecraftItemID
        public static COLORED_TORCH_RG: cn.nukkit.item.MinecraftItemID
        public static PURPUR_STAIRS: cn.nukkit.item.MinecraftItemID
        public static COLORED_TORCH_BP: cn.nukkit.item.MinecraftItemID
        public static UNDYED_SHULKER_BOX: cn.nukkit.item.MinecraftItemID
        public static END_BRICKS: cn.nukkit.item.MinecraftItemID
        public static FROSTED_ICE: cn.nukkit.item.MinecraftItemID
        public static END_ROD: cn.nukkit.item.MinecraftItemID
        public static END_GATEWAY: cn.nukkit.item.MinecraftItemID
        public static ALLOW: cn.nukkit.item.MinecraftItemID
        public static DENY: cn.nukkit.item.MinecraftItemID
        public static BORDER_BLOCK: cn.nukkit.item.MinecraftItemID
        public static MAGMA: cn.nukkit.item.MinecraftItemID
        public static NETHER_WART_BLOCK: cn.nukkit.item.MinecraftItemID
        public static RED_NETHER_BRICK: cn.nukkit.item.MinecraftItemID
        public static BONE_BLOCK: cn.nukkit.item.MinecraftItemID
        public static STRUCTURE_VOID: cn.nukkit.item.MinecraftItemID
        public static SHULKER_BOX: cn.nukkit.item.MinecraftItemID
        public static PURPLE_GLAZED_TERRACOTTA: cn.nukkit.item.MinecraftItemID
        public static WHITE_GLAZED_TERRACOTTA: cn.nukkit.item.MinecraftItemID
        public static ORANGE_GLAZED_TERRACOTTA: cn.nukkit.item.MinecraftItemID
        public static MAGENTA_GLAZED_TERRACOTTA: cn.nukkit.item.MinecraftItemID
        public static LIGHT_BLUE_GLAZED_TERRACOTTA: cn.nukkit.item.MinecraftItemID
        public static YELLOW_GLAZED_TERRACOTTA: cn.nukkit.item.MinecraftItemID
        public static LIME_GLAZED_TERRACOTTA: cn.nukkit.item.MinecraftItemID
        public static PINK_GLAZED_TERRACOTTA: cn.nukkit.item.MinecraftItemID
        public static GRAY_GLAZED_TERRACOTTA: cn.nukkit.item.MinecraftItemID
        public static SILVER_GLAZED_TERRACOTTA: cn.nukkit.item.MinecraftItemID
        public static CYAN_GLAZED_TERRACOTTA: cn.nukkit.item.MinecraftItemID
        public static BLUE_GLAZED_TERRACOTTA: cn.nukkit.item.MinecraftItemID
        public static BROWN_GLAZED_TERRACOTTA: cn.nukkit.item.MinecraftItemID
        public static GREEN_GLAZED_TERRACOTTA: cn.nukkit.item.MinecraftItemID
        public static RED_GLAZED_TERRACOTTA: cn.nukkit.item.MinecraftItemID
        public static BLACK_GLAZED_TERRACOTTA: cn.nukkit.item.MinecraftItemID
        public static CONCRETE: cn.nukkit.item.MinecraftItemID
        public static CONCRETE_POWDER: cn.nukkit.item.MinecraftItemID
        public static CHEMISTRY_TABLE: cn.nukkit.item.MinecraftItemID
        public static UNDERWATER_TORCH: cn.nukkit.item.MinecraftItemID
        public static CHORUS_PLANT: cn.nukkit.item.MinecraftItemID
        public static STAINED_GLASS: cn.nukkit.item.MinecraftItemID
        public static CAMERA_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static PODZOL: cn.nukkit.item.MinecraftItemID
        public static BEETROOT_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static STONECUTTER: cn.nukkit.item.MinecraftItemID
        public static GLOWINGOBSIDIAN: cn.nukkit.item.MinecraftItemID
        public static NETHERREACTOR: cn.nukkit.item.MinecraftItemID
        public static INFO_UPDATE: cn.nukkit.item.MinecraftItemID
        public static INFO_UPDATE2: cn.nukkit.item.MinecraftItemID
        public static OBSERVER: cn.nukkit.item.MinecraftItemID
        public static STRUCTURE_BLOCK: cn.nukkit.item.MinecraftItemID
        public static HARD_GLASS: cn.nukkit.item.MinecraftItemID
        public static HARD_STAINED_GLASS: cn.nukkit.item.MinecraftItemID
        public static RESERVED6: cn.nukkit.item.MinecraftItemID
        public static IRON_SHOVEL: cn.nukkit.item.MinecraftItemID
        public static IRON_PICKAXE: cn.nukkit.item.MinecraftItemID
        public static IRON_AXE: cn.nukkit.item.MinecraftItemID
        public static FLINT_AND_STEEL: cn.nukkit.item.MinecraftItemID
        public static APPLE: cn.nukkit.item.MinecraftItemID
        public static BOW: cn.nukkit.item.MinecraftItemID
        public static ARROW: cn.nukkit.item.MinecraftItemID
        public static COAL: cn.nukkit.item.MinecraftItemID
        public static DIAMOND: cn.nukkit.item.MinecraftItemID
        public static IRON_INGOT: cn.nukkit.item.MinecraftItemID
        public static GOLD_INGOT: cn.nukkit.item.MinecraftItemID
        public static IRON_SWORD: cn.nukkit.item.MinecraftItemID
        public static WOODEN_SWORD: cn.nukkit.item.MinecraftItemID
        public static WOODEN_SHOVEL: cn.nukkit.item.MinecraftItemID
        public static WOODEN_PICKAXE: cn.nukkit.item.MinecraftItemID
        public static WOODEN_AXE: cn.nukkit.item.MinecraftItemID
        public static STONE_SWORD: cn.nukkit.item.MinecraftItemID
        public static STONE_SHOVEL: cn.nukkit.item.MinecraftItemID
        public static STONE_PICKAXE: cn.nukkit.item.MinecraftItemID
        public static STONE_AXE: cn.nukkit.item.MinecraftItemID
        public static DIAMOND_SWORD: cn.nukkit.item.MinecraftItemID
        public static DIAMOND_SHOVEL: cn.nukkit.item.MinecraftItemID
        public static DIAMOND_PICKAXE: cn.nukkit.item.MinecraftItemID
        public static DIAMOND_AXE: cn.nukkit.item.MinecraftItemID
        public static STICK: cn.nukkit.item.MinecraftItemID
        public static BOWL: cn.nukkit.item.MinecraftItemID
        public static MUSHROOM_STEW: cn.nukkit.item.MinecraftItemID
        public static GOLDEN_SWORD: cn.nukkit.item.MinecraftItemID
        public static GOLDEN_SHOVEL: cn.nukkit.item.MinecraftItemID
        public static GOLDEN_PICKAXE: cn.nukkit.item.MinecraftItemID
        public static GOLDEN_AXE: cn.nukkit.item.MinecraftItemID
        public static STRING: cn.nukkit.item.MinecraftItemID
        public static FEATHER: cn.nukkit.item.MinecraftItemID
        public static GUNPOWDER: cn.nukkit.item.MinecraftItemID
        public static WOODEN_HOE: cn.nukkit.item.MinecraftItemID
        public static STONE_HOE: cn.nukkit.item.MinecraftItemID
        public static IRON_HOE: cn.nukkit.item.MinecraftItemID
        public static DIAMOND_HOE: cn.nukkit.item.MinecraftItemID
        public static GOLDEN_HOE: cn.nukkit.item.MinecraftItemID
        public static WHEAT_SEEDS: cn.nukkit.item.MinecraftItemID
        public static WHEAT: cn.nukkit.item.MinecraftItemID
        public static BREAD: cn.nukkit.item.MinecraftItemID
        public static LEATHER_HELMET: cn.nukkit.item.MinecraftItemID
        public static LEATHER_CHESTPLATE: cn.nukkit.item.MinecraftItemID
        public static LEATHER_LEGGINGS: cn.nukkit.item.MinecraftItemID
        public static LEATHER_BOOTS: cn.nukkit.item.MinecraftItemID
        public static CHAINMAIL_HELMET: cn.nukkit.item.MinecraftItemID
        public static CHAINMAIL_CHESTPLATE: cn.nukkit.item.MinecraftItemID
        public static CHAINMAIL_LEGGINGS: cn.nukkit.item.MinecraftItemID
        public static CHAINMAIL_BOOTS: cn.nukkit.item.MinecraftItemID
        public static IRON_HELMET: cn.nukkit.item.MinecraftItemID
        public static IRON_CHESTPLATE: cn.nukkit.item.MinecraftItemID
        public static IRON_LEGGINGS: cn.nukkit.item.MinecraftItemID
        public static IRON_BOOTS: cn.nukkit.item.MinecraftItemID
        public static DIAMOND_HELMET: cn.nukkit.item.MinecraftItemID
        public static DIAMOND_CHESTPLATE: cn.nukkit.item.MinecraftItemID
        public static DIAMOND_LEGGINGS: cn.nukkit.item.MinecraftItemID
        public static DIAMOND_BOOTS: cn.nukkit.item.MinecraftItemID
        public static GOLDEN_HELMET: cn.nukkit.item.MinecraftItemID
        public static GOLDEN_CHESTPLATE: cn.nukkit.item.MinecraftItemID
        public static GOLDEN_LEGGINGS: cn.nukkit.item.MinecraftItemID
        public static GOLDEN_BOOTS: cn.nukkit.item.MinecraftItemID
        public static FLINT: cn.nukkit.item.MinecraftItemID
        public static PORKCHOP: cn.nukkit.item.MinecraftItemID
        public static COOKED_PORKCHOP: cn.nukkit.item.MinecraftItemID
        public static PAINTING: cn.nukkit.item.MinecraftItemID
        public static GOLDEN_APPLE: cn.nukkit.item.MinecraftItemID
        public static OAK_SIGN: cn.nukkit.item.MinecraftItemID
        public static WOODEN_DOOR: cn.nukkit.item.MinecraftItemID
        public static BUCKET: cn.nukkit.item.MinecraftItemID
        public static MINECART: cn.nukkit.item.MinecraftItemID
        public static SADDLE: cn.nukkit.item.MinecraftItemID
        public static IRON_DOOR: cn.nukkit.item.MinecraftItemID
        public static REDSTONE: cn.nukkit.item.MinecraftItemID
        public static SNOWBALL: cn.nukkit.item.MinecraftItemID
        public static BOAT: cn.nukkit.item.MinecraftItemID
        public static LEATHER: cn.nukkit.item.MinecraftItemID
        public static KELP: cn.nukkit.item.MinecraftItemID
        public static BRICK: cn.nukkit.item.MinecraftItemID
        public static CLAY_BALL: cn.nukkit.item.MinecraftItemID
        public static SUGAR_CANE: cn.nukkit.item.MinecraftItemID
        public static PAPER: cn.nukkit.item.MinecraftItemID
        public static BOOK: cn.nukkit.item.MinecraftItemID
        public static SLIME_BALL: cn.nukkit.item.MinecraftItemID
        public static CHEST_MINECART: cn.nukkit.item.MinecraftItemID
        public static EGG: cn.nukkit.item.MinecraftItemID
        public static COMPASS: cn.nukkit.item.MinecraftItemID
        public static FISHING_ROD: cn.nukkit.item.MinecraftItemID
        public static CLOCK: cn.nukkit.item.MinecraftItemID
        public static GLOWSTONE_DUST: cn.nukkit.item.MinecraftItemID
        public static COD: cn.nukkit.item.MinecraftItemID
        public static COOKED_COD: cn.nukkit.item.MinecraftItemID
        public static DYE: cn.nukkit.item.MinecraftItemID
        public static BONE: cn.nukkit.item.MinecraftItemID
        public static SUGAR: cn.nukkit.item.MinecraftItemID
        public static CAKE: cn.nukkit.item.MinecraftItemID
        public static BED: cn.nukkit.item.MinecraftItemID
        public static REPEATER: cn.nukkit.item.MinecraftItemID
        public static COOKIE: cn.nukkit.item.MinecraftItemID
        public static FILLED_MAP: cn.nukkit.item.MinecraftItemID
        public static SHEARS: cn.nukkit.item.MinecraftItemID
        public static MELON_SLICE: cn.nukkit.item.MinecraftItemID
        public static PUMPKIN_SEEDS: cn.nukkit.item.MinecraftItemID
        public static MELON_SEEDS: cn.nukkit.item.MinecraftItemID
        public static BEEF: cn.nukkit.item.MinecraftItemID
        public static COOKED_BEEF: cn.nukkit.item.MinecraftItemID
        public static CHICKEN: cn.nukkit.item.MinecraftItemID
        public static COOKED_CHICKEN: cn.nukkit.item.MinecraftItemID
        public static ROTTEN_FLESH: cn.nukkit.item.MinecraftItemID
        public static ENDER_PEARL: cn.nukkit.item.MinecraftItemID
        public static BLAZE_ROD: cn.nukkit.item.MinecraftItemID
        public static GHAST_TEAR: cn.nukkit.item.MinecraftItemID
        public static GOLD_NUGGET: cn.nukkit.item.MinecraftItemID
        public static NETHER_WART: cn.nukkit.item.MinecraftItemID
        public static POTION: cn.nukkit.item.MinecraftItemID
        public static GLASS_BOTTLE: cn.nukkit.item.MinecraftItemID
        public static SPIDER_EYE: cn.nukkit.item.MinecraftItemID
        public static FERMENTED_SPIDER_EYE: cn.nukkit.item.MinecraftItemID
        public static BLAZE_POWDER: cn.nukkit.item.MinecraftItemID
        public static MAGMA_CREAM: cn.nukkit.item.MinecraftItemID
        public static BREWING_STAND: cn.nukkit.item.MinecraftItemID
        public static CAULDRON: cn.nukkit.item.MinecraftItemID
        public static ENDER_EYE: cn.nukkit.item.MinecraftItemID
        public static GLISTERING_MELON_SLICE: cn.nukkit.item.MinecraftItemID
        public static SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static EXPERIENCE_BOTTLE: cn.nukkit.item.MinecraftItemID
        public static FIRE_CHARGE: cn.nukkit.item.MinecraftItemID
        public static WRITABLE_BOOK: cn.nukkit.item.MinecraftItemID
        public static WRITTEN_BOOK: cn.nukkit.item.MinecraftItemID
        public static EMERALD: cn.nukkit.item.MinecraftItemID
        public static FRAME: cn.nukkit.item.MinecraftItemID
        public static FLOWER_POT: cn.nukkit.item.MinecraftItemID
        public static CARROT: cn.nukkit.item.MinecraftItemID
        public static POTATO: cn.nukkit.item.MinecraftItemID
        public static BAKED_POTATO: cn.nukkit.item.MinecraftItemID
        public static POISONOUS_POTATO: cn.nukkit.item.MinecraftItemID
        public static EMPTY_MAP: cn.nukkit.item.MinecraftItemID
        public static GOLDEN_CARROT: cn.nukkit.item.MinecraftItemID
        public static SKULL: cn.nukkit.item.MinecraftItemID
        public static CARROT_ON_A_STICK: cn.nukkit.item.MinecraftItemID
        public static NETHER_STAR: cn.nukkit.item.MinecraftItemID
        public static PUMPKIN_PIE: cn.nukkit.item.MinecraftItemID
        public static FIREWORK_ROCKET: cn.nukkit.item.MinecraftItemID
        public static FIREWORK_STAR: cn.nukkit.item.MinecraftItemID
        public static ENCHANTED_BOOK: cn.nukkit.item.MinecraftItemID
        public static COMPARATOR: cn.nukkit.item.MinecraftItemID
        public static NETHERBRICK: cn.nukkit.item.MinecraftItemID
        public static QUARTZ: cn.nukkit.item.MinecraftItemID
        public static TNT_MINECART: cn.nukkit.item.MinecraftItemID
        public static HOPPER_MINECART: cn.nukkit.item.MinecraftItemID
        public static PRISMARINE_SHARD: cn.nukkit.item.MinecraftItemID
        public static HOPPER: cn.nukkit.item.MinecraftItemID
        public static RABBIT: cn.nukkit.item.MinecraftItemID
        public static COOKED_RABBIT: cn.nukkit.item.MinecraftItemID
        public static RABBIT_STEW: cn.nukkit.item.MinecraftItemID
        public static RABBIT_FOOT: cn.nukkit.item.MinecraftItemID
        public static RABBIT_HIDE: cn.nukkit.item.MinecraftItemID
        public static LEATHER_HORSE_ARMOR: cn.nukkit.item.MinecraftItemID
        public static IRON_HORSE_ARMOR: cn.nukkit.item.MinecraftItemID
        public static GOLDEN_HORSE_ARMOR: cn.nukkit.item.MinecraftItemID
        public static DIAMOND_HORSE_ARMOR: cn.nukkit.item.MinecraftItemID
        public static LEAD: cn.nukkit.item.MinecraftItemID
        public static NAME_TAG: cn.nukkit.item.MinecraftItemID
        public static PRISMARINE_CRYSTALS: cn.nukkit.item.MinecraftItemID
        public static MUTTON: cn.nukkit.item.MinecraftItemID
        public static COOKED_MUTTON: cn.nukkit.item.MinecraftItemID
        public static ARMOR_STAND: cn.nukkit.item.MinecraftItemID
        public static END_CRYSTAL: cn.nukkit.item.MinecraftItemID
        public static SPRUCE_DOOR: cn.nukkit.item.MinecraftItemID
        public static BIRCH_DOOR: cn.nukkit.item.MinecraftItemID
        public static JUNGLE_DOOR: cn.nukkit.item.MinecraftItemID
        public static ACACIA_DOOR: cn.nukkit.item.MinecraftItemID
        public static DARK_OAK_DOOR: cn.nukkit.item.MinecraftItemID
        public static CHORUS_FRUIT: cn.nukkit.item.MinecraftItemID
        public static POPPED_CHORUS_FRUIT: cn.nukkit.item.MinecraftItemID
        public static BANNER_PATTERN: cn.nukkit.item.MinecraftItemID
        public static DRAGON_BREATH: cn.nukkit.item.MinecraftItemID
        public static SPLASH_POTION: cn.nukkit.item.MinecraftItemID
        public static LINGERING_POTION: cn.nukkit.item.MinecraftItemID
        public static SPARKLER: cn.nukkit.item.MinecraftItemID
        public static COMMAND_BLOCK_MINECART: cn.nukkit.item.MinecraftItemID
        public static ELYTRA: cn.nukkit.item.MinecraftItemID
        public static SHULKER_SHELL: cn.nukkit.item.MinecraftItemID
        public static BANNER: cn.nukkit.item.MinecraftItemID
        public static MEDICINE: cn.nukkit.item.MinecraftItemID
        public static BALLOON: cn.nukkit.item.MinecraftItemID
        public static RAPID_FERTILIZER: cn.nukkit.item.MinecraftItemID
        public static TOTEM_OF_UNDYING: cn.nukkit.item.MinecraftItemID
        public static BLEACH: cn.nukkit.item.MinecraftItemID
        public static IRON_NUGGET: cn.nukkit.item.MinecraftItemID
        public static ICE_BOMB: cn.nukkit.item.MinecraftItemID
        public static TRIDENT: cn.nukkit.item.MinecraftItemID
        public static BEETROOT: cn.nukkit.item.MinecraftItemID
        public static BEETROOT_SEEDS: cn.nukkit.item.MinecraftItemID
        public static BEETROOT_SOUP: cn.nukkit.item.MinecraftItemID
        public static SALMON: cn.nukkit.item.MinecraftItemID
        public static TROPICAL_FISH: cn.nukkit.item.MinecraftItemID
        public static PUFFERFISH: cn.nukkit.item.MinecraftItemID
        public static COOKED_SALMON: cn.nukkit.item.MinecraftItemID
        public static DRIED_KELP: cn.nukkit.item.MinecraftItemID
        public static NAUTILUS_SHELL: cn.nukkit.item.MinecraftItemID
        public static ENCHANTED_GOLDEN_APPLE: cn.nukkit.item.MinecraftItemID
        public static HEART_OF_THE_SEA: cn.nukkit.item.MinecraftItemID
        public static SCUTE: cn.nukkit.item.MinecraftItemID
        public static TURTLE_HELMET: cn.nukkit.item.MinecraftItemID
        public static PHANTOM_MEMBRANE: cn.nukkit.item.MinecraftItemID
        public static CROSSBOW: cn.nukkit.item.MinecraftItemID
        public static SPRUCE_SIGN: cn.nukkit.item.MinecraftItemID
        public static BIRCH_SIGN: cn.nukkit.item.MinecraftItemID
        public static JUNGLE_SIGN: cn.nukkit.item.MinecraftItemID
        public static ACACIA_SIGN: cn.nukkit.item.MinecraftItemID
        public static DARK_OAK_SIGN: cn.nukkit.item.MinecraftItemID
        public static SWEET_BERRIES: cn.nukkit.item.MinecraftItemID
        public static CAMERA: cn.nukkit.item.MinecraftItemID
        public static COMPOUND: cn.nukkit.item.MinecraftItemID
        public static MUSIC_DISC_13: cn.nukkit.item.MinecraftItemID
        public static MUSIC_DISC_CAT: cn.nukkit.item.MinecraftItemID
        public static MUSIC_DISC_BLOCKS: cn.nukkit.item.MinecraftItemID
        public static MUSIC_DISC_CHIRP: cn.nukkit.item.MinecraftItemID
        public static MUSIC_DISC_FAR: cn.nukkit.item.MinecraftItemID
        public static MUSIC_DISC_MALL: cn.nukkit.item.MinecraftItemID
        public static MUSIC_DISC_MELLOHI: cn.nukkit.item.MinecraftItemID
        public static MUSIC_DISC_STAL: cn.nukkit.item.MinecraftItemID
        public static MUSIC_DISC_STRAD: cn.nukkit.item.MinecraftItemID
        public static MUSIC_DISC_WARD: cn.nukkit.item.MinecraftItemID
        public static MUSIC_DISC_11: cn.nukkit.item.MinecraftItemID
        public static MUSIC_DISC_WAIT: cn.nukkit.item.MinecraftItemID
        public static SHIELD: cn.nukkit.item.MinecraftItemID
        public static CAMPFIRE: cn.nukkit.item.MinecraftItemID
        public static SUSPICIOUS_STEW: cn.nukkit.item.MinecraftItemID
        public static HONEYCOMB: cn.nukkit.item.MinecraftItemID
        public static HONEY_BOTTLE: cn.nukkit.item.MinecraftItemID
        public static LODESTONE_COMPASS: cn.nukkit.item.MinecraftItemID
        public static NETHERITE_INGOT: cn.nukkit.item.MinecraftItemID
        public static NETHERITE_SWORD: cn.nukkit.item.MinecraftItemID
        public static NETHERITE_SHOVEL: cn.nukkit.item.MinecraftItemID
        public static NETHERITE_PICKAXE: cn.nukkit.item.MinecraftItemID
        public static NETHERITE_AXE: cn.nukkit.item.MinecraftItemID
        public static NETHERITE_HOE: cn.nukkit.item.MinecraftItemID
        public static NETHERITE_HELMET: cn.nukkit.item.MinecraftItemID
        public static NETHERITE_CHESTPLATE: cn.nukkit.item.MinecraftItemID
        public static NETHERITE_LEGGINGS: cn.nukkit.item.MinecraftItemID
        public static NETHERITE_BOOTS: cn.nukkit.item.MinecraftItemID
        public static NETHERITE_SCRAP: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_SIGN: cn.nukkit.item.MinecraftItemID
        public static WARPED_SIGN: cn.nukkit.item.MinecraftItemID
        public static CRIMSON_DOOR: cn.nukkit.item.MinecraftItemID
        public static WARPED_DOOR: cn.nukkit.item.MinecraftItemID
        public static WARPED_FUNGUS_ON_A_STICK: cn.nukkit.item.MinecraftItemID
        public static CHAIN: cn.nukkit.item.MinecraftItemID
        public static MUSIC_DISC_PIGSTEP: cn.nukkit.item.MinecraftItemID
        public static NETHER_SPROUTS: cn.nukkit.item.MinecraftItemID
        public static SOUL_CAMPFIRE: cn.nukkit.item.MinecraftItemID
        public static COD_BUCKET: cn.nukkit.item.MinecraftItemID
        public static GHAST_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static FLOWER_BANNER_PATTERN: cn.nukkit.item.MinecraftItemID
        public static ZOGLIN_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static BLUE_DYE: cn.nukkit.item.MinecraftItemID
        public static SKULL_BANNER_PATTERN: cn.nukkit.item.MinecraftItemID
        public static ENDERMITE_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static POLAR_BEAR_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static WHITE_DYE: cn.nukkit.item.MinecraftItemID
        public static TROPICAL_FISH_BUCKET: cn.nukkit.item.MinecraftItemID
        public static CYAN_DYE: cn.nukkit.item.MinecraftItemID
        public static LIGHT_BLUE_DYE: cn.nukkit.item.MinecraftItemID
        public static LIME_DYE: cn.nukkit.item.MinecraftItemID
        public static ZOMBIE_VILLAGER_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static STRAY_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static GREEN_DYE: cn.nukkit.item.MinecraftItemID
        public static EVOKER_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static WITHER_SKELETON_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static SALMON_BUCKET: cn.nukkit.item.MinecraftItemID
        public static JUNGLE_BOAT: cn.nukkit.item.MinecraftItemID
        public static BLACK_DYE: cn.nukkit.item.MinecraftItemID
        public static MAGMA_CUBE_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static TROPICAL_FISH_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static VEX_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static FIELD_MASONED_BANNER_PATTERN: cn.nukkit.item.MinecraftItemID
        public static WANDERING_TRADER_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static BROWN_DYE: cn.nukkit.item.MinecraftItemID
        public static PANDA_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static SILVERFISH_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static OCELOT_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static LAVA_BUCKET: cn.nukkit.item.MinecraftItemID
        public static SKELETON_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static VILLAGER_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static ELDER_GUARDIAN_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static ACACIA_BOAT: cn.nukkit.item.MinecraftItemID
        public static OAK_BOAT: cn.nukkit.item.MinecraftItemID
        public static PHANTOM_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static HOGLIN_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static DARK_OAK_BOAT: cn.nukkit.item.MinecraftItemID
        public static HUSK_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static BLAZE_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static BORDURE_INDENTED_BANNER_PATTERN: cn.nukkit.item.MinecraftItemID
        public static MULE_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static CREEPER_BANNER_PATTERN: cn.nukkit.item.MinecraftItemID
        public static ZOMBIE_HORSE_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static BEE_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static COD_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static LLAMA_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static FOX_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static PIGLIN_BRUTE_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static PIG_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static COW_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static NPC_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static SQUID_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static MAGENTA_DYE: cn.nukkit.item.MinecraftItemID
        public static RED_DYE: cn.nukkit.item.MinecraftItemID
        public static WITCH_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static INK_SAC: cn.nukkit.item.MinecraftItemID
        public static ORANGE_DYE: cn.nukkit.item.MinecraftItemID
        public static PILLAGER_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static CAVE_SPIDER_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static BONE_MEAL: cn.nukkit.item.MinecraftItemID
        public static PUFFERFISH_BUCKET: cn.nukkit.item.MinecraftItemID
        public static BAT_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static SPRUCE_BOAT: cn.nukkit.item.MinecraftItemID
        public static SPIDER_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static PIGLIN_BANNER_PATTERN: cn.nukkit.item.MinecraftItemID
        public static RABBIT_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static MOJANG_BANNER_PATTERN: cn.nukkit.item.MinecraftItemID
        public static PIGLIN_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static TURTLE_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static MOOSHROOM_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static PUFFERFISH_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static PARROT_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static ZOMBIE_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static WOLF_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static GRAY_DYE: cn.nukkit.item.MinecraftItemID
        public static COCOA_BEANS: cn.nukkit.item.MinecraftItemID
        public static SKELETON_HORSE_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static SHEEP_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static SLIME_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static VINDICATOR_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static DROWNED_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static MILK_BUCKET: cn.nukkit.item.MinecraftItemID
        public static DOLPHIN_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static DONKEY_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static PURPLE_DYE: cn.nukkit.item.MinecraftItemID
        public static BIRCH_BOAT: cn.nukkit.item.MinecraftItemID
        public static ENDERMAN_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static CHICKEN_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static SHULKER_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static STRIDER_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static ZOMBIE_PIGMAN_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static YELLOW_DYE: cn.nukkit.item.MinecraftItemID
        public static CAT_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static GUARDIAN_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static PINK_DYE: cn.nukkit.item.MinecraftItemID
        public static SALMON_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static CREEPER_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static HORSE_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static LAPIS_LAZULI: cn.nukkit.item.MinecraftItemID
        public static RAVAGER_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static WATER_BUCKET: cn.nukkit.item.MinecraftItemID
        public static LIGHT_GRAY_DYE: cn.nukkit.item.MinecraftItemID
        public static CHARCOAL: cn.nukkit.item.MinecraftItemID
        public static AGENT_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static INFESTED_DEEPSLATE: cn.nukkit.item.MinecraftItemID
        public static RAW_GOLD_BLOCK: cn.nukkit.item.MinecraftItemID
        public static RAW_COPPER_BLOCK: cn.nukkit.item.MinecraftItemID
        public static RAW_IRON_BLOCK: cn.nukkit.item.MinecraftItemID
        public static WAXED_OXIDIZED_DOUBLE_CUT_COPPER_SLAB: cn.nukkit.item.MinecraftItemID
        public static WAXED_OXIDIZED_CUT_COPPER_SLAB: cn.nukkit.item.MinecraftItemID
        public static WAXED_OXIDIZED_CUT_COPPER_STAIRS: cn.nukkit.item.MinecraftItemID
        public static WAXED_OXIDIZED_CUT_COPPER: cn.nukkit.item.MinecraftItemID
        public static WAXED_OXIDIZED_COPPER: cn.nukkit.item.MinecraftItemID
        public static GLOW_LICHEN: cn.nukkit.item.MinecraftItemID
        public static CRACKED_DEEPSLATE_BRICKS: cn.nukkit.item.MinecraftItemID
        public static CRACKED_DEEPSLATE_TILES: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_COPPER_ORE: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_EMERALD_ORE: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_COAL_ORE: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_DIAMOND_ORE: cn.nukkit.item.MinecraftItemID
        public static LIT_DEEPSLATE_REDSTONE_ORE: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_REDSTONE_ORE: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_GOLD_ORE: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_IRON_ORE: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_LAPIS_ORE: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_BRICK_DOUBLE_SLAB: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_TILE_DOUBLE_SLAB: cn.nukkit.item.MinecraftItemID
        public static POLISHED_DEEPSLATE_DOUBLE_SLAB: cn.nukkit.item.MinecraftItemID
        public static COBBLED_DEEPSLATE_DOUBLE_SLAB: cn.nukkit.item.MinecraftItemID
        public static CHISELED_DEEPSLATE: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_BRICK_WALL: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_BRICK_STAIRS: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_BRICK_SLAB: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_BRICKS: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_TILE_WALL: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_TILE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_TILE_SLAB: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE_TILES: cn.nukkit.item.MinecraftItemID
        public static POLISHED_DEEPSLATE_WALL: cn.nukkit.item.MinecraftItemID
        public static POLISHED_DEEPSLATE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static POLISHED_DEEPSLATE_SLAB: cn.nukkit.item.MinecraftItemID
        public static POLISHED_DEEPSLATE: cn.nukkit.item.MinecraftItemID
        public static COBBLED_DEEPSLATE_WALL: cn.nukkit.item.MinecraftItemID
        public static COBBLED_DEEPSLATE_STAIRS: cn.nukkit.item.MinecraftItemID
        public static COBBLED_DEEPSLATE_SLAB: cn.nukkit.item.MinecraftItemID
        public static COBBLED_DEEPSLATE: cn.nukkit.item.MinecraftItemID
        public static DEEPSLATE: cn.nukkit.item.MinecraftItemID
        public static SMOOTH_BASALT: cn.nukkit.item.MinecraftItemID
        public static CAVE_VINES_HEAD_WITH_BERRIES: cn.nukkit.item.MinecraftItemID
        public static CAVE_VINES_BODY_WITH_BERRIES: cn.nukkit.item.MinecraftItemID
        public static WAXED_WEATHERED_DOUBLE_CUT_COPPER_SLAB: cn.nukkit.item.MinecraftItemID
        public static WAXED_EXPOSED_DOUBLE_CUT_COPPER_SLAB: cn.nukkit.item.MinecraftItemID
        public static WAXED_DOUBLE_CUT_COPPER_SLAB: cn.nukkit.item.MinecraftItemID
        public static OXIDIZED_DOUBLE_CUT_COPPER_SLAB: cn.nukkit.item.MinecraftItemID
        public static WEATHERED_DOUBLE_CUT_COPPER_SLAB: cn.nukkit.item.MinecraftItemID
        public static EXPOSED_DOUBLE_CUT_COPPER_SLAB: cn.nukkit.item.MinecraftItemID
        public static DOUBLE_CUT_COPPER_SLAB: cn.nukkit.item.MinecraftItemID
        public static WAXED_WEATHERED_CUT_COPPER_SLAB: cn.nukkit.item.MinecraftItemID
        public static WAXED_EXPOSED_CUT_COPPER_SLAB: cn.nukkit.item.MinecraftItemID
        public static WAXED_CUT_COPPER_SLAB: cn.nukkit.item.MinecraftItemID
        public static OXIDIZED_CUT_COPPER_SLAB: cn.nukkit.item.MinecraftItemID
        public static WEATHERED_CUT_COPPER_SLAB: cn.nukkit.item.MinecraftItemID
        public static EXPOSED_CUT_COPPER_SLAB: cn.nukkit.item.MinecraftItemID
        public static CUT_COPPER_SLAB: cn.nukkit.item.MinecraftItemID
        public static WAXED_WEATHERED_CUT_COPPER_STAIRS: cn.nukkit.item.MinecraftItemID
        public static WAXED_EXPOSED_CUT_COPPER_STAIRS: cn.nukkit.item.MinecraftItemID
        public static WAXED_CUT_COPPER_STAIRS: cn.nukkit.item.MinecraftItemID
        public static OXIDIZED_CUT_COPPER_STAIRS: cn.nukkit.item.MinecraftItemID
        public static WEATHERED_CUT_COPPER_STAIRS: cn.nukkit.item.MinecraftItemID
        public static EXPOSED_CUT_COPPER_STAIRS: cn.nukkit.item.MinecraftItemID
        public static CUT_COPPER_STAIRS: cn.nukkit.item.MinecraftItemID
        public static WAXED_WEATHERED_CUT_COPPER: cn.nukkit.item.MinecraftItemID
        public static WAXED_EXPOSED_CUT_COPPER: cn.nukkit.item.MinecraftItemID
        public static WAXED_CUT_COPPER: cn.nukkit.item.MinecraftItemID
        public static OXIDIZED_CUT_COPPER: cn.nukkit.item.MinecraftItemID
        public static WEATHERED_CUT_COPPER: cn.nukkit.item.MinecraftItemID
        public static EXPOSED_CUT_COPPER: cn.nukkit.item.MinecraftItemID
        public static CUT_COPPER: cn.nukkit.item.MinecraftItemID
        public static WAXED_WEATHERED_COPPER: cn.nukkit.item.MinecraftItemID
        public static WAXED_EXPOSED_COPPER: cn.nukkit.item.MinecraftItemID
        public static WAXED_COPPER: cn.nukkit.item.MinecraftItemID
        public static OXIDIZED_COPPER: cn.nukkit.item.MinecraftItemID
        public static WEATHERED_COPPER: cn.nukkit.item.MinecraftItemID
        public static EXPOSED_COPPER: cn.nukkit.item.MinecraftItemID
        public static COPPER_BLOCK: cn.nukkit.item.MinecraftItemID
        public static GLOW_FRAME_BLOCK_FORM: cn.nukkit.item.MinecraftItemID
        public static FLOWERING_AZALEA: cn.nukkit.item.MinecraftItemID
        public static AZALEA: cn.nukkit.item.MinecraftItemID
        public static SMALL_DRIPLEAF_BLOCK: cn.nukkit.item.MinecraftItemID
        public static MOSS_CARPET: cn.nukkit.item.MinecraftItemID
        public static TINTED_GLASS: cn.nukkit.item.MinecraftItemID
        public static TUFF: cn.nukkit.item.MinecraftItemID
        public static SMALL_AMETHYST_BUD: cn.nukkit.item.MinecraftItemID
        public static MEDIUM_AMETHYST_BUD: cn.nukkit.item.MinecraftItemID
        public static LARGE_AMETHYST_BUD: cn.nukkit.item.MinecraftItemID
        public static AMETHYST_CLUSTER: cn.nukkit.item.MinecraftItemID
        public static BUDDING_AMETHYST: cn.nukkit.item.MinecraftItemID
        public static AMETHYST_BLOCK: cn.nukkit.item.MinecraftItemID
        public static CALCITE: cn.nukkit.item.MinecraftItemID
        public static AZALEA_LEAVES_FLOWERED: cn.nukkit.item.MinecraftItemID
        public static AZALEA_LEAVES: cn.nukkit.item.MinecraftItemID
        public static BIG_DRIPLEAF: cn.nukkit.item.MinecraftItemID
        public static CAVE_VINES: cn.nukkit.item.MinecraftItemID
        public static SPORE_BLOSSOM: cn.nukkit.item.MinecraftItemID
        public static MOSS_BLOCK: cn.nukkit.item.MinecraftItemID
        public static HANGING_ROOTS: cn.nukkit.item.MinecraftItemID
        public static DIRT_WITH_ROOTS: cn.nukkit.item.MinecraftItemID
        public static DRIPSTONE_BLOCK: cn.nukkit.item.MinecraftItemID
        public static LIGHTNING_ROD: cn.nukkit.item.MinecraftItemID
        public static COPPER_ORE: cn.nukkit.item.MinecraftItemID
        public static POINTED_DRIPSTONE: cn.nukkit.item.MinecraftItemID
        public static SCULK_SENSOR: cn.nukkit.item.MinecraftItemID
        public static POWDER_SNOW: cn.nukkit.item.MinecraftItemID
        public static POWDER_SNOW_BUCKET: cn.nukkit.item.MinecraftItemID
        public static AXOLOTL_BUCKET: cn.nukkit.item.MinecraftItemID
        public static AXOLOTL_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static GOAT_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static GLOW_SQUID_SPAWN_EGG: cn.nukkit.item.MinecraftItemID
        public static GLOW_INK_SAC: cn.nukkit.item.MinecraftItemID
        public static COPPER_INGOT: cn.nukkit.item.MinecraftItemID
        public static RAW_IRON: cn.nukkit.item.MinecraftItemID
        public static RAW_GOLD: cn.nukkit.item.MinecraftItemID
        public static RAW_COPPER: cn.nukkit.item.MinecraftItemID
        public static GLOW_FRAME: cn.nukkit.item.MinecraftItemID
        public static GOAT_HORN: cn.nukkit.item.MinecraftItemID
        public static AMETHYST_SHARD: cn.nukkit.item.MinecraftItemID
        public static SPYGLASS: cn.nukkit.item.MinecraftItemID
        public static GLOW_BERRIES: cn.nukkit.item.MinecraftItemID
        public static MANGROVE_BOAT: cn.nukkit.item.MinecraftItemID
        public static MANGROVE_DOOR: cn.nukkit.item.MinecraftItemID
        public static MANGROVE_SIGN: cn.nukkit.item.MinecraftItemID
        static namespacedIdMap: java.util.Map<string, cn.nukkit.item.MinecraftItemID>
        namespacedId: string
        itemFormNamespaceId: string
        technical: boolean
        edu: boolean
        aliases: string[]
        static $VALUES: cn.nukkit.item.MinecraftItemID[]

    }
}

declare module "cn.nukkit.item.MinecraftItemID" {
    declare const MinecraftItemID = cn.nukkit.item.MinecraftItemID;
}

declare namespace cn.nukkit {
    declare class Server extends java.lang.Object {
        constructor(tempDir: java.io.File): void
        constructor(filePath: string, dataPath: string, pluginPath: string, predefinedLanguage: string): void
        public broadcastMessage(message: string): int
        public broadcastMessage(message: cn.nukkit.lang.TextContainer): int
        public broadcastMessage(message: string, recipients: cn.nukkit.command.CommandSender[]): int
        public broadcastMessage(message: string, recipients: java.util.Collection<cn.nukkit.command.CommandSender>): int
        public broadcastMessage(message: cn.nukkit.lang.TextContainer, recipients: java.util.Collection<cn.nukkit.command.CommandSender>): int
        public broadcast(message: string, permissions: string): int
        public broadcast(message: cn.nukkit.lang.TextContainer, permissions: string): int
        public static broadcastPacket(players: java.util.Collection<cn.nukkit.Player>, packet: cn.nukkit.network.protocol.DataPacket): void
        public static broadcastPacket(players: cn.nukkit.Player[], packet: cn.nukkit.network.protocol.DataPacket): void
        public batchPackets(players: cn.nukkit.Player[], packets: cn.nukkit.network.protocol.DataPacket[]): void
        public batchPackets(players: cn.nukkit.Player[], packets: cn.nukkit.network.protocol.DataPacket[], forceSync: boolean): void
        public broadcastPacketsCallback(data: byte[], targets: java.util.List<java.net.InetSocketAddress>): void
        public enablePlugins(type: cn.nukkit.plugin.PluginLoadOrder): void
        public enablePlugin(plugin: cn.nukkit.plugin.Plugin): void
        public disablePlugins(): void
        public dispatchCommand(sender: cn.nukkit.command.CommandSender, commandLine: string): boolean
        public getConsoleSender(): cn.nukkit.command.ConsoleCommandSender
        public reload(): void
        public shutdown(): void
        public forceShutdown(): void
        public start(): void
        public handlePacket(address: java.net.InetSocketAddress, payload: io.netty.buffer.ByteBuf): void
        public tickProcessor(): void
        public onPlayerCompleteLoginSequence(player: cn.nukkit.Player): void
        public onPlayerLogin(player: cn.nukkit.Player): void
        public addPlayer(socketAddress: java.net.InetSocketAddress, player: cn.nukkit.Player): void
        public addOnlinePlayer(player: cn.nukkit.Player): void
        public removeOnlinePlayer(player: cn.nukkit.Player): void
        public updatePlayerListData(uuid: java.util.UUID, entityId: long, var2: string, name: cn.nukkit.entity.data.Skin): void
        public updatePlayerListData(uuid: java.util.UUID, entityId: long, var2: string, name: cn.nukkit.entity.data.Skin, skin: string): void
        public updatePlayerListData(uuid: java.util.UUID, entityId: long, var2: string, name: cn.nukkit.entity.data.Skin, skin: cn.nukkit.Player[]): void
        public updatePlayerListData(uuid: java.util.UUID, entityId: long, var2: string, name: cn.nukkit.entity.data.Skin, skin: string, xboxUserId: cn.nukkit.Player[]): void
        public updatePlayerListData(uuid: java.util.UUID, entityId: long, var2: string, name: cn.nukkit.entity.data.Skin, skin: string, xboxUserId: java.util.Collection<cn.nukkit.Player>): void
        public removePlayerListData(uuid: java.util.UUID): void
        public removePlayerListData(uuid: java.util.UUID, players: cn.nukkit.Player[]): void
        public removePlayerListData(uuid: java.util.UUID, player: cn.nukkit.Player): void
        public removePlayerListData(uuid: java.util.UUID, players: java.util.Collection<cn.nukkit.Player>): void
        public sendFullPlayerListData(player: cn.nukkit.Player): void
        public sendRecipeList(player: cn.nukkit.Player): void
        checkTickUpdates(currentTick: int, tickTime: long): void
        public doAutoSave(): void
        tick(): boolean
        public getNextTick(): long
        public titleTick(): void
        public getQueryInformation(): cn.nukkit.event.server.QueryRegenerateEvent
        public getName(): string
        public isRunning(): boolean
        public getNukkitVersion(): string
        public getGitCommit(): string
        public getCodename(): string
        public getVersion(): string
        public getApiVersion(): string
        public getFilePath(): string
        public getDataPath(): string
        public getPluginPath(): string
        public getMaxPlayers(): int
        public setMaxPlayers(maxPlayers: int): void
        public getPort(): int
        public getViewDistance(): int
        public getIp(): string
        public getServerUniqueId(): java.util.UUID
        public getAutoSave(): boolean
        public setAutoSave(autoSave: boolean): void
        public getLevelType(): string
        public getGenerateStructures(): boolean
        public getGamemode(): int
        public getForceGamemode(): boolean
        public static getGamemodeString(mode: int): string
        public static getGamemodeString(mode: int, direct: boolean): string
        public static getGamemodeFromString(str: string): int
        public static getDifficultyFromString(str: string): int
        public getDifficulty(): int
        public setDifficulty(difficulty: int): void
        public hasWhitelist(): boolean
        public getSpawnRadius(): int
        public getAllowFlight(): boolean
        public isHardcore(): boolean
        public getDefaultGamemode(): int
        public getMotd(): string
        public getSubMotd(): string
        public getForceResources(): boolean
        public getLogger(): cn.nukkit.utils.MainLogger
        public getEntityMetadata(): cn.nukkit.metadata.EntityMetadataStore
        public getPlayerMetadata(): cn.nukkit.metadata.PlayerMetadataStore
        public getLevelMetadata(): cn.nukkit.metadata.LevelMetadataStore
        public getPluginManager(): cn.nukkit.plugin.PluginManager
        public getCraftingManager(): cn.nukkit.inventory.CraftingManager
        public getResourcePackManager(): cn.nukkit.resourcepacks.ResourcePackManager
        public getScoreboardManager(): cn.nukkit.scoreboard.ScoreboardManager
        public getFunctionManager(): cn.nukkit.command.function.FunctionManager
        public getScheduler(): cn.nukkit.scheduler.ServerScheduler
        public getTick(): int
        public getTicksPerSecond(): float
        public getTicksPerSecondAverage(): float
        public getTickUsage(): float
        public getTickUsageAverage(): float
        public getCommandMap(): cn.nukkit.command.SimpleCommandMap
        public getOnlinePlayers(): java.util.Map<java.util.UUID, cn.nukkit.Player>
        public addRecipe(recipe: cn.nukkit.inventory.Recipe): void
        public getPlayer(uuid: java.util.UUID): java.util.Optional<cn.nukkit.Player>
        public lookupName(name: string): java.util.Optional<java.util.UUID>
        updateName(uuid: java.util.UUID, name: string): void
        public getOfflinePlayer(name: string): cn.nukkit.IPlayer
        public getOfflinePlayer(uuid: java.util.UUID): cn.nukkit.IPlayer
        public getOfflinePlayerData(uuid: java.util.UUID): cn.nukkit.nbt.tag.CompoundTag
        public getOfflinePlayerData(uuid: java.util.UUID, create: boolean): cn.nukkit.nbt.tag.CompoundTag
        public getOfflinePlayerData(name: string): cn.nukkit.nbt.tag.CompoundTag
        public getOfflinePlayerData(name: string, create: boolean): cn.nukkit.nbt.tag.CompoundTag
        getOfflinePlayerDataInternal(name: string, runEvent: boolean, create: boolean): cn.nukkit.nbt.tag.CompoundTag
        public saveOfflinePlayerData(uuid: java.util.UUID, tag: cn.nukkit.nbt.tag.CompoundTag): void
        public saveOfflinePlayerData(name: string, tag: cn.nukkit.nbt.tag.CompoundTag): void
        public saveOfflinePlayerData(uuid: java.util.UUID, tag: cn.nukkit.nbt.tag.CompoundTag, async: boolean): void
        public saveOfflinePlayerData(name: string, tag: cn.nukkit.nbt.tag.CompoundTag, async: boolean): void
        saveOfflinePlayerData(name: string, tag: cn.nukkit.nbt.tag.CompoundTag, async: boolean, runEvent: boolean): void
        saveOfflinePlayerDataInternal(serializer: cn.nukkit.utils.PlayerDataSerializer, tag: cn.nukkit.nbt.tag.CompoundTag, name: string, uuid: java.util.UUID): void
        convertLegacyPlayerData(): void
        public getPlayer(name: string): cn.nukkit.Player
        public getPlayerExact(name: string): cn.nukkit.Player
        public matchPlayer(partialName: string): cn.nukkit.Player[]
        public removePlayer(player: cn.nukkit.Player): void
        public getLevels(): java.util.Map<int, cn.nukkit.level.Level>
        public getDefaultLevel(): cn.nukkit.level.Level
        public setDefaultLevel(defaultLevel: cn.nukkit.level.Level): void
        public isLevelLoaded(name: string): boolean
        public getLevel(levelId: int): cn.nukkit.level.Level
        public getLevelByName(name: string): cn.nukkit.level.Level
        public unloadLevel(level: cn.nukkit.level.Level): boolean
        public unloadLevel(level: cn.nukkit.level.Level, forceUnload: boolean): boolean
        public loadLevel(name: string): boolean
        public generateLevel(name: string): boolean
        public generateLevel(name: string, seed: long): boolean
        public generateLevel(name: string, seed: long, var2: java.lang.Class<cn.nukkit.level.generator.Generator>): boolean
        public generateLevel(name: string, seed: long, var2: java.lang.Class<cn.nukkit.level.generator.Generator>, generator: java.util.Map<string, java.lang.Object>): boolean
        public generateLevel(name: string, seed: long, var2: java.lang.Class<cn.nukkit.level.generator.Generator>, generator: java.util.Map<string, java.lang.Object>, options: java.lang.Class<cn.nukkit.level.format.LevelProvider>): boolean
        public isLevelGenerated(name: string): boolean
        public getLanguage(): cn.nukkit.lang.BaseLang
        public isLanguageForced(): boolean
        public isRedstoneEnabled(): boolean
        public setRedstoneEnabled(redstoneEnabled: boolean): void
        public getNetwork(): cn.nukkit.network.Network
        public getConfig(): cn.nukkit.utils.Config
        public getConfig(variable: java.lang.Object): string
        public getConfig(variable: java.lang.Object): string
        public getProperties(): cn.nukkit.utils.Config
        public getProperty(variable: string): java.lang.Object
        public getProperty(variable: string, defaultValue: java.lang.Object): java.lang.Object
        public setPropertyString(variable: string, value: string): void
        public getPropertyString(variable: string): string
        public getPropertyString(variable: string, defaultValue: string): string
        public getPropertyInt(variable: string): int
        public getPropertyInt(variable: string, defaultValue: int): int
        public setPropertyInt(variable: string, value: int): void
        public getPropertyBoolean(variable: string): boolean
        public getPropertyBoolean(variable: string, defaultValue: java.lang.Object): boolean
        public setPropertyBoolean(variable: string, value: boolean): void
        public getPluginCommand(name: string): cn.nukkit.command.PluginIdentifiableCommand
        public getNameBans(): cn.nukkit.permission.BanList
        public getIPBans(): cn.nukkit.permission.BanList
        public addOp(name: string): void
        public removeOp(name: string): void
        public addWhitelist(name: string): void
        public removeWhitelist(name: string): void
        public isWhitelisted(name: string): boolean
        public isOp(name: string): boolean
        public getWhitelist(): cn.nukkit.utils.Config
        public getOps(): cn.nukkit.utils.Config
        public reloadWhitelist(): void
        public getServiceManager(): cn.nukkit.plugin.service.ServiceManager
        public getCommandAliases(): java.util.Map<string, java.util.List<string>>
        public shouldSavePlayerData(): boolean
        public getPlayerSkinChangeCooldown(): int
        public isPrimaryThread(): boolean
        public getPrimaryThread(): java.lang.Thread
        registerEntities(): void
        registerBlockEntities(): void
        public isNetherAllowed(): boolean
        public getPlayerDataSerializer(): cn.nukkit.utils.PlayerDataSerializer
        public setPlayerDataSerializer(playerDataSerializer: cn.nukkit.utils.PlayerDataSerializer): void
        public isIgnoredPacket(clazz: java.lang.Class<cn.nukkit.network.protocol.DataPacket>): boolean
        public isSafeSpawn(): boolean
        public static getInstance(): cn.nukkit.Server
        public getPositionTrackingService(): cn.nukkit.positiontracking.PositionTrackingService
        public isForceSkinTrusted(): boolean
        public isCheckMovement(): boolean
        public getLaunchTime(): long
        public isTheEndAllowed(): boolean
        public isEnableCustomItem(): boolean
        static lambda$convertLegacyPlayerData$6(uuidPattern: java.util.regex.Pattern, file: java.io.File): boolean
        lambda$getOfflinePlayer$5(uuid: java.util.UUID): cn.nukkit.OfflinePlayer
        static lambda$sendFullPlayerListData$4(x$0: int): cn.nukkit.network.protocol.PlayerListPacket$Entry[]
        static lambda$sendFullPlayerListData$3(p: cn.nukkit.Player): cn.nukkit.network.protocol.PlayerListPacket$Entry
        lambda$dispatchCommand$2(sender: cn.nukkit.command.CommandSender, commandLine: string): void
        static lambda$new$1(line: string): string
        static lambda$new$0(line: string): boolean
        static log: org.apache.logging.log4j.Logger
        public static BROADCAST_CHANNEL_ADMINISTRATIVE: string
        public static BROADCAST_CHANNEL_USERS: string
        static instance: cn.nukkit.Server
        banByName: cn.nukkit.permission.BanList
        banByIP: cn.nukkit.permission.BanList
        operators: cn.nukkit.utils.Config
        whitelist: cn.nukkit.utils.Config
        isRunning: java.util.concurrent.atomic.AtomicBoolean
        hasStopped: boolean
        pluginManager: cn.nukkit.plugin.PluginManager
        profilingTickrate: int
        scheduler: cn.nukkit.scheduler.ServerScheduler
        tickCounter: int
        nextTick: long
        tickAverage: float[]
        useAverage: float[]
        maxTick: float
        maxUse: float
        sendUsageTicker: int
        dispatchSignals: boolean
        console: cn.nukkit.console.NukkitConsole
        consoleThread: cn.nukkit.Server$ConsoleThread
        public computeThreadPool: java.util.concurrent.ForkJoinPool
        commandMap: cn.nukkit.command.SimpleCommandMap
        craftingManager: cn.nukkit.inventory.CraftingManager
        resourcePackManager: cn.nukkit.resourcepacks.ResourcePackManager
        consoleSender: cn.nukkit.command.ConsoleCommandSender
        scoreboardManager: cn.nukkit.scoreboard.ScoreboardManager
        functionManager: cn.nukkit.command.function.FunctionManager
        maxPlayers: int
        autoSave: boolean
        redstoneEnabled: boolean
        public checkLoginTime: boolean
        rcon: cn.nukkit.network.rcon.RCON
        entityMetadata: cn.nukkit.metadata.EntityMetadataStore
        playerMetadata: cn.nukkit.metadata.PlayerMetadataStore
        levelMetadata: cn.nukkit.metadata.LevelMetadataStore
        network: cn.nukkit.network.Network
        networkCompressionAsync: boolean
        public networkCompressionLevel: int
        networkZlibProvider: int
        autoTickRate: boolean
        autoTickRateLimit: int
        alwaysTickPlayers: boolean
        baseTickRate: int
        getAllowFlight: boolean
        difficulty: int
        defaultGamemode: int
        autoSaveTicker: int
        autoSaveTicks: int
        baseLang: cn.nukkit.lang.BaseLang
        forceLanguage: boolean
        serverID: java.util.UUID
        filePath: string
        dataPath: string
        pluginPath: string
        commandDataPath: string
        uniquePlayers: java.util.Set<java.util.UUID>
        queryHandler: cn.nukkit.network.query.QueryHandler
        queryRegenerateEvent: cn.nukkit.event.server.QueryRegenerateEvent
        properties: cn.nukkit.utils.Config
        config: cn.nukkit.utils.Config
        players: java.util.Map<java.net.InetSocketAddress, cn.nukkit.Player>
        playerList: java.util.Map<java.util.UUID, cn.nukkit.Player>
        positionTrackingService: cn.nukkit.positiontracking.PositionTrackingService
        levels: java.util.Map<int, cn.nukkit.level.Level>
        levelArray: cn.nukkit.level.Level[]
        serviceManager: cn.nukkit.plugin.service.ServiceManager
        defaultLevel: cn.nukkit.level.Level
        allowNether: boolean
        currentThread: java.lang.Thread
        launchTime: long
        watchdog: cn.nukkit.utils.Watchdog
        nameLookup: org.iq80.leveldb.DB
        playerDataSerializer: cn.nukkit.utils.PlayerDataSerializer
        ignoredPackets: java.util.Set<string>
        safeSpawn: boolean
        forceSkinTrusted: boolean
        checkMovement: boolean
        allowTheEnd: boolean
        useTerra: boolean
        enableCustomItem: boolean
        lastLevelGC: int

    }
}

declare module "cn.nukkit.Server" {
    declare const Server = cn.nukkit.Server;
}

declare namespace cn.nukkit.entity {
    declare class Entity extends cn.nukkit.level.Location implements cn.nukkit.metadata.Metadatable {
        public getNetworkId(): int
        public getHeight(): float
        public getCurrentHeight(): float
        public getEyeHeight(): float
        public getWidth(): float
        public getLength(): float
        getStepHeight(): double
        public canCollide(): boolean
        getGravity(): float
        getDrag(): float
        getBaseOffset(): float
        public constructor(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        initEntity(): void
        init(chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag): void
        public hasCustomName(): boolean
        public getNameTag(): string
        public isNameTagVisible(): boolean
        public isNameTagAlwaysVisible(): boolean
        public setNameTag(name: string): void
        public setNameTagVisible(): void
        public setNameTagVisible(value: boolean): void
        public setNameTagAlwaysVisible(): void
        public setNameTagAlwaysVisible(value: boolean): void
        public setScoreTag(score: string): void
        public getScoreTag(): string
        public isSneaking(): boolean
        public setSneaking(): void
        public setSneaking(value: boolean): void
        public isSwimming(): boolean
        public getSwimmingHeight(): float
        public setSwimming(): void
        public setSwimming(value: boolean): void
        public isSprinting(): boolean
        public setSprinting(): void
        public setSprinting(value: boolean): void
        public isGliding(): boolean
        public setGliding(): void
        public setGliding(value: boolean): void
        public isImmobile(): boolean
        public setImmobile(): void
        public setImmobile(value: boolean): void
        public canClimb(): boolean
        public setCanClimb(): void
        public setCanClimb(value: boolean): void
        public canClimbWalls(): boolean
        public setCanClimbWalls(): void
        public setCanClimbWalls(value: boolean): void
        public setScale(scale: float): void
        public getScale(): float
        public getPassengers(): java.util.List<cn.nukkit.entity.Entity>
        public getPassenger(): cn.nukkit.entity.Entity
        public isPassenger(entity: cn.nukkit.entity.Entity): boolean
        public isControlling(entity: cn.nukkit.entity.Entity): boolean
        public hasControllingPassenger(): boolean
        public getRiding(): cn.nukkit.entity.Entity
        public getEffects(): java.util.Map<int, cn.nukkit.potion.Effect>
        public removeAllEffects(): void
        public removeEffect(effectId: int): void
        public getEffect(effectId: int): cn.nukkit.potion.Effect
        public hasEffect(effectId: int): boolean
        public addEffect(effect: cn.nukkit.potion.Effect): void
        public recalculateBoundingBox(): void
        public recalculateBoundingBox(send: boolean): void
        recalculateEffectColor(): void
        public static createEntity(name: string, pos: cn.nukkit.level.Position, args: java.lang.Object[]): cn.nukkit.entity.Entity
        public static createEntity(type: int, pos: cn.nukkit.level.Position, args: java.lang.Object[]): cn.nukkit.entity.Entity
        public static createEntity(name: string, chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, args: java.lang.Object[]): cn.nukkit.entity.Entity
        public static createEntity(type: int, chunk: cn.nukkit.level.format.FullChunk, nbt: cn.nukkit.nbt.tag.CompoundTag, args: java.lang.Object[]): cn.nukkit.entity.Entity
        public static registerEntity(name: string, clazz: java.lang.Class<cn.nukkit.entity.Entity>): boolean
        public static registerEntity(name: string, clazz: java.lang.Class<cn.nukkit.entity.Entity>, force: boolean): boolean
        public static getKnownEntityIds(): it.unimi.dsi.fastutil.ints.IntCollection
        public static getSaveIds(): java.util.List<string>
        public static getSaveId(id: string): java.util.OptionalInt
        public static getSaveId(id: int): string
        public static getDefaultNBT(pos: cn.nukkit.math.Vector3): cn.nukkit.nbt.tag.CompoundTag
        public static getDefaultNBT(pos: cn.nukkit.math.Vector3, motion: cn.nukkit.math.Vector3): cn.nukkit.nbt.tag.CompoundTag
        public static getDefaultNBT(pos: cn.nukkit.math.Vector3, motion: cn.nukkit.math.Vector3, yaw: float, pitch: float): cn.nukkit.nbt.tag.CompoundTag
        public saveNBT(): void
        public getOriginalName(): string
        public getVisibleName(): string
        public getName(): string
        public getSaveId(): string
        public spawnTo(player: cn.nukkit.Player): void
        createAddEntityPacket(): cn.nukkit.network.protocol.DataPacket
        public getViewers(): java.util.Map<int, cn.nukkit.Player>
        public sendPotionEffects(player: cn.nukkit.Player): void
        public sendData(player: cn.nukkit.Player): void
        public sendData(player: cn.nukkit.Player, data: cn.nukkit.entity.data.EntityMetadata): void
        public sendData(players: cn.nukkit.Player[]): void
        public sendData(players: cn.nukkit.Player[], data: cn.nukkit.entity.data.EntityMetadata): void
        public despawnFrom(player: cn.nukkit.Player): void
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        public attack(damage: float): boolean
        public heal(source: cn.nukkit.event.entity.EntityRegainHealthEvent): void
        public heal(amount: float): void
        public getHealth(): float
        public isAlive(): boolean
        public isClosed(): boolean
        public setHealth(health: float): void
        public setLastDamageCause(type: cn.nukkit.event.entity.EntityDamageEvent): void
        public getLastDamageCause(): cn.nukkit.event.entity.EntityDamageEvent
        public getMaxHealth(): int
        public setMaxHealth(maxHealth: int): void
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean
        checkObstruction(x: double, var1: double, y: double): boolean
        public entityBaseTick(): boolean
        public entityBaseTick(tickDiff: int): boolean
        getNearestValidPortal(currentPos: cn.nukkit.level.Position): cn.nukkit.level.Position
        public updateMovement(): void
        public addMovement(x: double, var1: double, y: double, var3: double, z: double, var5: double): void
        public addMotion(motionX: double, var1: double, motionY: double): void
        public getDirectionVector(): cn.nukkit.math.Vector3
        public getDirectionPlane(): cn.nukkit.math.Vector2
        public getHorizontalFacing(): cn.nukkit.math.BlockFace
        public onUpdate(currentTick: int): boolean
        public mountEntity(entity: cn.nukkit.entity.Entity): boolean
        public mountEntity(entity: cn.nukkit.entity.Entity, mode: byte): boolean
        public dismountEntity(entity: cn.nukkit.entity.Entity): boolean
        public dismountEntity(entity: cn.nukkit.entity.Entity, sendLinks: boolean): boolean
        broadcastLinkPacket(rider: cn.nukkit.entity.Entity, type: byte): void
        public updatePassengers(): void
        updatePassengerPosition(passenger: cn.nukkit.entity.Entity): void
        public setSeatPosition(pos: cn.nukkit.math.Vector3f): void
        public getSeatPosition(): cn.nukkit.math.Vector3f
        public getMountedOffset(entity: cn.nukkit.entity.Entity): cn.nukkit.math.Vector3f
        public scheduleUpdate(): void
        public isOnFire(): boolean
        public setOnFire(seconds: int): void
        public getAbsorption(): float
        public setAbsorption(absorption: float): void
        public canBePushed(): boolean
        public getDirection(): cn.nukkit.math.BlockFace
        public extinguish(): void
        public canTriggerWalking(): boolean
        public resetFallDistance(): void
        updateFallState(onGround: boolean): void
        public getBoundingBox(): cn.nukkit.math.AxisAlignedBB
        public fall(fallDistance: float): void
        onPhysicalInteraction(block: cn.nukkit.block.Block, cancelled: boolean): boolean
        public handleLavaMovement(): void
        public moveFlying(strafe: float, forward: float, friction: float): void
        public onCollideWithPlayer(entityPlayer: cn.nukkit.entity.EntityHuman): void
        public applyEntityCollision(entity: cn.nukkit.entity.Entity): void
        public onStruckByLightning(entity: cn.nukkit.entity.Entity): void
        public onPushByPiston(piston: cn.nukkit.blockentity.BlockEntityPistonArm): void
        public onInteract(player: cn.nukkit.Player, item: cn.nukkit.item.Item, clickedPos: cn.nukkit.math.Vector3): boolean
        public onInteract(player: cn.nukkit.Player, item: cn.nukkit.item.Item): boolean
        switchLevel(targetLevel: cn.nukkit.level.Level): boolean
        public getPosition(): cn.nukkit.level.Position
        public getLocation(): cn.nukkit.level.Location
        public isTouchingWater(): boolean
        public isInsideOfWater(): boolean
        public isUnderBlock(): boolean
        hasWaterAt(height: float): boolean
        public isInsideOfSolid(): boolean
        public isInsideOfFire(): boolean
        public collideWithBlock(classType: cn.nukkit.block.Block, var1: java.lang.Class<any>): boolean
        public isInsideOfLava(): boolean
        public isOnLadder(): boolean
        public fastMove(dx: double, var1: double, dy: double): boolean
        public move(dx: double, var1: double, dy: double): boolean
        checkGroundState(movX: double, var1: double, movY: double, var3: double, movZ: double, var5: double): void
        public getBlocksAround(): java.util.List<cn.nukkit.block.Block>
        public getCollisionBlocks(): java.util.List<cn.nukkit.block.Block>
        public canBeMovedByCurrents(): boolean
        checkBlockCollision(): void
        public setPositionAndRotation(pos: cn.nukkit.math.Vector3, yaw: double, var2: double): boolean
        public setPositionAndRotation(pos: cn.nukkit.math.Vector3, yaw: double, var2: double, pitch: double): boolean
        public setRotation(yaw: double, var1: double): void
        public setRotation(yaw: double, var1: double, pitch: double): void
        public doesTriggerPressurePlate(): boolean
        public canPassThrough(): boolean
        checkChunks(): void
        public setPosition(pos: cn.nukkit.math.Vector3): boolean
        public getMotion(): cn.nukkit.math.Vector3
        public setMotion(motion: cn.nukkit.math.Vector3): boolean
        public isOnGround(): boolean
        public kill(): void
        public teleport(pos: cn.nukkit.math.Vector3): boolean
        public teleport(pos: cn.nukkit.math.Vector3, cause: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause): boolean
        public teleport(pos: cn.nukkit.level.Position): boolean
        public teleport(pos: cn.nukkit.level.Position, cause: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause): boolean
        public teleport(location: cn.nukkit.level.Location): boolean
        public teleport(location: cn.nukkit.level.Location, cause: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause): boolean
        public getId(): long
        public getUniqueId(): java.util.UUID
        public respawnToAll(): void
        public spawnToAll(): void
        public despawnFromAll(): void
        public close(): void
        close(despawn: boolean): void
        public setDataProperty(data: cn.nukkit.entity.data.EntityData): boolean
        public setDataProperty(data: cn.nukkit.entity.data.EntityData, send: boolean): boolean
        public getDataProperties(): cn.nukkit.entity.data.EntityMetadata
        public getDataProperty(id: int): cn.nukkit.entity.data.EntityData
        public getDataPropertyInt(id: int): int
        public getDataPropertyShort(id: int): int
        public getDataPropertyByte(id: int): int
        public getDataPropertyBoolean(id: int): boolean
        public getDataPropertyLong(id: int): long
        public getDataPropertyString(id: int): string
        public getDataPropertyFloat(id: int): float
        public getDataPropertyNBT(id: int): cn.nukkit.nbt.tag.CompoundTag
        public getDataPropertyPos(id: int): cn.nukkit.math.Vector3
        public getDataPropertyVector3f(id: int): cn.nukkit.math.Vector3f
        public getDataPropertyType(id: int): int
        public setDataFlag(propertyId: int, id: int): void
        public setDataFlag(propertyId: int, id: int, value: boolean): void
        public getDataFlag(propertyId: int, id: int): boolean
        public setMetadata(metadataKey: string, newMetadataValue: cn.nukkit.metadata.MetadataValue): void
        public getMetadata(metadataKey: string): java.util.List<cn.nukkit.metadata.MetadataValue>
        public hasMetadata(metadataKey: string): boolean
        public removeMetadata(metadataKey: string, owningPlugin: cn.nukkit.plugin.Plugin): void
        public getServer(): cn.nukkit.Server
        public isUndead(): boolean
        public isInEndPortal(): boolean
        public isPreventingSleep(player: cn.nukkit.Player): boolean
        public equals(obj: java.lang.Object): boolean
        public hashCode(): int
        public isSpinAttacking(): boolean
        public setSpinAttacking(): void
        public setSpinAttacking(value: boolean): void
        public isNoClip(): boolean
        public setNoClip(noClip: boolean): void
        public isBoss(): boolean
        public addTag(tag: string): void
        public removeTag(tag: string): void
        public containTag(tag: string): boolean
        public getAllTags(): java.util.List<cn.nukkit.nbt.tag.StringTag>
        public setFreezingEffectStrength(strength: float): void
        public getFreezingEffectStrength(): float
        public setFreezingTicks(ticks: int): void
        public getFreezingTicks(): int
        public addFreezingTicks(increments: int): void
        static lambda$containTag$6(tag: string, t: cn.nukkit.nbt.tag.StringTag): boolean
        static lambda$getNearestValidPortal$5(block: cn.nukkit.block.Block): boolean
        static lambda$getNearestValidPortal$4(by: double, var1: cn.nukkit.block.Block): double
        static lambda$getNearestValidPortal$3(currentPosV2: cn.nukkit.math.Vector2, block: cn.nukkit.block.Block): double
        static lambda$getNearestValidPortal$2(pos: cn.nukkit.math.BlockVector3, state: cn.nukkit.blockstate.BlockState): boolean
        static lambda$entityBaseTick$1(block: cn.nukkit.block.Block): boolean
        static lambda$getSaveId$0(entityClass: java.lang.Class, entry: java.util.Map$Entry): boolean
        static log: org.apache.logging.log4j.Logger
        public static EMPTY_ARRAY: cn.nukkit.entity.Entity[]
        public static NETWORK_ID: int
        public static DATA_TYPE_BYTE: int
        public static DATA_TYPE_SHORT: int
        public static DATA_TYPE_INT: int
        public static DATA_TYPE_FLOAT: int
        public static DATA_TYPE_STRING: int
        public static DATA_TYPE_NBT: int
        public static DATA_TYPE_POS: int
        public static DATA_TYPE_LONG: int
        public static DATA_TYPE_VECTOR3F: int
        public static DATA_FLAGS: int
        public static DATA_HEALTH: int
        public static DATA_VARIANT: int
        public static DATA_COLOR: int
        public static DATA_COLOUR: int
        public static DATA_NAMETAG: int
        public static DATA_OWNER_EID: int
        public static DATA_TARGET_EID: int
        public static DATA_AIR: int
        public static DATA_POTION_COLOR: int
        public static DATA_POTION_AMBIENT: int
        public static DATA_JUMP_DURATION: int
        public static DATA_HURT_TIME: int
        public static DATA_HURT_DIRECTION: int
        public static DATA_PADDLE_TIME_LEFT: int
        public static DATA_PADDLE_TIME_RIGHT: int
        public static DATA_EXPERIENCE_VALUE: int
        public static DATA_DISPLAY_ITEM: int
        public static DATA_DISPLAY_OFFSET: int
        public static DATA_HAS_DISPLAY: int
        public static DATA_SWELL: int
        public static DATA_OLD_SWELL: int
        public static DATA_SWELL_DIR: int
        public static DATA_CHARGE_AMOUNT: int
        public static DATA_ENDERMAN_HELD_RUNTIME_ID: int
        public static DATA_CLIENT_EVENT: int
        public static DATA_ENTITY_AGE: int
        public static DATA_USING_ITEM: int
        public static DATA_PLAYER_FLAGS: int
        public static DATA_PLAYER_INDEX: int
        public static DATA_PLAYER_BED_POSITION: int
        public static DATA_FIREBALL_POWER_X: int
        public static DATA_FIREBALL_POWER_Y: int
        public static DATA_FIREBALL_POWER_Z: int
        public static DATA_AUX_POWER: int
        public static DATA_FISH_X: int
        public static DATA_FISH_Z: int
        public static DATA_FISH_ANGLE: int
        public static DATA_POTION_AUX_VALUE: int
        public static DATA_LEAD_HOLDER_EID: int
        public static DATA_SCALE: int
        public static DATA_HAS_NPC_COMPONENT: int
        public static DATA_NPC_SKIN_DATA: int
        public static DATA_NPC_ACTIONS: int
        public static DATA_MAX_AIR: int
        public static DATA_MARK_VARIANT: int
        public static DATA_CONTAINER_TYPE: int
        public static DATA_CONTAINER_BASE_SIZE: int
        public static DATA_CONTAINER_EXTRA_SLOTS_PER_STRENGTH: int
        public static DATA_BLOCK_TARGET: int
        public static DATA_WITHER_INVULNERABLE_TICKS: int
        public static DATA_WITHER_TARGET_1: int
        public static DATA_WITHER_TARGET_2: int
        public static DATA_WITHER_TARGET_3: int
        public static DATA_AERIAL_ATTACK: int
        public static DATA_BOUNDING_BOX_WIDTH: int
        public static DATA_BOUNDING_BOX_HEIGHT: int
        public static DATA_FUSE_LENGTH: int
        public static DATA_RIDER_SEAT_POSITION: int
        public static DATA_RIDER_ROTATION_LOCKED: int
        public static DATA_RIDER_MAX_ROTATION: int
        public static DATA_RIDER_MIN_ROTATION: int
        public static DATA_RIDER_ROTATION_OFFSET: int
        public static DATA_AREA_EFFECT_CLOUD_RADIUS: int
        public static DATA_AREA_EFFECT_CLOUD_WAITING: int
        public static DATA_AREA_EFFECT_CLOUD_PARTICLE_ID: int
        public static DATA_SHULKER_PEEK_ID: int
        public static DATA_SHULKER_ATTACH_FACE: int
        public static DATA_SHULKER_ATTACHED: int
        public static DATA_SHULKER_ATTACH_POS: int
        public static DATA_TRADING_PLAYER_EID: int
        public static DATA_TRADING_CAREER: int
        public static DATA_HAS_COMMAND_BLOCK: int
        public static DATA_COMMAND_BLOCK_COMMAND: int
        public static DATA_COMMAND_BLOCK_LAST_OUTPUT: int
        public static DATA_COMMAND_BLOCK_TRACK_OUTPUT: int
        public static DATA_CONTROLLING_RIDER_SEAT_NUMBER: int
        public static DATA_STRENGTH: int
        public static DATA_MAX_STRENGTH: int
        public static DATA_SPELL_CASTING_COLOR: int
        public static DATA_LIMITED_LIFE: int
        public static DATA_ARMOR_STAND_POSE_INDEX: int
        public static DATA_ENDER_CRYSTAL_TIME_OFFSET: int
        public static DATA_ALWAYS_SHOW_NAMETAG: int
        public static DATA_COLOR_2: int
        public static DATA_NAME_AUTHOR: int
        public static DATA_SCORE_TAG: int
        public static DATA_BALLOON_ATTACHED_ENTITY: int
        public static DATA_PUFFERFISH_SIZE: int
        public static DATA_BUBBLE_TIME: int
        public static DATA_AGENT: int
        public static DATA_SITTING_AMOUNT: int
        public static DATA_SITTING_AMOUNT_PREVIOUS: int
        public static DATA_EATING_COUNTER: int
        public static DATA_FLAGS_EXTENDED: int
        public static DATA_LAYING_AMOUNT: int
        public static DATA_LAYING_AMOUNT_PREVIOUS: int
        public static DATA_DURATION: int
        public static DATA_SPAWN_TIME: int
        public static DATA_CHANGE_RATE: int
        public static DATA_CHANGE_ON_PICKUP: int
        public static DATA_PICKUP_COUNT: int
        public static DATA_INTERACTIVE_TAG: int
        public static DATA_INTERACT_TEXT: int
        public static DATA_TRADE_TIER: int
        public static DATA_MAX_TRADE_TIER: int
        public static DATA_TRADE_EXPERIENCE: int
        public static DATA_SKIN_ID: int
        public static DATA_SPAWNING_FRAMES: int
        public static DATA_COMMAND_BLOCK_TICK_DELAY: int
        public static DATA_COMMAND_BLOCK_EXECUTE_ON_FIRST_TICK: int
        public static DATA_AMBIENT_SOUND_INTERVAL: int
        public static DATA_AMBIENT_SOUND_INTERVAL_RANGE: int
        public static DATA_AMBIENT_SOUND_EVENT_NAME: int
        public static DATA_FALL_DAMAGE_MULTIPLIER: int
        public static DATA_NAME_RAW_TEXT: int
        public static DATA_CAN_RIDE_TARGET: int
        public static DATA_LOW_TIER_CURED_DISCOUNT: int
        public static DATA_HIGH_TIER_CURED_DISCOUNT: int
        public static DATA_NEARBY_CURED_DISCOUNT: int
        public static DATA_NEARBY_CURED_DISCOUNT_TIMESTAMP: int
        public static DATA_HITBOX: int
        public static DATA_IS_BUOYANT: int
        public static DATA_BASE_RUNTIME_ID: int
        public static DATA_FREEZING_EFFECT_STRENGTH: int
        public static DATA_BUOYANCY_DATA: int
        public static DATA_GOAT_HORN_COUNT: int
        public static DATA_UPDATE_PROPERTIES: int
        public static DATA_MOVEMENT_SOUND_DISTANCE_OFFSET: int
        public static DATA_HEARTBEAT_INTERVAL_TICKS: int
        public static DATA_HEARTBEAT_SOUND_EVENT: int
        public static DATA_FLAG_ONFIRE: int
        public static DATA_FLAG_SNEAKING: int
        public static DATA_FLAG_RIDING: int
        public static DATA_FLAG_SPRINTING: int
        public static DATA_FLAG_ACTION: int
        public static DATA_FLAG_INVISIBLE: int
        public static DATA_FLAG_TEMPTED: int
        public static DATA_FLAG_INLOVE: int
        public static DATA_FLAG_SADDLED: int
        public static DATA_FLAG_POWERED: int
        public static DATA_FLAG_IGNITED: int
        public static DATA_FLAG_BABY: int
        public static DATA_FLAG_CONVERTING: int
        public static DATA_FLAG_CRITICAL: int
        public static DATA_FLAG_CAN_SHOW_NAMETAG: int
        public static DATA_FLAG_ALWAYS_SHOW_NAMETAG: int
        public static DATA_FLAG_IMMOBILE: int
        public static DATA_FLAG_NO_AI: int
        public static DATA_FLAG_SILENT: int
        public static DATA_FLAG_WALLCLIMBING: int
        public static DATA_FLAG_CAN_CLIMB: int
        public static DATA_FLAG_SWIMMER: int
        public static DATA_FLAG_CAN_FLY: int
        public static DATA_FLAG_WALKER: int
        public static DATA_FLAG_RESTING: int
        public static DATA_FLAG_SITTING: int
        public static DATA_FLAG_ANGRY: int
        public static DATA_FLAG_INTERESTED: int
        public static DATA_FLAG_CHARGED: int
        public static DATA_FLAG_TAMED: int
        public static DATA_FLAG_ORPHANED: int
        public static DATA_FLAG_LEASHED: int
        public static DATA_FLAG_SHEARED: int
        public static DATA_FLAG_GLIDING: int
        public static DATA_FLAG_ELDER: int
        public static DATA_FLAG_MOVING: int
        public static DATA_FLAG_BREATHING: int
        public static DATA_FLAG_CHESTED: int
        public static DATA_FLAG_STACKABLE: int
        public static DATA_FLAG_SHOWBASE: int
        public static DATA_FLAG_REARING: int
        public static DATA_FLAG_VIBRATING: int
        public static DATA_FLAG_IDLING: int
        public static DATA_FLAG_EVOKER_SPELL: int
        public static DATA_FLAG_CHARGE_ATTACK: int
        public static DATA_FLAG_WASD_CONTROLLED: int
        public static DATA_FLAG_CAN_POWER_JUMP: int
        public static DATA_FLAG_LINGER: int
        public static DATA_FLAG_HAS_COLLISION: int
        public static DATA_FLAG_GRAVITY: int
        public static DATA_FLAG_FIRE_IMMUNE: int
        public static DATA_FLAG_DANCING: int
        public static DATA_FLAG_ENCHANTED: int
        public static DATA_FLAG_SHOW_TRIDENT_ROPE: int
        public static DATA_FLAG_CONTAINER_PRIVATE: int
        public static DATA_FLAG_IS_TRANSFORMING: int
        public static DATA_FLAG_SPIN_ATTACK: int
        public static DATA_FLAG_SWIMMING: int
        public static DATA_FLAG_BRIBED: int
        public static DATA_FLAG_PREGNANT: int
        public static DATA_FLAG_LAYING_EGG: int
        public static DATA_FLAG_RIDER_CAN_PICK: int
        public static DATA_FLAG_TRANSITION_SITTING: int
        public static DATA_FLAG_TRANSITION_SETTING: int
        public static DATA_FLAG_EATING: int
        public static DATA_FLAG_LAYING_DOWN: int
        public static DATA_FLAG_SNEEZING: int
        public static DATA_FLAG_TRUSTING: int
        public static DATA_FLAG_ROLLING: int
        public static DATA_FLAG_SCARED: int
        public static DATA_FLAG_IN_SCAFFOLDING: int
        public static DATA_FLAG_OVER_SCAFFOLDING: int
        public static DATA_FLAG_FALL_THROUGH_SCAFFOLDING: int
        public static DATA_FLAG_BLOCKING: int
        public static DATA_FLAG_TRANSITION_BLOCKING: int
        public static DATA_FLAG_BLOCKED_USING_SHIELD: int
        public static DATA_FLAG_BLOCKED_USING_DAMAGED_SHIELD: int
        public static DATA_FLAG_SLEEPING: int
        public static DATA_FLAG_ENTITY_GROW_UP: int
        public static DATA_FLAG_TRADE_INTEREST: int
        public static DATA_FLAG_DOOR_BREAKER: int
        public static DATA_FLAG_BREAKING_OBSTRUCTION: int
        public static DATA_FLAG_DOOR_OPENER: int
        public static DATA_FLAG_IS_ILLAGER_CAPTAIN: int
        public static DATA_FLAG_STUNNED: int
        public static DATA_FLAG_ROARING: int
        public static DATA_FLAG_DELAYED_ATTACK: int
        public static DATA_FLAG_IS_AVOIDING_MOBS: int
        public static DATA_FLAG_IS_AVOIDING_BLOCKS: int
        public static DATA_FLAG_FACING_TARGET_TO_RANGE_ATTACK: int
        public static DATA_FLAG_HIDDEN_WHEN_INVISIBLE: int
        public static DATA_FLAG_IS_IN_UI: int
        public static DATA_FLAG_STALKING: int
        public static DATA_FLAG_EMOTING: int
        public static DATA_FLAG_CELEBRATING: int
        public static DATA_FLAG_ADMIRING: int
        public static DATA_FLAG_CELEBRATING_SPECIAL: int
        public static DATA_FLAG_RAM_ATTACK: int
        public static DATA_FLAG_PLAYING_DEAD: int
        public static DATA_FLAG_IN_ASCENDABLE_BLOCK: int
        public static DATA_FLAG_OVER_DESCENDABLE_BLOCK: int
        public static DATA_FLAG_CROAKING: int
        public static DATA_FLAG_EAT_MOB: int
        public static DATA_FLAG_JUMP_GOAL_JUMP: int
        public static DATA_FLAG_EMERGING: int
        public static DATA_FLAG_SNIFFING: int
        public static DATA_FLAG_DIGGING: int
        public static entityCount: long
        static knownEntities: java.util.Map<string, java.lang.Class<cn.nukkit.entity.Entity>>
        static shortNames: java.util.Map<string, string>
        hasSpawned: java.util.Map<int, cn.nukkit.Player>
        effects: java.util.Map<int, cn.nukkit.potion.Effect>
        entityUniqueId: java.util.UUID
        id: long
        dataProperties: cn.nukkit.entity.data.EntityMetadata
        public passengers: java.util.List<cn.nukkit.entity.Entity>
        public riding: cn.nukkit.entity.Entity
        public chunk: cn.nukkit.level.format.FullChunk
        lastDamageCause: cn.nukkit.event.entity.EntityDamageEvent
        public blocksAround: java.util.List<cn.nukkit.block.Block>
        public collisionBlocks: java.util.List<cn.nukkit.block.Block>
        public lastX: double
        public lastY: double
        public lastZ: double
        public firstMove: boolean
        public motionX: double
        public motionY: double
        public motionZ: double
        public temporalVector: cn.nukkit.math.Vector3
        public lastMotionX: double
        public lastMotionY: double
        public lastMotionZ: double
        public lastPitch: double
        public lastYaw: double
        public lastHeadYaw: double
        public pitchDelta: double
        public yawDelta: double
        public headYawDelta: double
        public entityCollisionReduction: double
        public boundingBox: cn.nukkit.math.AxisAlignedBB
        public offsetBoundingBox: cn.nukkit.math.AxisAlignedBB
        public onGround: boolean
        public inBlock: boolean
        public positionChanged: boolean
        public motionChanged: boolean
        public deadTicks: int
        age: int
        health: float
        maxHealth: int
        absorption: float
        ySize: float
        public keepMovement: boolean
        public fallDistance: float
        public ticksLived: int
        public lastUpdate: int
        public maxFireTicks: int
        public fireTicks: int
        public inPortalTicks: int
        public freezingTicks: int
        inEndPortal: boolean
        public scale: float
        public namedTag: cn.nukkit.nbt.tag.CompoundTag
        isStatic: boolean
        public isCollided: boolean
        public isCollidedHorizontally: boolean
        public isCollidedVertically: boolean
        public noDamageTicks: int
        public justCreated: boolean
        public fireProof: boolean
        public invulnerable: boolean
        server: cn.nukkit.Server
        public highestPosition: double
        public closed: boolean
        timing: co.aikar.timings.Timing
        isPlayer: boolean
        initialized: boolean
        public noClip: boolean

    }
}

declare module "cn.nukkit.entity.Entity" {
    declare const Entity = cn.nukkit.entity.Entity;
}

declare namespace cn.nukkit.level {
    declare class Sound extends java.lang.Enum {
        public static values(): cn.nukkit.level.Sound[]
        public static valueOf(name: string): cn.nukkit.level.Sound
        constructor(var0: string): void
        public getSound(): string
        static $values(): cn.nukkit.level.Sound[]
        public static AMBIENT_BASALT_DELTAS_ADDITIONS: cn.nukkit.level.Sound
        public static AMBIENT_BASALT_DELTAS_LOOP: cn.nukkit.level.Sound
        public static AMBIENT_BASALT_DELTAS_MOOD: cn.nukkit.level.Sound
        public static AMBIENT_CANDLE: cn.nukkit.level.Sound
        public static AMBIENT_CAVE: cn.nukkit.level.Sound
        public static AMBIENT_CRIMSON_FOREST_ADDITIONS: cn.nukkit.level.Sound
        public static AMBIENT_CRIMSON_FOREST_LOOP: cn.nukkit.level.Sound
        public static AMBIENT_CRIMSON_FOREST_MOOD: cn.nukkit.level.Sound
        public static AMBIENT_NETHER_WASTES_ADDITIONS: cn.nukkit.level.Sound
        public static AMBIENT_NETHER_WASTES_LOOP: cn.nukkit.level.Sound
        public static AMBIENT_NETHER_WASTES_MOOD: cn.nukkit.level.Sound
        public static AMBIENT_SOULSAND_VALLEY_ADDITIONS: cn.nukkit.level.Sound
        public static AMBIENT_SOULSAND_VALLEY_LOOP: cn.nukkit.level.Sound
        public static AMBIENT_SOULSAND_VALLEY_MOOD: cn.nukkit.level.Sound
        public static AMBIENT_WARPED_FOREST_ADDITIONS: cn.nukkit.level.Sound
        public static AMBIENT_WARPED_FOREST_LOOP: cn.nukkit.level.Sound
        public static AMBIENT_WARPED_FOREST_MOOD: cn.nukkit.level.Sound
        public static AMBIENT_WEATHER_LIGHTNING_IMPACT: cn.nukkit.level.Sound
        public static AMBIENT_WEATHER_RAIN: cn.nukkit.level.Sound
        public static AMBIENT_WEATHER_THUNDER: cn.nukkit.level.Sound
        public static ARMOR_EQUIP_CHAIN: cn.nukkit.level.Sound
        public static ARMOR_EQUIP_DIAMOND: cn.nukkit.level.Sound
        public static ARMOR_EQUIP_GENERIC: cn.nukkit.level.Sound
        public static ARMOR_EQUIP_GOLD: cn.nukkit.level.Sound
        public static ARMOR_EQUIP_IRON: cn.nukkit.level.Sound
        public static ARMOR_EQUIP_LEATHER: cn.nukkit.level.Sound
        public static ARMOR_EQUIP_NETHERITE: cn.nukkit.level.Sound
        public static BEACON_ACTIVATE: cn.nukkit.level.Sound
        public static BEACON_AMBIENT: cn.nukkit.level.Sound
        public static BEACON_DEACTIVATE: cn.nukkit.level.Sound
        public static BEACON_POWER: cn.nukkit.level.Sound
        public static BLOCK_BAMBOO_BREAK: cn.nukkit.level.Sound
        public static BLOCK_BAMBOO_FALL: cn.nukkit.level.Sound
        public static BLOCK_BAMBOO_HIT: cn.nukkit.level.Sound
        public static BLOCK_BAMBOO_PLACE: cn.nukkit.level.Sound
        public static BLOCK_BAMBOO_STEP: cn.nukkit.level.Sound
        public static BLOCK_BAMBOO_SAPLING_BREAK: cn.nukkit.level.Sound
        public static BLOCK_BAMBOO_SAPLING_PLACE: cn.nukkit.level.Sound
        public static BLOCK_BARREL_CLOSE: cn.nukkit.level.Sound
        public static BLOCK_BARREL_OPEN: cn.nukkit.level.Sound
        public static BLOCK_BEEHIVE_DRIP: cn.nukkit.level.Sound
        public static BLOCK_BEEHIVE_ENTER: cn.nukkit.level.Sound
        public static BLOCK_BEEHIVE_EXIT: cn.nukkit.level.Sound
        public static BLOCK_BEEHIVE_SHEAR: cn.nukkit.level.Sound
        public static BLOCK_BEEHIVE_WORK: cn.nukkit.level.Sound
        public static BLOCK_BELL_HIT: cn.nukkit.level.Sound
        public static BLOCK_BLASTFURNACE_FIRE_CRACKLE: cn.nukkit.level.Sound
        public static BLOCK_BOWHIT: cn.nukkit.level.Sound
        public static BLOCK_CAMPFIRE_CRACKLE: cn.nukkit.level.Sound
        public static BLOCK_CARTOGRAPHY_TABLE_USE: cn.nukkit.level.Sound
        public static BLOCK_CHORUSFLOWER_DEATH: cn.nukkit.level.Sound
        public static BLOCK_CHORUSFLOWER_GROW: cn.nukkit.level.Sound
        public static BLOCK_CLICK: cn.nukkit.level.Sound
        public static BLOCK_COMPOSTER_EMPTY: cn.nukkit.level.Sound
        public static BLOCK_COMPOSTER_FILL: cn.nukkit.level.Sound
        public static BLOCK_COMPOSTER_FILL_SUCCESS: cn.nukkit.level.Sound
        public static BLOCK_COMPOSTER_READY: cn.nukkit.level.Sound
        public static BLOCK_END_PORTAL_SPAWN: cn.nukkit.level.Sound
        public static BLOCK_END_PORTAL_FRAME_FILL: cn.nukkit.level.Sound
        public static BLOCK_FALSE_PERMISSIONS: cn.nukkit.level.Sound
        public static BLOCK_FURNACE_LIT: cn.nukkit.level.Sound
        public static BLOCK_GRINDSTONE_USE: cn.nukkit.level.Sound
        public static BLOCK_ITEMFRAME_ADD_ITEM: cn.nukkit.level.Sound
        public static BLOCK_ITEMFRAME_BREAK: cn.nukkit.level.Sound
        public static BLOCK_ITEMFRAME_PLACE: cn.nukkit.level.Sound
        public static BLOCK_ITEMFRAME_REMOVE_ITEM: cn.nukkit.level.Sound
        public static BLOCK_ITEMFRAME_ROTATE_ITEM: cn.nukkit.level.Sound
        public static BLOCK_LANTERN_BREAK: cn.nukkit.level.Sound
        public static BLOCK_LANTERN_FALL: cn.nukkit.level.Sound
        public static BLOCK_LANTERN_HIT: cn.nukkit.level.Sound
        public static BLOCK_LANTERN_PLACE: cn.nukkit.level.Sound
        public static BLOCK_LANTERN_STEP: cn.nukkit.level.Sound
        public static BLOCK_LOOM_USE: cn.nukkit.level.Sound
        public static BLOCK_MANGROVE_ROOTS_BREAK: cn.nukkit.level.Sound
        public static BLOCK_MANGROVE_ROOTS_FALL: cn.nukkit.level.Sound
        public static BLOCK_MANGROVE_ROOTS_HIT: cn.nukkit.level.Sound
        public static BLOCK_MANGROVE_ROOTS_PLACE: cn.nukkit.level.Sound
        public static BLOCK_MANGROVE_ROOTS_STEP: cn.nukkit.level.Sound
        public static BLOCK_MUD_BREAK: cn.nukkit.level.Sound
        public static BLOCK_MUD_FALL: cn.nukkit.level.Sound
        public static BLOCK_MUD_HIT: cn.nukkit.level.Sound
        public static BLOCK_MUD_PLACE: cn.nukkit.level.Sound
        public static BLOCK_MUD_STEP: cn.nukkit.level.Sound
        public static BLOCK_MUD_BRICKS_BREAK: cn.nukkit.level.Sound
        public static BLOCK_MUD_BRICKS_FALL: cn.nukkit.level.Sound
        public static BLOCK_MUD_BRICKS_HIT: cn.nukkit.level.Sound
        public static BLOCK_MUD_BRICKS_PLACE: cn.nukkit.level.Sound
        public static BLOCK_MUD_BRICKS_STEP: cn.nukkit.level.Sound
        public static BLOCK_MUDDY_MANGROVE_ROOTS_BREAK: cn.nukkit.level.Sound
        public static BLOCK_MUDDY_MANGROVE_ROOTS_FALL: cn.nukkit.level.Sound
        public static BLOCK_MUDDY_MANGROVE_ROOTS_HIT: cn.nukkit.level.Sound
        public static BLOCK_MUDDY_MANGROVE_ROOTS_PLACE: cn.nukkit.level.Sound
        public static BLOCK_MUDDY_MANGROVE_ROOTS_STEP: cn.nukkit.level.Sound
        public static BLOCK_PACKED_MUD_BREAK: cn.nukkit.level.Sound
        public static BLOCK_PACKED_MUD_FALL: cn.nukkit.level.Sound
        public static BLOCK_PACKED_MUD_HIT: cn.nukkit.level.Sound
        public static BLOCK_PACKED_MUD_PLACE: cn.nukkit.level.Sound
        public static BLOCK_PACKED_MUD_STEP: cn.nukkit.level.Sound
        public static BLOCK_SCAFFOLDING_BREAK: cn.nukkit.level.Sound
        public static BLOCK_SCAFFOLDING_CLIMB: cn.nukkit.level.Sound
        public static BLOCK_SCAFFOLDING_FALL: cn.nukkit.level.Sound
        public static BLOCK_SCAFFOLDING_HIT: cn.nukkit.level.Sound
        public static BLOCK_SCAFFOLDING_PLACE: cn.nukkit.level.Sound
        public static BLOCK_SCAFFOLDING_STEP: cn.nukkit.level.Sound
        public static BLOCK_SMOKER_SMOKE: cn.nukkit.level.Sound
        public static BLOCK_STONECUTTER_USE: cn.nukkit.level.Sound
        public static BLOCK_SWEET_BERRY_BUSH_BREAK: cn.nukkit.level.Sound
        public static BLOCK_SWEET_BERRY_BUSH_HURT: cn.nukkit.level.Sound
        public static BLOCK_SWEET_BERRY_BUSH_PICK: cn.nukkit.level.Sound
        public static BLOCK_SWEET_BERRY_BUSH_PLACE: cn.nukkit.level.Sound
        public static BLOCK_TURTLE_EGG_BREAK: cn.nukkit.level.Sound
        public static BLOCK_TURTLE_EGG_CRACK: cn.nukkit.level.Sound
        public static BLOCK_TURTLE_EGG_DROP: cn.nukkit.level.Sound
        public static BLOOM_SCULK_CATALYST: cn.nukkit.level.Sound
        public static BOTTLE_DRAGONBREATH: cn.nukkit.level.Sound
        public static BREAK_AMETHYST_BLOCK: cn.nukkit.level.Sound
        public static BREAK_AMETHYST_CLUSTER: cn.nukkit.level.Sound
        public static BREAK_AZALEA: cn.nukkit.level.Sound
        public static BREAK_BIG_DRIPLEAF: cn.nukkit.level.Sound
        public static BREAK_CALCITE: cn.nukkit.level.Sound
        public static BREAK_DIRT_WITH_ROOTS: cn.nukkit.level.Sound
        public static BREAK_DRIPSTONE_BLOCK: cn.nukkit.level.Sound
        public static BREAK_FROG_SPAWN: cn.nukkit.level.Sound
        public static BREAK_FROGLIGHT: cn.nukkit.level.Sound
        public static BREAK_HANGING_ROOTS: cn.nukkit.level.Sound
        public static BREAK_LARGE_AMETHYST_BUD: cn.nukkit.level.Sound
        public static BREAK_MEDIUM_AMETHYST_BUD: cn.nukkit.level.Sound
        public static BREAK_POINTED_DRIPSTONE: cn.nukkit.level.Sound
        public static BREAK_SCULK: cn.nukkit.level.Sound
        public static BREAK_SCULK_CATALYST: cn.nukkit.level.Sound
        public static BREAK_SCULK_SENSOR: cn.nukkit.level.Sound
        public static BREAK_SCULK_SHRIEKER: cn.nukkit.level.Sound
        public static BREAK_SCULK_VEIN: cn.nukkit.level.Sound
        public static BREAK_SMALL_AMETHYST_BUD: cn.nukkit.level.Sound
        public static BREAK_SPORE_BLOSSOM: cn.nukkit.level.Sound
        public static BREAK_TUFF: cn.nukkit.level.Sound
        public static BUBBLE_DOWN: cn.nukkit.level.Sound
        public static BUBBLE_DOWNINSIDE: cn.nukkit.level.Sound
        public static BUBBLE_POP: cn.nukkit.level.Sound
        public static BUBBLE_UP: cn.nukkit.level.Sound
        public static BUBBLE_UPINSIDE: cn.nukkit.level.Sound
        public static BUCKET_EMPTY_FISH: cn.nukkit.level.Sound
        public static BUCKET_EMPTY_LAVA: cn.nukkit.level.Sound
        public static BUCKET_EMPTY_POWDER_SNOW: cn.nukkit.level.Sound
        public static BUCKET_EMPTY_WATER: cn.nukkit.level.Sound
        public static BUCKET_FILL_FISH: cn.nukkit.level.Sound
        public static BUCKET_FILL_LAVA: cn.nukkit.level.Sound
        public static BUCKET_FILL_POWDER_SNOW: cn.nukkit.level.Sound
        public static BUCKET_FILL_WATER: cn.nukkit.level.Sound
        public static CAKE_ADD_CANDLE: cn.nukkit.level.Sound
        public static CAMERA_TAKE_PICTURE: cn.nukkit.level.Sound
        public static CAULDRON_ADDDYE: cn.nukkit.level.Sound
        public static CAULDRON_CLEANARMOR: cn.nukkit.level.Sound
        public static CAULDRON_CLEANBANNER: cn.nukkit.level.Sound
        public static CAULDRON_DYEARMOR: cn.nukkit.level.Sound
        public static CAULDRON_EXPLODE: cn.nukkit.level.Sound
        public static CAULDRON_FILLPOTION: cn.nukkit.level.Sound
        public static CAULDRON_FILLWATER: cn.nukkit.level.Sound
        public static CAULDRON_TAKEPOTION: cn.nukkit.level.Sound
        public static CAULDRON_TAKEWATER: cn.nukkit.level.Sound
        public static CAULDRON_DRIP_LAVA_POINTED_DRIPSTONE: cn.nukkit.level.Sound
        public static CAULDRON_DRIP_WATER_POINTED_DRIPSTONE: cn.nukkit.level.Sound
        public static CHARGE_SCULK: cn.nukkit.level.Sound
        public static CHIME_AMETHYST_BLOCK: cn.nukkit.level.Sound
        public static COMPONENT_JUMP_TO_BLOCK: cn.nukkit.level.Sound
        public static CONDUIT_ACTIVATE: cn.nukkit.level.Sound
        public static CONDUIT_AMBIENT: cn.nukkit.level.Sound
        public static CONDUIT_ATTACK: cn.nukkit.level.Sound
        public static CONDUIT_DEACTIVATE: cn.nukkit.level.Sound
        public static CONDUIT_SHORT: cn.nukkit.level.Sound
        public static COPPER_WAX_OFF: cn.nukkit.level.Sound
        public static COPPER_WAX_ON: cn.nukkit.level.Sound
        public static CROSSBOW_LOADING_END: cn.nukkit.level.Sound
        public static CROSSBOW_LOADING_MIDDLE: cn.nukkit.level.Sound
        public static CROSSBOW_LOADING_START: cn.nukkit.level.Sound
        public static CROSSBOW_QUICK_CHARGE_END: cn.nukkit.level.Sound
        public static CROSSBOW_QUICK_CHARGE_MIDDLE: cn.nukkit.level.Sound
        public static CROSSBOW_QUICK_CHARGE_START: cn.nukkit.level.Sound
        public static CROSSBOW_SHOOT: cn.nukkit.level.Sound
        public static DAMAGE_FALLBIG: cn.nukkit.level.Sound
        public static DAMAGE_FALLSMALL: cn.nukkit.level.Sound
        public static DIG_ANCIENT_DEBRIS: cn.nukkit.level.Sound
        public static DIG_AZALEA_LEAVES: cn.nukkit.level.Sound
        public static DIG_BASALT: cn.nukkit.level.Sound
        public static DIG_BONE_BLOCK: cn.nukkit.level.Sound
        public static DIG_CANDLE: cn.nukkit.level.Sound
        public static DIG_CAVE_VINES: cn.nukkit.level.Sound
        public static DIG_CHAIN: cn.nukkit.level.Sound
        public static DIG_CLOTH: cn.nukkit.level.Sound
        public static DIG_COPPER: cn.nukkit.level.Sound
        public static DIG_CORAL: cn.nukkit.level.Sound
        public static DIG_DEEPSLATE: cn.nukkit.level.Sound
        public static DIG_DEEPSLATE_BRICKS: cn.nukkit.level.Sound
        public static DIG_FUNGUS: cn.nukkit.level.Sound
        public static DIG_GRASS: cn.nukkit.level.Sound
        public static DIG_GRAVEL: cn.nukkit.level.Sound
        public static DIG_HONEY_BLOCK: cn.nukkit.level.Sound
        public static DIG_LODESTONE: cn.nukkit.level.Sound
        public static DIG_MOSS: cn.nukkit.level.Sound
        public static DIG_NETHER_BRICK: cn.nukkit.level.Sound
        public static DIG_NETHER_GOLD_ORE: cn.nukkit.level.Sound
        public static DIG_NETHER_SPROUTS: cn.nukkit.level.Sound
        public static DIG_NETHER_WART: cn.nukkit.level.Sound
        public static DIG_NETHERITE: cn.nukkit.level.Sound
        public static DIG_NETHERRACK: cn.nukkit.level.Sound
        public static DIG_NYLIUM: cn.nukkit.level.Sound
        public static DIG_POWDER_SNOW: cn.nukkit.level.Sound
        public static DIG_ROOTS: cn.nukkit.level.Sound
        public static DIG_SAND: cn.nukkit.level.Sound
        public static DIG_SHROOMLIGHT: cn.nukkit.level.Sound
        public static DIG_SNOW: cn.nukkit.level.Sound
        public static DIG_SOUL_SAND: cn.nukkit.level.Sound
        public static DIG_SOUL_SOIL: cn.nukkit.level.Sound
        public static DIG_STEM: cn.nukkit.level.Sound
        public static DIG_STONE: cn.nukkit.level.Sound
        public static DIG_VINES: cn.nukkit.level.Sound
        public static DIG_WOOD: cn.nukkit.level.Sound
        public static DRIP_LAVA_POINTED_DRIPSTONE: cn.nukkit.level.Sound
        public static DRIP_WATER_POINTED_DRIPSTONE: cn.nukkit.level.Sound
        public static ELYTRA_LOOP: cn.nukkit.level.Sound
        public static ENTITY_ZOMBIE_CONVERTED_TO_DROWNED: cn.nukkit.level.Sound
        public static EXTINGUISH_CANDLE: cn.nukkit.level.Sound
        public static FALL_AMETHYST_BLOCK: cn.nukkit.level.Sound
        public static FALL_AMETHYST_CLUSTER: cn.nukkit.level.Sound
        public static FALL_ANCIENT_DEBRIS: cn.nukkit.level.Sound
        public static FALL_AZALEA: cn.nukkit.level.Sound
        public static FALL_AZALEA_LEAVES: cn.nukkit.level.Sound
        public static FALL_BASALT: cn.nukkit.level.Sound
        public static FALL_BIG_DRIPLEAF: cn.nukkit.level.Sound
        public static FALL_BONE_BLOCK: cn.nukkit.level.Sound
        public static FALL_CALCITE: cn.nukkit.level.Sound
        public static FALL_CAVE_VINES: cn.nukkit.level.Sound
        public static FALL_CHAIN: cn.nukkit.level.Sound
        public static FALL_CLOTH: cn.nukkit.level.Sound
        public static FALL_COPPER: cn.nukkit.level.Sound
        public static FALL_CORAL: cn.nukkit.level.Sound
        public static FALL_DEEPSLATE: cn.nukkit.level.Sound
        public static FALL_DEEPSLATE_BRICKS: cn.nukkit.level.Sound
        public static FALL_DIRT_WITH_ROOTS: cn.nukkit.level.Sound
        public static FALL_DRIPSTONE_BLOCK: cn.nukkit.level.Sound
        public static FALL_EGG: cn.nukkit.level.Sound
        public static FALL_GRASS: cn.nukkit.level.Sound
        public static FALL_GRAVEL: cn.nukkit.level.Sound
        public static FALL_HANGING_ROOTS: cn.nukkit.level.Sound
        public static FALL_HONEY_BLOCK: cn.nukkit.level.Sound
        public static FALL_LADDER: cn.nukkit.level.Sound
        public static FALL_MOSS: cn.nukkit.level.Sound
        public static FALL_NETHER_BRICK: cn.nukkit.level.Sound
        public static FALL_NETHER_GOLD_ORE: cn.nukkit.level.Sound
        public static FALL_NETHER_SPROUTS: cn.nukkit.level.Sound
        public static FALL_NETHER_WART: cn.nukkit.level.Sound
        public static FALL_NETHERITE: cn.nukkit.level.Sound
        public static FALL_NETHERRACK: cn.nukkit.level.Sound
        public static FALL_NYLIUM: cn.nukkit.level.Sound
        public static FALL_POINTED_DRIPSTONE: cn.nukkit.level.Sound
        public static FALL_POWDER_SNOW: cn.nukkit.level.Sound
        public static FALL_ROOTS: cn.nukkit.level.Sound
        public static FALL_SAND: cn.nukkit.level.Sound
        public static FALL_SCULK_SENSOR: cn.nukkit.level.Sound
        public static FALL_SCULK_SHRIEKER: cn.nukkit.level.Sound
        public static FALL_SHROOMLIGHT: cn.nukkit.level.Sound
        public static FALL_SLIME: cn.nukkit.level.Sound
        public static FALL_SNOW: cn.nukkit.level.Sound
        public static FALL_SOUL_SAND: cn.nukkit.level.Sound
        public static FALL_SOUL_SOIL: cn.nukkit.level.Sound
        public static FALL_SPORE_BLOSSOM: cn.nukkit.level.Sound
        public static FALL_STEM: cn.nukkit.level.Sound
        public static FALL_STONE: cn.nukkit.level.Sound
        public static FALL_TUFF: cn.nukkit.level.Sound
        public static FALL_VINES: cn.nukkit.level.Sound
        public static FALL_WOOD: cn.nukkit.level.Sound
        public static FIRE_FIRE: cn.nukkit.level.Sound
        public static FIRE_IGNITE: cn.nukkit.level.Sound
        public static FIREWORK_BLAST: cn.nukkit.level.Sound
        public static FIREWORK_LARGE_BLAST: cn.nukkit.level.Sound
        public static FIREWORK_LAUNCH: cn.nukkit.level.Sound
        public static FIREWORK_SHOOT: cn.nukkit.level.Sound
        public static FIREWORK_TWINKLE: cn.nukkit.level.Sound
        public static GAME_PLAYER_ATTACK_NODAMAGE: cn.nukkit.level.Sound
        public static GAME_PLAYER_ATTACK_STRONG: cn.nukkit.level.Sound
        public static GAME_PLAYER_DIE: cn.nukkit.level.Sound
        public static GAME_PLAYER_HURT: cn.nukkit.level.Sound
        public static HATCH_FROG_SPAWN: cn.nukkit.level.Sound
        public static HIT_AMETHYST_BLOCK: cn.nukkit.level.Sound
        public static HIT_AMETHYST_CLUSTER: cn.nukkit.level.Sound
        public static HIT_ANCIENT_DEBRIS: cn.nukkit.level.Sound
        public static HIT_ANVIL: cn.nukkit.level.Sound
        public static HIT_AZALEA: cn.nukkit.level.Sound
        public static HIT_AZALEA_LEAVES: cn.nukkit.level.Sound
        public static HIT_BASALT: cn.nukkit.level.Sound
        public static HIT_BIG_DRIPLEAF: cn.nukkit.level.Sound
        public static HIT_BONE_BLOCK: cn.nukkit.level.Sound
        public static HIT_CALCITE: cn.nukkit.level.Sound
        public static HIT_CANDLE: cn.nukkit.level.Sound
        public static HIT_CAVE_VINES: cn.nukkit.level.Sound
        public static HIT_CHAIN: cn.nukkit.level.Sound
        public static HIT_CLOTH: cn.nukkit.level.Sound
        public static HIT_COPPER: cn.nukkit.level.Sound
        public static HIT_CORAL: cn.nukkit.level.Sound
        public static HIT_DEEPSLATE: cn.nukkit.level.Sound
        public static HIT_DEEPSLATE_BRICKS: cn.nukkit.level.Sound
        public static HIT_DIRT_WITH_ROOTS: cn.nukkit.level.Sound
        public static HIT_DRIPSTONE_BLOCK: cn.nukkit.level.Sound
        public static HIT_GRASS: cn.nukkit.level.Sound
        public static HIT_GRAVEL: cn.nukkit.level.Sound
        public static HIT_HANGING_ROOTS: cn.nukkit.level.Sound
        public static HIT_HONEY_BLOCK: cn.nukkit.level.Sound
        public static HIT_LADDER: cn.nukkit.level.Sound
        public static HIT_MOSS: cn.nukkit.level.Sound
        public static HIT_NETHER_BRICK: cn.nukkit.level.Sound
        public static HIT_NETHER_GOLD_ORE: cn.nukkit.level.Sound
        public static HIT_NETHER_SPROUTS: cn.nukkit.level.Sound
        public static HIT_NETHER_WART: cn.nukkit.level.Sound
        public static HIT_NETHERITE: cn.nukkit.level.Sound
        public static HIT_NETHERRACK: cn.nukkit.level.Sound
        public static HIT_NYLIUM: cn.nukkit.level.Sound
        public static HIT_POINTED_DRIPSTONE: cn.nukkit.level.Sound
        public static HIT_POWDER_SNOW: cn.nukkit.level.Sound
        public static HIT_ROOTS: cn.nukkit.level.Sound
        public static HIT_SAND: cn.nukkit.level.Sound
        public static HIT_SCULK: cn.nukkit.level.Sound
        public static HIT_SCULK_CATALYST: cn.nukkit.level.Sound
        public static HIT_SCULK_SENSOR: cn.nukkit.level.Sound
        public static HIT_SCULK_SHRIEKER: cn.nukkit.level.Sound
        public static HIT_SHROOMLIGHT: cn.nukkit.level.Sound
        public static HIT_SLIME: cn.nukkit.level.Sound
        public static HIT_SNOW: cn.nukkit.level.Sound
        public static HIT_SOUL_SAND: cn.nukkit.level.Sound
        public static HIT_SOUL_SOIL: cn.nukkit.level.Sound
        public static HIT_SPORE_BLOSSOM: cn.nukkit.level.Sound
        public static HIT_STEM: cn.nukkit.level.Sound
        public static HIT_STONE: cn.nukkit.level.Sound
        public static HIT_TUFF: cn.nukkit.level.Sound
        public static HIT_VINES: cn.nukkit.level.Sound
        public static HIT_WOOD: cn.nukkit.level.Sound
        public static HORN_CALL_0: cn.nukkit.level.Sound
        public static HORN_CALL_1: cn.nukkit.level.Sound
        public static HORN_CALL_2: cn.nukkit.level.Sound
        public static HORN_CALL_3: cn.nukkit.level.Sound
        public static HORN_CALL_4: cn.nukkit.level.Sound
        public static HORN_CALL_5: cn.nukkit.level.Sound
        public static HORN_CALL_6: cn.nukkit.level.Sound
        public static HORN_CALL_7: cn.nukkit.level.Sound
        public static ITEM_BONE_MEAL_USE: cn.nukkit.level.Sound
        public static ITEM_BOOK_PAGE_TURN: cn.nukkit.level.Sound
        public static ITEM_BOOK_PUT: cn.nukkit.level.Sound
        public static ITEM_SHIELD_BLOCK: cn.nukkit.level.Sound
        public static ITEM_SPYGLASS_STOP_USING: cn.nukkit.level.Sound
        public static ITEM_SPYGLASS_USE: cn.nukkit.level.Sound
        public static ITEM_TRIDENT_HIT: cn.nukkit.level.Sound
        public static ITEM_TRIDENT_HIT_GROUND: cn.nukkit.level.Sound
        public static ITEM_TRIDENT_RETURN: cn.nukkit.level.Sound
        public static ITEM_TRIDENT_RIPTIDE_1: cn.nukkit.level.Sound
        public static ITEM_TRIDENT_RIPTIDE_2: cn.nukkit.level.Sound
        public static ITEM_TRIDENT_RIPTIDE_3: cn.nukkit.level.Sound
        public static ITEM_TRIDENT_THROW: cn.nukkit.level.Sound
        public static ITEM_TRIDENT_THUNDER: cn.nukkit.level.Sound
        public static JUMP_ANCIENT_DEBRIS: cn.nukkit.level.Sound
        public static JUMP_AZALEA: cn.nukkit.level.Sound
        public static JUMP_BASALT: cn.nukkit.level.Sound
        public static JUMP_BIG_DRIPLEAF: cn.nukkit.level.Sound
        public static JUMP_BONE_BLOCK: cn.nukkit.level.Sound
        public static JUMP_CAVE_VINES: cn.nukkit.level.Sound
        public static JUMP_CHAIN: cn.nukkit.level.Sound
        public static JUMP_CLOTH: cn.nukkit.level.Sound
        public static JUMP_CORAL: cn.nukkit.level.Sound
        public static JUMP_DEEPSLATE: cn.nukkit.level.Sound
        public static JUMP_DEEPSLATE_BRICKS: cn.nukkit.level.Sound
        public static JUMP_DIRT_WITH_ROOTS: cn.nukkit.level.Sound
        public static JUMP_DRIPSTONE_BLOCK: cn.nukkit.level.Sound
        public static JUMP_GRASS: cn.nukkit.level.Sound
        public static JUMP_GRAVEL: cn.nukkit.level.Sound
        public static JUMP_HANGING_ROOTS: cn.nukkit.level.Sound
        public static JUMP_HONEY_BLOCK: cn.nukkit.level.Sound
        public static JUMP_MOSS: cn.nukkit.level.Sound
        public static JUMP_NETHER_BRICK: cn.nukkit.level.Sound
        public static JUMP_NETHER_GOLD_ORE: cn.nukkit.level.Sound
        public static JUMP_NETHER_SPROUTS: cn.nukkit.level.Sound
        public static JUMP_NETHER_WART: cn.nukkit.level.Sound
        public static JUMP_NETHERITE: cn.nukkit.level.Sound
        public static JUMP_NETHERRACK: cn.nukkit.level.Sound
        public static JUMP_NYLIUM: cn.nukkit.level.Sound
        public static JUMP_POINTED_DRIPSTONE: cn.nukkit.level.Sound
        public static JUMP_ROOTS: cn.nukkit.level.Sound
        public static JUMP_SAND: cn.nukkit.level.Sound
        public static JUMP_SCULK_SENSOR: cn.nukkit.level.Sound
        public static JUMP_SHROOMLIGHT: cn.nukkit.level.Sound
        public static JUMP_SLIME: cn.nukkit.level.Sound
        public static JUMP_SNOW: cn.nukkit.level.Sound
        public static JUMP_SOUL_SAND: cn.nukkit.level.Sound
        public static JUMP_SOUL_SOIL: cn.nukkit.level.Sound
        public static JUMP_SPORE_BLOSSOM: cn.nukkit.level.Sound
        public static JUMP_STEM: cn.nukkit.level.Sound
        public static JUMP_STONE: cn.nukkit.level.Sound
        public static JUMP_VINES: cn.nukkit.level.Sound
        public static JUMP_WOOD: cn.nukkit.level.Sound
        public static LAND_ANCIENT_DEBRIS: cn.nukkit.level.Sound
        public static LAND_AZALEA: cn.nukkit.level.Sound
        public static LAND_BASALT: cn.nukkit.level.Sound
        public static LAND_BIG_DRIPLEAF: cn.nukkit.level.Sound
        public static LAND_BONE_BLOCK: cn.nukkit.level.Sound
        public static LAND_CAVE_VINES: cn.nukkit.level.Sound
        public static LAND_CHAIN: cn.nukkit.level.Sound
        public static LAND_CLOTH: cn.nukkit.level.Sound
        public static LAND_CORAL: cn.nukkit.level.Sound
        public static LAND_DEEPSLATE: cn.nukkit.level.Sound
        public static LAND_DEEPSLATE_BRICKS: cn.nukkit.level.Sound
        public static LAND_DIRT_WITH_ROOTS: cn.nukkit.level.Sound
        public static LAND_DRIPSTONE_BLOCK: cn.nukkit.level.Sound
        public static LAND_GRASS: cn.nukkit.level.Sound
        public static LAND_GRAVEL: cn.nukkit.level.Sound
        public static LAND_HANGING_ROOTS: cn.nukkit.level.Sound
        public static LAND_HONEY_BLOCK: cn.nukkit.level.Sound
        public static LAND_MOSS: cn.nukkit.level.Sound
        public static LAND_NETHER_BRICK: cn.nukkit.level.Sound
        public static LAND_NETHER_GOLD_ORE: cn.nukkit.level.Sound
        public static LAND_NETHER_SPROUTS: cn.nukkit.level.Sound
        public static LAND_NETHER_WART: cn.nukkit.level.Sound
        public static LAND_NETHERITE: cn.nukkit.level.Sound
        public static LAND_NETHERRACK: cn.nukkit.level.Sound
        public static LAND_NYLIUM: cn.nukkit.level.Sound
        public static LAND_POINTED_DRIPSTONE: cn.nukkit.level.Sound
        public static LAND_ROOTS: cn.nukkit.level.Sound
        public static LAND_SAND: cn.nukkit.level.Sound
        public static LAND_SCULK_SENSOR: cn.nukkit.level.Sound
        public static LAND_SHROOMLIGHT: cn.nukkit.level.Sound
        public static LAND_SLIME: cn.nukkit.level.Sound
        public static LAND_SNOW: cn.nukkit.level.Sound
        public static LAND_SOUL_SAND: cn.nukkit.level.Sound
        public static LAND_SOUL_SOIL: cn.nukkit.level.Sound
        public static LAND_SPORE_BLOSSOM: cn.nukkit.level.Sound
        public static LAND_STEM: cn.nukkit.level.Sound
        public static LAND_STONE: cn.nukkit.level.Sound
        public static LAND_VINES: cn.nukkit.level.Sound
        public static LAND_WOOD: cn.nukkit.level.Sound
        public static LEASHKNOT_BREAK: cn.nukkit.level.Sound
        public static LEASHKNOT_PLACE: cn.nukkit.level.Sound
        public static LIQUID_LAVA: cn.nukkit.level.Sound
        public static LIQUID_LAVAPOP: cn.nukkit.level.Sound
        public static LIQUID_WATER: cn.nukkit.level.Sound
        public static LODESTONE_COMPASS_LINK_COMPASS_TO_LODESTONE: cn.nukkit.level.Sound
        public static MINECART_BASE: cn.nukkit.level.Sound
        public static MINECART_INSIDE: cn.nukkit.level.Sound
        public static MOB_AGENT_SPAWN: cn.nukkit.level.Sound
        public static MOB_ALLAY_DEATH: cn.nukkit.level.Sound
        public static MOB_ALLAY_HURT: cn.nukkit.level.Sound
        public static MOB_ALLAY_IDLE: cn.nukkit.level.Sound
        public static MOB_ALLAY_IDLE_HOLDING: cn.nukkit.level.Sound
        public static MOB_ALLAY_ITEM_GIVEN: cn.nukkit.level.Sound
        public static MOB_ALLAY_ITEM_TAKEN: cn.nukkit.level.Sound
        public static MOB_ALLAY_ITEM_THROWN: cn.nukkit.level.Sound
        public static MOB_ARMOR_STAND_BREAK: cn.nukkit.level.Sound
        public static MOB_ARMOR_STAND_HIT: cn.nukkit.level.Sound
        public static MOB_ARMOR_STAND_LAND: cn.nukkit.level.Sound
        public static MOB_ARMOR_STAND_PLACE: cn.nukkit.level.Sound
        public static MOB_AXOLOTL_ATTACK: cn.nukkit.level.Sound
        public static MOB_AXOLOTL_DEATH: cn.nukkit.level.Sound
        public static MOB_AXOLOTL_HURT: cn.nukkit.level.Sound
        public static MOB_AXOLOTL_IDLE: cn.nukkit.level.Sound
        public static MOB_AXOLOTL_IDLE_WATER: cn.nukkit.level.Sound
        public static MOB_AXOLOTL_SPLASH: cn.nukkit.level.Sound
        public static MOB_AXOLOTL_SWIM: cn.nukkit.level.Sound
        public static MOB_BAT_DEATH: cn.nukkit.level.Sound
        public static MOB_BAT_HURT: cn.nukkit.level.Sound
        public static MOB_BAT_IDLE: cn.nukkit.level.Sound
        public static MOB_BAT_TAKEOFF: cn.nukkit.level.Sound
        public static MOB_BEE_AGGRESSIVE: cn.nukkit.level.Sound
        public static MOB_BEE_DEATH: cn.nukkit.level.Sound
        public static MOB_BEE_HURT: cn.nukkit.level.Sound
        public static MOB_BEE_LOOP: cn.nukkit.level.Sound
        public static MOB_BEE_POLLINATE: cn.nukkit.level.Sound
        public static MOB_BEE_STING: cn.nukkit.level.Sound
        public static MOB_BLAZE_BREATHE: cn.nukkit.level.Sound
        public static MOB_BLAZE_DEATH: cn.nukkit.level.Sound
        public static MOB_BLAZE_HIT: cn.nukkit.level.Sound
        public static MOB_BLAZE_SHOOT: cn.nukkit.level.Sound
        public static MOB_CAT_BEG: cn.nukkit.level.Sound
        public static MOB_CAT_EAT: cn.nukkit.level.Sound
        public static MOB_CAT_HISS: cn.nukkit.level.Sound
        public static MOB_CAT_HIT: cn.nukkit.level.Sound
        public static MOB_CAT_MEOW: cn.nukkit.level.Sound
        public static MOB_CAT_PURR: cn.nukkit.level.Sound
        public static MOB_CAT_PURREOW: cn.nukkit.level.Sound
        public static MOB_CAT_STRAYMEOW: cn.nukkit.level.Sound
        public static MOB_CHICKEN_HURT: cn.nukkit.level.Sound
        public static MOB_CHICKEN_PLOP: cn.nukkit.level.Sound
        public static MOB_CHICKEN_SAY: cn.nukkit.level.Sound
        public static MOB_CHICKEN_STEP: cn.nukkit.level.Sound
        public static MOB_COW_HURT: cn.nukkit.level.Sound
        public static MOB_COW_MILK: cn.nukkit.level.Sound
        public static MOB_COW_SAY: cn.nukkit.level.Sound
        public static MOB_COW_STEP: cn.nukkit.level.Sound
        public static MOB_CREEPER_DEATH: cn.nukkit.level.Sound
        public static MOB_CREEPER_SAY: cn.nukkit.level.Sound
        public static MOB_DOLPHIN_ATTACK: cn.nukkit.level.Sound
        public static MOB_DOLPHIN_BLOWHOLE: cn.nukkit.level.Sound
        public static MOB_DOLPHIN_DEATH: cn.nukkit.level.Sound
        public static MOB_DOLPHIN_EAT: cn.nukkit.level.Sound
        public static MOB_DOLPHIN_HURT: cn.nukkit.level.Sound
        public static MOB_DOLPHIN_IDLE: cn.nukkit.level.Sound
        public static MOB_DOLPHIN_IDLE_WATER: cn.nukkit.level.Sound
        public static MOB_DOLPHIN_JUMP: cn.nukkit.level.Sound
        public static MOB_DOLPHIN_PLAY: cn.nukkit.level.Sound
        public static MOB_DOLPHIN_SPLASH: cn.nukkit.level.Sound
        public static MOB_DOLPHIN_SWIM: cn.nukkit.level.Sound
        public static MOB_DROWNED_DEATH: cn.nukkit.level.Sound
        public static MOB_DROWNED_DEATH_WATER: cn.nukkit.level.Sound
        public static MOB_DROWNED_HURT: cn.nukkit.level.Sound
        public static MOB_DROWNED_HURT_WATER: cn.nukkit.level.Sound
        public static MOB_DROWNED_SAY: cn.nukkit.level.Sound
        public static MOB_DROWNED_SAY_WATER: cn.nukkit.level.Sound
        public static MOB_DROWNED_SHOOT: cn.nukkit.level.Sound
        public static MOB_DROWNED_STEP: cn.nukkit.level.Sound
        public static MOB_DROWNED_SWIM: cn.nukkit.level.Sound
        public static MOB_ELDERGUARDIAN_CURSE: cn.nukkit.level.Sound
        public static MOB_ELDERGUARDIAN_DEATH: cn.nukkit.level.Sound
        public static MOB_ELDERGUARDIAN_HIT: cn.nukkit.level.Sound
        public static MOB_ELDERGUARDIAN_IDLE: cn.nukkit.level.Sound
        public static MOB_ENDERDRAGON_DEATH: cn.nukkit.level.Sound
        public static MOB_ENDERDRAGON_FLAP: cn.nukkit.level.Sound
        public static MOB_ENDERDRAGON_GROWL: cn.nukkit.level.Sound
        public static MOB_ENDERDRAGON_HIT: cn.nukkit.level.Sound
        public static MOB_ENDERMEN_DEATH: cn.nukkit.level.Sound
        public static MOB_ENDERMEN_HIT: cn.nukkit.level.Sound
        public static MOB_ENDERMEN_IDLE: cn.nukkit.level.Sound
        public static MOB_ENDERMEN_PORTAL: cn.nukkit.level.Sound
        public static MOB_ENDERMEN_SCREAM: cn.nukkit.level.Sound
        public static MOB_ENDERMEN_STARE: cn.nukkit.level.Sound
        public static MOB_ENDERMITE_HIT: cn.nukkit.level.Sound
        public static MOB_ENDERMITE_KILL: cn.nukkit.level.Sound
        public static MOB_ENDERMITE_SAY: cn.nukkit.level.Sound
        public static MOB_ENDERMITE_STEP: cn.nukkit.level.Sound
        public static MOB_EVOCATION_FANGS_ATTACK: cn.nukkit.level.Sound
        public static MOB_EVOCATION_ILLAGER_AMBIENT: cn.nukkit.level.Sound
        public static MOB_EVOCATION_ILLAGER_CAST_SPELL: cn.nukkit.level.Sound
        public static MOB_EVOCATION_ILLAGER_CELEBRATE: cn.nukkit.level.Sound
        public static MOB_EVOCATION_ILLAGER_DEATH: cn.nukkit.level.Sound
        public static MOB_EVOCATION_ILLAGER_HURT: cn.nukkit.level.Sound
        public static MOB_EVOCATION_ILLAGER_PREPARE_ATTACK: cn.nukkit.level.Sound
        public static MOB_EVOCATION_ILLAGER_PREPARE_SUMMON: cn.nukkit.level.Sound
        public static MOB_EVOCATION_ILLAGER_PREPARE_WOLOLO: cn.nukkit.level.Sound
        public static MOB_FISH_FLOP: cn.nukkit.level.Sound
        public static MOB_FISH_HURT: cn.nukkit.level.Sound
        public static MOB_FISH_STEP: cn.nukkit.level.Sound
        public static MOB_FOX_AGGRO: cn.nukkit.level.Sound
        public static MOB_FOX_AMBIENT: cn.nukkit.level.Sound
        public static MOB_FOX_BITE: cn.nukkit.level.Sound
        public static MOB_FOX_DEATH: cn.nukkit.level.Sound
        public static MOB_FOX_EAT: cn.nukkit.level.Sound
        public static MOB_FOX_HURT: cn.nukkit.level.Sound
        public static MOB_FOX_SCREECH: cn.nukkit.level.Sound
        public static MOB_FOX_SLEEP: cn.nukkit.level.Sound
        public static MOB_FOX_SNIFF: cn.nukkit.level.Sound
        public static MOB_FOX_SPIT: cn.nukkit.level.Sound
        public static MOB_FROG_AMBIENT: cn.nukkit.level.Sound
        public static MOB_FROG_DEATH: cn.nukkit.level.Sound
        public static MOB_FROG_EAT: cn.nukkit.level.Sound
        public static MOB_FROG_HURT: cn.nukkit.level.Sound
        public static MOB_FROG_JUMP_TO_BLOCK: cn.nukkit.level.Sound
        public static MOB_FROG_LAY_SPAWN: cn.nukkit.level.Sound
        public static MOB_FROG_STEP: cn.nukkit.level.Sound
        public static MOB_FROG_TONGUE: cn.nukkit.level.Sound
        public static MOB_GHAST_AFFECTIONATE_SCREAM: cn.nukkit.level.Sound
        public static MOB_GHAST_CHARGE: cn.nukkit.level.Sound
        public static MOB_GHAST_DEATH: cn.nukkit.level.Sound
        public static MOB_GHAST_FIREBALL: cn.nukkit.level.Sound
        public static MOB_GHAST_MOAN: cn.nukkit.level.Sound
        public static MOB_GHAST_SCREAM: cn.nukkit.level.Sound
        public static MOB_GLOW_SQUID_AMBIENT: cn.nukkit.level.Sound
        public static MOB_GLOW_SQUID_DEATH: cn.nukkit.level.Sound
        public static MOB_GLOW_SQUID_HURT: cn.nukkit.level.Sound
        public static MOB_GLOW_SQUID_INK_SQUIRT: cn.nukkit.level.Sound
        public static MOB_GOAT_AMBIENT: cn.nukkit.level.Sound
        public static MOB_GOAT_AMBIENT_SCREAMER: cn.nukkit.level.Sound
        public static MOB_GOAT_DEATH: cn.nukkit.level.Sound
        public static MOB_GOAT_DEATH_SCREAMER: cn.nukkit.level.Sound
        public static MOB_GOAT_EAT: cn.nukkit.level.Sound
        public static MOB_GOAT_HORN_BREAK: cn.nukkit.level.Sound
        public static MOB_GOAT_HURT: cn.nukkit.level.Sound
        public static MOB_GOAT_HURT_SCREAMER: cn.nukkit.level.Sound
        public static MOB_GOAT_MILK_SCREAMER: cn.nukkit.level.Sound
        public static MOB_GOAT_PREPARE_RAM: cn.nukkit.level.Sound
        public static MOB_GOAT_PREPARE_RAM_SCREAMER: cn.nukkit.level.Sound
        public static MOB_GOAT_RAM_IMPACT: cn.nukkit.level.Sound
        public static MOB_GOAT_RAM_IMPACT_SCREAMER: cn.nukkit.level.Sound
        public static MOB_GOAT_STEP: cn.nukkit.level.Sound
        public static MOB_GUARDIAN_AMBIENT: cn.nukkit.level.Sound
        public static MOB_GUARDIAN_ATTACK_LOOP: cn.nukkit.level.Sound
        public static MOB_GUARDIAN_DEATH: cn.nukkit.level.Sound
        public static MOB_GUARDIAN_FLOP: cn.nukkit.level.Sound
        public static MOB_GUARDIAN_HIT: cn.nukkit.level.Sound
        public static MOB_GUARDIAN_LAND_DEATH: cn.nukkit.level.Sound
        public static MOB_GUARDIAN_LAND_HIT: cn.nukkit.level.Sound
        public static MOB_GUARDIAN_LAND_IDLE: cn.nukkit.level.Sound
        public static MOB_HOGLIN_AMBIENT: cn.nukkit.level.Sound
        public static MOB_HOGLIN_ANGRY: cn.nukkit.level.Sound
        public static MOB_HOGLIN_ATTACK: cn.nukkit.level.Sound
        public static MOB_HOGLIN_DEATH: cn.nukkit.level.Sound
        public static MOB_HOGLIN_HOWL: cn.nukkit.level.Sound
        public static MOB_HOGLIN_HURT: cn.nukkit.level.Sound
        public static MOB_HOGLIN_RETREAT: cn.nukkit.level.Sound
        public static MOB_HOGLIN_STEP: cn.nukkit.level.Sound
        public static MOB_HORSE_ANGRY: cn.nukkit.level.Sound
        public static MOB_HORSE_ARMOR: cn.nukkit.level.Sound
        public static MOB_HORSE_BREATHE: cn.nukkit.level.Sound
        public static MOB_HORSE_DEATH: cn.nukkit.level.Sound
        public static MOB_HORSE_DONKEY_ANGRY: cn.nukkit.level.Sound
        public static MOB_HORSE_DONKEY_DEATH: cn.nukkit.level.Sound
        public static MOB_HORSE_DONKEY_HIT: cn.nukkit.level.Sound
        public static MOB_HORSE_DONKEY_IDLE: cn.nukkit.level.Sound
        public static MOB_HORSE_EAT: cn.nukkit.level.Sound
        public static MOB_HORSE_GALLOP: cn.nukkit.level.Sound
        public static MOB_HORSE_HIT: cn.nukkit.level.Sound
        public static MOB_HORSE_IDLE: cn.nukkit.level.Sound
        public static MOB_HORSE_JUMP: cn.nukkit.level.Sound
        public static MOB_HORSE_LAND: cn.nukkit.level.Sound
        public static MOB_HORSE_LEATHER: cn.nukkit.level.Sound
        public static MOB_HORSE_SKELETON_DEATH: cn.nukkit.level.Sound
        public static MOB_HORSE_SKELETON_HIT: cn.nukkit.level.Sound
        public static MOB_HORSE_SKELETON_IDLE: cn.nukkit.level.Sound
        public static MOB_HORSE_SOFT: cn.nukkit.level.Sound
        public static MOB_HORSE_WOOD: cn.nukkit.level.Sound
        public static MOB_HORSE_ZOMBIE_DEATH: cn.nukkit.level.Sound
        public static MOB_HORSE_ZOMBIE_HIT: cn.nukkit.level.Sound
        public static MOB_HORSE_ZOMBIE_IDLE: cn.nukkit.level.Sound
        public static MOB_HUSK_AMBIENT: cn.nukkit.level.Sound
        public static MOB_HUSK_DEATH: cn.nukkit.level.Sound
        public static MOB_HUSK_HURT: cn.nukkit.level.Sound
        public static MOB_HUSK_STEP: cn.nukkit.level.Sound
        public static MOB_IRONGOLEM_CRACK: cn.nukkit.level.Sound
        public static MOB_IRONGOLEM_DEATH: cn.nukkit.level.Sound
        public static MOB_IRONGOLEM_HIT: cn.nukkit.level.Sound
        public static MOB_IRONGOLEM_REPAIR: cn.nukkit.level.Sound
        public static MOB_IRONGOLEM_THROW: cn.nukkit.level.Sound
        public static MOB_IRONGOLEM_WALK: cn.nukkit.level.Sound
        public static MOB_LLAMA_ANGRY: cn.nukkit.level.Sound
        public static MOB_LLAMA_DEATH: cn.nukkit.level.Sound
        public static MOB_LLAMA_EAT: cn.nukkit.level.Sound
        public static MOB_LLAMA_HURT: cn.nukkit.level.Sound
        public static MOB_LLAMA_IDLE: cn.nukkit.level.Sound
        public static MOB_LLAMA_SPIT: cn.nukkit.level.Sound
        public static MOB_LLAMA_STEP: cn.nukkit.level.Sound
        public static MOB_LLAMA_SWAG: cn.nukkit.level.Sound
        public static MOB_MAGMACUBE_BIG: cn.nukkit.level.Sound
        public static MOB_MAGMACUBE_JUMP: cn.nukkit.level.Sound
        public static MOB_MAGMACUBE_SMALL: cn.nukkit.level.Sound
        public static MOB_MOOSHROOM_CONVERT: cn.nukkit.level.Sound
        public static MOB_MOOSHROOM_EAT: cn.nukkit.level.Sound
        public static MOB_MOOSHROOM_SUSPICIOUS_MILK: cn.nukkit.level.Sound
        public static MOB_OCELOT_DEATH: cn.nukkit.level.Sound
        public static MOB_OCELOT_IDLE: cn.nukkit.level.Sound
        public static MOB_PANDA_BITE: cn.nukkit.level.Sound
        public static MOB_PANDA_CANT_BREED: cn.nukkit.level.Sound
        public static MOB_PANDA_DEATH: cn.nukkit.level.Sound
        public static MOB_PANDA_EAT: cn.nukkit.level.Sound
        public static MOB_PANDA_HURT: cn.nukkit.level.Sound
        public static MOB_PANDA_IDLE: cn.nukkit.level.Sound
        public static MOB_PANDA_IDLE_AGGRESSIVE: cn.nukkit.level.Sound
        public static MOB_PANDA_IDLE_WORRIED: cn.nukkit.level.Sound
        public static MOB_PANDA_PRESNEEZE: cn.nukkit.level.Sound
        public static MOB_PANDA_SNEEZE: cn.nukkit.level.Sound
        public static MOB_PANDA_STEP: cn.nukkit.level.Sound
        public static MOB_PANDA_BABY_IDLE: cn.nukkit.level.Sound
        public static MOB_PARROT_DEATH: cn.nukkit.level.Sound
        public static MOB_PARROT_EAT: cn.nukkit.level.Sound
        public static MOB_PARROT_FLY: cn.nukkit.level.Sound
        public static MOB_PARROT_HURT: cn.nukkit.level.Sound
        public static MOB_PARROT_IDLE: cn.nukkit.level.Sound
        public static MOB_PARROT_STEP: cn.nukkit.level.Sound
        public static MOB_PHANTOM_BITE: cn.nukkit.level.Sound
        public static MOB_PHANTOM_DEATH: cn.nukkit.level.Sound
        public static MOB_PHANTOM_FLAP: cn.nukkit.level.Sound
        public static MOB_PHANTOM_HURT: cn.nukkit.level.Sound
        public static MOB_PHANTOM_IDLE: cn.nukkit.level.Sound
        public static MOB_PHANTOM_SWOOP: cn.nukkit.level.Sound
        public static MOB_PIG_BOOST: cn.nukkit.level.Sound
        public static MOB_PIG_DEATH: cn.nukkit.level.Sound
        public static MOB_PIG_SAY: cn.nukkit.level.Sound
        public static MOB_PIG_STEP: cn.nukkit.level.Sound
        public static MOB_PIGLIN_ADMIRING_ITEM: cn.nukkit.level.Sound
        public static MOB_PIGLIN_AMBIENT: cn.nukkit.level.Sound
        public static MOB_PIGLIN_ANGRY: cn.nukkit.level.Sound
        public static MOB_PIGLIN_CELEBRATE: cn.nukkit.level.Sound
        public static MOB_PIGLIN_CONVERTED_TO_ZOMBIFIED: cn.nukkit.level.Sound
        public static MOB_PIGLIN_DEATH: cn.nukkit.level.Sound
        public static MOB_PIGLIN_HURT: cn.nukkit.level.Sound
        public static MOB_PIGLIN_JEALOUS: cn.nukkit.level.Sound
        public static MOB_PIGLIN_RETREAT: cn.nukkit.level.Sound
        public static MOB_PIGLIN_STEP: cn.nukkit.level.Sound
        public static MOB_PIGLIN_BRUTE_AMBIENT: cn.nukkit.level.Sound
        public static MOB_PIGLIN_BRUTE_ANGRY: cn.nukkit.level.Sound
        public static MOB_PIGLIN_BRUTE_CONVERTED_TO_ZOMBIFIED: cn.nukkit.level.Sound
        public static MOB_PIGLIN_BRUTE_DEATH: cn.nukkit.level.Sound
        public static MOB_PIGLIN_BRUTE_HURT: cn.nukkit.level.Sound
        public static MOB_PIGLIN_BRUTE_STEP: cn.nukkit.level.Sound
        public static MOB_PILLAGER_CELEBRATE: cn.nukkit.level.Sound
        public static MOB_PILLAGER_DEATH: cn.nukkit.level.Sound
        public static MOB_PILLAGER_HURT: cn.nukkit.level.Sound
        public static MOB_PILLAGER_IDLE: cn.nukkit.level.Sound
        public static MOB_PLAYER_HURT_DROWN: cn.nukkit.level.Sound
        public static MOB_PLAYER_HURT_FREEZE: cn.nukkit.level.Sound
        public static MOB_PLAYER_HURT_ON_FIRE: cn.nukkit.level.Sound
        public static MOB_POLARBEAR_DEATH: cn.nukkit.level.Sound
        public static MOB_POLARBEAR_HURT: cn.nukkit.level.Sound
        public static MOB_POLARBEAR_IDLE: cn.nukkit.level.Sound
        public static MOB_POLARBEAR_STEP: cn.nukkit.level.Sound
        public static MOB_POLARBEAR_WARNING: cn.nukkit.level.Sound
        public static MOB_POLARBEAR_BABY_IDLE: cn.nukkit.level.Sound
        public static MOB_RABBIT_DEATH: cn.nukkit.level.Sound
        public static MOB_RABBIT_HOP: cn.nukkit.level.Sound
        public static MOB_RABBIT_HURT: cn.nukkit.level.Sound
        public static MOB_RABBIT_IDLE: cn.nukkit.level.Sound
        public static MOB_RAVAGER_AMBIENT: cn.nukkit.level.Sound
        public static MOB_RAVAGER_BITE: cn.nukkit.level.Sound
        public static MOB_RAVAGER_CELEBRATE: cn.nukkit.level.Sound
        public static MOB_RAVAGER_DEATH: cn.nukkit.level.Sound
        public static MOB_RAVAGER_HURT: cn.nukkit.level.Sound
        public static MOB_RAVAGER_ROAR: cn.nukkit.level.Sound
        public static MOB_RAVAGER_STEP: cn.nukkit.level.Sound
        public static MOB_RAVAGER_STUN: cn.nukkit.level.Sound
        public static MOB_SHEEP_SAY: cn.nukkit.level.Sound
        public static MOB_SHEEP_SHEAR: cn.nukkit.level.Sound
        public static MOB_SHEEP_STEP: cn.nukkit.level.Sound
        public static MOB_SHULKER_AMBIENT: cn.nukkit.level.Sound
        public static MOB_SHULKER_BULLET_HIT: cn.nukkit.level.Sound
        public static MOB_SHULKER_CLOSE: cn.nukkit.level.Sound
        public static MOB_SHULKER_CLOSE_HURT: cn.nukkit.level.Sound
        public static MOB_SHULKER_DEATH: cn.nukkit.level.Sound
        public static MOB_SHULKER_HURT: cn.nukkit.level.Sound
        public static MOB_SHULKER_OPEN: cn.nukkit.level.Sound
        public static MOB_SHULKER_SHOOT: cn.nukkit.level.Sound
        public static MOB_SHULKER_TELEPORT: cn.nukkit.level.Sound
        public static MOB_SILVERFISH_HIT: cn.nukkit.level.Sound
        public static MOB_SILVERFISH_KILL: cn.nukkit.level.Sound
        public static MOB_SILVERFISH_SAY: cn.nukkit.level.Sound
        public static MOB_SILVERFISH_STEP: cn.nukkit.level.Sound
        public static MOB_SKELETON_CONVERT_TO_STRAY: cn.nukkit.level.Sound
        public static MOB_SKELETON_DEATH: cn.nukkit.level.Sound
        public static MOB_SKELETON_HURT: cn.nukkit.level.Sound
        public static MOB_SKELETON_SAY: cn.nukkit.level.Sound
        public static MOB_SKELETON_STEP: cn.nukkit.level.Sound
        public static MOB_SLIME_ATTACK: cn.nukkit.level.Sound
        public static MOB_SLIME_BIG: cn.nukkit.level.Sound
        public static MOB_SLIME_DEATH: cn.nukkit.level.Sound
        public static MOB_SLIME_HURT: cn.nukkit.level.Sound
        public static MOB_SLIME_JUMP: cn.nukkit.level.Sound
        public static MOB_SLIME_SMALL: cn.nukkit.level.Sound
        public static MOB_SLIME_SQUISH: cn.nukkit.level.Sound
        public static MOB_SNOWGOLEM_DEATH: cn.nukkit.level.Sound
        public static MOB_SNOWGOLEM_HURT: cn.nukkit.level.Sound
        public static MOB_SNOWGOLEM_SHOOT: cn.nukkit.level.Sound
        public static MOB_SPIDER_DEATH: cn.nukkit.level.Sound
        public static MOB_SPIDER_SAY: cn.nukkit.level.Sound
        public static MOB_SPIDER_STEP: cn.nukkit.level.Sound
        public static MOB_SQUID_AMBIENT: cn.nukkit.level.Sound
        public static MOB_SQUID_DEATH: cn.nukkit.level.Sound
        public static MOB_SQUID_HURT: cn.nukkit.level.Sound
        public static MOB_SQUID_INK_SQUIRT: cn.nukkit.level.Sound
        public static MOB_STRAY_AMBIENT: cn.nukkit.level.Sound
        public static MOB_STRAY_DEATH: cn.nukkit.level.Sound
        public static MOB_STRAY_HURT: cn.nukkit.level.Sound
        public static MOB_STRAY_STEP: cn.nukkit.level.Sound
        public static MOB_STRIDER_DEATH: cn.nukkit.level.Sound
        public static MOB_STRIDER_EAT: cn.nukkit.level.Sound
        public static MOB_STRIDER_HURT: cn.nukkit.level.Sound
        public static MOB_STRIDER_IDLE: cn.nukkit.level.Sound
        public static MOB_STRIDER_PANIC: cn.nukkit.level.Sound
        public static MOB_STRIDER_STEP: cn.nukkit.level.Sound
        public static MOB_STRIDER_STEP_LAVA: cn.nukkit.level.Sound
        public static MOB_STRIDER_TEMPT: cn.nukkit.level.Sound
        public static MOB_TADPOLE_CONVERT_TO_FROG: cn.nukkit.level.Sound
        public static MOB_TADPOLE_DEATH: cn.nukkit.level.Sound
        public static MOB_TADPOLE_HURT: cn.nukkit.level.Sound
        public static MOB_TURTLE_AMBIENT: cn.nukkit.level.Sound
        public static MOB_TURTLE_DEATH: cn.nukkit.level.Sound
        public static MOB_TURTLE_HURT: cn.nukkit.level.Sound
        public static MOB_TURTLE_STEP: cn.nukkit.level.Sound
        public static MOB_TURTLE_SWIM: cn.nukkit.level.Sound
        public static MOB_TURTLE_BABY_BORN: cn.nukkit.level.Sound
        public static MOB_TURTLE_BABY_DEATH: cn.nukkit.level.Sound
        public static MOB_TURTLE_BABY_HURT: cn.nukkit.level.Sound
        public static MOB_TURTLE_BABY_STEP: cn.nukkit.level.Sound
        public static MOB_VEX_AMBIENT: cn.nukkit.level.Sound
        public static MOB_VEX_CHARGE: cn.nukkit.level.Sound
        public static MOB_VEX_DEATH: cn.nukkit.level.Sound
        public static MOB_VEX_HURT: cn.nukkit.level.Sound
        public static MOB_VILLAGER_DEATH: cn.nukkit.level.Sound
        public static MOB_VILLAGER_HAGGLE: cn.nukkit.level.Sound
        public static MOB_VILLAGER_HIT: cn.nukkit.level.Sound
        public static MOB_VILLAGER_IDLE: cn.nukkit.level.Sound
        public static MOB_VILLAGER_NO: cn.nukkit.level.Sound
        public static MOB_VILLAGER_YES: cn.nukkit.level.Sound
        public static MOB_VINDICATOR_CELEBRATE: cn.nukkit.level.Sound
        public static MOB_VINDICATOR_DEATH: cn.nukkit.level.Sound
        public static MOB_VINDICATOR_HURT: cn.nukkit.level.Sound
        public static MOB_VINDICATOR_IDLE: cn.nukkit.level.Sound
        public static MOB_WANDERINGTRADER_DEATH: cn.nukkit.level.Sound
        public static MOB_WANDERINGTRADER_DISAPPEARED: cn.nukkit.level.Sound
        public static MOB_WANDERINGTRADER_DRINK_MILK: cn.nukkit.level.Sound
        public static MOB_WANDERINGTRADER_DRINK_POTION: cn.nukkit.level.Sound
        public static MOB_WANDERINGTRADER_HAGGLE: cn.nukkit.level.Sound
        public static MOB_WANDERINGTRADER_HURT: cn.nukkit.level.Sound
        public static MOB_WANDERINGTRADER_IDLE: cn.nukkit.level.Sound
        public static MOB_WANDERINGTRADER_NO: cn.nukkit.level.Sound
        public static MOB_WANDERINGTRADER_REAPPEARED: cn.nukkit.level.Sound
        public static MOB_WANDERINGTRADER_YES: cn.nukkit.level.Sound
        public static MOB_WARDEN_AGITATED: cn.nukkit.level.Sound
        public static MOB_WARDEN_ANGRY: cn.nukkit.level.Sound
        public static MOB_WARDEN_ATTACK: cn.nukkit.level.Sound
        public static MOB_WARDEN_CLICKING: cn.nukkit.level.Sound
        public static MOB_WARDEN_DEATH: cn.nukkit.level.Sound
        public static MOB_WARDEN_DIG: cn.nukkit.level.Sound
        public static MOB_WARDEN_EMERGE: cn.nukkit.level.Sound
        public static MOB_WARDEN_HEARTBEAT: cn.nukkit.level.Sound
        public static MOB_WARDEN_HURT: cn.nukkit.level.Sound
        public static MOB_WARDEN_IDLE: cn.nukkit.level.Sound
        public static MOB_WARDEN_LISTENING: cn.nukkit.level.Sound
        public static MOB_WARDEN_LISTENING_ANGRY: cn.nukkit.level.Sound
        public static MOB_WARDEN_NEARBY_CLOSE: cn.nukkit.level.Sound
        public static MOB_WARDEN_NEARBY_CLOSER: cn.nukkit.level.Sound
        public static MOB_WARDEN_NEARBY_CLOSEST: cn.nukkit.level.Sound
        public static MOB_WARDEN_ROAR: cn.nukkit.level.Sound
        public static MOB_WARDEN_SNIFF: cn.nukkit.level.Sound
        public static MOB_WARDEN_SONIC_BOOM: cn.nukkit.level.Sound
        public static MOB_WARDEN_SONIC_CHARGE: cn.nukkit.level.Sound
        public static MOB_WARDEN_STEP: cn.nukkit.level.Sound
        public static MOB_WITCH_AMBIENT: cn.nukkit.level.Sound
        public static MOB_WITCH_CELEBRATE: cn.nukkit.level.Sound
        public static MOB_WITCH_DEATH: cn.nukkit.level.Sound
        public static MOB_WITCH_DRINK: cn.nukkit.level.Sound
        public static MOB_WITCH_HURT: cn.nukkit.level.Sound
        public static MOB_WITCH_THROW: cn.nukkit.level.Sound
        public static MOB_WITHER_AMBIENT: cn.nukkit.level.Sound
        public static MOB_WITHER_BREAK_BLOCK: cn.nukkit.level.Sound
        public static MOB_WITHER_DEATH: cn.nukkit.level.Sound
        public static MOB_WITHER_HURT: cn.nukkit.level.Sound
        public static MOB_WITHER_SHOOT: cn.nukkit.level.Sound
        public static MOB_WITHER_SPAWN: cn.nukkit.level.Sound
        public static MOB_WOLF_BARK: cn.nukkit.level.Sound
        public static MOB_WOLF_DEATH: cn.nukkit.level.Sound
        public static MOB_WOLF_GROWL: cn.nukkit.level.Sound
        public static MOB_WOLF_HURT: cn.nukkit.level.Sound
        public static MOB_WOLF_PANTING: cn.nukkit.level.Sound
        public static MOB_WOLF_SHAKE: cn.nukkit.level.Sound
        public static MOB_WOLF_STEP: cn.nukkit.level.Sound
        public static MOB_WOLF_WHINE: cn.nukkit.level.Sound
        public static MOB_ZOGLIN_ANGRY: cn.nukkit.level.Sound
        public static MOB_ZOGLIN_ATTACK: cn.nukkit.level.Sound
        public static MOB_ZOGLIN_DEATH: cn.nukkit.level.Sound
        public static MOB_ZOGLIN_HURT: cn.nukkit.level.Sound
        public static MOB_ZOGLIN_IDLE: cn.nukkit.level.Sound
        public static MOB_ZOGLIN_STEP: cn.nukkit.level.Sound
        public static MOB_ZOMBIE_DEATH: cn.nukkit.level.Sound
        public static MOB_ZOMBIE_HURT: cn.nukkit.level.Sound
        public static MOB_ZOMBIE_REMEDY: cn.nukkit.level.Sound
        public static MOB_ZOMBIE_SAY: cn.nukkit.level.Sound
        public static MOB_ZOMBIE_STEP: cn.nukkit.level.Sound
        public static MOB_ZOMBIE_UNFECT: cn.nukkit.level.Sound
        public static MOB_ZOMBIE_WOOD: cn.nukkit.level.Sound
        public static MOB_ZOMBIE_WOODBREAK: cn.nukkit.level.Sound
        public static MOB_ZOMBIE_VILLAGER_DEATH: cn.nukkit.level.Sound
        public static MOB_ZOMBIE_VILLAGER_HURT: cn.nukkit.level.Sound
        public static MOB_ZOMBIE_VILLAGER_SAY: cn.nukkit.level.Sound
        public static MOB_ZOMBIEPIG_ZPIG: cn.nukkit.level.Sound
        public static MOB_ZOMBIEPIG_ZPIGANGRY: cn.nukkit.level.Sound
        public static MOB_ZOMBIEPIG_ZPIGDEATH: cn.nukkit.level.Sound
        public static MOB_ZOMBIEPIG_ZPIGHURT: cn.nukkit.level.Sound
        public static MUSIC_GAME: cn.nukkit.level.Sound
        public static MUSIC_GAME_BASALT_DELTAS: cn.nukkit.level.Sound
        public static MUSIC_GAME_CREATIVE: cn.nukkit.level.Sound
        public static MUSIC_GAME_CREDITS: cn.nukkit.level.Sound
        public static MUSIC_GAME_CRIMSON_FOREST: cn.nukkit.level.Sound
        public static MUSIC_GAME_DEEP_DARK: cn.nukkit.level.Sound
        public static MUSIC_GAME_DRIPSTONE_CAVES: cn.nukkit.level.Sound
        public static MUSIC_GAME_END: cn.nukkit.level.Sound
        public static MUSIC_GAME_ENDBOSS: cn.nukkit.level.Sound
        public static MUSIC_GAME_FROZEN_PEAKS: cn.nukkit.level.Sound
        public static MUSIC_GAME_GROVE: cn.nukkit.level.Sound
        public static MUSIC_GAME_JAGGED_PEAKS: cn.nukkit.level.Sound
        public static MUSIC_GAME_LUSH_CAVES: cn.nukkit.level.Sound
        public static MUSIC_GAME_MEADOW: cn.nukkit.level.Sound
        public static MUSIC_GAME_NETHER: cn.nukkit.level.Sound
        public static MUSIC_GAME_NETHER_WASTES: cn.nukkit.level.Sound
        public static MUSIC_GAME_SNOWY_SLOPES: cn.nukkit.level.Sound
        public static MUSIC_GAME_SOUL_SAND_VALLEY: cn.nukkit.level.Sound
        public static MUSIC_GAME_SOULSAND_VALLEY: cn.nukkit.level.Sound
        public static MUSIC_GAME_STONY_PEAKS: cn.nukkit.level.Sound
        public static MUSIC_GAME_SWAMP_MUSIC: cn.nukkit.level.Sound
        public static MUSIC_GAME_WARPED_FOREST: cn.nukkit.level.Sound
        public static MUSIC_GAME_WATER: cn.nukkit.level.Sound
        public static MUSIC_GAME_AND_WILD_EQUAL_CHANCE: cn.nukkit.level.Sound
        public static MUSIC_GAME_AND_WILD_FAVOR_GAME: cn.nukkit.level.Sound
        public static MUSIC_MENU: cn.nukkit.level.Sound
        public static NOTE_BANJO: cn.nukkit.level.Sound
        public static NOTE_BASS: cn.nukkit.level.Sound
        public static NOTE_BASSATTACK: cn.nukkit.level.Sound
        public static NOTE_BD: cn.nukkit.level.Sound
        public static NOTE_BELL: cn.nukkit.level.Sound
        public static NOTE_BIT: cn.nukkit.level.Sound
        public static NOTE_CHIME: cn.nukkit.level.Sound
        public static NOTE_COW_BELL: cn.nukkit.level.Sound
        public static NOTE_DIDGERIDOO: cn.nukkit.level.Sound
        public static NOTE_FLUTE: cn.nukkit.level.Sound
        public static NOTE_GUITAR: cn.nukkit.level.Sound
        public static NOTE_HARP: cn.nukkit.level.Sound
        public static NOTE_HAT: cn.nukkit.level.Sound
        public static NOTE_IRON_XYLOPHONE: cn.nukkit.level.Sound
        public static NOTE_PLING: cn.nukkit.level.Sound
        public static NOTE_SNARE: cn.nukkit.level.Sound
        public static NOTE_XYLOPHONE: cn.nukkit.level.Sound
        public static PARTICLE_SOUL_ESCAPE: cn.nukkit.level.Sound
        public static PICK_BERRIES_CAVE_VINES: cn.nukkit.level.Sound
        public static PLACE_AMETHYST_BLOCK: cn.nukkit.level.Sound
        public static PLACE_AMETHYST_CLUSTER: cn.nukkit.level.Sound
        public static PLACE_AZALEA: cn.nukkit.level.Sound
        public static PLACE_AZALEA_LEAVES: cn.nukkit.level.Sound
        public static PLACE_BIG_DRIPLEAF: cn.nukkit.level.Sound
        public static PLACE_CALCITE: cn.nukkit.level.Sound
        public static PLACE_COPPER: cn.nukkit.level.Sound
        public static PLACE_DEEPSLATE: cn.nukkit.level.Sound
        public static PLACE_DEEPSLATE_BRICKS: cn.nukkit.level.Sound
        public static PLACE_DIRT_WITH_ROOTS: cn.nukkit.level.Sound
        public static PLACE_DRIPSTONE_BLOCK: cn.nukkit.level.Sound
        public static PLACE_HANGING_ROOTS: cn.nukkit.level.Sound
        public static PLACE_LARGE_AMETHYST_BUD: cn.nukkit.level.Sound
        public static PLACE_MEDIUM_AMETHYST_BUD: cn.nukkit.level.Sound
        public static PLACE_MOSS: cn.nukkit.level.Sound
        public static PLACE_POINTED_DRIPSTONE: cn.nukkit.level.Sound
        public static PLACE_POWDER_SNOW: cn.nukkit.level.Sound
        public static PLACE_SCULK: cn.nukkit.level.Sound
        public static PLACE_SCULK_CATALYST: cn.nukkit.level.Sound
        public static PLACE_SCULK_SENSOR: cn.nukkit.level.Sound
        public static PLACE_SCULK_SHRIEKER: cn.nukkit.level.Sound
        public static PLACE_SMALL_AMETHYST_BUD: cn.nukkit.level.Sound
        public static PLACE_SPORE_BLOSSOM: cn.nukkit.level.Sound
        public static PLACE_TUFF: cn.nukkit.level.Sound
        public static PORTAL_PORTAL: cn.nukkit.level.Sound
        public static PORTAL_TRAVEL: cn.nukkit.level.Sound
        public static PORTAL_TRIGGER: cn.nukkit.level.Sound
        public static POWER_OFF_SCULK_SENSOR: cn.nukkit.level.Sound
        public static POWER_ON_SCULK_SENSOR: cn.nukkit.level.Sound
        public static RAID_HORN: cn.nukkit.level.Sound
        public static RANDOM_ANVIL_BREAK: cn.nukkit.level.Sound
        public static RANDOM_ANVIL_LAND: cn.nukkit.level.Sound
        public static RANDOM_ANVIL_USE: cn.nukkit.level.Sound
        public static RANDOM_BOW: cn.nukkit.level.Sound
        public static RANDOM_BOWHIT: cn.nukkit.level.Sound
        public static RANDOM_BREAK: cn.nukkit.level.Sound
        public static RANDOM_BURP: cn.nukkit.level.Sound
        public static RANDOM_CHESTCLOSED: cn.nukkit.level.Sound
        public static RANDOM_CHESTOPEN: cn.nukkit.level.Sound
        public static RANDOM_CLICK: cn.nukkit.level.Sound
        public static RANDOM_DOOR_CLOSE: cn.nukkit.level.Sound
        public static RANDOM_DOOR_OPEN: cn.nukkit.level.Sound
        public static RANDOM_DRINK: cn.nukkit.level.Sound
        public static RANDOM_DRINK_HONEY: cn.nukkit.level.Sound
        public static RANDOM_EAT: cn.nukkit.level.Sound
        public static RANDOM_ENDERCHESTCLOSED: cn.nukkit.level.Sound
        public static RANDOM_ENDERCHESTOPEN: cn.nukkit.level.Sound
        public static RANDOM_EXPLODE: cn.nukkit.level.Sound
        public static RANDOM_FIZZ: cn.nukkit.level.Sound
        public static RANDOM_FUSE: cn.nukkit.level.Sound
        public static RANDOM_GLASS: cn.nukkit.level.Sound
        public static RANDOM_HURT: cn.nukkit.level.Sound
        public static RANDOM_LEVELUP: cn.nukkit.level.Sound
        public static RANDOM_ORB: cn.nukkit.level.Sound
        public static RANDOM_POP: cn.nukkit.level.Sound
        public static RANDOM_POP2: cn.nukkit.level.Sound
        public static RANDOM_POTION_BREWED: cn.nukkit.level.Sound
        public static RANDOM_SCREENSHOT: cn.nukkit.level.Sound
        public static RANDOM_SHULKERBOXCLOSED: cn.nukkit.level.Sound
        public static RANDOM_SHULKERBOXOPEN: cn.nukkit.level.Sound
        public static RANDOM_SPLASH: cn.nukkit.level.Sound
        public static RANDOM_SWIM: cn.nukkit.level.Sound
        public static RANDOM_TOAST: cn.nukkit.level.Sound
        public static RANDOM_TOTEM: cn.nukkit.level.Sound
        public static RECORD_11: cn.nukkit.level.Sound
        public static RECORD_13: cn.nukkit.level.Sound
        public static RECORD_5: cn.nukkit.level.Sound
        public static RECORD_BLOCKS: cn.nukkit.level.Sound
        public static RECORD_CAT: cn.nukkit.level.Sound
        public static RECORD_CHIRP: cn.nukkit.level.Sound
        public static RECORD_FAR: cn.nukkit.level.Sound
        public static RECORD_MALL: cn.nukkit.level.Sound
        public static RECORD_MELLOHI: cn.nukkit.level.Sound
        public static RECORD_OTHERSIDE: cn.nukkit.level.Sound
        public static RECORD_PIGSTEP: cn.nukkit.level.Sound
        public static RECORD_STAL: cn.nukkit.level.Sound
        public static RECORD_STRAD: cn.nukkit.level.Sound
        public static RECORD_WAIT: cn.nukkit.level.Sound
        public static RECORD_WARD: cn.nukkit.level.Sound
        public static RESPAWN_ANCHOR_AMBIENT: cn.nukkit.level.Sound
        public static RESPAWN_ANCHOR_CHARGE: cn.nukkit.level.Sound
        public static RESPAWN_ANCHOR_DEPLETE: cn.nukkit.level.Sound
        public static RESPAWN_ANCHOR_SET_SPAWN: cn.nukkit.level.Sound
        public static SCRAPE: cn.nukkit.level.Sound
        public static SHRIEK_SCULK_SHRIEKER: cn.nukkit.level.Sound
        public static SIGN_DYE_USE: cn.nukkit.level.Sound
        public static SIGN_INK_SAC_USE: cn.nukkit.level.Sound
        public static SMITHING_TABLE_USE: cn.nukkit.level.Sound
        public static SPREAD_SCULK: cn.nukkit.level.Sound
        public static STEP_AMETHYST_BLOCK: cn.nukkit.level.Sound
        public static STEP_AMETHYST_CLUSTER: cn.nukkit.level.Sound
        public static STEP_ANCIENT_DEBRIS: cn.nukkit.level.Sound
        public static STEP_AZALEA: cn.nukkit.level.Sound
        public static STEP_AZALEA_LEAVES: cn.nukkit.level.Sound
        public static STEP_BASALT: cn.nukkit.level.Sound
        public static STEP_BIG_DRIPLEAF: cn.nukkit.level.Sound
        public static STEP_BONE_BLOCK: cn.nukkit.level.Sound
        public static STEP_CALCITE: cn.nukkit.level.Sound
        public static STEP_CANDLE: cn.nukkit.level.Sound
        public static STEP_CAVE_VINES: cn.nukkit.level.Sound
        public static STEP_CHAIN: cn.nukkit.level.Sound
        public static STEP_CLOTH: cn.nukkit.level.Sound
        public static STEP_COPPER: cn.nukkit.level.Sound
        public static STEP_CORAL: cn.nukkit.level.Sound
        public static STEP_DEEPSLATE: cn.nukkit.level.Sound
        public static STEP_DEEPSLATE_BRICKS: cn.nukkit.level.Sound
        public static STEP_DIRT_WITH_ROOTS: cn.nukkit.level.Sound
        public static STEP_DRIPSTONE_BLOCK: cn.nukkit.level.Sound
        public static STEP_FROG_SPAWN: cn.nukkit.level.Sound
        public static STEP_FROGLIGHT: cn.nukkit.level.Sound
        public static STEP_GRASS: cn.nukkit.level.Sound
        public static STEP_GRAVEL: cn.nukkit.level.Sound
        public static STEP_HANGING_ROOTS: cn.nukkit.level.Sound
        public static STEP_HONEY_BLOCK: cn.nukkit.level.Sound
        public static STEP_LADDER: cn.nukkit.level.Sound
        public static STEP_MOSS: cn.nukkit.level.Sound
        public static STEP_NETHER_BRICK: cn.nukkit.level.Sound
        public static STEP_NETHER_GOLD_ORE: cn.nukkit.level.Sound
        public static STEP_NETHER_SPROUTS: cn.nukkit.level.Sound
        public static STEP_NETHER_WART: cn.nukkit.level.Sound
        public static STEP_NETHERITE: cn.nukkit.level.Sound
        public static STEP_NETHERRACK: cn.nukkit.level.Sound
        public static STEP_NYLIUM: cn.nukkit.level.Sound
        public static STEP_POINTED_DRIPSTONE: cn.nukkit.level.Sound
        public static STEP_POWDER_SNOW: cn.nukkit.level.Sound
        public static STEP_ROOTS: cn.nukkit.level.Sound
        public static STEP_SAND: cn.nukkit.level.Sound
        public static STEP_SCULK: cn.nukkit.level.Sound
        public static STEP_SCULK_CATALYST: cn.nukkit.level.Sound
        public static STEP_SCULK_SENSOR: cn.nukkit.level.Sound
        public static STEP_SCULK_SHRIEKER: cn.nukkit.level.Sound
        public static STEP_SCULK_VEIN: cn.nukkit.level.Sound
        public static STEP_SHROOMLIGHT: cn.nukkit.level.Sound
        public static STEP_SLIME: cn.nukkit.level.Sound
        public static STEP_SNOW: cn.nukkit.level.Sound
        public static STEP_SOUL_SAND: cn.nukkit.level.Sound
        public static STEP_SOUL_SOIL: cn.nukkit.level.Sound
        public static STEP_SPORE_BLOSSOM: cn.nukkit.level.Sound
        public static STEP_STEM: cn.nukkit.level.Sound
        public static STEP_STONE: cn.nukkit.level.Sound
        public static STEP_TUFF: cn.nukkit.level.Sound
        public static STEP_VINES: cn.nukkit.level.Sound
        public static STEP_WOOD: cn.nukkit.level.Sound
        public static TILE_PISTON_IN: cn.nukkit.level.Sound
        public static TILE_PISTON_OUT: cn.nukkit.level.Sound
        public static TILT_DOWN_BIG_DRIPLEAF: cn.nukkit.level.Sound
        public static TILT_UP_BIG_DRIPLEAF: cn.nukkit.level.Sound
        public static UI_CARTOGRAPHY_TABLE_TAKE_RESULT: cn.nukkit.level.Sound
        public static UI_LOOM_SELECT_PATTERN: cn.nukkit.level.Sound
        public static UI_LOOM_TAKE_RESULT: cn.nukkit.level.Sound
        public static UI_STONECUTTER_TAKE_RESULT: cn.nukkit.level.Sound
        public static USE_ANCIENT_DEBRIS: cn.nukkit.level.Sound
        public static USE_BASALT: cn.nukkit.level.Sound
        public static USE_BONE_BLOCK: cn.nukkit.level.Sound
        public static USE_CANDLE: cn.nukkit.level.Sound
        public static USE_CAVE_VINES: cn.nukkit.level.Sound
        public static USE_CHAIN: cn.nukkit.level.Sound
        public static USE_CLOTH: cn.nukkit.level.Sound
        public static USE_COPPER: cn.nukkit.level.Sound
        public static USE_CORAL: cn.nukkit.level.Sound
        public static USE_DEEPSLATE: cn.nukkit.level.Sound
        public static USE_DEEPSLATE_BRICKS: cn.nukkit.level.Sound
        public static USE_DIRT_WITH_ROOTS: cn.nukkit.level.Sound
        public static USE_DRIPSTONE_BLOCK: cn.nukkit.level.Sound
        public static USE_GRASS: cn.nukkit.level.Sound
        public static USE_GRAVEL: cn.nukkit.level.Sound
        public static USE_HANGING_ROOTS: cn.nukkit.level.Sound
        public static USE_HONEY_BLOCK: cn.nukkit.level.Sound
        public static USE_LADDER: cn.nukkit.level.Sound
        public static USE_MOSS: cn.nukkit.level.Sound
        public static USE_NETHER_BRICK: cn.nukkit.level.Sound
        public static USE_NETHER_GOLD_ORE: cn.nukkit.level.Sound
        public static USE_NETHER_SPROUTS: cn.nukkit.level.Sound
        public static USE_NETHER_WART: cn.nukkit.level.Sound
        public static USE_NETHERITE: cn.nukkit.level.Sound
        public static USE_NETHERRACK: cn.nukkit.level.Sound
        public static USE_NYLIUM: cn.nukkit.level.Sound
        public static USE_POINTED_DRIPSTONE: cn.nukkit.level.Sound
        public static USE_ROOTS: cn.nukkit.level.Sound
        public static USE_SAND: cn.nukkit.level.Sound
        public static USE_SCULK_SENSOR: cn.nukkit.level.Sound
        public static USE_SHROOMLIGHT: cn.nukkit.level.Sound
        public static USE_SLIME: cn.nukkit.level.Sound
        public static USE_SNOW: cn.nukkit.level.Sound
        public static USE_SOUL_SAND: cn.nukkit.level.Sound
        public static USE_SOUL_SOIL: cn.nukkit.level.Sound
        public static USE_SPORE_BLOSSOM: cn.nukkit.level.Sound
        public static USE_STEM: cn.nukkit.level.Sound
        public static USE_STONE: cn.nukkit.level.Sound
        public static USE_VINES: cn.nukkit.level.Sound
        public static USE_WOOD: cn.nukkit.level.Sound
        public static VR_STUTTERTURN: cn.nukkit.level.Sound
        sound: string
        static $VALUES: cn.nukkit.level.Sound[]

    }
}

declare module "cn.nukkit.level.Sound" {
    declare const Sound = cn.nukkit.level.Sound;
}

declare namespace cn.nukkit.level {
    declare class Level extends java.lang.Object implements cn.nukkit.level.ChunkManager, cn.nukkit.metadata.Metadatable {
        public static canRandomTick(blockId: int): boolean
        public static setCanRandomTick(blockId: int, newValue: boolean): void
        public constructor(server: cn.nukkit.Server, name: string, path: string, provider: java.lang.Class<cn.nukkit.level.format.LevelProvider>): void
        constructor(server: cn.nukkit.Server, name: string, path: java.io.File, usesChunkSection: boolean, provider: cn.nukkit.level.format.LevelProvider): void
        constructor(server: cn.nukkit.Server, name: string, path: string, usesChunkSection: java.util.function.BooleanSupplier, provider: java.util.function.BiFunction<cn.nukkit.level.Level, string, cn.nukkit.level.format.LevelProvider>): void
        public static chunkHash(x: int, z: int): long
        public static blockHash(x: int, y: int, z: int): long
        public static blockHash(x: int, y: int, z: int, level: cn.nukkit.level.Level): long
        public static localBlockHash(x: double, var1: double, y: double, var3: cn.nukkit.level.Level): int
        public static getBlockXYZ(chunkHash: long, var1: int, blockHash: cn.nukkit.level.Level): cn.nukkit.math.Vector3
        public static chunkBlockHash(x: int, y: int, z: int): int
        public static getHashX(hash: long): int
        public static getHashZ(hash: long): int
        public static getBlockXYZ(hash: cn.nukkit.math.BlockVector3): cn.nukkit.math.Vector3
        public static getChunkXZ(hash: long): cn.nukkit.level.format.Chunk$Entry
        public static generateChunkLoaderId(loader: cn.nukkit.level.ChunkLoader): int
        public getTickRate(): int
        public getTickRateTime(): int
        public setTickRate(tickRate: int): void
        public recalcTickOptDelay(): int
        public initLevel(): void
        public getGenerator(): cn.nukkit.level.generator.Generator
        public getBlockMetadata(): cn.nukkit.metadata.BlockMetadataStore
        public getServer(): cn.nukkit.Server
        public getProvider(): cn.nukkit.level.format.LevelProvider
        public requireProvider(): cn.nukkit.level.format.LevelProvider
        public getId(): int
        public close(): void
        public addSound(pos: cn.nukkit.math.Vector3, sound: cn.nukkit.level.Sound): void
        public addSound(pos: cn.nukkit.math.Vector3, sound: cn.nukkit.level.Sound, volume: float, pitch: float): void
        public addSound(pos: cn.nukkit.math.Vector3, sound: cn.nukkit.level.Sound, volume: float, pitch: float, players: java.util.Collection<cn.nukkit.Player>): void
        public addSound(pos: cn.nukkit.math.Vector3, sound: cn.nukkit.level.Sound, volume: float, pitch: float, players: cn.nukkit.Player[]): void
        public addLevelEvent(type: int, data: int): void
        public addLevelEvent(type: int, data: int, pos: cn.nukkit.math.Vector3): void
        public addLevelEvent(type: int, data: int, x: float, y: float, z: float): void
        public addLevelEvent(pos: cn.nukkit.math.Vector3, event: int): void
        public addLevelEvent(pos: cn.nukkit.math.Vector3, event: int, data: int): void
        public addLevelSoundEvent(pos: cn.nukkit.math.Vector3, type: int, data: int, entityType: int): void
        public addLevelSoundEvent(pos: cn.nukkit.math.Vector3, type: int, data: int, entityType: int, isBaby: boolean, isGlobal: boolean): void
        public addLevelSoundEvent(pos: cn.nukkit.math.Vector3, type: int): void
        public addLevelSoundEvent(pos: cn.nukkit.math.Vector3, type: int, data: int): void
        public addLevelSoundEvent(pos: cn.nukkit.math.Vector3, type: int, data: int, identifier: string, isBaby: boolean, isGlobal: boolean): void
        public addParticle(particle: cn.nukkit.level.particle.Particle): void
        public addParticle(particle: cn.nukkit.level.particle.Particle, player: cn.nukkit.Player): void
        public addParticle(particle: cn.nukkit.level.particle.Particle, players: cn.nukkit.Player[]): void
        public addParticle(particle: cn.nukkit.level.particle.Particle, players: java.util.Collection<cn.nukkit.Player>): void
        public addParticleEffect(pos: cn.nukkit.math.Vector3, particleEffect: cn.nukkit.level.ParticleEffect): void
        public addParticleEffect(pos: cn.nukkit.math.Vector3, particleEffect: cn.nukkit.level.ParticleEffect, uniqueEntityId: long): void
        public addParticleEffect(pos: cn.nukkit.math.Vector3, particleEffect: cn.nukkit.level.ParticleEffect, uniqueEntityId: long, var3: int): void
        public addParticleEffect(pos: cn.nukkit.math.Vector3, particleEffect: cn.nukkit.level.ParticleEffect, uniqueEntityId: long, var3: int, dimensionId: java.util.Collection<cn.nukkit.Player>): void
        public addParticleEffect(pos: cn.nukkit.math.Vector3, particleEffect: cn.nukkit.level.ParticleEffect, uniqueEntityId: long, var3: int, dimensionId: cn.nukkit.Player[]): void
        public addParticleEffect(pos: cn.nukkit.math.Vector3f, identifier: string, uniqueEntityId: long, var3: int, dimensionId: cn.nukkit.Player[]): void
        public getAutoSave(): boolean
        public setAutoSave(autoSave: boolean): void
        public unload(): boolean
        public unload(force: boolean): boolean
        public getChunkPlayers(chunkX: int, chunkZ: int): java.util.Map<int, cn.nukkit.Player>
        public getChunkLoaders(chunkX: int, chunkZ: int): cn.nukkit.level.ChunkLoader[]
        public addChunkPacket(chunkX: int, chunkZ: int, packet: cn.nukkit.network.protocol.DataPacket): void
        public registerChunkLoader(loader: cn.nukkit.level.ChunkLoader, chunkX: int, chunkZ: int): void
        public registerChunkLoader(loader: cn.nukkit.level.ChunkLoader, chunkX: int, chunkZ: int, autoLoad: boolean): void
        public unregisterChunkLoader(loader: cn.nukkit.level.ChunkLoader, chunkX: int, chunkZ: int): void
        public checkTime(): void
        public sendTime(players: cn.nukkit.Player[]): void
        public sendTime(): void
        public getGameRules(): cn.nukkit.level.GameRules
        public doTick(currentTick: int): void
        performThunder(index: long, var1: cn.nukkit.level.format.FullChunk): void
        public adjustPosToNearbyEntity(pos: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3
        public checkSleep(): void
        public sendBlockExtraData(x: int, y: int, z: int, id: int, data: int): void
        public sendBlockExtraData(x: int, y: int, z: int, id: int, data: int, players: java.util.Collection<cn.nukkit.Player>): void
        public sendBlockExtraData(x: int, y: int, z: int, id: int, data: int, players: cn.nukkit.Player[]): void
        public sendBlocks(target: cn.nukkit.Player[], blocks: cn.nukkit.math.Vector3[]): void
        public sendBlocks(target: cn.nukkit.Player[], blocks: cn.nukkit.math.Vector3[], flags: int): void
        public sendBlocks(target: cn.nukkit.Player[], blocks: cn.nukkit.math.Vector3[], flags: int, optimizeRebuilds: boolean): void
        public sendBlocks(target: cn.nukkit.Player[], blocks: cn.nukkit.math.Vector3[], flags: int, dataLayer: int): void
        public sendBlocks(target: cn.nukkit.Player[], blocks: cn.nukkit.math.Vector3[], flags: int, dataLayer: int, optimizeRebuilds: boolean): void
        tickChunks(): void
        public save(): boolean
        public save(force: boolean): boolean
        public saveChunks(): void
        public updateAroundRedstone(pos: cn.nukkit.math.Vector3, face: cn.nukkit.math.BlockFace): void
        public updateComparatorOutputLevel(v: cn.nukkit.math.Vector3): void
        public updateComparatorOutputLevelSelective(v: cn.nukkit.math.Vector3, observer: boolean): void
        public updateAround(pos: cn.nukkit.math.Vector3): void
        public updateAround(x: int, y: int, z: int): void
        public scheduleUpdate(pos: cn.nukkit.block.Block, delay: int): void
        public scheduleUpdate(pos: cn.nukkit.block.Block, delay: int, checkBlockWhenUpdate: boolean): void
        public scheduleUpdate(block: cn.nukkit.block.Block, pos: cn.nukkit.math.Vector3, delay: int): void
        public scheduleUpdate(block: cn.nukkit.block.Block, pos: cn.nukkit.math.Vector3, delay: int, priority: int): void
        public scheduleUpdate(block: cn.nukkit.block.Block, pos: cn.nukkit.math.Vector3, delay: int, priority: int, checkArea: boolean): void
        public scheduleUpdate(block: cn.nukkit.block.Block, pos: cn.nukkit.math.Vector3, delay: int, priority: int, checkArea: boolean, checkBlockWhenUpdate: boolean): void
        public cancelSheduledUpdate(pos: cn.nukkit.math.Vector3, block: cn.nukkit.block.Block): boolean
        public isUpdateScheduled(pos: cn.nukkit.math.Vector3, block: cn.nukkit.block.Block): boolean
        public isBlockTickPending(pos: cn.nukkit.math.Vector3, block: cn.nukkit.block.Block): boolean
        public getPendingBlockUpdates(chunk: cn.nukkit.level.format.FullChunk): java.util.Set<cn.nukkit.utils.BlockUpdateEntry>
        public getPendingBlockUpdates(boundingBox: cn.nukkit.math.AxisAlignedBB): java.util.Set<cn.nukkit.utils.BlockUpdateEntry>
        public scanBlocks(bb: cn.nukkit.math.AxisAlignedBB, condition: java.util.function.BiPredicate<cn.nukkit.math.BlockVector3, cn.nukkit.blockstate.BlockState>): java.util.List<cn.nukkit.block.Block>
        public getCollisionBlocks(bb: cn.nukkit.math.AxisAlignedBB): cn.nukkit.block.Block[]
        public getCollisionBlocks(bb: cn.nukkit.math.AxisAlignedBB, targetFirst: boolean): cn.nukkit.block.Block[]
        public getCollisionBlocks(bb: cn.nukkit.math.AxisAlignedBB, targetFirst: boolean, ignoreCollidesCheck: boolean): cn.nukkit.block.Block[]
        public getCollisionBlocks(bb: cn.nukkit.math.AxisAlignedBB, targetFirst: boolean, ignoreCollidesCheck: boolean, condition: java.util.function.Predicate<cn.nukkit.block.Block>): cn.nukkit.block.Block[]
        public isFullBlock(pos: cn.nukkit.math.Vector3): boolean
        public getCollisionCubes(entity: cn.nukkit.entity.Entity, bb: cn.nukkit.math.AxisAlignedBB): cn.nukkit.math.AxisAlignedBB[]
        public getCollisionCubes(entity: cn.nukkit.entity.Entity, bb: cn.nukkit.math.AxisAlignedBB, entities: boolean): cn.nukkit.math.AxisAlignedBB[]
        public getCollisionCubes(entity: cn.nukkit.entity.Entity, bb: cn.nukkit.math.AxisAlignedBB, entities: boolean, solidEntities: boolean): cn.nukkit.math.AxisAlignedBB[]
        public fastCollisionCubes(entity: cn.nukkit.entity.Entity, bb: cn.nukkit.math.AxisAlignedBB): java.util.List<cn.nukkit.math.AxisAlignedBB>
        public fastCollisionCubes(entity: cn.nukkit.entity.Entity, bb: cn.nukkit.math.AxisAlignedBB, entities: boolean): java.util.List<cn.nukkit.math.AxisAlignedBB>
        public fastCollisionCubes(entity: cn.nukkit.entity.Entity, bb: cn.nukkit.math.AxisAlignedBB, entities: boolean, solidEntities: boolean): java.util.List<cn.nukkit.math.AxisAlignedBB>
        public hasCollision(entity: cn.nukkit.entity.Entity, bb: cn.nukkit.math.AxisAlignedBB, entities: boolean): boolean
        public getFullLight(pos: cn.nukkit.math.Vector3): int
        public calculateSkylightSubtracted(tickDiff: float): int
        public getRainStrength(tickDiff: float): float
        public getThunderStrength(tickDiff: float): float
        public getCelestialAngle(tickDiff: float): float
        public calculateCelestialAngle(time: int, tickDiff: float): float
        public getMoonPhase(worldTime: long): int
        public getFullBlock(x: int, y: int, z: int): int
        public getFullBlock(x: int, y: int, z: int, layer: int): int
        public getBlockRuntimeId(x: int, y: int, z: int): int
        public getBlockRuntimeId(x: int, y: int, z: int, layer: int): int
        public getBlockAround(pos: cn.nukkit.math.Vector3): java.util.Set<cn.nukkit.block.Block>
        public getBlock(pos: cn.nukkit.math.Vector3): cn.nukkit.block.Block
        public getBlock(pos: cn.nukkit.math.Vector3, layer: int): cn.nukkit.block.Block
        public getBlock(pos: cn.nukkit.math.Vector3, load: boolean): cn.nukkit.block.Block
        public getBlock(pos: cn.nukkit.math.Vector3, layer: int, load: boolean): cn.nukkit.block.Block
        public getBlock(x: int, y: int, z: int): cn.nukkit.block.Block
        public getBlock(x: int, y: int, z: int, layer: int): cn.nukkit.block.Block
        public getBlock(x: int, y: int, z: int, load: boolean): cn.nukkit.block.Block
        public getBlock(x: int, y: int, z: int, layer: int, load: boolean): cn.nukkit.block.Block
        public updateAllLight(pos: cn.nukkit.math.Vector3): void
        public updateBlockSkyLight(x: int, y: int, z: int): void
        public getHighestAdjacentBlockSkyLight(x: int, y: int, z: int): int
        public updateBlockLight(map: java.util.Map<long, java.util.Map<int, java.lang.Object>>): void
        computeRemoveBlockLight(x: int, y: int, z: int, currentLight: int, queue: java.util.Queue<java.lang.Object[]>, spreadQueue: java.util.Queue<long>, visited: java.util.Map<long, java.lang.Object>, spreadVisited: java.util.Map<long, java.lang.Object>): void
        computeSpreadBlockLight(x: int, y: int, z: int, currentLight: int, queue: java.util.Queue<long>, visited: java.util.Map<long, java.lang.Object>): void
        public addLightUpdate(x: int, y: int, z: int): void
        public setBlockFullIdAt(x: int, y: int, z: int, fullId: int): void
        public setBlockFullIdAt(x: int, y: int, z: int, layer: int, fullId: int): void
        public setBlock(pos: cn.nukkit.math.Vector3, block: cn.nukkit.block.Block): boolean
        public setBlock(pos: cn.nukkit.math.Vector3, layer: int, block: cn.nukkit.block.Block): boolean
        public setBlock(pos: cn.nukkit.math.Vector3, block: cn.nukkit.block.Block, direct: boolean): boolean
        public setBlock(pos: cn.nukkit.math.Vector3, layer: int, block: cn.nukkit.block.Block, direct: boolean): boolean
        public setBlock(pos: cn.nukkit.math.Vector3, block: cn.nukkit.block.Block, direct: boolean, update: boolean): boolean
        public setBlock(pos: cn.nukkit.math.Vector3, layer: int, block: cn.nukkit.block.Block, direct: boolean, update: boolean): boolean
        public setBlock(x: int, y: int, z: int, block: cn.nukkit.block.Block, direct: boolean, update: boolean): boolean
        public setBlock(x: int, y: int, z: int, layer: int, block: cn.nukkit.block.Block, direct: boolean, update: boolean): boolean
        addBlockChange(x: int, y: int, z: int): void
        addBlockChange(index: long, var1: int, x: int, y: int): void
        public dropItem(source: cn.nukkit.math.Vector3, item: cn.nukkit.item.Item): void
        public dropItem(source: cn.nukkit.math.Vector3, item: cn.nukkit.item.Item, motion: cn.nukkit.math.Vector3): void
        public dropItem(source: cn.nukkit.math.Vector3, item: cn.nukkit.item.Item, motion: cn.nukkit.math.Vector3, delay: int): void
        public dropItem(source: cn.nukkit.math.Vector3, item: cn.nukkit.item.Item, motion: cn.nukkit.math.Vector3, dropAround: boolean, delay: int): void
        public dropAndGetItem(source: cn.nukkit.math.Vector3, item: cn.nukkit.item.Item): cn.nukkit.entity.item.EntityItem
        public dropAndGetItem(source: cn.nukkit.math.Vector3, item: cn.nukkit.item.Item, motion: cn.nukkit.math.Vector3): cn.nukkit.entity.item.EntityItem
        public dropAndGetItem(source: cn.nukkit.math.Vector3, item: cn.nukkit.item.Item, motion: cn.nukkit.math.Vector3, delay: int): cn.nukkit.entity.item.EntityItem
        public dropAndGetItem(source: cn.nukkit.math.Vector3, item: cn.nukkit.item.Item, motion: cn.nukkit.math.Vector3, dropAround: boolean, delay: int): cn.nukkit.entity.item.EntityItem
        public useBreakOn(vector: cn.nukkit.math.Vector3): cn.nukkit.item.Item
        public useBreakOn(vector: cn.nukkit.math.Vector3, item: cn.nukkit.item.Item): cn.nukkit.item.Item
        public useBreakOn(vector: cn.nukkit.math.Vector3, item: cn.nukkit.item.Item, player: cn.nukkit.Player): cn.nukkit.item.Item
        public useBreakOn(vector: cn.nukkit.math.Vector3, item: cn.nukkit.item.Item, player: cn.nukkit.Player, createParticles: boolean): cn.nukkit.item.Item
        public useBreakOn(vector: cn.nukkit.math.Vector3, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item, player: cn.nukkit.Player, createParticles: boolean): cn.nukkit.item.Item
        public useBreakOn(vector: cn.nukkit.math.Vector3, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item, player: cn.nukkit.Player, createParticles: boolean, setBlockDestroy: boolean): cn.nukkit.item.Item
        public useBreakOn(vector: cn.nukkit.math.Vector3, layer: int, face: cn.nukkit.math.BlockFace, item: cn.nukkit.item.Item, player: cn.nukkit.Player, createParticles: boolean, setBlockDestroy: boolean): cn.nukkit.item.Item
        public dropExpOrb(source: cn.nukkit.math.Vector3, exp: int): void
        public dropExpOrb(source: cn.nukkit.math.Vector3, exp: int, motion: cn.nukkit.math.Vector3): void
        public dropExpOrb(source: cn.nukkit.math.Vector3, exp: int, motion: cn.nukkit.math.Vector3, delay: int): void
        public dropExpOrbAndGetEntities(source: cn.nukkit.math.Vector3, exp: int): java.util.List<cn.nukkit.entity.item.EntityXPOrb>
        public dropExpOrbAndGetEntities(source: cn.nukkit.math.Vector3, exp: int, motion: cn.nukkit.math.Vector3): java.util.List<cn.nukkit.entity.item.EntityXPOrb>
        public dropExpOrbAndGetEntities(source: cn.nukkit.math.Vector3, exp: int, motion: cn.nukkit.math.Vector3, delay: int): java.util.List<cn.nukkit.entity.item.EntityXPOrb>
        public useItemOn(vector: cn.nukkit.math.Vector3, item: cn.nukkit.item.Item, face: cn.nukkit.math.BlockFace, fx: float, fy: float, fz: float): cn.nukkit.item.Item
        public useItemOn(vector: cn.nukkit.math.Vector3, item: cn.nukkit.item.Item, face: cn.nukkit.math.BlockFace, fx: float, fy: float, fz: float, player: cn.nukkit.Player): cn.nukkit.item.Item
        public useItemOn(vector: cn.nukkit.math.Vector3, item: cn.nukkit.item.Item, face: cn.nukkit.math.BlockFace, fx: float, fy: float, fz: float, player: cn.nukkit.Player, playSound: boolean): cn.nukkit.item.Item
        public isInSpawnRadius(vector3: cn.nukkit.math.Vector3): boolean
        public getEntity(entityId: long): cn.nukkit.entity.Entity
        public getEntities(): cn.nukkit.entity.Entity[]
        public getCollidingEntities(bb: cn.nukkit.math.AxisAlignedBB): cn.nukkit.entity.Entity[]
        public getCollidingEntities(bb: cn.nukkit.math.AxisAlignedBB, entity: cn.nukkit.entity.Entity): cn.nukkit.entity.Entity[]
        public fastCollidingEntities(bb: cn.nukkit.math.AxisAlignedBB): java.util.List<cn.nukkit.entity.Entity>
        public fastCollidingEntities(bb: cn.nukkit.math.AxisAlignedBB, entity: cn.nukkit.entity.Entity): java.util.List<cn.nukkit.entity.Entity>
        public streamCollidingEntities(bb: cn.nukkit.math.AxisAlignedBB, entity: cn.nukkit.entity.Entity): java.util.stream.Stream<cn.nukkit.entity.Entity>
        public getNearbyEntities(bb: cn.nukkit.math.AxisAlignedBB): cn.nukkit.entity.Entity[]
        public getNearbyEntities(bb: cn.nukkit.math.AxisAlignedBB, entity: cn.nukkit.entity.Entity): cn.nukkit.entity.Entity[]
        public getNearbyEntities(bb: cn.nukkit.math.AxisAlignedBB, entity: cn.nukkit.entity.Entity, loadChunks: boolean): cn.nukkit.entity.Entity[]
        public fastNearbyEntities(bb: cn.nukkit.math.AxisAlignedBB): java.util.List<cn.nukkit.entity.Entity>
        public fastNearbyEntities(bb: cn.nukkit.math.AxisAlignedBB, entity: cn.nukkit.entity.Entity): java.util.List<cn.nukkit.entity.Entity>
        public fastNearbyEntities(bb: cn.nukkit.math.AxisAlignedBB, entity: cn.nukkit.entity.Entity, loadChunks: boolean): java.util.List<cn.nukkit.entity.Entity>
        addEntityToBuffer(index: int, overflow: java.util.ArrayList<cn.nukkit.entity.Entity>, ent: cn.nukkit.entity.Entity): java.util.ArrayList<cn.nukkit.entity.Entity>
        getEntitiesFromBuffer(index: int, overflow: java.util.ArrayList<cn.nukkit.entity.Entity>): cn.nukkit.entity.Entity[]
        public getBlockEntities(): java.util.Map<long, cn.nukkit.blockentity.BlockEntity>
        public getBlockEntityById(blockEntityId: long): cn.nukkit.blockentity.BlockEntity
        public getPlayers(): java.util.Map<long, cn.nukkit.Player>
        public getLoaders(): java.util.Map<int, cn.nukkit.level.ChunkLoader>
        public getBlockEntity(pos: cn.nukkit.math.Vector3): cn.nukkit.blockentity.BlockEntity
        public getBlockEntity(pos: cn.nukkit.math.BlockVector3): cn.nukkit.blockentity.BlockEntity
        public getBlockEntityIfLoaded(pos: cn.nukkit.math.Vector3): cn.nukkit.blockentity.BlockEntity
        public getChunkEntities(X: int, Z: int): java.util.Map<long, cn.nukkit.entity.Entity>
        public getChunkEntities(X: int, Z: int, loadChunks: boolean): java.util.Map<long, cn.nukkit.entity.Entity>
        public getChunkBlockEntities(X: int, Z: int): java.util.Map<long, cn.nukkit.blockentity.BlockEntity>
        public getBlockStateAt(x: int, y: int, z: int, layer: int): cn.nukkit.blockstate.BlockState
        public getBlockIdAt(x: int, y: int, z: int): int
        public getBlockIdAt(x: int, y: int, z: int, layer: int): int
        public setBlockIdAt(x: int, y: int, z: int, id: int): void
        public setBlockIdAt(x: int, y: int, z: int, layer: int, id: int): void
        public setBlockAt(x: int, y: int, z: int, id: int, data: int): void
        public setBlockAtLayer(x: int, y: int, z: int, layer: int, id: int, data: int): boolean
        public setBlockStateAt(x: int, y: int, z: int, layer: int, state: cn.nukkit.blockstate.BlockState): boolean
        public getBlockDataAt(x: int, y: int, z: int): int
        public getBlockExtraDataAt(x: int, y: int, z: int): int
        public setBlockExtraDataAt(x: int, y: int, z: int, id: int, data: int): void
        public getBlockDataAt(x: int, y: int, z: int, layer: int): int
        public setBlockDataAt(x: int, y: int, z: int, data: int): void
        public setBlockDataAt(x: int, y: int, z: int, layer: int, data: int): void
        public getBlockSkyLightAt(x: int, y: int, z: int): int
        public setBlockSkyLightAt(x: int, y: int, z: int, level: int): void
        public getBlockLightAt(x: int, y: int, z: int): int
        public setBlockLightAt(x: int, y: int, z: int, level: int): void
        public getBiomeId(x: int, z: int): int
        public setBiomeId(x: int, z: int, biomeId: byte): void
        public getHeightMap(x: int, z: int): int
        public setHeightMap(x: int, z: int, value: int): void
        public getChunks(): java.util.Map<long, cn.nukkit.level.format.FullChunk>
        public getChunk(chunkX: int, chunkZ: int): cn.nukkit.level.format.generic.BaseFullChunk
        public getChunk(chunkX: int, chunkZ: int, create: boolean): cn.nukkit.level.format.generic.BaseFullChunk
        public getChunkIfLoaded(chunkX: int, chunkZ: int): cn.nukkit.level.format.generic.BaseFullChunk
        public generateChunkCallback(x: int, z: int, chunk: cn.nukkit.level.format.generic.BaseFullChunk): void
        public generateChunkCallback(x: int, z: int, chunk: cn.nukkit.level.format.generic.BaseFullChunk, isPopulated: boolean): void
        public setChunk(chunkX: int, chunkZ: int): void
        public setChunk(chunkX: int, chunkZ: int, chunk: cn.nukkit.level.format.generic.BaseFullChunk): void
        public setChunk(chunkX: int, chunkZ: int, chunk: cn.nukkit.level.format.generic.BaseFullChunk, unload: boolean): void
        public getHighestBlockAt(x: int, z: int): int
        public getMapColorAt(x: int, z: int): cn.nukkit.utils.BlockColor
        public isChunkLoaded(x: int, z: int): boolean
        areNeighboringChunksLoaded(hash: long): boolean
        public isChunkGenerated(x: int, z: int): boolean
        public isChunkPopulated(x: int, z: int): boolean
        public getSpawnLocation(): cn.nukkit.level.Position
        public getFuzzySpawnLocation(): cn.nukkit.level.Position
        public setSpawnLocation(pos: cn.nukkit.math.Vector3): void
        public requestChunk(x: int, z: int, player: cn.nukkit.Player): void
        sendChunk(x: int, z: int, index: long, var3: cn.nukkit.network.protocol.DataPacket): void
        processChunkRequest(): void
        public chunkRequestCallback(timestamp: long, var1: int, x: int, z: int, subChunkCount: byte[]): void
        public removeEntity(entity: cn.nukkit.entity.Entity): void
        public addEntity(entity: cn.nukkit.entity.Entity): void
        public addBlockEntity(blockEntity: cn.nukkit.blockentity.BlockEntity): void
        public scheduleBlockEntityUpdate(entity: cn.nukkit.blockentity.BlockEntity): void
        public removeBlockEntity(entity: cn.nukkit.blockentity.BlockEntity): void
        public isChunkInUse(x: int, z: int): boolean
        public isChunkInUse(hash: long): boolean
        public loadChunk(x: int, z: int): boolean
        public loadChunk(x: int, z: int, generate: boolean): boolean
        forceLoadChunk(index: long, var1: int, x: int, z: boolean): cn.nukkit.level.format.generic.BaseFullChunk
        queueUnloadChunk(x: int, z: int): void
        public unloadChunkRequest(x: int, z: int): boolean
        public unloadChunkRequest(x: int, z: int, safe: boolean): boolean
        public cancelUnloadChunkRequest(x: int, z: int): void
        public cancelUnloadChunkRequest(hash: long): void
        public unloadChunk(x: int, z: int): boolean
        public unloadChunk(x: int, z: int, safe: boolean): boolean
        public unloadChunk(x: int, z: int, safe: boolean, trySave: boolean): boolean
        public isSpawnChunk(X: int, Z: int): boolean
        public getSafeSpawn(): cn.nukkit.level.Position
        public getSafeSpawn(spawn: cn.nukkit.math.Vector3): cn.nukkit.level.Position
        public getSafeSpawn(spawn: cn.nukkit.math.Vector3, horizontalMaxOffset: int): cn.nukkit.level.Position
        public getSafeSpawn(spawn: cn.nukkit.math.Vector3, horizontalMaxOffset: int, allowWaterUnder: boolean): cn.nukkit.level.Position
        public standable(vec: cn.nukkit.math.Vector3): boolean
        public standable(vec: cn.nukkit.math.Vector3, allowWaterUnder: boolean): boolean
        public getTime(): int
        public isDaytime(): boolean
        public getCurrentTick(): long
        public getName(): string
        public getFolderName(): string
        public setTime(time: int): void
        public stopTime(): void
        public startTime(): void
        public getSeed(): long
        public setSeed(seed: int): void
        public populateChunk(x: int, z: int): boolean
        public populateChunk(x: int, z: int, force: boolean): boolean
        public generateChunk(x: int, z: int): void
        public generateChunk(x: int, z: int, force: boolean): void
        public regenerateChunk(x: int, z: int): void
        public doChunkGarbageCollection(): void
        public doGarbageCollection(allocatedTime: long): void
        public unloadChunks(): void
        public unloadChunks(force: boolean): void
        public unloadChunks(maxUnload: int, force: boolean): void
        unloadChunks(now: long, var1: long, allocatedTime: boolean): boolean
        public setMetadata(metadataKey: string, newMetadataValue: cn.nukkit.metadata.MetadataValue): void
        public getMetadata(metadataKey: string): java.util.List<cn.nukkit.metadata.MetadataValue>
        public hasMetadata(metadataKey: string): boolean
        public removeMetadata(metadataKey: string, owningPlugin: cn.nukkit.plugin.Plugin): void
        public addPlayerMovement(entity: cn.nukkit.entity.Entity, x: double, var2: double, y: double, var4: double, z: double, var6: double): void
        public addEntityMovement(entity: cn.nukkit.entity.Entity, x: double, var2: double, y: double, var4: double, z: double, var6: double): void
        public isRaining(): boolean
        public setRaining(raining: boolean): boolean
        public getRainTime(): int
        public setRainTime(rainTime: int): void
        public isThundering(): boolean
        public setThundering(thundering: boolean): boolean
        public getThunderTime(): int
        public setThunderTime(thunderTime: int): void
        public sendWeather(players: cn.nukkit.Player[]): void
        public sendWeather(player: cn.nukkit.Player): void
        public sendWeather(players: java.util.Collection<cn.nukkit.Player>): void
        public getDimensionData(): cn.nukkit.level.DimensionData
        public getDimension(): int
        public isOverWorld(): boolean
        public isNether(): boolean
        public isTheEnd(): boolean
        public isYInRange(y: int): boolean
        public canBlockSeeSky(pos: cn.nukkit.math.Vector3): boolean
        public getMinHeight(): int
        public getMaxHeight(): int
        public getStrongPower(pos: cn.nukkit.math.Vector3, direction: cn.nukkit.math.BlockFace): int
        public getStrongPower(pos: cn.nukkit.math.Vector3): int
        public isSidePowered(pos: cn.nukkit.math.Vector3, face: cn.nukkit.math.BlockFace): boolean
        public getRedstonePower(pos: cn.nukkit.math.Vector3, face: cn.nukkit.math.BlockFace): int
        public isBlockPowered(pos: cn.nukkit.math.Vector3): boolean
        public isBlockIndirectlyGettingPowered(pos: cn.nukkit.math.Vector3): int
        public isAreaLoaded(bb: cn.nukkit.math.AxisAlignedBB): boolean
        public getUpdateLCG(): int
        public createPortal(target: cn.nukkit.block.Block): boolean
        ensureY(y: int): int
        public toString(): string
        static lambda$streamCollidingEntities$16(entity: cn.nukkit.entity.Entity, bb: cn.nukkit.math.AxisAlignedBB, each: cn.nukkit.entity.Entity): boolean
        static lambda$addBlockChange$15(k: long): java.lang.ref.SoftReference
        static lambda$fastCollisionCubes$14(ent: cn.nukkit.entity.Entity): cn.nukkit.math.AxisAlignedBB
        static lambda$fastCollisionCubes$13(solidEntities: boolean, ent: cn.nukkit.entity.Entity): boolean
        static lambda$getCollisionBlocks$12(block: cn.nukkit.block.Block): boolean
        static lambda$scanBlocks$11(min: cn.nukkit.math.BlockVector3, max: cn.nukkit.math.BlockVector3, condition: java.util.function.BiPredicate, chunk: cn.nukkit.level.format.generic.BaseFullChunk): java.util.stream.Stream
        static lambda$scanBlocks$10(minChunk: cn.nukkit.math.ChunkVector2, maxChunk: cn.nukkit.math.ChunkVector2, x: int): java.util.stream.Stream
        static lambda$scanBlocks$9(x: int, z: int): cn.nukkit.math.ChunkVector2
        static lambda$doTick$8(blockEntity: cn.nukkit.blockentity.BlockEntity): boolean
        lambda$doTick$7(currentTick: int): void
        static lambda$doTick$6(currentTick: int, entityAsyncPrepare: cn.nukkit.entity.EntityAsyncPrepare): void
        lambda$doTick$5(id: long): cn.nukkit.entity.EntityAsyncPrepare
        static lambda$addChunkPacket$4(i: long): java.util.Deque
        static lambda$new$3(provider: cn.nukkit.level.format.LevelProvider, lvl: cn.nukkit.level.Level, p: string): cn.nukkit.level.format.LevelProvider
        static lambda$new$2(usesChunkSection: boolean): boolean
        static lambda$new$1(provider: java.lang.Class, level: cn.nukkit.level.Level, levelPath: string): cn.nukkit.level.format.LevelProvider
        static lambda$new$0(provider: java.lang.Class): boolean
        static log: org.apache.logging.log4j.Logger
        public static EMPTY_ARRAY: cn.nukkit.level.Level[]
        static levelIdCounter: int
        static chunkLoaderCounter: int
        public static COMPRESSION_LEVEL: int
        public static BLOCK_UPDATE_NORMAL: int
        public static BLOCK_UPDATE_RANDOM: int
        public static BLOCK_UPDATE_SCHEDULED: int
        public static BLOCK_UPDATE_WEAK: int
        public static BLOCK_UPDATE_TOUCH: int
        public static BLOCK_UPDATE_REDSTONE: int
        public static BLOCK_UPDATE_TICK: int
        public static BLOCK_UPDATE_MOVED: int
        public static TIME_DAY: int
        public static TIME_NOON: int
        public static TIME_SUNSET: int
        public static TIME_NIGHT: int
        public static TIME_MIDNIGHT: int
        public static TIME_SUNRISE: int
        public static TIME_FULL: int
        public static DIMENSION_OVERWORLD: int
        public static DIMENSION_NETHER: int
        public static DIMENSION_THE_END: int
        public static MAX_BLOCK_CACHE: int
        static randomTickBlocks: boolean[]
        blockEntities: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<cn.nukkit.blockentity.BlockEntity>
        players: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<cn.nukkit.Player>
        entities: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<cn.nukkit.entity.Entity>
        public updateEntities: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<cn.nukkit.entity.Entity>
        updateBlockEntities: java.util.concurrent.ConcurrentLinkedQueue<cn.nukkit.blockentity.BlockEntity>
        cacheChunks: boolean
        server: cn.nukkit.Server
        levelId: int
        provider: cn.nukkit.level.format.LevelProvider
        loaders: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap<cn.nukkit.level.ChunkLoader>
        loaderCounter: it.unimi.dsi.fastutil.ints.Int2IntMap
        chunkLoaders: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<java.util.Map<int, cn.nukkit.level.ChunkLoader>>
        playerLoaders: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<java.util.Map<int, cn.nukkit.Player>>
        chunkPackets: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<java.util.Deque<cn.nukkit.network.protocol.DataPacket>>
        unloadQueue: it.unimi.dsi.fastutil.longs.Long2LongMap
        time: float
        public stopTime: boolean
        nextTimeSendTick: int
        public skyLightSubtracted: float
        folderName: string
        mutableBlock: cn.nukkit.math.Vector3
        changedBlocks: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<java.lang.ref.SoftReference<it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap<java.lang.Object>>>
        changeBlocksPresent: java.lang.Object
        changeBlocksFullMap: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap<java.lang.Object>
        updateQueue: cn.nukkit.scheduler.BlockUpdateScheduler
        normalUpdateQueue: java.util.Queue<cn.nukkit.level.Level$QueuedUpdate>
        chunkSendQueue: java.util.concurrent.ConcurrentMap<long, it.unimi.dsi.fastutil.ints.Int2ObjectMap<cn.nukkit.Player>>
        chunkSendTasks: it.unimi.dsi.fastutil.longs.LongSet
        chunkPopulationQueue: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<boolean>
        chunkPopulationLock: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<boolean>
        chunkGenerationQueue: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<boolean>
        chunkGenerationQueueSize: int
        chunkPopulationQueueSize: int
        autoSave: boolean
        blockMetadata: cn.nukkit.metadata.BlockMetadataStore
        useSections: boolean
        temporalPosition: cn.nukkit.level.Position
        temporalVector: cn.nukkit.math.Vector3
        public sleepTicks: int
        chunkTickRadius: int
        chunkTickList: it.unimi.dsi.fastutil.longs.Long2IntMap
        chunksPerTicks: int
        clearChunksOnTick: boolean
        updateLCG: int
        static LCG_CONSTANT: int
        public timings: cn.nukkit.timings.LevelTimings
        tickRate: int
        public tickRateTime: int
        public tickRateCounter: int
        public tickRateOptDelay: int
        generatorClass: java.lang.Class<cn.nukkit.level.generator.Generator>
        generators: cn.nukkit.utils.IterableThreadLocal<cn.nukkit.level.generator.Generator>
        raining: boolean
        rainTime: int
        thundering: boolean
        thunderTime: int
        levelCurrentTick: long
        dimensionData: cn.nukkit.level.DimensionData
        public gameRules: cn.nukkit.level.GameRules
        lightQueue: java.util.Map<long, java.util.Map<int, java.lang.Object>>
        static ENTITY_BUFFER: cn.nukkit.entity.Entity[]
        lastUnloadIndex: int

    }
}

declare module "cn.nukkit.level.Level" {
    declare const Level = cn.nukkit.level.Level;
}

declare namespace cn.nukkit {
    declare class Player extends cn.nukkit.entity.EntityHuman implements cn.nukkit.command.CommandSender, cn.nukkit.inventory.InventoryHolder, cn.nukkit.level.ChunkLoader, cn.nukkit.IPlayer {
        public getSoulSpeedMultiplier(): float
        public getStartActionTick(): int
        public startAction(): void
        public stopAction(): void
        public getLastEnderPearlThrowingTick(): int
        public onThrowEnderPearl(): void
        public getLastChorusFruitTeleport(): int
        public onChorusFruitTeleport(): void
        public getViewingEnderChest(): cn.nukkit.block.BlockEnderChest
        public setViewingEnderChest(chest: cn.nukkit.block.BlockEnderChest): void
        public getLeaveMessage(): cn.nukkit.lang.TranslationContainer
        public getClientSecret(): string
        public getClientId(): long
        public isBanned(): boolean
        public setBanned(value: boolean): void
        public isWhitelisted(): boolean
        public setWhitelisted(value: boolean): void
        public getPlayer(): cn.nukkit.Player
        public getFirstPlayed(): long
        public getLastPlayed(): long
        public hasPlayedBefore(): boolean
        public getAdventureSettings(): cn.nukkit.AdventureSettings
        public setAdventureSettings(adventureSettings: cn.nukkit.AdventureSettings): void
        public resetInAirTicks(): void
        public setAllowFlight(value: boolean): void
        public getAllowFlight(): boolean
        public setAllowModifyWorld(value: boolean): void
        public setAllowInteract(value: boolean): void
        public setAllowInteract(value: boolean, containers: boolean): void
        public setAutoJump(value: boolean): void
        public hasAutoJump(): boolean
        public spawnTo(player: cn.nukkit.Player): void
        public getServer(): cn.nukkit.Server
        public getRemoveFormat(): boolean
        public setRemoveFormat(): void
        public setRemoveFormat(remove: boolean): void
        public canSee(player: cn.nukkit.Player): boolean
        public hidePlayer(player: cn.nukkit.Player): void
        public showPlayer(player: cn.nukkit.Player): void
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean
        public resetFallDistance(): void
        public isOnline(): boolean
        public isOp(): boolean
        public setOp(value: boolean): void
        public isPermissionSet(name: string): boolean
        public isPermissionSet(permission: cn.nukkit.permission.Permission): boolean
        public hasPermission(name: string): boolean
        public hasPermission(permission: cn.nukkit.permission.Permission): boolean
        public addAttachment(plugin: cn.nukkit.plugin.Plugin): cn.nukkit.permission.PermissionAttachment
        public addAttachment(plugin: cn.nukkit.plugin.Plugin, name: string): cn.nukkit.permission.PermissionAttachment
        public addAttachment(plugin: cn.nukkit.plugin.Plugin, name: string, value: boolean): cn.nukkit.permission.PermissionAttachment
        public removeAttachment(attachment: cn.nukkit.permission.PermissionAttachment): void
        public recalculatePermissions(): void
        public isEnableClientCommand(): boolean
        public setEnableClientCommand(enable: boolean): void
        public sendCommandData(): void
        public getEffectivePermissions(): java.util.Map<string, cn.nukkit.permission.PermissionAttachmentInfo>
        static uncheckedNewInetSocketAddress(ip: string, port: int): java.net.InetSocketAddress
        public constructor(interfaz: cn.nukkit.network.SourceInterface, clientID: long, ip: string, port: int): void
        public constructor(interfaz: cn.nukkit.network.SourceInterface, clientID: long, socketAddress: java.net.InetSocketAddress): void
        initEntity(): void
        public isPlayer(): boolean
        public asPlayer(): cn.nukkit.Player
        public isEntity(): boolean
        public asEntity(): cn.nukkit.entity.Entity
        public removeAchievement(achievementId: string): void
        public hasAchievement(achievementId: string): boolean
        public isConnected(): boolean
        public getDisplayName(): string
        public setDisplayName(displayName: string): void
        public setSkin(skin: cn.nukkit.entity.data.Skin): void
        public getAddress(): string
        public getPort(): int
        public getSocketAddress(): java.net.InetSocketAddress
        public getNextPosition(): cn.nukkit.level.Position
        public isSleeping(): boolean
        public getInAirTicks(): int
        public isUsingItem(): boolean
        public setUsingItem(value: boolean): void
        public getButtonText(): string
        public setButtonText(text: string): void
        public unloadChunk(x: int, z: int): void
        public unloadChunk(x: int, z: int, level: cn.nukkit.level.Level): void
        public isInOverWorld(): boolean
        public getSpawn(): cn.nukkit.level.Position
        public getSpawnBlock(): cn.nukkit.math.Vector3
        public setSpawnBlock(spawnBlock: cn.nukkit.math.Vector3): void
        public sendChunk(x: int, z: int, packet: cn.nukkit.network.protocol.DataPacket): void
        public sendChunk(x: int, z: int, subChunkCount: int, payload: byte[]): void
        sendNextChunk(): void
        doFirstSpawn(): void
        public updateTrackingPositions(): void
        public updateTrackingPositions(delayed: boolean): void
        orderChunks(): boolean
        public batchDataPacket(packet: cn.nukkit.network.protocol.DataPacket): boolean
        public dataPacket(packet: cn.nukkit.network.protocol.DataPacket): boolean
        public dataPacket(packet: cn.nukkit.network.protocol.DataPacket, needACK: boolean): int
        public directDataPacket(packet: cn.nukkit.network.protocol.DataPacket): boolean
        public directDataPacket(packet: cn.nukkit.network.protocol.DataPacket, needACK: boolean): int
        public getPing(): int
        public sleepOn(pos: cn.nukkit.math.Vector3): boolean
        public setSpawn(pos: cn.nukkit.math.Vector3): void
        public stopSleep(): void
        public awardAchievement(achievementId: string): boolean
        public getGamemode(): int
        static getClientFriendlyGamemode(gamemode: int): int
        public setGamemode(gamemode: int): boolean
        public setGamemode(gamemode: int, clientSide: boolean): boolean
        public setGamemode(gamemode: int, clientSide: boolean, newSettings: cn.nukkit.AdventureSettings): boolean
        public sendSettings(): void
        public isSurvival(): boolean
        public isCreative(): boolean
        public isSpectator(): boolean
        public isAdventure(): boolean
        public getDrops(): cn.nukkit.item.Item[]
        public fastMove(dx: double, var1: double, dy: double): boolean
        checkGroundState(movX: double, var1: double, movY: double, var3: double, movZ: double, var5: double): void
        public reCalcOffsetBoundingBox(): cn.nukkit.math.AxisAlignedBB
        checkBlockCollision(): void
        checkNearEntities(): void
        processMovement(tickDiff: int): void
        public addMovement(x: double, var1: double, y: double, var3: double, z: double, var5: double): void
        public setMotion(motion: cn.nukkit.math.Vector3): boolean
        public sendAttributes(): void
        logTriedToSetButHadInHand(tried: cn.nukkit.item.Item, had: cn.nukkit.item.Item): void
        public onUpdate(currentTick: int): boolean
        public entityBaseTick(tickDiff: int): boolean
        public checkInteractNearby(): void
        public getEntityPlayerLookingAt(maxDistance: int): cn.nukkit.entity.EntityInteractable
        getEntityAtPosition(nearbyEntities: cn.nukkit.entity.Entity[], x: int, y: int, z: int): cn.nukkit.entity.EntityInteractable
        public checkNetwork(): void
        public canInteract(pos: cn.nukkit.math.Vector3, maxDistance: double): boolean
        public canInteract(pos: cn.nukkit.math.Vector3, maxDistance: double, var2: double): boolean
        processLogin(): void
        completeLoginSequence(): void
        unpackBatchedPackets(packet: cn.nukkit.network.protocol.BatchPacket): java.util.List<cn.nukkit.network.protocol.DataPacket>
        public handleDataPacket(packet: cn.nukkit.network.protocol.DataPacket): void
        public chat(message: string): boolean
        public kick(): boolean
        public kick(reason: string, isAdmin: boolean): boolean
        public kick(reason: string): boolean
        public kick(reason: cn.nukkit.event.player.PlayerKickEvent$Reason): boolean
        public kick(reason: cn.nukkit.event.player.PlayerKickEvent$Reason, reasonString: string): boolean
        public kick(reason: cn.nukkit.event.player.PlayerKickEvent$Reason, isAdmin: boolean): boolean
        public kick(reason: cn.nukkit.event.player.PlayerKickEvent$Reason, reasonString: string, isAdmin: boolean): boolean
        public setViewDistance(distance: int): void
        public getViewDistance(): int
        public sendMessage(message: string): void
        public sendMessage(message: cn.nukkit.lang.TextContainer): void
        public sendRawTextMessage(text: cn.nukkit.command.utils.RawText): void
        public sendTranslation(message: string): void
        public sendTranslation(message: string, parameters: string[]): void
        public sendChat(message: string): void
        public sendChat(source: string, message: string): void
        public sendPopup(message: string): void
        public sendPopup(message: string, subtitle: string): void
        public sendTip(message: string): void
        public clearTitle(): void
        public resetTitleSettings(): void
        public setSubtitle(subtitle: string): void
        public setRawTextSubTitle(text: cn.nukkit.command.utils.RawText): void
        public setTitleAnimationTimes(fadein: int, duration: int, fadeout: int): void
        setTitle(text: string): void
        public setRawTextTitle(text: cn.nukkit.command.utils.RawText): void
        public sendTitle(title: string): void
        public sendTitle(title: string, subtitle: string): void
        public sendTitle(title: string, subtitle: string, fadeIn: int, stay: int, fadeOut: int): void
        public sendActionBar(title: string): void
        public sendActionBar(title: string, fadein: int, duration: int, fadeout: int): void
        public setRawTextActionBar(text: cn.nukkit.command.utils.RawText): void
        public setRawTextActionBar(text: cn.nukkit.command.utils.RawText, fadein: int, duration: int, fadeout: int): void
        public close(): void
        public close(message: string): void
        public close(message: string, reason: string): void
        public close(message: string, reason: string, notify: boolean): void
        public close(message: cn.nukkit.lang.TextContainer): void
        public close(message: cn.nukkit.lang.TextContainer, reason: string): void
        public close(message: cn.nukkit.lang.TextContainer, reason: string, notify: boolean): void
        public save(): void
        public saveNBT(): void
        public save(async: boolean): void
        public getOriginalName(): string
        public getName(): string
        public kill(): void
        isValidRespawnBlock(block: cn.nukkit.block.Block): boolean
        respawn(): void
        public setHealth(health: float): void
        public setMaxHealth(maxHealth: int): void
        public getExperience(): int
        public getExperienceLevel(): int
        public addExperience(add: int): void
        public addExperience(add: int, playLevelUpSound: boolean): void
        public static calculateRequireExperience(level: int): int
        public setExperience(exp: int): void
        public setExperience(exp: int, level: int): void
        public setExperience(exp: int, level: int, playLevelUpSound: boolean): void
        public sendExperience(): void
        public sendExperience(exp: int): void
        public sendExperienceLevel(): void
        public sendExperienceLevel(level: int): void
        public setAttribute(attribute: cn.nukkit.entity.Attribute): void
        public setMovementSpeed(speed: float): void
        public setMovementSpeed(speed: float, send: boolean): void
        public sendMovementSpeed(speed: float): void
        public getKiller(): cn.nukkit.entity.Entity
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean
        public dropItem(item: cn.nukkit.item.Item): boolean
        public dropAndGetItem(item: cn.nukkit.item.Item): cn.nukkit.entity.item.EntityItem
        public sendPosition(pos: cn.nukkit.math.Vector3): void
        public sendPosition(pos: cn.nukkit.math.Vector3, yaw: double): void
        public sendPosition(pos: cn.nukkit.math.Vector3, yaw: double, var2: double): void
        public sendPosition(pos: cn.nukkit.math.Vector3, yaw: double, var2: double, pitch: int): void
        public sendPosition(pos: cn.nukkit.math.Vector3, yaw: double, var2: double, pitch: int, var4: cn.nukkit.Player[]): void
        checkChunks(): void
        checkTeleportPosition(): boolean
        sendPlayStatus(status: int): void
        sendPlayStatus(status: int, immediate: boolean): void
        public teleport(location: cn.nukkit.level.Location, cause: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause): boolean
        forceSendEmptyChunks(): void
        public teleportImmediate(location: cn.nukkit.level.Location): void
        public teleportImmediate(location: cn.nukkit.level.Location, cause: cn.nukkit.event.player.PlayerTeleportEvent$TeleportCause): void
        public showFormWindow(window: cn.nukkit.form.window.FormWindow): int
        public showFormWindow(window: cn.nukkit.form.window.FormWindow, id: int): int
        public showDialogWindow(dialog: cn.nukkit.dialog.window.FormWindowDialog): void
        public showDialogWindow(dialog: cn.nukkit.dialog.window.FormWindowDialog, book: boolean): void
        public addServerSettings(window: cn.nukkit.form.window.FormWindow): int
        public createBossBar(text: string, length: int): long
        public createBossBar(dummyBossBar: cn.nukkit.utils.DummyBossBar): long
        public getDummyBossBar(bossBarId: long): cn.nukkit.utils.DummyBossBar
        public getDummyBossBars(): java.util.Map<long, cn.nukkit.utils.DummyBossBar>
        public updateBossBar(text: string, length: int, bossBarId: long): void
        public removeBossBar(bossBarId: long): void
        public getWindowId(inventory: cn.nukkit.inventory.Inventory): int
        public getWindowById(id: int): cn.nukkit.inventory.Inventory
        public addWindow(inventory: cn.nukkit.inventory.Inventory): int
        public addWindow(inventory: cn.nukkit.inventory.Inventory, forceId: int): int
        public addWindow(inventory: cn.nukkit.inventory.Inventory, forceId: int, isPermanent: boolean): int
        public addWindow(inventory: cn.nukkit.inventory.Inventory, forceId: int, isPermanent: boolean, alwaysOpen: boolean): int
        public getTopWindow(): java.util.Optional<cn.nukkit.inventory.Inventory>
        public removeWindow(inventory: cn.nukkit.inventory.Inventory): void
        removeWindow(inventory: cn.nukkit.inventory.Inventory, isResponse: boolean): void
        public sendAllInventories(): void
        addDefaultWindows(): void
        public getUIInventory(): cn.nukkit.inventory.PlayerUIInventory
        public getCursorInventory(): cn.nukkit.inventory.PlayerCursorInventory
        public getCraftingGrid(): cn.nukkit.inventory.CraftingGrid
        public setCraftingGrid(grid: cn.nukkit.inventory.CraftingGrid): void
        public resetCraftingGridType(): void
        public removeAllWindows(): void
        public removeAllWindows(permanent: boolean): void
        public getClosingWindowId(): int
        public setMetadata(metadataKey: string, newMetadataValue: cn.nukkit.metadata.MetadataValue): void
        public getMetadata(metadataKey: string): java.util.List<cn.nukkit.metadata.MetadataValue>
        public hasMetadata(metadataKey: string): boolean
        public removeMetadata(metadataKey: string, owningPlugin: cn.nukkit.plugin.Plugin): void
        public onChunkChanged(chunk: cn.nukkit.level.format.FullChunk): void
        public onChunkLoaded(chunk: cn.nukkit.level.format.FullChunk): void
        public onChunkPopulated(chunk: cn.nukkit.level.format.FullChunk): void
        public onChunkUnloaded(chunk: cn.nukkit.level.format.FullChunk): void
        public onBlockChanged(block: cn.nukkit.math.Vector3): void
        public getLoaderId(): int
        public isLoaderActive(): boolean
        public static getChunkCacheFromData(chunkX: int, chunkZ: int, subChunkCount: int, payload: byte[]): cn.nukkit.network.protocol.BatchPacket
        public isFoodEnabled(): boolean
        public setFoodEnabled(foodEnabled: boolean): void
        public getFoodData(): cn.nukkit.PlayerFood
        setDimension(dimension: int): void
        public switchLevel(level: cn.nukkit.level.Level): boolean
        public setCheckMovement(checkMovement: boolean): void
        public isCheckingMovement(): boolean
        public setLocale(locale: java.util.Locale): void
        public getLocale(): java.util.Locale
        public setSprinting(value: boolean): void
        public transfer(address: java.net.InetSocketAddress): void
        public getLoginChainData(): cn.nukkit.utils.LoginChainData
        public pickupEntity(entity: cn.nukkit.entity.Entity, near: boolean): boolean
        public hashCode(): int
        public equals(obj: java.lang.Object): boolean
        public isBreakingBlock(): boolean
        public showXboxProfile(xuid: string): void
        public startFishing(fishingRod: cn.nukkit.item.Item): void
        public stopFishing(click: boolean): void
        public doesTriggerPressurePlate(): boolean
        updateBlockingFlag(): void
        onBlock(entity: cn.nukkit.entity.Entity, animate: boolean): void
        public getNoShieldTicks(): int
        public setNoShieldTicks(noShieldTicks: int): void
        public toString(): string
        public giveItem(items: cn.nukkit.item.Item[]): void
        public getTimeSinceRest(): int
        public setTimeSinceRest(timeSinceRest: int): void
        public sendPopupJukebox(message: string): void
        public sendSystem(message: string): void
        public sendWhisper(message: string): void
        public sendWhisper(source: string, message: string): void
        public sendAnnouncement(message: string): void
        public sendAnnouncement(source: string, message: string): void
        public completeUsingItem(itemId: int, action: int): void
        public isShowingCredits(): boolean
        public setShowingCredits(showingCredits: boolean): void
        public showCredits(): void
        public hasSeenCredits(): boolean
        public setHasSeenCredits(hasSeenCredits: boolean): void
        public dataPacketImmediately(packet: cn.nukkit.network.protocol.DataPacket): boolean
        public dataResourcePacket(packet: cn.nukkit.network.protocol.DataPacket): boolean
        public sendScoreboard(scoreboard: cn.nukkit.scoreboard.Scoreboard, slot: cn.nukkit.scoreboard.data.DisplaySlot): void
        public clearScoreboardSlot(slot: cn.nukkit.scoreboard.data.DisplaySlot): void
        public shakeCamera(intensity: float, duration: float, shakeType: cn.nukkit.network.protocol.CameraShakePacket$CameraShakeType, shakeAction: cn.nukkit.network.protocol.CameraShakePacket$CameraShakeAction): void
        public sendToast(title: string, content: string): void
        static lambda$sendScoreboard$9(line: cn.nukkit.network.protocol.SetScorePacket$ScoreInfo): boolean
        static lambda$sendScoreboard$8(line: cn.nukkit.scoreboard.Scoreboard$ScoreboardLine): cn.nukkit.network.protocol.SetScorePacket$ScoreInfo
        lambda$onBlock$7(): void
        lambda$kill$6(slot: int, item: cn.nukkit.item.Item): void
        lambda$kill$5(slot: int, item: cn.nukkit.item.Item): void
        lambda$handleDataPacket$4(id: int, window: cn.nukkit.form.window.FormWindow): void
        static lambda$handleDataPacket$3(name: string): string
        static lambda$handleDataPacket$2(packet: cn.nukkit.network.protocol.DataPacket, field: java.lang.reflect.Field): boolean
        static lambda$handleDataPacket$1(field: java.lang.reflect.Field): boolean
        static lambda$checkBlockCollision$0(b: cn.nukkit.block.Block): boolean
        static access$000(x0: cn.nukkit.Player): java.util.UUID
        static access$100(x0: cn.nukkit.Player): cn.nukkit.Server
        static log: org.apache.logging.log4j.Logger
        public static EMPTY_ARRAY: cn.nukkit.Player[]
        static NO_SHIELD_DELAY: int
        public static SURVIVAL: int
        public static CREATIVE: int
        public static ADVENTURE: int
        public static SPECTATOR: int
        public static VIEW: int
        public static SURVIVAL_SLOTS: int
        public static CREATIVE_SLOTS: int
        public static CRAFTING_SMALL: int
        public static CRAFTING_BIG: int
        public static CRAFTING_ANVIL: int
        public static CRAFTING_ENCHANT: int
        public static CRAFTING_BEACON: int
        public static CRAFTING_GRINDSTONE: int
        public static CRAFTING_STONECUTTER: int
        public static CRAFTING_CARTOGRAPHY: int
        public static CRAFTING_SMITHING: int
        public static DEFAULT_SPEED: float
        public static MAXIMUM_SPEED: float
        public static PERMISSION_CUSTOM: int
        public static PERMISSION_OPERATOR: int
        public static PERMISSION_MEMBER: int
        public static PERMISSION_VISITOR: int
        public static ANVIL_WINDOW_ID: int
        public static ENCHANT_WINDOW_ID: int
        public static BEACON_WINDOW_ID: int
        public static GRINDSTONE_WINDOW_ID: int
        public static SMITHING_WINDOW_ID: int
        static RESOURCE_PACK_CHUNK_SIZE: int
        interfaz: cn.nukkit.network.SourceInterface
        public playedBefore: boolean
        public spawned: boolean
        public loggedIn: boolean
        public locallyInitialized: boolean
        verified: boolean
        unverifiedPackets: int
        public gamemode: int
        public lastBreak: long
        lastBreakPosition: cn.nukkit.math.BlockVector3
        windowCnt: int
        windows: com.google.common.collect.BiMap<cn.nukkit.inventory.Inventory, int>
        windowIndex: com.google.common.collect.BiMap<int, cn.nukkit.inventory.Inventory>
        permanentWindows: java.util.Set<int>
        inventoryOpen: boolean
        closingWindowId: int
        messageCounter: int
        clientSecret: string
        public speed: cn.nukkit.math.Vector3
        public achievements: java.util.HashSet<string>
        public craftingType: int
        playerUIInventory: cn.nukkit.inventory.PlayerUIInventory
        craftingGrid: cn.nukkit.inventory.CraftingGrid
        craftingTransaction: cn.nukkit.inventory.transaction.CraftingTransaction
        enchantTransaction: cn.nukkit.inventory.transaction.EnchantTransaction
        repairItemTransaction: cn.nukkit.inventory.transaction.RepairItemTransaction
        grindstoneTransaction: cn.nukkit.inventory.transaction.GrindstoneTransaction
        smithingTransaction: cn.nukkit.inventory.transaction.SmithingTransaction
        public creationTime: long
        randomClientId: long
        forceMovement: cn.nukkit.math.Vector3
        teleportPosition: cn.nukkit.math.Vector3
        connected: boolean
        socketAddress: java.net.InetSocketAddress
        removeFormat: boolean
        username: string
        iusername: string
        displayName: string
        startAction: int
        sleeping: cn.nukkit.math.Vector3
        clientID: long
        loaderId: int
        stepHeight: float
        public usedChunks: java.util.Map<long, boolean>
        chunkLoadCount: int
        loadQueue: it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap<boolean>
        nextChunkOrderRun: int
        hiddenPlayers: java.util.Map<java.util.UUID, cn.nukkit.Player>
        newPosition: cn.nukkit.math.Vector3
        chunkRadius: int
        viewDistance: int
        chunksPerTick: int
        spawnThreshold: int
        spawnPosition: cn.nukkit.level.Position
        spawnBlockPosition: cn.nukkit.math.Vector3
        inAirTicks: int
        startAirTicks: int
        noShieldTicks: int
        adventureSettings: cn.nukkit.AdventureSettings
        checkMovement: boolean
        perm: cn.nukkit.permission.PermissibleBase
        exp: int
        expLevel: int
        foodData: cn.nukkit.PlayerFood
        killer: cn.nukkit.entity.Entity
        locale: java.util.concurrent.atomic.AtomicReference<java.util.Locale>
        hash: int
        buttonText: string
        enableClientCommand: boolean
        viewingEnderChest: cn.nukkit.block.BlockEnderChest
        lastEnderPearl: int
        lastChorusFruitTeleport: int
        loginChainData: cn.nukkit.utils.LoginChainData
        public breakingBlock: cn.nukkit.block.Block
        public pickedXPOrb: int
        formWindowCount: int
        formWindows: java.util.Map<int, cn.nukkit.form.window.FormWindow>
        serverSettings: java.util.Map<int, cn.nukkit.form.window.FormWindow>
        dialogWindows: com.google.common.cache.Cache<string, cn.nukkit.dialog.window.FormWindowDialog>
        dummyBossBars: java.util.Map<long, cn.nukkit.utils.DummyBossBar>
        preLoginEventTask: cn.nukkit.scheduler.AsyncTask
        shouldLogin: boolean
        public fishing: cn.nukkit.entity.item.EntityFishingHook
        public lastSkinChange: long
        lastRightClickTime: double
        lastRightClickPos: cn.nukkit.math.Vector3
        timeSinceRest: int
        lastPlayerdLevelUpSoundTime: int
        delayedPosTrackingUpdate: cn.nukkit.scheduler.TaskHandler
        soulSpeedMultiplier: float
        wasInSoulSandCompatible: boolean
        showingCredits: boolean
        hasSeenCredits: boolean
        foodEnabled: boolean

    }
}

declare module "cn.nukkit.Player" {
    declare const Player = cn.nukkit.Player;
}